>>>> sui/docs/content/guides/developer/cryptography/zklogin-integration/developer-account.mdx
---
title: Configure OpenID Providers
description: zkLogin can be integrated with an application using an OpenID provider's OAuth Client ID and redirect URI.
keywords: [ zklogin, how to integrate zklogin, oauth, openID, integrate openID, openID providers, open id ]
---

To integrate zkLogin with your app, you need an OAuth client from at least one of the [available providers](#openid-providers). You will use the Client ID and redirect URI from those providers in your zkLogin project. For example, the following TypeScript code constructs a Google login URL for testing.

```typescript
const REDIRECT_URI = '<YOUR_SITE_URL>';

const params = new URLSearchParams({
	// Configure client ID and redirect URI with an OpenID provider
	client_id: $CLIENT_ID,
	redirect_uri: $REDIRECT_URI,
	response_type: 'id_token',
	scope: 'openid',
	// See below for details about generation of the nonce
	nonce: nonce,
});

const loginURL = `https://accounts.google.com/o/oauth2/v2/auth?${params}`;
```

## OpenID providers

<ImportContent source="openid-providers.mdx" mode="snippet" />

## Configuring an OpenID provider

Select a tab for instruction on configuring the client ID (`$CLIENT_ID` in the previous example) and redirect URI (`$REDIRECT_URI` in the previous example) with the relevant provider.

<Tabs groupId="oauth-providers">

<TabItem label="Google" value="google">

1. Navigate a browser to the [Google Cloud dashboard](https://console.cloud.google.com/projectselector2/home/dashboard). Either sign in or register for a Google Cloud account.
1. Open **APIs & Services** > **Credentials** using the Google Cloud dashboard navigation. 

    ![1](images/google-nav.png 'Open APIs & Services > Credentials')

1. On the Credentials page, select **CREATE CREDENTIALS** > **OAuth client ID**.

    ![2](images/google-oauth.png 'Select CREATE CREDENTIALS > OAuth client ID')

1. Set the **Application type** and **Name** of your application.

    ![3](images/google-appmeta.png 'Set type and name')

1. In the **Authorized redirect URIs** section, click the **ADD URI** button. Set the value for your redirect URI in the field. This should be the wallet or application frontend.

    ![4](images/google-addauth.png 'Add redirect URL')

1. Click **Create**. If successful, Google Cloud displays the **OAuth client created** dialog with metadata, including your **Client ID**. Click **OK** to dismiss the dialog. 

Your new OAuth client should now appear in the **OAuth 2.0 Client IDs** section of the Credentials page. Click the **Client ID** that appears next to the client to copy the value to your clipboard. Click the client name to access the redirect URI and other client data.

</TabItem>

<TabItem label="Facebook" value="facebook">

1. Register for a Facebook developer account and access the [dashboard](https://developers.facebook.com/apps/).

1. Select **Build your app** then **Products** then **Facebook Login** where you can find the client ID. Set the redirect URL. This should be the wallet or application frontend.

![1](../../../../concepts/cryptography/images/zklogin-facebook1.png 'Sign up for Facebook developer account')

_Sign up for Facebook developer account_

![2](../../../../concepts/cryptography/images/zklogin-facebook2.png 'Go to Settings')

_Go to Settings_

</TabItem>

<TabItem label="Twitch" value="twitch">

1. Register for a Twitch developer account. Access the [dashboard](https://dev.twitch.tv/console).

1. Go to **Register Your Application** then **Application** where you can find the client ID. Set the redirect URL. This should be the wallet or application frontend.

![1](../../../../concepts/cryptography/images/zklogin-twitch1.png "Sign up for Twitch developer account")

*Sign up for Twitch developer account*

![2](../../../../concepts/cryptography/images/zklogin-twitch2.png "Go to Console")

*Go to Console*

</TabItem>

<TabItem label="Kakao" value="kakao">

1. Register for a Kakao developer account. Access the [dashboard](https://developers.kakao.com/console/app) and add an application.

![1](../../../../concepts/cryptography/images/zklogin-kakao1.png "Add applications to Kakao")

*Add applications to Kakao*

1. Go to **App Keys** where you can find the corresponding client ID for different platforms.

- Native app key: Used to call APIs through the Android or iOS SDK.
- JavaScript key: Used to call APIs through the JavaScript SDK.
- REST API key: Used to call APIs through the REST API.

![2](../../../../concepts/cryptography/images/zklogin-kakao2.png "Find Client ID")

*Find client ID*

1. Toggle on **Kakao Login Activation** and **OpenID Connect Activation**.Set the redirect URL in **Kakao Login** under **Product Settings**.This should be the wallet or application frontend.

![1](../../../../concepts/cryptography/images/zklogin-kakao3.png "Set Redirect URL")

*Set redirect URL*

</TabItem>

<TabItem label="Slack" value="slack">

1. Register for a Slack developer account. Access the [dashboard](https://api.slack.com/apps) and go to **Create New App** then choose **From scratch**.

	![1](../../../../concepts/cryptography/images/zklogin-slack1.png "Create app in Slack")

	*Create app in Slack*

1. Find the Client ID and Client Secret under **App Credentials**.

	![1](../../../../concepts/cryptography/images/zklogin-slack2.png "Find Client ID and Client Secret")

	*Find Client ID and Client Secret*

1. Set Redirect URL in **OAuth & Permissions** under **Features**. This should be the wallet or application frontend.

	![1](../../../../concepts/cryptography/images/zklogin-slack3.png "Set Redirect URL")

	*Set Redirect URL*

</TabItem>

<TabItem label="Apple" value="apple">

1. Register for an [Apple developer account](https://developer.apple.com/). Go to the **Certificates, Identifiers and Profiles** section.

	![1](../../../../concepts/cryptography/images/zklogin-apple1.png "Click on Certificates, Identifiers and Profiles")
	
	*This is where you can create Certificates, Identifiers and Profiles*

1. Create an App ID
    - From the sidebar, select **Identifiers** and click the blue plus icon to create a new one.
    - Choose **App IDs** as the identifier type and click **Continue**.
    - In the next screen, enter a descriptive name for your App ID and a unique Bundle ID in reverse-dns format (for example, `com.example.app`).
    - Scroll down to the list of capabilities and enable **Sign In with Apple** by checking the box next to it.

	![1](../../../../concepts/cryptography/images/zklogin-apple2.png "Create an App ID")
	
	*This is how you can enable Sign In with Apple for your App ID*

1. Create a Services ID

	A Services ID identifies a specific instance of your app and is used as the OAuth `client_id`. You need a Services ID if you want to use **Sign In with Apple** for your web app.

	![1](../../../../concepts/cryptography/images/zklogin-apple3.png "Create a Services ID")

	*This is where you Create a Services ID*

1. Create a new identifier and select **Services IDs** as the identifier type.

    - In the next step, enter a name for your app that will be displayed to the users during the sign-in process and a unique identifier that will be used as the OAuth `client_id`. Make sure to enable **Sign In with Apple** by checking the box next to it.
	- Click the **Configure** button next to **Sign In with Apple** to set up the domain and redirect URLs for your app. You need to specify the domain name where your app is hosted and the redirect URL that will handle the OAuth response from Apple.

	Select the App ID that you created in the previous step as the Primary App ID. This will associate your Services ID with your App ID.

	Enter the domain name of your app (for example, example-app.com) and the redirect URL that will receive the authorization code from Apple (for example, https://example-app.com/redirect). Note that Apple does not allow localhost or IP addresses as valid domains or redirect URLs.

	Click **Save** and then **Continue** and **Register** until you complete this step.

	You have now created an App ID and a Services ID for your app. The identifier of your Services ID is your OAuth `client_id`. In my example, that is com.example.client.

	![1](../../../../concepts/cryptography/images/zklogin-apple4.png "Set Redirect URL")
	
	*This is where you Set Redirect URL*

</TabItem>

<TabItem label="Microsoft" value="microsoft">

1. Register and sign in to the [Microsoft Entra admin center](https://entra.microsoft.com/). 
1. Select **Applications** > **App registrations** from the left nav.

	![Nav menu](./images/microsoft1.png)
1. Click the **New Registration** button in the top left to open the **Register an application** page.

	![New Registration](./images/microsoft2.png)
1. Type the application name in the **Name** field, select the appropriate **Supported account types** option, and set the **Redirect URI** value. When satisfied, click **Register**.

	![Create application page](./images/microsoft3.png "Create application")
1. After clicking the **Register** button, the admin center opens the application view. Select **Authentication** from the left nav of the application view.

	![Select Authentication](./images/microsoft4.png "Select Authentication")
1. In the **Implicit grant and hybrid flows** section, check the **ID tokens (used for implicit and hybrid flows)** box.

	![Enable ID tokens](./images/microsoft5.png "Enable ID tokens")
1. Click **Save**.
1. Client ID is available in the **Essentials** section of the application's **Overview** tab.

	![Find Client ID](./images/microsoft6.png "Find Client ID")
</TabItem>

</Tabs>

## Related links

<RelatedLink to="/guides/developer/cryptography/zklogin-integration.mdx" />
<RelatedLink to="/guides/developer/cryptography/zklogin-integration/zklogin-example.mdx" />

>>>> sui/docs/content/guides/developer/cryptography/zklogin-integration/zklogin-example.mdx
---
title: zkLogin Example
description: An example that breaks down the logic behind each step of zkLogin.
keywords: [ zklogin, how to use zklogin, generate ephemeral key pair, fetch JWT, decode JWT, generate salt, generate user Sui address, fetch ZK proof, assemble zkLogin signature ]
---

The Sui community created an example to facilitate a comprehensive understanding of each step involved in Sui zkLogin for developers.

- [Sui zkLogin Example](https://sui-zklogin.vercel.app/)

![ZKLogin Overview](images/overview.png "ZKLogin Overview")
This example breaks down the complete process of Sui zkLogin into seven steps, as follows:

1. Generate ephemeral key pair
1. Fetch JWT
1. Decode JWT
1. Generate salt
1. Generate user Sui address
1. Fetch ZK proof
1. Assemble zkLogin signature

Each step includes corresponding code snippets, providing instructions on how to obtain the required data for each step.

## Operating environment

The example runs in Sui Devnet. All data the user generates is stored locally on the client-side (browser). The acquisition of the zero-knowledge proof (ZK proof) is done through a call to the [Mysten Labs-maintained proving service](../zklogin-integration.mdx#call-the-mysten-labs-maintained-proving-service). Therefore, running the example does not require an additional deployed backend server (or a Docker container).

## Storage locations for key data

The following table lists the storage location for key data the example uses:

| Data | Storage location |
| --- | --- |
| Ephemeral key pair | `window.sessionStorage` |
| Randomness | `window.sessionStorage` | 
| User salt | `window.localStorage` | 
| Max epoch | `window.localStorage` | 

The user salt is stored long-term in the browser's `localStorage`. Consequently, provided the `localStorage` is not cleared manually, you can use the same JWT (in this example, logging in with the same Google account) to access the corresponding zkLogin address generated from the current salt value at any time.

:::caution

Changing browsers or devices results in the inability to access previously generated Sui zkLogin addresses, even when using the same JWT.

:::

## Troubleshooting

- **ZK Proof request failure:**
  - This might occur because of inconsistencies in the creation of multiple randomness or user salts, causing request failures. Click the **Reset Button** in the top right corner of the UI to restart the entire process.

- **Request test tokens failure:**
  - This is because you have surpassed the faucet server request frequency limitations. 
  - You can go to Sui [#devnet-faucet](https://discord.com/channels/916379725201563759/971488439931392130) or [#testnet-faucet](https://discord.com/channels/916379725201563759/1037811694564560966) Discord channels to claim test coins.

- Any suggestions are welcome on the project's GitHub repo through raised issues, and of course, pull requests are highly appreciated.

## Related links

<RelatedLink to="/guides/developer/cryptography/zklogin-integration.mdx" />
<RelatedLink to="/concepts/cryptography/zklogin.mdx#faq" />
<RelatedLink to="/guides/developer/cryptography/zklogin-integration/developer-account.mdx" />

>>>> sui/docs/content/concepts.mdx
---
title: Sui Concepts Overview
sidebar_label: Overview
description: Learn about how Sui is different from other blockchains. 
keywords: [ app developers, move, move book, objects, cryptography, tokenomics ]
---

Sui is different than other blockchains. The concepts explored in this section provide a background to the Sui blockchain and Web3 in general.

## App developers

<Cards>
<Card title="Move overview" href="/concepts/sui-move-concepts"/>
<Card title="Package upgrades" href="/concepts/sui-move-concepts/packages/upgrade"/>
<Card title="Gaming on Sui" href="/concepts/gaming"/>
<Card title="The Move Book" href="https://move-book.com">
A comprehensive guide to the Move programming language on the Sui blockchain.
</Card>
</Cards>

## Objects

<Cards>
<Card title="Object Model" href="concepts/object-model"/>
<Card title="Transfer to Object" href="concepts/transfers/transfer-to-object"/>
</Cards>

## Cryptography

<Cards>
<Card title="zkLogin" href="concepts/cryptography/zklogin"/>
<Card title="Transaction authentication" href="concepts/cryptography/transaction-auth"/>
</Cards>

## Tokenomics

<Cards>
<Card title="SUI tokenomics" href="concepts/tokenomics" />
<Card title="Gas in Sui" href="concepts/tokenomics/gas-in-sui" />
<Card title="Vesting strategies" href="concepts/tokenomics/vesting-strategies" />
</Cards>

>>>> sui/docs/content/concepts/app-devs.mdx
---
title: App Developers
description: Topics covered in this section pertain to developing smart contracts on Sui.
keywords: [ app developers, develop apps, developer dapps, create apps, create dapps ]
pagination_prev: null
---

import ImportContent from "@site/src/components/ImportContent";

The topics in this section explore some of the concepts that are of interest to developers creating smart contracts on Sui. After becoming familiar with these concepts, be sure to check out the [Guides](../guides.mdx) section for instruction on how to implement these concepts in your own code. 

Instructions for common tasks, based on your role in the Sui ecosystem.

<Cards>
<Card title="Object Model" href="/concepts/object-model">
</Card>
<Card title="Move Overview" href="/concepts/sui-move-concepts">
</Card>
<Card title="Transactions" href="/concepts/transactions">
</Card>
<Card title="gRPC API for Sui" href="/concepts/grpc-overview">
</Card>
<Card title="GraphQL RPC for Sui" href="/concepts//graphql-rpc">
</Card>
</Cards>

>>>> sui/docs/content/concepts/architecture.mdx
---
title: Architecture
draft: true
---

Content coming soon
>>>> sui/docs/content/concepts/archival-store.mdx
---
title: Archival Store and Service (Beta)
description: Overview of the Archival Store and Service to access historical Sui network data.
beta: testnet, mainnet
keywords: [ grpc, g rpc, RPC, sui full node grpc, full node rpc, what is grpc, grpc on sui, graphql, graph ql, what is graphql, graphql rpc ]
---

The Archival Store and Service provide a scalable, consistent foundation for accessing historical data on Sui beyond what Full nodes or indexer databases typically retain. They power rich developer experiences through [gRPC](./grpc-overview.mdx) and [GraphQL](/concepts/graphql-indexer.mdx) APIs while keeping storage and operations manageable.

:::note

GraphQL RPC is yet to integrate with the Archival Service. Until that happens, the GraphQL RPC beta will only be available as a hosted service from the Sui Foundation, and connects directly to the Archival Store (Bigtable) operated by the Sui Foundation.

:::

:::info

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::

## Overview

- **Archival Store:** A long-term storage system (such as [Bigtable](https://cloud.google.com/bigtable)) that holds checkpoint-indexed Sui data.
- **Archival Service:** A [gRPC API (LedgerService)](./grpc-overview.mdx) layer that exposes access to this store, enabling point lookups of historical data.

Together, they let developers and data providers access older transactions, object versions, and checkpoints that Full nodes no longer store.

## When and why to use

Though their goals and usage patterns differ, both developers and RPC / data providers benefit from using the Archival Store and Service.

### Developers

- Access historical data for rendering UI features like transaction history, object lineage, and previous app states.
- Rely on hosted archival services for long-term data to avoid infrastructure overhead.
- Implement fallback mechanisms in apps such that they can query archival data if Full nodes or indexer databases return insufficient retention.

### RPC and data providers

- Operate a differentiated infrastructure service by offering historical data access to developers.
- Extend the retention horizon of GraphQL or gRPC-based APIs by using the Archival Service.
- Maintain operational independence by running your own Archival Store and Service (using Bigtable) or a custom backend).

## Accessing the Archival Service

### Developers

Access the Archival Service hosted by any participating provider. Sui Foundation offers a public good service on a Bigtable-based store. This service has strict rate limits:

- Testnet: archive.testnet.sui.io
- Mainnet: archive.mainnet.sui.io

### RPC and data providers

Operate the Archival Store and Service yourself:

- Deploy the Archival Service binary.
- Maintain a store like Bigtable.
- Populate the store with checkpoints using an ingestion mechanism.

Refer to [populating the Archival Store](#populating-the-archival-store) and [running the Archival Service](#running-the-archival-service).

## Populating the Archival Store

Run an indexer pipeline to keep the Archival Store updated. Sui Foundation provides an ingestion mechanism for Bigtable:

- Tool: [sui-kv-store](https://github.com/MystenLabs/sui/tree/main/crates/sui-kvstore)
- Run the following script to initialize the Bigtable cluster:
```shell
$ ./crates/sui-kvstore/src/bigtable/init.sh <name_of_bigtable_cluster>
```
- Run the ingestion daemon with:
```shell
$ cargo run --bin sui-kvstore <name_of_your_bigtable_cluster> ingestion <mainnet|testnet>
```

If you're using a different storage backend:

- Build a compatible indexer using the [custom indexing framework](./custom-indexing-framework.mdx).
- Ensure it emits data in a structure that is compatible with the [gRPC API's](./grpc-overview.mdx) `LedgerService` endpoints.

## Running the Archival Service

The Archival Service implements the [gRPC API's](./grpc-overview.mdx) `LedgerService`. Any implementation must support this interface.

- Reference implementation for Bigtable: [sui-kv-rpc](https://github.com/MystenLabs/sui/tree/main/crates/sui-kv-rpc).
- Deploy the service independently or colocated with other infrastructure.

## Integration points

### gRPC APIs

- Apps can query the Archival Service directly when gRPC on Full nodes returns retention-related errors. This approach provides a graceful fallback without requiring the app or Full node to store historical data itself.
- Access the Archival Service in the same way you access [gRPC `LedgerService` APIs](./grpc-overview.mdx) on a Full node. Replace the Full node URL with the Archival Service endpoint.

### GraphQL RPC

- [GraphQL RPC](/concepts/graphql-indexer.mdx) will delegate historical lookups to the Archival Service using the planned integration. It will enable cost-efficient setup of a General-purpose Indexer database with limited retention.

## Related links

<RelatedLink href="https://cloud.google.com/bigtable" label="Bigtable" desc="Low-latency, Cassandra, and HBase-compatible NoSQL database service for machine learning, operational analytics, and user-facing applications." />

>>>> sui/docs/content/concepts/components.mdx
---
title: Sui Components
description: Sui is a layer 1 blockchain that performs its own consensus and validation of transaction blocks. Sui is comprised of the blockchain itself, the blockchain's activity such as transactions, and the validator entities that verify this activity. 
keywords: [ sui blockchain, sui components, sui validators, sui transactions, components of sui, what is sui comprised of, delegated proof of stake, delegated proof-of-stake, dpos, consensus, sui networks, sui mainnet, sui testnet, sui devnet, move, move language ]
---

The name Sui, pronounced swÄ“ in English, is derived from a Japanese word for the element of water. You can see this influence in the name of the blockchain, its native token elements (SUI and MIST), and the imagery used in its branding. 

When you read about Sui in this documentation, it's referencing all the pieces of the system that comprise the blockchain. This includes the blockchain itself, its various networks (Mainnet, for example), the activity on the blockchain (transaction blocks), the distributed entities that verify this activity (validators), and the Full nodes that execute transaction blocks. The documentation refers to the entirety of these elements as the Sui platform, or simply Sui.

## The Sui blockchain

Sui is defined as a layer 1 protocol blockchain. In basic terms, this means that Sui performs its own consensus and validation for transaction blocks (activity) on its networks using its own native token (SUI, in this case). Ethereum (ETH) and Bitcoin (BTC) are other examples of layer 1 blockchains. 

Layer 2 blockchains, by contrast, leverage the infrastructure of layer 1 networks, relying on the layer 1 blockchain to finalize transaction blocks. Polygon (MATIC) is an example of a Layer 2 blockchain that extends Ethereum.

## SUI tokens

The native token for Sui is SUI. Whenever the documentation mentions SUI (all uppercase letters), it's referring to this token. Transaction blocks on Sui often deal with small fractions of the value of one SUI. To make these transaction blocks easier to work with, Sui provides MIST. It takes one billion MIST to equal one SUI. 

There is a cost associated with everything, and blockchain transactions are no exception. It costs money to provide computational power to process transaction blocks and store their results. The term for the cost of processing transaction blocks is _gas_. You pay for gas and the cost of storing data with a blockchain's native tokens, in this case, SUI (or MIST).

To learn more about the tokenomics of Sui, see the following topics:

- [Sui Tokenomics](./tokenomics.mdx)
- [Gas in Sui](./tokenomics/gas-in-sui.mdx)
- [Gas Pricing](./tokenomics/gas-pricing.mdx)
- [Staking and Unstaking](./tokenomics/staking-unstaking.mdx)
- [Sui Bridging](./tokenomics/sui-bridging.mdx)

## Delegated proof-of-stake consensus

Sui uses a delegated proof-of-stake (DPoS) consensus mechanism to validate on-chain transaction blocks. This means that validators on the Sui network must have a certain amount of SUI secured on Sui Mainnet, either with their own funds or in partnership with Sui Foundation, to prove their interest in the security of the blockchain. This approach aligns the interest of all validators with that of Sui users (an efficient, secure blockchain), without the high energy-resource demands of earlier blockchains. 

To learn more about consensus on Sui, see the following guides and topics:

- [Validator Committee](/guides/operator/validator/validator-committee.mdx)
- [Sui Full Node Data Management](/guides/operator/data-management.mdx) 

## Sui networks

Sui has several networks available, each serving a different purpose.

- **Mainnet:** The network that processes production transaction blocks. When you trade SUI or NFTs that are ultimately based on fiat currency, you are doing so on Mainnet.
- **Testnet:** Staging network to provide quality assurance that any planned changes to Sui do not adversely impact performance. Developers can use this network to test their code before placing it in production.
- **Devnet:** A more unstable network that is used to develop new features. Developers can leverage this network to code against the latest planned features of Sui.
- **Localnet:** You can run a Sui network on your local computer. Developing on a local network provides an optimized workflow in an environment you control. 

To learn more about these networks and how to interact with them, see the following guides:

- [Create a Local Sui Network](/guides/developer/sui-101/local-network.mdx)

## Move

The Move language provides the logic for all activity on Sui, like trading NFTs, playing Sui-integrated games (dApps), and all other transaction-based events. The Sui platform uses a concept novel to earlier blockchains, where blocks on the chain are actually objects that define assets rather than simple key-value stores that define addresses. The increased programmability inherent with objects required a more robust logic engine to maximize the benefits of this new approach to blockchain technology. 

To learn more about Move, see [Move Concepts](./sui-move-concepts.mdx).

>>>> sui/docs/content/concepts/cryptography.mdx
---
title: Cryptography
description: Sui supports multiple cryptography algorithms and primitives, while also defining its own such as public keys, signatures, aggregated signatures, and hash functions. 
keywords: [ cryptographic primitives, public keys, signatures, aggregated signatures, hash functions, cryptographic algorithms, cryptography on sui, zkLogin, transaction authentication, passkey ]
pagination_prev: null
---

Cryptographic agility is core to Sui. The system supports multiple cryptography algorithms and primitives and can switch between them rapidly. With Sui, you can choose the right cryptography solution for your system and implement the latest algorithms as they become available.

Sui defines its cryptography primitives, such as public key, signature, aggregated signature, and hash functions, under one unified type alias or enum wrapper that is shared across the entire repository. Making changes to these primitives affects all of an application's components. You can quickly update application cryptography and be assured of uniform security.

<Cards>
<Card title="Transaction Authentication" href="/concepts/cryptography/transaction-auth">
</Card>
<Card title="zkLogin" href="/concepts/cryptography/zklogin">
</Card>
<Card title="Passkey" href="/concepts/cryptography/passkeys">
</Card>
</Cards>

>>>> sui/docs/content/concepts/cryptography/nautilus.mdx
---
title: Nautilus
description: Run secure, off-chain logic in trusted execution environments (TEEs), and verify it on-chain to trigger safe smart contract workflows.
---

Nautilus is a framework for secure and verifiable off-chain computation on Sui. It enables builders to delegate sensitive or resource-intensive tasks to a self-managed [trusted execution environment (TEE)](https://en.wikipedia.org/wiki/Trusted_execution_environment) while preserving trust on-chain through smart contract-based verification.

Nautilus supports hybrid decentralized applications (dApps) that require:
- Private data handling
- Complex computations
- Integration with external (Web2) systems

The framework ensures computations are tamper-resistant, isolated, and cryptographically verifiable.

It currently supports self-managed [AWS Nitro Enclave TEEs](https://aws.amazon.com/ec2/nitro/nitro-enclaves/). Developers can verify AWS-signed enclave attestations on-chain using Sui smart contracts written in Move. Refer to the [Github repo](https://github.com/MystenLabs/nautilus) for the reproducible build template.

## Features

A Nautilus application consists of 2 components:

- **Off-chain server:** Runs inside a TEE (like AWS Nitro Enclaves) and handles computations like user input processing or scheduled tasks.
- **On-chain smart contract**: Written in Move, verifies TEE attestations before executing transactions.

:::info

Initial support for AWS Nitro Enclaves is due to its maturity and reproducibility. Additional TEE providers might become available in the future.

:::

### How it works

- Deploy the off-chain server to a self-managed TEE, such as AWS Nitro Enclaves. You have the option of using the [available reproducible build template](https://github.com/MystenLabs/nautilus).
- The TEE generates a cryptographic attestation that proves the integrity of the execution environment.
- Sui smart contracts verify the attestation on-chain before accepting the TEE output.
- The integrity of the TEE is auditable and anchored by the provider's root of trust.

Refer to [Nautilus Design](nautilus/nautilus-design.mdx) and [Using Nautilus](nautilus/using-nautilus.mdx) for details.

:::important

The [provided reproducible build template](https://github.com/MystenLabs/nautilus) is intended as a starting point for building your own enclave. It is not feature complete, has not undergone a security audit, and is offered as a modification-friendly reference licensed under the Apache 2.0 license. THE TEMPLATE AND ITS RELATED DOCUMENTATION ARE PROVIDED `AS IS` WITHOUT WARRANTY OF ANY KIND FOR EVALUATION PURPOSES ONLY.
You can adapt and extend it to fit your specific use case.

:::

## Use cases

Nautilus supports several Web3 use cases for trustworthy and verifiable off-chain computation. Some examples include:

- **Trusted oracles**: Process off-chain data from Web2 services (weather, sports, financial data) or decentralized storage platforms like [Walrus](https://walrus.xyz) in a tamper-resistant way.
- **AI agents:** Nautilus is ideal for securely running AI models for inference or to execute agentic workflows to produce actionable outcomes, while providing data and model provenance on-chain.
- **DePIN solutions:** DePIN (Decentralized Physical Infrastructure) can leverage Nautilus for private data computation in IoT and supply chain networks.
- **Fraud prevention in multi-party systems:** Decentralized exchanges (DEXs) could use Nautilus for order matching and settlement, or layer-2 solutions could prevent collision and fraud by securely running computations between untrusted parties.
- **Identity management:** Nautilus can provide solutions in the identity management space that require on-chain verifiability for decentralized governance and proof of tamper resistance.

When used together, Nautilus and [Seal](https://github.com/MystenLabs/seal) enable powerful privacy-preserving use cases by combining secure and verifiable computation with secure key access. A common challenge with TEEs is persisting secret keys across restarts and different machines. Seal can address this by securely storing long-term keys and granting access only to properly attested TEEs. In this model, Nautilus handles computation over the encrypted data, while Seal controls key access. Applications that require a shared encrypted state can use both tools to privately process user requests and update encrypted data on public networks.

## Future plans and non-goals

Nautilus will support additional TEE providers in the future. Your suggestions on which platforms to prioritize or support is greatly appreciated. Contact the Nautilus team on [Sui Discord](https://discord.com/channels/916379725201563759/1361500579603546223).

<ImportContent source="contact-nautilus.mdx" mode="snippet" />

Nautilus does not have a native, readily usable TEE network. Nautilus partners might provide such TEE networks, however. Apart from such networks, you are encouraged to deploy and manage your own TEEs for running off-chain Nautilus servers.
>>>> sui/docs/content/concepts/cryptography/nautilus/nautilus-design.mdx
---
title: Nautilus Design
description: Overview of the design aspects of Nautilus, including its trust model.
---

![image](../images/flows.png)

## dApp developer actions

1. Create a Nautilus off-chain server with a reproducible build using the [provided template](https://github.com/MystenLabs/nautilus).
1. Publish the server code to a public repository like GitHub to ensure transparency and verifiability.
1. Register the platform configuration registers (PCRs) of the instance. PCRs are measurements of the trusted computing base. Use a Sui smart contract to register them.
1. Deploy the server to an AWS Nitro Enclave.
1. Register the deployed enclave using a Sui smart contract and attestation document. Include the ephemeral public key of the enclave for signing responses.

To reduce the trusted computing base, route access to the enclave through backend services that handle load balancing, rate limiting, and other related aspects.

:::tip

Verify attestation documents on-chain only during enclave registration due to high gas costs. After registration, use the enclave key for more efficient message verification.

:::

## dApp user and client actions

1. (Optional) Verify the Nautilus off-chain server code by building it locally and confirming that the generated PCRs match the on-chain records.
1. Send a request to the deployed enclave and receive a signed response.
1. Submit the signed response on-chain for verification before executing the corresponding application logic.

## Trust model

The attestation document from an AWS Nitro Enclave includes a certificate chain that you can verify on-chain using AWS as the root certificate authority. This verification confirms the following:

- The enclave instance is running unmodified software, as validated by its PCR values.
- Users can independently verify that the computation of the instance aligns with the published source code, ensuring transparency and trust.

Reproducible builds allow builders and users to optionally verify that the binary running inside an enclave instance matches a specific version of the source code. This approach provides the following benefits:

- Anyone can build and compare the binary to confirm consistency with the published source code.
- Any changes to the software result in different PCR values, making unauthorized modifications detectable.
- Reproducible builds shift the trust from runtime to build time, strengthening the overall security posture of the dApp.

:::info

Reproducible builds might not apply to all use cases, such as when the source code is not public.

:::

### TEE security considerations

Nautilus uses cloud-based enclaves designed to protect against software-level attacks. The focus on cloud-hosted TEEs, like AWS Nitro Enclaves, is intentional for the following reasons:

- **Cloud providers respond quickly to vulnerabilities.** They receive early signals about security issues and can patch them efficiently.
- **They maintain strong physical security.** Access to cloud data centers is tightly controlled, reducing the risk of physical hardware attacks.
- **They operate under strict compliance standards.** Providers like AWS and GCP are regularly audited against frameworks like SOC 2, ISO 27001, CSA STAR, and others, ensuring operational integrity.

You are encouraged to evaluate whether this trust model aligns with the threat profile and security needs of your application.
>>>> sui/docs/content/concepts/cryptography/nautilus/using-nautilus.mdx
---
title: Using Nautilus
description: Details on how to use Nautilus with the reproducible build template
---

The [Nautilus framework](https://github.com/MystenLabs/nautilus) helps you deploy an AWS Nitro Enclave with scaffolding such as reproducible builds, signature formatting, and HTTPS traffic forwarding. This allows you to focus on implementing the off-chain computation logic inside the enclave.

The framework also provides an on-chain template that includes the minimal smart contract code required to register a Nautilus instance and its public key. To use Nautilus in your dApp:

1. Implement the enclave in Rust with the desired computation logic.  
2. Deploy a Move smart contract that stores the expected platform configuration registers (PCRs) and allows updates by the contract deployer.  
3. Deploy the enclave instance on AWS and register it on-chain using its attestation document.  
4. Upload signed responses from the registered enclave, verify them on-chain, and consume the results in your smart contract.  

## Purpose of this guide

This guide walks you through the following steps:

1. Write and deploy a basic Nautilus off-chain instance using AWS Nitro Enclaves. The example instance runs a server that fetches weather data for a specific location.  
2. Write a Move smart contract that registers the enclave by verifying its attestation and public key, then verifies the Nautilus response (signature and payload) on-chain and mints an NFT with the location and temperature data.  

The setup script performs these actions:

- Launches a preconfigured EC2 instance and allocates a Nitro Enclave.  
- Builds the Rust-based template application into an enclave image format (EIF) binary and runs it inside the enclave.  
- Configures required HTTP domains so the enclave can access external APIs through the parent EC2 instance (as the enclave itself has no internet access).  
- Exposes three endpoints to allow client-side communication with the enclave.  

When the enclave starts, it generates a fresh key pair and exposes the following endpoints:

- `health_check`: Probes allowed domains inside the enclave. This logic is built into the template and does not require modification.  
- `get_attestation`: Returns a signed attestation document over the enclave public key. Use this during on-chain registration. This logic is built into the template and does not require modification.  
- `process_data`: Fetches weather data from an external API, signs it with the enclave key, and returns the result. You must implement this customizable logic.  

## Code structure

Refer to the [GitHub repository](https://github.com/MystenLabs/nautilus) for the latest structure and related instructions.

```sh title="Repository structure"
/move
  /enclave          # Utility functions for enclave config and public key registration
  /weather-example  # Example on-chain logic using enclave functions
  /twitter-example  # Alternative example on-chain logic

/src
  /aws              # AWS boilerplate; does not require modification.
  /init             # AWS boilerplate; does not require modification.
  /system           # AWS boilerplate; does not require modification.
  /nautilus-server  # Nautilus server that runs inside the enclave.
    /src
      /apps
        /weather-example    # Example directory. Replace with your own application logic as needed.
          mod.rs            # Defines the process_data endpoint and related logic. Replace with your off-chain computation logic.
          allowed_endpoints.yaml  # Lists all endpoints the enclave can access. By default, the enclave has no internet access. During configuration, this file generates code for traffic forwarding.
        /twitter-example    # Another example directory with similar structure. 
    run.sh           # Runs the Rust server inside the enclave. Do not modify.
    common.rs        # Common code for retrieving attestation. Do not modify. 
```

Key implementation files:

- `allowed_endpoints.yaml`: Defines external API access permissions.  
- `mod.rs`: Contains application-specific computation logic.  
- `run.sh`: Handles server startup and configuration.  
- `common.rs`: Manages retrieving attestation.  

To create your own Nautilus app:

- Add a directory under `move/my_app` for your Move modules.  
- Add a directory under `src/nautilus-server/src/apps/my_app` for your Rust server logic.  
- Use existing app directories as references.  
- Build frontend logic to interact with the deployed Move contract and enclave-hosted Rust server.  

Most of the template can remain unmodified, which streamlines development while giving you full control over app-specific logic.

:::info
Frontend code is not included in this guide. The Move call is demonstrated using the CLI.
:::

## Run the example enclave

1. Set up an AWS developer account and install the AWS CLI. For detailed instructions, see the [AWS Nitro Enclaves getting started guide](https://docs.aws.amazon.com/enclaves/latest/user/getting-started.html#launch-instance).

1. Run the following script and follow the prompts. The script prompts you to enter some values - see the next step if you want to run this example as is. If the script completes successfully, it generates code locally that you need to commit. If you encounter issues, refer to the information box that follows, as instructions might vary depending on your AWS account settings.

    ```sh
    $ export KEY_PAIR=<your-key-pair-name>
    $ export AWS_ACCESS_KEY_ID=<your-access-key>
    $ export AWS_SECRET_ACCESS_KEY=<your-secret-key>
    $ export AWS_SESSION_TOKEN=<your-session-token>
    $ sh configure_enclave.sh <APP> # ex. `sh configure_enclave.sh weather-example`
    ```

    :::info

    - Run `sh configure_enclave.sh -h` to view additional instructions.
    - If your AWS account is not in `us-east-1`, you might need to configure `REGION` and `AMI_ID` values specific to your region. Refer to this [guide](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/finding-an-ami.html) to find a suitable Amazon Linux image ID. 

        ```sh
        $ export REGION=<your-region>
        $ export AMI_ID=<find-an-amazon-linux-ami-for-your-region>
        ```
    - To find the values for `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_SESSION_TOKEN`, refer to this [AWS guide](https://docs.aws.amazon.com/streams/latest/dev/setting-up.html).
    - Set `KEY_PAIR` to the name of your existing AWS key pair or one you create. To create a key pair, refer to this [AWS guide](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/create-key-pairs.html).
    - You might need to create a VPC with a public subnet. Refer to this [AWS guide](https://000058.awsstudygroup.com/2-prerequiste/2.1-createec2/2.1.2-createpublicsubnet/) for instructions.

    :::

1. To run the weather example as is, you do not need to modify `allowed_endpoints.yaml` because it already includes `api.weatherapi.com`. Follow the prompts to enter the required values. This step demonstrates how to store a secret (an API key) using AWS Secrets Manager, so you can avoid including the secret in the public application code.

    ```sh
    Enter EC2 instance base name: weather # anything you like
    Do you want to use a secret? (y/n): y
    Do you want to create a new secret or use an existing secret ARN? (new/existing): new
    Enter secret name: weather-api-key # anything you like
    Enter secret value: 045a27812dbe456392913223221306 # this is an example api key, you can get your own at weatherapi.com
    ```
    For the Twitter example, this secret value refers to the API Bearer Token associated with your Twitter Developer account.

2. If the script completes successfully, changes are generated in `/src/nautilus-server/run.sh` and `expose_enclave.sh`. Commit these changes, as they are required when building the enclave image.

    :::info

    - To allow the enclave to access additional external domains, add them to `allowed_endpoints.yaml`. If you update this file, you must rerun `configure_enclave.sh` to generate a new instance, as the endpoint list is compiled into the enclave build.
    - You can optionally create a secret to store any sensitive value you do not want included in the codebase. The secret is passed to the enclave as an environment variable. You can verify newly created secrets or find existing ARNs in the [AWS Secrets Manager console](https://us-east-1.console.aws.amazon.com/secretsmanager/).

    :::

3. Connect to your instance and clone the repository. For detailed instructions, see [Connect to your Linux instance using SSH](https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/connect-linux-inst-ssh.html#connect-linux-inst-sshClient) in the AWS documentation.

4. You are now inside the directory containing the server code, including the committed file changes from the previous step. Next, build the enclave image, run it, and expose the HTTP endpoint on port 3000. 

    ```sh
    $ cd nautilus/
    $ make ENCLAVE_APP=<APP> && make run # this builds the enclave and runs it, ex. `make ENCLAVE_APP=weather-example`
    $ sh expose_enclave.sh # this exposes port 3000 to the Internet for traffic
    ```

    :::info

    Use `make run-debug` instead of `make run` to run the enclave in debug mode. This prints all logs, where the production build does not. In debug mode, the PCR values are all zeros and are not valid for production use.

    :::

5. Congratulations. ðŸŽ‰ You can now interact with the enclave from the outside world. You can find the `PUBLIC_IP` in the AWS console.

    ```sh
    $ curl -H 'Content-Type: application/json' -X GET http://<PUBLIC_IP>:3000/health_check
    $ curl -H 'Content-Type: application/json' -X GET http://<PUBLIC_IP>:3000/get_attestation
    $ curl -H 'Content-Type: application/json' -d '{"payload": { "location": "San Francisco"}}' -X POST http://<PUBLIC_IP>:3000/process_data
    ```

6. Optionally, you can set up an application load balancer (ALB) for the EC2 instance with an SSL/TLS certificate from AWS Certificate Manager (ACM), and configure Amazon Route 53 for DNS routing. For more information, see the [ACM User Guide](https://docs.aws.amazon.com/acm/latest/userguide/gs-acm-request-public.html) and the [ALB Guide](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/introduction.html).

## Develop your own Nautilus server

The Nautilus server logic lives in `src/nautilus-server`. To customize the application, refer to `apps/weather-example` or `apps/twitter-example` as templates:

- Define `allowed_endpoints.yaml` to specify any external domains your application needs to access.
- Create `mod.rs` to define your `process_data` logic and register any additional endpoints.

The following files typically do not require modification:

- `common.rs` handles the `get_attestation` endpoint.
- `main.rs` initializes the ephemeral key pair and sets up the HTTP server.

You can test most functionality by running the server locally. However, the `get_attestation` endpoint doesn't work locally because it requires access to the Nitro Secure Module (NSM) driver, which is only available when running the code inside the configured EC2 instance. This endpoint functions correctly when the server runs within the enclave as described in the setup steps.

To test the `process_data` endpoint locally, run the following:

```sh
$ cd src/nautilus-server/
$ RUST_LOG=debug API_KEY=045a27812dbe456392913223221306 cargo run --features=weather-example --bin nautilus-server
$ curl -H 'Content-Type: application/json' -d '{"payload": { "location": "San Francisco"}}' -X POST http://localhost:3000/process_data
```

<details>

<summary>Output</summary>

```json
{
  "response":
    {
      "intent":0,
      "timestamp_ms":1744041600000,
      "data":
        {
          "location":"San Francisco",
          "temperature":13
        }
    },
  "signature":"b75d2d44c4a6b3c676fe087465c0e85206b101e21be6cda4c9ab2fd4ba5c0d8c623bf0166e274c5491a66001d254ce4c8c345b78411fdee7225111960cff250a"
}
```

</details>


### Troubleshooting

- **Traffic forwarder error:** Ensure all targeted domains are listed in the `allowed_endpoints.yaml`. Use the following command to test enclave connections to all domains.

```sh
$ curl -H 'Content-Type: application/json' -X GET http://<PUBLIC_IP>:3000/health_check
```

<details>

<summary>Output</summary>

```json
{
  "pk":"f343dae1df7f2c4676612368e40bf42878e522349e4135c2caa52bc79f0fc6e2",
  "endpoints_status":
    {
      "api.weatherapi.com":true
    }
}
```

</details>

- **Docker is not running:** The EC2 instance might still be starting up. Wait a few moments, then try again.

- **Cannot connect to enclave:** This might be due to a VSOCK communication issue. Verify that the enclave is running and properly exposed with `sh expose_enclave.sh`.

### Reset

```sh
$ cd nautilus/
$ sh reset_enclave.sh
```
Then repeat the image build step.

## Build locally to check reproducibility

Every enclave built from the same source code (everything in `/src`) can produce identical PCRs through reproducible builds. This includes any traffic forwarding changes made in `run.sh` (see branch `example-configuration`).

```sh
$ cd nautilus/
$ make ENCLAVE_APP=weather-example
$ cat out/nitro.pcrs
```

<details>

<summary>Output</summary>

```sh
911c87d0abc8c9840a0810d57dfb718865f35dc42010a2d5b30e7840b03edeea83a26aad51593ade1e47ab6cced4653e PCR0
911c87d0abc8c9840a0810d57dfb718865f35dc42010a2d5b30e7840b03edeea83a26aad51593ade1e47ab6cced4653e PCR1
21b9efbc184807662e966d34f390821309eeac6802309798826296bf3e8bec7c10edb30948c90ba67310f7b964fc500a PCR2
```

</details>

```sh
# Add env var that will be used later when registering the enclave.
$ PCR0=911c87d0abc8c9840a0810d57dfb718865f35dc42010a2d5b30e7840b03edeea83a26aad51593ade1e47ab6cced4653e
$ PCR1=911c87d0abc8c9840a0810d57dfb718865f35dc42010a2d5b30e7840b03edeea83a26aad51593ade1e47ab6cced4653e
$ PCR2=21b9efbc184807662e966d34f390821309eeac6802309798826296bf3e8bec7c10edb30948c90ba67310f7b964fc500a
```

## Register the enclave on chain

After finalizing the Rust code, the dApp administrator can register the enclave with the corresponding PCRs and public key.

```sh
# optionally
$ sui client switch --env testnet # or appropriate network
$ sui client faucet
$ sui client gas
# deploy the enclave package
$ cd move/enclave
$ sui move build
$ sui client publish

# record ENCLAVE_PACKAGE_ID as env var from publish output
$ ENCLAVE_PACKAGE_ID=0x3b009f952e11f0fa0612d0a8e07461fb69edc355d732e5d6e39267b1b4fd7138

# deploy your dApp logic
$ cd ../<APP>
$ sui move build
$ sui client publish

# record CAP_OBJECT_ID (owned object of type Cap), ENCLAVE_CONFIG_OBJECT_ID (shared object), APP_PACKAGE_ID (package containing weather module) as env var from publish output

$ CAP_OBJECT_ID=0xb232d20245ba2d624d1c1628c4fc062bd1d3249601385476d9736fc60c897d2b
$ ENCLAVE_CONFIG_OBJECT_ID=0x9a50017ab37090ef4b5704eb24201c88b2e4bbad2aad1d4e69ecf1bdfbae9ccb
$ APP_PACKAGE_ID=0x097b551dec72f0c47e32e5f8114d0d12a98ab31762d21adff295f6d95d353154

# record the deployed enclave url, e.g. http://<PUBLIC_IP>:3000
$ ENCLAVE_URL=<DEPLOYED_URL>

# the module name and otw name used to create the dApp, defined in your Move code `fun init`
$ MODULE_NAME=weather
$ OTW_NAME=WEATHER

# make sure all env vars are populated
$ echo $APP_PACKAGE_ID
$ echo $ENCLAVE_PACKAGE_ID
$ echo $CAP_OBJECT_ID
$ echo $ENCLAVE_CONFIG_OBJECT_ID
$ echo 0x$PCR0
$ echo 0x$PCR1
$ echo 0x$PCR2
$ echo $MODULE_NAME
$ echo $OTW_NAME
$ echo $ENCLAVE_URL

# =======
# the two steps that follow (update pcrs, register enclave) can be reused if enclave server is updated
# =======

# this calls the update_pcrs on-chain with the enclave cap and built PCRs, this can be reused to update PCRs if Rust server code is updated
$ sui client call --function update_pcrs --module enclave --package $ENCLAVE_PACKAGE_ID --type-args "$APP_PACKAGE_ID::$MODULE_NAME::$OTW_NAME" --args $ENCLAVE_CONFIG_OBJECT_ID $CAP_OBJECT_ID 0x$PCR0 0x$PCR1 0x$PCR2

# optional, give it a name you like
$ sui client call --function update_name --module enclave --package $ENCLAVE_PACKAGE_ID --type-args "$APP_PACKAGE_ID::$MODULE_NAME::$OTW_NAME" --args $ENCLAVE_CONFIG_OBJECT_ID $CAP_OBJECT_ID "weather enclave, updated 2025-05-13"

# this script calls the get_attestation endpoint from your enclave url and use it to calls register_enclave on-chain to register the public key, results in the created enclave object
$ sh ../../register_enclave.sh $ENCLAVE_PACKAGE_ID $APP_PACKAGE_ID $ENCLAVE_CONFIG_OBJECT_ID $ENCLAVE_URL $MODULE_NAME $OTW_NAME

# record the created shared object ENCLAVE_OBJECT_ID as env var from register output
$ ENCLAVE_OBJECT_ID=0x1c9ccfc0f391f5e679e1f9f7d53c7fa455bf977e0f6dc71222990401f359c42a
```

You can view an [example enclave config object](https://testnet.suivision.xyz/object/0x58a6a284aaea8c8e71151e4ae0de2350ae877f0bd94adc2b2d0266cf23b6b41d) containing PCR values on SuiScan. Additionally, see an [example enclave object](https://testnet.suivision.xyz/object/0xe0e70df5347560a1b43e5954267cadd1386a562095cb4285f2581bf2974c838d) that includes the registered enclave public key.

### Artifacts for Twitter example

```sh
$ cd nautilus/
$ make ENCLAVE_APP=twitter-example
$ cat out/nitro.pcrs
```

<details>
<summary>Output</summary>

```sh
968f1266150cf8c4d62c9692b9f9b8fd6889d9331019d323f67a6ae6ab88b9378ad23f49f58c349526b9fdd5865da879 PCR0
968f1266150cf8c4d62c9692b9f9b8fd6889d9331019d323f67a6ae6ab88b9378ad23f49f58c349526b9fdd5865da879 PCR1
21b9efbc184807662e966d34f390821309eeac6802309798826296bf3e8bec7c10edb30948c90ba67310f7b964fc500a PCR2
```

</details>

```sh
# Add environment variables to use later when registering the enclave.
$ PCR0=968f1266150cf8c4d62c9692b9f9b8fd6889d9331019d323f67a6ae6ab88b9378ad23f49f58c349526b9fdd5865da879
$ PCR1=968f1266150cf8c4d62c9692b9f9b8fd6889d9331019d323f67a6ae6ab88b9378ad23f49f58c349526b9fdd5865da879
$ PCR2=21b9efbc184807662e966d34f390821309eeac6802309798826296bf3e8bec7c10edb30948c90ba67310f7b964fc500a

$ MODULE_NAME=twitter
$ OTW_NAME=TWITTER

# replace with your registered enclave
$ ENCLAVE_PACKAGE_ID=0xcca410b231d0acfa92c7709d490ab2f15fb5619be719ee0786099ffc3f6c9ab8
$ APP_PACKAGE_ID=0x652875162b566bb04187c76f93215e56c28aa05487393056279e331598ba4978
$ CAP_OBJECT_ID=0x44f3b57aa3870762ad334424cccb7f4c785cac007baab7e987c6d6a43c6aa100
$ ENCLAVE_CONFIG_OBJECT_ID=0xe33641a2dae5eb4acad3859e603ec4e25641af05f837c85058645c7d8d9d831a
$ ENCLAVE_OBJECT_ID=0x53db077721140910697668f9b2ee80fbecd104ac076d60fc1fb49ae57cd96c0d

# replace with your own enclave IP
$ ENCLAVE_URL=http://<PUBLIC_IP>:3000
```

You can view an [example enclave config object](https://testnet.suivision.xyz/object/0xe33641a2dae5eb4acad3859e603ec4e25641af05f837c85058645c7d8d9d831a) containing PCR values. You can also view an [example enclave object](https://testnet.suivision.xyz/object/0x53db077721140910697668f9b2ee80fbecd104ac076d60fc1fb49ae57cd96c0d) that includes the registered enclave public key.

You can find the frontend code for the Twitter example [in this repository](https://github.com/MystenLabs/nautilus-twitter/tree/main/frontend).

### Enclave management

The template allows the admin to register multiple `Enclave` objects associated with one `EnclaveConfig` that defines PCRs. Each `Enclave` object represents a specific enclave instance with a unique public key, while the `EnclaveConfig` tracks the PCR values and their associated version. You can register all new `Enclave` instances with the latest `config_version` to ensure consistency. 

This design allows the admin to run multiple instances of the same enclave with different public keys, where `config_version` is set to the latest version when creating an `Enclave` object. The admin can register or destroy their `Enclave` objects. 

### Update PCRs

The deployer of the smart contract holds the `EnclaveCap`, which allows for updating the PCRs and enclave public key if the Nautilus server code has been modified. You can retrieve the new PCRs using `make ENCLAVE_APP=<APP> && cat out/nitro.pcrs`. To update the PCRs or register the enclave again, reuse the steps outlined in the previous section.

## Using the verified computation in Move

You can now write your frontend code to interact with the enclave for computation, and then send the resulting data to the Move contract for use. For the weather example, you can request the enclave to retrieve weather data for a specific location:

```sh
$ curl -H 'Content-Type: application/json' -d '{"payload": { "location": "San Francisco"}}' -X POST http://<PUBLIC_IP>:3000/process_data
```

<details>

<summary>Output</summary>

```json
{
  "response":
    {
      "intent":0,
      "timestamp_ms":1744683300000,
      "data":
        {
          "location":"San Francisco",
          "temperature":13
        }
    },
  "signature":"77b6d8be225440d00f3d6eb52e91076a8927cebfb520e58c19daf31ecf06b3798ec3d3ce9630a9eceee46d24f057794a60dd781657cb06d952269cfc5ae19500"
}
```

</details>

Then use the values from the enclave response - `signature`, `timestamp`, `location`, and `temperature` - to call `update_weather` in the Move contract. In this example, the call is demonstrated using a script, but it should be integrated into your dApp frontend.

```sh
$ sh ../../update_weather.sh \
    $APP_PACKAGE_ID \
    $MODULE_NAME \
    $OTW_NAME \
    $ENCLAVE_OBJECT_ID \
    "77b6d8be225440d00f3d6eb52e91076a8927cebfb520e58c19daf31ecf06b3798ec3d3ce9630a9eceee46d24f057794a60dd781657cb06d952269cfc5ae19500" \
    1744683300000 \
    "San Francisco" \
    13
```

An example of a [created weather NFT](https://testnet.suivision.xyz/object/0xa78e166630c0ed004b3115b474fed15d71f27fc80b68e37d451494c6e815931e) is available on network scanners.

### Signing payload

Signing payloads in Move are constructed using Binary Canonical Serialization (BCS). These must match the structure specified in the enclave Rust code when generating the signature; otherwise, signature verification in `enclave.move` might fail.

Write unit tests in both Move and Rust to ensure consistency. See `test_serde()` in `src/nautilus-server/src/app.rs` and the examples in `move/enclave/enclave.move`.

## FAQs

Some questions the community often asks about are answered in the following sections.

### Why did Sui choose AWS Nitro Enclaves initially?

There are many TEE providers available, but initial support for AWS Nitro Enclaves is due to their maturity and support for reproducible builds. Support for additional TEE providers might be considered in the future.

<ImportContent source="contact-nautilus.mdx" mode="snippet" />

### Where is the root of trust of AWS?

It is stored as part of the Sui framework and used to verify AWS attestation documents. You can verify its hash by following the steps outlined on [AWS](https://docs.aws.amazon.com/enclaves/latest/user/verify-root.html#validation-process).

```sh
$ curl https://raw.githubusercontent.com/MystenLabs/sui/refs/heads/main/crates/sui-types/src/nitro_root_certificate.pem -o cert_sui.pem
$ sha256sum cert_sui.pem

6eb9688305e4bbca67f44b59c29a0661ae930f09b5945b5d1d9ae01125c8d6c0

$ curl https://aws-nitro-enclaves.amazonaws.com/AWS_NitroEnclaves_Root-G1.zip -o cert_aws.zip
$ unzip cert_aws.zip
$ sha256sum root.pem

6eb9688305e4bbca67f44b59c29a0661ae930f09b5945b5d1d9ae01125c8d6c0 # check it matches from the one downloaded from the Sui repo
```
>>>> sui/docs/content/concepts/cryptography/passkeys.mdx
---
title: Passkey
description: Sui supports the passkey signature scheme that enables you to sign in to apps and sign transactions using a private key stored securely on a passkey authenticator. It uses the WebAuthn standard.
---

Passkey provides a secure and user-friendly alternative for submitting transactions to Sui. Built on the **WebAuthn standard**, passkey allows users to authenticate and sign transactions using:

- Hardware security keys, such as YubiKeys  
- Mobile devices, such as smartphones and tablets  
- Platform-based authenticators, such as Face ID and Touch ID  

Passkey simplifies authentication by removing the need to manage seed phrases or private keys manually. Instead, it relies on device-based authentication and cloud synchronization, allowing seamless, phishing-resistant access across multiple devices. You can also use passkey in a [multisig setup](./transaction-auth/multisig.mdx), which provides more flexibility to build secure and recoverable wallet experiences.

By supporting the passkey signature scheme, Sui improves security and accessibility, making it easier for users to manage their accounts with hardened security. Passkey-based wallets are tied to the origin, meaning they cannot be phished or used on a different site. This makes passkey a more secure authentication option.

See the [TypeScript SDK documentation](https://sdk.mystenlabs.com/typescript/cryptography/passkey) to learn how to add passkey support to your application. For the product specification, see [SIP-9](https://github.com/sui-foundation/sips/blob/main/sips/sip-9.md).

:::info
Passkey support is available in beta in Sui Devnet and Testnet. Mainnet release is not yet scheduled.  
:::

## Benefits of using passkey

- **Sign transactions securely:**  
  Users can sign transactions in Sui using passkey, while the private key stays securely stored within the authenticator. This reduces the risk of key extraction attacks.  

- **Authenticate across devices:**  
  Users can scan a QR code displayed on a desktop browser with a mobile device to approve transactions. Cloud-synchronized passkey (such as those stored in Apple iCloud or Google Password Manager) allows users to authenticate across multiple devices without manual key transfers.  

- **Use hardware security keys:**  
  Users can sign transactions with external security keys, such as YubiKeys, to add another layer of protection against phishing and unauthorized access.  

- **Authenticate with platform-based security:**  
  Users can sign transactions directly on devices with built-in authenticators, such as Face ID on iPhones or Windows Hello on Windows PCs. This approach allows users to sign transactions natively without needing an external security key.  

- **Recover access with cloud-synced passkey:**  
  Cloud-synced passkey helps users recover access if they lose a device.  

- **Work with multisig wallets:**  
  Combine passkey with other authentication types to build 2-of-2 or m-of-n [multisig wallets](./transaction-auth/multisig.mdx). This enables secure recovery options and shared access patterns.  

## Limitations of passkey

- **Functionality varies by authenticator:**  
  Some security keys do not support biometric authentication, requiring users to enter a PIN instead. Because WebAuthn does not provide access to private keys, users must either store their passkey securely or enable cloud synchronization for recovery.  

- **Cloud synchronization introduces risks:**  
  Cloud-synced passkey improves accessibility but also creates risks if a cloud provider is compromised or if a user loses access to their cloud account. Users who prefer full self-custody can use hardware-based passkey that does not rely on cloud synchronization.  

- **Passkey cannot be exported:**  
  Users cannot transfer a passkey between different authenticators. For example, a passkey created on a security key cannot move to another device unless it syncs through a cloud provider. To avoid losing access, users should set up authentication on multiple devices.
>>>> sui/docs/content/concepts/cryptography/system.mdx
---
title: System
draft: true
---

Content coming soon
>>>> sui/docs/content/concepts/cryptography/system/checkpoint-verification.mdx
---
title: Checkpoint Verification
description: On the Sui network, checkpoints define the history of the blockchain. Checkpoint verification is how full nodes and other clients guarantee their state is exactly the same as the Sui network.
---

Unlike traditional blockchains that create blocks before execution, Sui creates checkpoints after transaction execution to provide a certified record of chain history.

Checkpoints contain:

- The cryptographic hash of the previous checkpoint.
- A list of all the transaction digests (and the corresponding transaction effects digests) that are included in the checkpoint.
- A set of signatures from a quorum (more than 2/3) of the validators that formed the committee at the time the checkpoint was created.

Both validators and full nodes consume checkpoints to remain synchronized with the network.

## Verifying checkpoints

Full nodes and validators verify a checkpoint to trust it. This verification confirms that the Sui validator committee created it and that it is authentic.

Checkpoint verification requires two interdependent steps:

1. A client that has the public keys of the validator committee can check the signatures on the checkpoint. Checkpoints are signed by the aggregated BLS signatures of a quorum of the committee. If the signatures are valid, the client knows the checkpoint was created by the validator committee and not another party.  
1. By validating checkpoints, the client can learn the composition of the committee. The final checkpoint of each epoch contains the validator committee, including the public keys, of the next epoch.  

This process creates an apparent circular dependency. The client needs to know the committee to verify checkpoints, but also learns the committee through checkpoint validation. The process is bootstrapped from the genesis checkpoint, the earliest checkpoint in a Sui network. The genesis checkpoint contains the initial validator committee, which allows the client to verify all checkpoints in history by following this process:

1. The client obtains the genesis checkpoint from some trusted source.
1. The client loads the initial committee from the genesis checkpoint.
1. The client uses the state sync network or Sui archive to obtain the next checkpoint.
1. The client verifies the signatures on the checkpoint using the current committee public keys, and verifies that the previous checkpoint hash is equal to the hash of the previous checkpoint that the client validated.
1. If the checkpoint is invalid, the client raises an error.
1. Otherwise, the client checks if the checkpoint is the last one of the current epoch.
    - If so, load the next committee from it, and use that committee as the current committee.
    - If not, return to step 3 and continue.

This process allows the client to verify all checkpoints up to the present time.

## Checkpoint commitments

After a client verifies a checkpoint, it can use the information to execute transactions and confirm results.  

A checkpoint contains a list of transactions, so a full node can fetch and execute them. Because transactions are identified by their digest (a cryptographic hash), the client can be sure they have not been altered.  

The checkpoint also includes the effects digests of each transaction. An effects digest is the cryptographic hash of the `TransactionEffects` structure, which lists all transaction inputs and outputs, including the digests of all objects written by the transaction. This allows a full node to confirm it has the same execution results as the validators who signed the checkpoint.  

By executing checkpoints and verifying transaction outputs, a full node can build the entire state of the Sui network (the collection of objects in the network) and trust that every byte of every object is correct.
>>>> sui/docs/content/concepts/cryptography/system/intents-for-validation.mdx
---
title: Intents for Validation
draft: true
---

Content coming soon
>>>> sui/docs/content/concepts/cryptography/system/validator-signatures.mdx
---
title: Validator Signatures
draft: true
---

Content coming soon
>>>> sui/docs/content/concepts/cryptography/transaction-auth.mdx
---
title: Transaction Authentication
description: Transaction security is arguably the most important feature of a blockchain. Sui provides multiple features to secure your transactions, whether on chain or off.
---

Transaction authentication features on Sui provide security against unauthorized access to on-chain data. 

<Cards>
<Card title="Keys and Addresses" href="/concepts/cryptography/transaction-auth/keys-addresses">
</Card>
<Card title="Signatures" href="/concepts/cryptography/transaction-auth/signatures">
</Card>
<Card title="Multisig" href="/concepts/cryptography/transaction-auth/multisig">
</Card>
<Card title="Offline Signing" href="/concepts/cryptography/transaction-auth/offline-signing">
</Card>
<Card title="Intent Signing" href="/concepts/cryptography/transaction-auth/intent-signing">
</Card>
</Cards>
>>>> sui/docs/content/concepts/cryptography/transaction-auth/intent-signing.mdx
---
title: Intent Signing
description: Intent signing provides a compact domain separator to data signed by both user and authority signatures. Data that each signature commits to is called an intent message, which all signatures on Sui must include. 
keywords: [ intent, signing, intent signatures, intent message, domain separators, compact structs, signing standard, compact domain separator, user signatures, authority signatures, proof of possession, generate proof of possession ]
---

In Sui, an intent is a compact struct that serves as the domain separator for a message that a signature commits to. The data that the signature commits to is an intent message. All signatures in Sui must commit to an intent message, instead of the message itself.

## Motivation

In previous releases, Sui used a special `Signable` trait that attached the Rust struct name as a prefix to the serialized data. This is not ideal because it is:

- **Not compact:** The prefix `TransactionData::` is significantly larger than 1 byte.
- **Not user-friendly:** Non-Rust applications need to maintain a list of Rust-struct names.

The intent signing standard provides a compact domain separator to the data being signed for both user signatures and authority signatures. It has several benefits, including:

- The intent scope is replaced by a u8 representation instead of a Rust struct tag name string.
- In addition to the intent scope, other important domain separators can be committed as well (such as intent version and app ID).
- The data itself no longer needs to implement the `Signable` trait, it just needs to implement `Serialize`.
- All signatures can adopt the same intent message structure, including both user signatures (only to commit to `TransactionData`) and authority signature (commits to all internal intent scopes such as `TransactionEffects`, `ProofOfPossession`, and `SenderSignedTransaction`).

## Structs

The `IntentMessage` struct consists of the intent and the serialized data value.

```rust
pub struct IntentMessage<T> {
  pub intent: Intent,
  pub value: T,
}
```

To create an intent struct, include the `IntentScope` (what the type of the message is), `IntentVersion` (what version the network supports), and `AppId` (what application that the signature refers to).

```rust
pub struct Intent {
  scope: IntentScope,
  version: IntentVersion,
  app_id: AppId,
}
```

For detailed field definitions, see the enum definitions in the source code:

<ImportContent source="crates/shared-crypto/src/intent.rs" mode="code" enumeration="IntentScope,IntentVersion,AppId,HashingIntentScope" />

The serialization of an `Intent` is a 3-byte array where each field is represented by a byte.

The serialization of an `IntentMessage<T>` is the 3 bytes of the intent concatenated with the BCS serialized message.

## User signature

To create a user signature, construct an intent message first, and create the signature over the 32-byte Blake2b hash of the BCS serialized value of the intent message of the transaction data (`intent || message`).

Here is an example in Rust:

```rust
let intent = Intent::default();
let intent_msg = IntentMessage::new(intent, data);
let signature = Signature::new_secure(&intent_msg, signer);
```

Here is an example in TypeScript:

```typescript
const intentMessage = messageWithIntent('TransactionData', transactionBytes);
const signature = await this.sign(intentMessage);
```

Under the hood, the `new_secure` method in Rust and the `signData` method in TypeScript does the following:

1.  Serializes the intent message as the 3-byte intent concatenated with the BCS serialized bytes of the transaction data.
1.  Applies Blake2b hash to get the 32-byte digest.
1.  Passes the digest to the signing API for each corresponding scheme of the signer. The supported signature schemes are pure Ed25519, ECDSA Secp256k1, and ECDSA Secp256r1. See [Sui Signatures](./signatures.mdx#signature-requirements) for requirements of each scheme.

## Authority signature

The authority signature is created using the protocol key. The data that it commits to is also an intent message `intent || message`. See all available intent scopes [in the source code](https://github.com/MystenLabs/sui/blob/0dc1a38f800fc2d8fabe11477fdef702058cf00d/crates/sui-types/src/intent.rs#L66).

### How to generate proof of possession for an authority

When an authority requests to join the network, the protocol public key and its proof of possession (PoP) are required to be submitted. PoP is required to prevent [rogue key attack](https://crypto.stanford.edu/~dabo/pubs/papers/BLSmultisig.html).

The proof of possession is a BLS signature created using the authority protocol private key, committed over the following message: `intent || pubkey || address || epoch`. Here `intent` is serialized to `[5, 0, 0]` representing an intent with scope as `Proof of Possession`, `version` as `V0`, and `app_id` as `Sui`. The `pubkey` value is the serialized public key bytes of the authority BLS protocol key. The `address` value is the account address associated with the authority account key. The `epoch` value is serialized to `[0, 0, 0, 0, 0, 0, 0, 0]`.

To generate a proof of possession in Rust, see implementation at `fn generate_proof_of_possession`. For test vectors, see `fn test_proof_of_possession`.

# Implementation

1. [Struct and enum definitions](https://github.com/MystenLabs/sui/blob/0dc1a38f800fc2d8fabe11477fdef702058cf00d/crates/sui-types/src/intent.rs)
2. [Test](https://github.com/MystenLabs/sui/blob/d009e82fa35bda4f2b3e7a86a9529d36c32a8159/crates/sui-types/src/unit_tests/intent_tests.rs)
3. User transaction intent signing [PR 1](https://github.com/MystenLabs/sui/pull/6445), [PR 2](https://github.com/MystenLabs/sui/pull/8321)
4. Authority intent signing [PR 1](https://github.com/MystenLabs/sui/pull/8154), [PR 2](https://github.com/MystenLabs/sui/pull/8726)
>>>> sui/docs/content/concepts/cryptography/transaction-auth/keys-addresses.mdx
---
title: Keys and Addresses
description: Sui supports the wallet specifications BIP-32, SLIP-0010, BIP-44, and BIP-39. For signed transactions, Sui supports pure Ed25519, ECDSA Secp256k1, ECDSA Secp256r1, and multisig. 
keywords: [ BIP-32, SLIP-0010, BIP-44, BIP-39, Ed25519, ECDSA Secp256k1, ECDSA Secp256r1, multisig, key derivation, key derivation paths, key derivation schemes, address format ]
---

Sui adheres to widely accepted wallet specifications in the cryptocurrency industry, including BIP-32 and its variation SLIP-0010, BIP-44, and BIP-39, to facilitate key management for users. At present, Sui supports pure Ed25519, ECDSA Secp256k1, ECDSA Secp256r1, and multisig for signed transactions.

Follow the relevant links for more information on each wallet specification:

- [BIP-32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
- [BIP-39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki)
- [BIP-44](https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki)
- [SLIP-0010](https://github.com/satoshilabs/slips/blob/master/slip-0010)

## Key derivation scheme

Sui uses SLIP-0010 to manage wallets that support Ed25519 (EdDSA) signing.

For managing wallets that support the Ed25519 (EdDSA) signing scheme, Sui follows SLIP-0010, which enforces wallets to always derive child private keys from parent private keys using the hardened key path.

Sui follows BIP-32 for managing wallets that support the ECDSA Secp256k1 and ECDSA Secp256r1 signing scheme.

BIP-32 defines the hierarchical deterministic wallet structure to logically associate a set of keys. Grouping keys in this manner reduces the overhead of keeping track of a large number of private keys for a user. This method also allows custodians to issue distinct managed addresses for each user account under one source of control. Using BIP-32 decouples the private key derivation from the public key derivation, enabling the watch-only wallet use case, where a chain of public keys and its addresses can be derived, while the private key can be kept offline for signing.

## Key derivation path

BIP-44 further defines the 5 levels of the derivation path with their exact meanings:
`m / purpose' / coin_type' / account' / change / address_index`. In this structure, the slashes indicate new levels, or children, in the hierarchy.

The `purpose` level is generally set to `44`, corresponding to the BIP number. In Sui, however, the purpose level distinguishes different signing schemes: `44` is set for Ed25519, `54` for ECDSA Secp256k1, and `74` for Secp256r1. While it is non-standard to set the purpose level to a value that is not `44`, it is common to use the purpose field to distinguish different signing schemes. BIP-49 and BIP-84, for example, are used to identify script types in Bitcoin. Sui chose `54` to indicate ECDSA Secp256k1 because there is no existing BIP under `54`, avoiding confusion with any Bitcoin standard.

The `coin_type` value is managed with a repository of all other cryptocurrencies. Both signature schemes use Sui's registered `coin_type`: `784`.

The `account` level is usually used for logically separating user accounts and creating specific account categories.

It is generally accepted that, while account-based currencies define only the first 3 levels, UTXO-based currencies add change and address level definitions. Because Sui's object-oriented data model is neither UTXO nor account-based (it in fact combines both), it employs all 5 levels for maximum compatibility.

| Scheme          | Path                                         | Comments                                       |
| --------------- | -------------------------------------------- | ---------------------------------------------- |
| Ed25519         | `m/44'/784'/{account}'/{change}'/{address}'` | Each level of the derivation path is hardened. |
| ECDSA Secp256k1 | `m/54'/784'/{account}'/{change}/{address}`   | The first 3 levels are hardened.               |
| ECDSA Secp256r1 | `m/74'/784'/{account}'/{change}/{address}`   | The first 3 levels are hardened.               |

## Mnemonics support

After Sui defines the deterministic way to derive the master key from a seed, BIP-39 is introduced to make the seed more human-readable and memorizable using mnemonics. Sui accepts 12, 15, 18, 21, and 24 words from the BIP-39 word list that is properly checksummed, corresponding to 128, 160, 192, 224, and 256 bits of entropy. Sui Wallet and SDKs provide a flexible interface to sign transactions with various signing schemes.

## Address format

For deriving a 32-byte Sui address, Sui hashes the signature scheme flag 1-byte concatenated with public key bytes using the [BLAKE2b](https://www.blake2.net/) (256 bits output) hashing function. Sui address currently supports pure Ed25519, Secp256k1, Secp256r1, and MultiSig with corresponding flag bytes of 0x00, 0x01, 0x02, and 0x03, respectively.

## Example

Sui Wallet and SDKs provide a flexible interface to sign transactions with various signing schemes.

<Tabs>
<TabItem value="typescript" label="TypeScript">

```typescript
const keypair = Ed25519Keypair.deriveKeypair(TEST_MNEMONIC, `m/44'/784'/0'/0'/0'`);
const address = keypair.getPublicKey().toSuiAddress();
```

</TabItem>
<TabItem value="cli" label="CLI">

```sh
$ sui keytool import "TEST_MNEMONIC" ed25519 "m/44'/784'/0'/0'/0'"
```
```sh
$ sui client new-address ed25519 "m/44'/784'/0'/0'/0'"
```

</TabItem>
</Tabs>

See more test vectors for [pure Ed25519](https://github.com/MystenLabs/sui/blob/f3b5fdd73da64a0df65fb4323471512b0f57ec4d/sdk/typescript/test/unit/cryptography/ed25519-keypair.test.ts) or [ECDSA Secp256k1](https://github.com/MystenLabs/sui/blob/199f06d25ce85f0270a1a5a0396156bb2b83122c/sdk/typescript/test/unit/cryptography/secp256k1-keypair.test.ts).
>>>> sui/docs/content/concepts/cryptography/transaction-auth/multisig.mdx
---
title: Multisig
description: Multi-signature (multisig) transactions require multiple keys for authentication rather than a single key. Sui supports multisig transactions for pure Ed25519, ECDSA Secp256k1, and ECDSA Secp256r1 encryption keys.
keywords: [ multi-signature, multi-sig, multisig, multiple signatures, pure Ed25519, ECDSA Secp256k1, ECDSA Secp256r1 ]
---

Sui supports multi-signature (multisig) transactions, which require multiple keys for authorization rather than a single, one-key signature. In technical terms, Sui supports `k` out of `n` multisig transactions, where `k` is the threshold and `n` is the total weights of all participating parties. The maximum number of parties is 10. To learn more about the single key signatures that Sui supports, see [Signatures](./signatures.mdx).

Valid participating keys for multisig are pure Ed25519, ECDSA Secp256k1, and ECDSA Secp256r1. A ([u8](https://doc.rust-lang.org/std/primitive.u8.html)) weight is set for each participating key and the threshold can be set as [u16](https://doc.rust-lang.org/std/primitive.u16.html). If the serialized multisig contains enough valid signatures of which the sum of weights passes the threshold, Sui considers the multisig valid and the transaction executes.

## Applications of multisig

Sui allows you to mix and match key schemes in a single multisig account. For example, you can pick a single Ed25519 mnemonic-based key and two ECDSA Secp256r1 keys to create a multisig account that always requires the Ed25519 key, but also one of the ECDSA Secp256r1 keys to sign. You could use this structure for mobile secure enclave stored keys as two-factor authentication.

:::info

Currently, iPhone and high-end Android devices support only ECDSA Secp256r1 enclave-stored keys.

:::

Compared to threshold signatures, a multisig account is generally more flexible and straightforward to implement and use, without requiring complex multi-party computation (MPC) account setup ceremonies and related software, and any dependency in threshold crypto providers. Additionally, apart from the ability to mix and match key schemes and setting different weights for each key (which is complex in threshold cryptography), multisig accounts are accountable and transparent by design because both participating parties and observers can see who signed each transaction. On the other hand, threshold signatures provide the benefits of hiding the threshold policy, but also resulting in a single signature payload, making it indistinguishable from a single-key account.

![Multisig structure diagram](images/sui_multisig_structures.png 'Supported multisig configurations in Sui')
_Multisig structures supported in Sui._

## Related links

<RelatedLink to="/guides/developer/cryptography/multisig.mdx" />
>>>> sui/docs/content/concepts/cryptography/transaction-auth/offline-signing.mdx
---
title: Offline Signing
description: Offline signing can be used to sign a Sui transaction when a device is not connected to a Sui network, or if the signing wallet uses a different programming language than that of the transaction being signed.
keywords: [ offline signing, sign offline, sign transaction offline, offline transaction, serialize data, sign data, sign serialized data, sign with Sui Keystore, Sui Keystore, Keystore ]
---

Sui supports offline signing, which is signing transactions using a device not connected to a Sui network, or in a wallet implemented in a different programming language without relying on the Sui key store. The steps to implement offline signing include:

1. Serialize the data for signing.
1. Sign the serialized data. Put the serialized data in a location to sign (such as the wallet of your choice, or tools in other programming languages) and to produce a signature with the corresponding public key.
1. Execute the signed transaction.

## Serializing data for transfer

You must serialize transaction data following [Binary Canonical Serialization](https://crates.io/crates/bcs) (BCS). It is supported in other languages.

The following example demonstrates how to serialize data for a transfer using the [Sui CLI](/references/cli.mdx). This returns serialized transaction data in Base64. Submit the raw transaction to execute as `tx_bytes`.

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client transfer-sui --to <SUI-ADDRESS> --sui-coin-object-id <COIN-OBJECT-ID> --gas-budget <GAS-AMOUNT> --serialize-unsigned-transaction
```

The console responds with the resulting `<TX_BYTES>` value.


:::tip

All other CLI commands that craft a transaction (such as `sui client publish` and `sui client call`) also accept the `--serialize-unsigned-transaction` flag used in the same way.

:::

## Sign the serialized data {#sign}

You can sign the data using the device and programming language you choose. Sui accepts signatures for pure Ed25519, ECDSA secp256k1, ECDSA secp256r1, and native multisig. To learn more about the requirements of the signatures, see [Sui Signatures](/concepts/cryptography/transaction-auth/signatures.mdx).

This example uses the `sui keytool` command to sign, using the Ed25519 key corresponding to the provided address stored in `sui.keystore`. This command outputs the signature, the public key, and the flag encoded in Base64. This command is backed by fastcrypto.
`sui keytool sign --address <SUI-ADDRESS> --data <TX_BYTES>`

You receive the following response:

```sh
Signer address: <SUI-ADDRESS>
Raw tx_bytes to execute: <TX_BYTES>
Intent: Intent { scope: TransactionData, version: V0, app_id: Sui }
Raw intent message: <INTENT-MESSAGE>
Digest to sign: <DIGEST>
Serialized signature (`flag || sig || pk` in Base64): <SERIALIZED-SIGNATURE>
```

To ensure the signature produced offline matches with Sui validity rules for testing purposes, you can import the mnemonics to `sui.keystore` using `sui keytool import`. You can then sign with it using `sui keytool sign` and then compare the signature results. Additionally, you can find test vectors in `~/sui/sdk/typescript/test/e2e/raw-signer.test.ts`.

To verify a signature against the cryptography library backing Sui when debugging, see [sigs-cli](https://github.com/MystenLabs/fastcrypto/blob/4cf71bd8b3a373495beeb77ce81c27827516c218/fastcrypto-cli/src/sigs_cli.rs).

## Execute the signed transaction {#execute}

After you obtain the serialized signature, you can submit it using the execution transaction command. This command takes `--tx-bytes` as the raw transaction bytes to execute (see output of the previous `sui client transfer` command) and the serialized signature (Base64 encoded `flag || sig || pk`, see output of `sui keytool sign`). This executes the signed transaction and returns the certificate and transaction effects if successful.

```sh
$ sui client execute-signed-tx --tx-bytes <TX_BYTES> --signatures <SERIALIZED-SIGNATURE>
```

You get the following response:

```sh
----- Certificate ----
Transaction Hash: <TRANSACTION-ID>
Transaction Signature: <SIGNATURE>
Signed Authorities Bitmap: RoaringBitmap<[0, 1, 3]>
Transaction Kind : Transfer SUI
Recipient : <SUI-ADDRESS>
Amount: Full Balance

----- Transaction Effects ----
Status : Success
Mutated Objects:
 - ID: <OBJECT_ID> , Owner: Account Address ( <SUI-ADDRESS> )
```

## Alternative: Sign with Sui Keystore and execute transaction

Alternatively, you can use the active key in Sui Keystore to sign and output a Base64-encoded sender signed data with flag `--serialize-signed-transaction`. 

```sh
$ sui client transfer-sui --to <SUI-ADDRESS> --sui-coin-object-id <COIN-OBJECT-ID> --gas-budget <GAS-AMOUNT> --serialize-signed-transaction
```

The console responds with the resulting `<SIGNED-TX-BYTES>` value.

After you obtain the signed transaction bytes, you can submit it using the `execute-combined-signed-tx` command. This command takes `--signed-tx-bytes` as the signed transaction bytes to execute (see output of the previous `sui client transfer-sui` command). This executes the signed transaction and returns the certificate and transaction effects if successful.

```sh
$ sui client execute-combined-signed-tx --signed-tx-bytes <SIGNED-TX-BYTES>
```
>>>> sui/docs/content/concepts/cryptography/transaction-auth/signatures.mdx
---
title: Signatures
description: Sui supports multiple cryptography algorithms and primitives. Switching between them rapidly is supported.
keywords: [ Ed25519 pure, pure Ed255190, ECDSA Secp256k1, ECDSA Secp256r1, multisig, zkLogin, passkey, signature requirements, signature authority, authority signature, account key pair, account key pair, network key pair ]
---

When a user submits a signed transaction, a serialized signature and a serialized transaction data is submitted. The serialized transaction data is the BCS serialized bytes of the struct `TransactionData` and the serialized signature is defined as a concatenation of bytes of `flag || sig || pk`.

The `flag` is a 1-byte representation corresponding to the signature scheme that the signer chooses. The following table lists each signing scheme and its corresponding flag:

| Scheme          | Flag |
| --------------- | ---- |
| Pure Ed25519    | 0x00 |
| ECDSA Secp256k1 | 0x01 |
| ECDSA Secp256r1 | 0x02 |
| multisig        | 0x03 |
| zkLogin         | 0x05 |
| passkey         | 0x06 |

The `sig` bytes are the compressed bytes representation of the signature instead of DER encoding. The following table lists the expected size of each format:

| Scheme          | Signature                                                                                      |
| --------------- | -----------------------------------------------------------------------------------------------|
| Pure Ed25519    | Compressed, 64 bytes                                                                           |
| ECDSA Secp256k1 | Non-recoverable, compressed, 64 bytes                                                          |
| ECDSA Secp256r1 | Non-recoverable, compressed, 64 bytes                                                          |
| multisig        | BCS serialized all signatures, size varies                                                     |
| zkLogin         | BCS serialized zkLogin inputs, max epoch and ephemeral signature, size varies                  |
| passkey         | BCS serialized passkey inputs (authenticatorData, clientDataJson, userSignature), size varies  |

The `pk` bytes are the bytes representation of the public key corresponding to the signature.

| Scheme          | Public key                                                                           |
| --------------- | ------------------------------------------------------------------------------------ |
| Pure Ed25519    | Compressed, 32 bytes                                                                 |
| ECDSA Secp256k1 | Compressed, 33 bytes                                                                 |
| ECDSA Secp256r1 | Compressed, 33 bytes                                                                 |
| multisig        | BCS serialized all participating public keys, size varies                            |
| zkLogin         | Concatenation of iss length, iss bytes, address seed padded to 32-bytes, size varies |
| passkey         | Compressed, 33 bytes                                                                 |

## Signature requirements {#signature-requirements}

The signature must commit to the hash of the intent message of the transaction data, which you can construct by appending the 3-byte intent before the BCS serialized transaction data. To learn more on what an intent is and how to construct an intent message, see [Sui Intent Signing](intent-signing.mdx).

When invoking the signing API, you must first hash the intent message of the transaction data to 32 bytes using Blake2b. This external hashing is distinct from the hashing performed inside the signing API. To be compatible with existing standards and hardware secure modules (HSMs), the signing algorithms perform additional hashing internally. For ECDSA Secp256k1 and Secp256r1, you must use SHA-2 SHA256 as the internal hash function. For pure Ed25519, you must use SHA-512.

An accepted ECDSA Secp256k1 and Secp256r1 signature must follow:

1. The internal hash used by ECDSA must be SHA256 [SHA-2](https://en.wikipedia.org/wiki/SHA-2) hash of the transaction data. Sui uses SHA256 because it is supported by [Apple](https://developer.apple.com/forums/thread/89619), HSMs, and [cloud](https://developer.apple.com/forums/thread/89619), and it is widely adopted by [Bitcoin](https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm).
1. The signature must be of length 64 bytes in the form of `[r, s]` where the first 32 bytes are `r`, the second 32 bytes are `s`.
1. The `r` value can be between `0x1` and `0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364140` (inclusive).
1. The `s` value must be in the lower half of the curve order. If the signature is too high, convert it to a lower `s` according to [BIP-0062](https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki#low-s-values-in-signatures) with the corresponding curve orders using `order - s`. For Secp256k1, the curve order is `0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141`. For Secp256r1, the curve order is `0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551` defined in [Standards for Efficient Cryptography](https://secg.org/SEC2-Ver-1.0.pdf).
1. Ideally, the signature must be generated with deterministic nonce according to [RFC6979](https://www.rfc-editor.org/rfc/rfc6979).

An accepted pure Ed25519 signature must follow:

1. The signature must be produced according to [RFC 8032](https://www.rfc-editor.org/rfc/rfc8032.html#section-5.1.6). The internal hash used is SHA-512.
1. The signature must be valid according to [ZIP215](https://github.com/zcash/zips/blob/main/zips/zip-0215.rst).

See a concrete example for offline signing using CLI in the [Offline Signing](../transaction-auth/offline-signing.mdx) topic.

For more on zkLogin signature, see [zkLogin](../zklogin.mdx).

For more on passkey signature, see [SIP-8](https://github.com/sui-foundation/sips/blob/main/sips/sip-9.md).

## Authority signature

The Authority on Sui (collection of validators) holds 3 distinctive key pairs:

1.  [Protocol key pair](#protocol-pair)
1.  [Account key pair](#account-pair)
1.  [Network key pair](#network-pair)

### Protocol key pair {#protocol-pair}

The protocol key pair provides authority signatures on user-signed transactions if they are verified. When a stake of the authorities that provide signatures on user transactions passes the required two-thirds threshold, Sui executes the transaction. Sui uses the BLS12381 scheme for its fast verification on aggregated signatures for a given number of authorities. In particular, Sui uses the minSig BLS mode, where each individual public key is 96 bytes, while the signature is 48 bytes. The latter is important as typically validators register their keys once at the beginning of each epoch and then they continuously sign transactions; thus, Sui optimizes on minimum signature size.

As with the BLS scheme, you can aggregate independent signatures resulting in a single BLS signature payload. Sui also accompanies the aggregated signature with a bitmap to denote which of the validators signed. This effectively reduces the authorities signature size from (2f + 1) Ã— `BLS_sig` size to just one `BLS_sig` payload. This has significant network cost benefits resulting in compressed transaction certificates independently on the validators set size.

To counter potential rogue key attacks on BLS12381 aggregated signatures, proof of knowledge of the secret key (KOSK) is used during authority registration. When an authority requests to be added to the validator set, a proof of possession is submitted and verified. See [Intent Signing](/concepts/cryptography/transaction-auth/intent-signing.mdx) on how to create a proof of possession. Unlike most standards, the Sui proof of knowledge scheme commits to the address as well, which offers an extra protection against adversarial reuse of a validator BLS key from another malicious validator.

### Account key pair {#account-pair}

The account that the authority uses to receive payments on staking rewards is secured by the account key pair. Sui uses pure Ed25519 as the signing scheme.

### Network key pair {#network-pair}

The private key is used to perform the TLS handshake required for consensus networking. The public key is used for validator identity. Pure Ed25519 is used as the scheme.

See more authority key toolings in [Validator Tool](https://github.com/MystenLabs/sui/blob/f8b5ad9aaecc3c4b30a060ec5e00bdad9ba75a93/nre/validator_tool.md).
>>>> sui/docs/content/concepts/cryptography/zklogin.mdx
---
title: zkLogin
description: zkLogin is a Sui primitive that enables you to send transactions from a Sui address using an OAuth credential without publicly linking the two.
---

zkLogin is a Sui primitive that allows you to send transactions from a Sui address using an OAuth credential, without publicly linking the two.

zkLogin is designed with the following goals:

- **Streamlined onboarding:** zkLogin enables you to transact on Sui using the familiar OAuth login flow, removing the need to handle cryptographic keys or remember mnemonics.  
- **Self-custody:** A zkLogin transaction requires user approval through the standard OAuth login process. The OAuth provider cannot transact on the user behalf.  
- **Security:** zkLogin is a two-factor authentication scheme. Sending a transaction requires both a credential from a recent OAuth login and a salt not managed by the OAuth provider. An attacker who compromises an OAuth account cannot transact from the user Sui address unless they also compromise the salt.  
- **Privacy:** Zero-knowledge proofs prevent third parties from linking a Sui address with its corresponding OAuth identifier.  
- **Optional verified identity:** A user can opt in to verify the OAuth identifier used to derive a particular Sui address. This creates the foundation for a verifiable on-chain identity layer.  
- **Accessibility:** zkLogin is one of several native Sui signature schemes thanks to [Sui cryptography agility](/concepts/cryptography/transaction-auth/signatures.mdx). It integrates with other Sui primitives, such as sponsored transactions and multisig.  
- **Rigor:** The code for zkLogin has been independently [audited](https://github.com/sui-foundation/security-audits/blob/main/docs/zksecurity_zklogin-circuits.pdf) by 2 firms specializing in zero knowledge. The public zkLogin ceremony for creating the common reference string included contributions from more than 100 participants.  

If you are a builder who wants to integrate zkLogin into your application or wallet, see the [zkLogin integration guide](/guides/developer/cryptography/zklogin-integration.mdx).  

To learn how zkLogin works, including how the zero-knowledge proof is generated and how Sui verifies a zkLogin transaction, see [how zkLogin works](#how-zklogin-works).  

For information about the security model and privacy considerations of zkLogin, see [security and privacy](#security-and-privacy).  

For common questions, see the [FAQ section](#faq).  

## OpenID providers

<ImportContent source="openid-providers.mdx" mode="snippet" />

## How zkLogin works {#how-zklogin-works}

At a high level, the zkLogin protocol works as follows:

1. A JWT is a signed payload from OAuth providers that includes a user-defined field named nonce. zkLogin uses [the OpenID Connect OAuth flow](https://openid.net/developers/how-connect-works/) by defining the nonce as a public key and an expiry epoch.  
2. The wallet stores an ephemeral key pair, where the ephemeral public key is defined in the nonce. The ephemeral private key signs transactions for a short session. The Groth16 zero-knowledge proof is generated from the JWT, which conceals sensitive fields.  
3. A transaction is submitted on-chain with the ephemeral signature and the zero-knowledge proof. Sui authorities execute the transaction after verifying the ephemeral signature and the proof.  
4. Instead of deriving the Sui address based on a public key, the zkLogin address is derived from `sub` (user identifier), `iss` (provider), `aud` (application), and `user_salt` (a value that unlinks the OAuth identifier from the on-chain address).  

## The complete zkLogin flow

![zkLogin flow diagram](images/zklogin-flow.png 'zkLogin complete flow')

#### Step 0: zkLogin uses Groth16 for zkSNARK instantiation, which requires a common reference string (CRS) linked to the circuit. 
A ceremony generates the CRS, which is used to produce the proving key in the proving service and the verifying key in Sui authorities. See [ceremony](#ceremony) for details.  

#### Steps 1-3: The user logs in to an OpenID provider (OP) to obtain a JWT containing a nonce. 

The user generates an ephemeral key pair `(eph_sk, eph_pk)` and embeds `eph_pk`, expiry times (`max_epoch`), and randomness (`jwt_randomness`) into the nonce. After login, the JWT appears in the redirect URL in the application.  

#### Steps 4-5: The application frontend sends the JWT to a salt service. The service returns the unique `user_salt` based on `iss`, `aud`, and `sub`.  

#### Steps 6-7: The user sends the JWT, user salt, ephemeral public key, JWT randomness, and key claim name (for example, `sub`) to the proving service.

The proving service generates a zero-knowledge proof that:  
- Confirms the nonce is derived correctly.  
- Confirms the key claim value matches the corresponding JWT field.  
- Verifies the RSA signature from the provider on the JWT.  
- Confirms the address is consistent with the key claim and user salt.  

#### Step 8: The application computes the user address based on `iss`, `aud`, and `sub`.  

#### Steps 9-10: The user signs the transaction with the ephemeral private key and submits it with the ephemeral signature, ZK proof, and other inputs to Sui.  

After Step 10, Sui authorities verify the ZK proof against the provider's JWKs (stored by consensus) and the ephemeral signature.  


## Entities

1. Application frontend: This describes the wallet or frontend application that supports zkLogin. This frontend is responsible for storing the ephemeral private key, directing users to complete the OAuth login flow, creating and signing a zkLogin transaction.

2. Salt Backup Service: This is a backend service responsible for returning a salt per unique user. See [zkLogin Integration Guide](/guides/developer/cryptography/zklogin-integration.mdx) for other strategies to maintain salt.

3. ZK Proving Service: This is a backend service responsible for generating ZK proofs based on JWT, JWT randomness, user salt, and max epoch. This proof is submitted on-chain along with the ephemeral signature for a zkLogin transaction.

## Address definition

The address is computed on the following inputs:

1. The address flag: `zk_login_flag = 0x05` for zkLogin address. This serves as a domain separator as a signature scheme defined in [crypto agility](./transaction-auth/signatures.mdx).

1. `kc_name_F = hashBytesToField(kc_name, maxKCNameLen)`: Name of the key claim, ex. `sub`. The sequence of bytes is mapped to a field element in BN254 using `hashBytesToField` (defined below).

1. `kc_value_F = hashBytesToField(kc_value, maxKCValueLen)`: The value of the key claim mapped using `hashBytesToField`.

1. `aud_F = hashBytesToField(aud, maxAudValueLen)`: The relying party (RP) identifier. See [definition](#terminology-and-notations).

1. `iss`: The OpenID Provider (OP) identifier. See [definition](#terminology-and-notations).

1. `user_salt`: A value introduced to unlink the OAuth identifier with the on-chain address.

Finally, Sui derives `zk_login_address = Blake2b_256(zk_login_flag, iss_L, iss, addr_seed)` where `addr_seed = Poseidon_BN254(kc_name_F, kc_value_F, aud_F, Poseidon_BN254(user_salt)`.

## Terminology and notations

See below for all relevant OpenID terminology defined in [spec](https://openid.net/specs/openid-connect-core-1_0.html#Terminology) and how they are used in zkLogin, along with definitions for protocol details.

### OpenID provider (OP)

OAuth 2.0 authorization server that is capable of authenticating the end-user and providing claims to an RP about the authentication event and the end-user. This is identified in the `iss` field in JWT payload. Check the [table of available OPs](#openid-providers) for the entities zkLogin currently supports.

### Relying party (RP) or client

OAuth 2.0 client application requiring end-user authentication and claims from an OpenID provider. This is assigned by OP when the developer creates the application. This is identified in the `aud` field in JWT payload. This refers to any zkLogin enabled wallet or application.

### Subject identifier (sub)

Locally unique and never reassigned identifier within the issuer for the end user, which the RP is intended to consume. Sui uses this as the key claim to derive user address.

### JSON Web Key (JWK)

A JSON data structure that represents a set of public keys for an OP. A public endpoint (as in https://www.googleapis.com/oauth2/v3/certs) can be queried to retrieve the valid public keys corresponding to `kid` for the provider. Upon matching with the `kid` in the header of a JWT, the JWT can be verified against the payload and its corresponding JWK. In Sui, all authorities call the JWK endpoints independently, and update the latest view of JWKs for all supported providers during protocol upgrades. The correctness of JWKs is guaranteed by the quorum (2f+1) of validator stake.

### JSON Web Token (JWT)

JWT is in the redirect URI to RP after the user completes the OAuth login flow (as in `https://redirect.com?id_token=$JWT_TOKEN`). The JWT contains a `header`, `payload`, and a `signature`. The signature is an RSA signature verified against `jwt_message = header + . + payload` and its JWK identified by `kid`. The `payload` contains a JSON of many claims that is a name-value pair. See below for the specific claims that are relevant to the zkLogin protocol.

**Header**

| Name | Example Value                            | Usage                                                     |
| ---- | ---------------------------------------- | --------------------------------------------------------- |
| alg  | RS256                                    | zkLogin only supports `RS256` (RSA + SHA-256).            |
| kid  | c3afe7a9bda46bae6ef97e46c95cda48912e5979 | Identifies the JWK that should be used to verify the JWT. |
| typ  | JWT                                      | zkLogin only supports `JWT`.                              |

**Payload**

| Name  | Example Value                                                            | Usage                                                                                                                                                      |
| ----- | ------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| iss   | https://accounts.google.com                                              | A unique identifier assigned to the OAuth provider.                                                                                                        |
| aud   | 575519200000-msop9ep45u2uo98hapqmngv8d8000000.apps.googleusercontent.com | A unique identifier assigned to the relying party by the OAuth provider.                                                                                   |
| nonce | hTPpgF7XAKbW37rEUS6pEVZqmoI                                              | A value set by the relying party. The zkLogin enabled wallet is required to set this to the hash of ephemeral public key, an expiry time and a randomness. |
| sub   | 110463452167303000000                                                    | A unique identifier assigned to the user.                                                                                                                  |

For a zkLogin transaction, the `iat` and `exp` claims (timestamp) are not used. Instead, the `nonce` specifies expiry times.

### Key claim
The claim used to derive a users' address is termed the _key claim_, such as sub or email. Naturally, it's ideal to use claims that are fixed once and never changed again. zkLogin currently supports sub as the key claim because OpenID spec mandates that providers do not change this identifier. In the future, this can be extended to use email, username, and so on.

### Notations

1. `(eph_sk, eph_pk)`: Ephemeral key pair refers to the private and public key pair used to produce ephemeral signatures. The signing mechanism is the same as traditional transaction signing, but it is ephemeral because it is only stored for a short session and can be refreshed upon new OAuth sessions. The ephemeral public key is used to compute nonce.
2. `nonce`: An application-defined field embedded in the JWT payload, computed as the hash of the ephemeral public key, JWT randomness, and the maximum epoch (Sui's defined expiry epoch). Specifically, a zkLogin compatible nonce is required to passed in as `nonce = ToBase64URL(Poseidon_BN254([ext_eph_pk_bigint / 2^128, ext_eph_pk_bigint % 2^128, max_epoch, jwt_randomness]).to_bytes()[len - 20..])` where `ext_eph_pk_bigint` is the BigInt representation of `ext_eph_pk`.
3. `ext_eph_pk`: The byte representation of an ephemeral public key (`flag || eph_pk`). Size varies depending on the choice of the signature scheme (denoted by the flag, defined in [Signatures](./transaction-auth/signatures.mdx)).
4. `user_salt`: A value introduced to unlink the OAuth identifier with the on-chain address.
5. `max_epoch`: The epoch at which the JWT expires. This is u64 used in Sui.
6. `kc_name`: The key claim name, e.g. `sub`.
7. `kc_value`: The key claim value, e.g. `110463452167303000000`.
8. `hashBytesToField(str, maxLen)`: Hashes the ASCII string to a field element using the Poseidon hash.

## Ceremony

To preserve privacy of the OAuth artifacts, a zero-knowledge proof of possession of the artifacts is provided. zkLogin employs the Groth16 zkSNARK to instantiate the zero-knowledge proofs, as it is the most efficient general-purpose zkSNARK in terms of proof size and verification efficiency.

However, Groth16 needs a computation-specific common reference string (CRS) to be setup by a trusted party. With zkLogin expected to ensure the safe-keeping of high value transactions and the integrity of critical smart contracts, we cannot base the security of the system on the honesty of a single entity. Hence, to generate the CRS for the zkLogin circuit, it is vital to run a protocol which bases its security on the assumed honesty of a small fraction of a large number of parties.

### What is the ceremony?

The Sui zkLogin ceremony is essentially a cryptographic multi-party computation (MPC) performed by a diverse group of participants to generate this CRS. We follow the MPC protocol [MMORPG](https://eprint.iacr.org/2017/1050.pdf) described by Bowe, Gabizon and Miers. The protocol roughly proceeds in 2 phases. The first phase results in a series of powers of a secret quantity tau in the exponent of an elliptic curve element. Since this phase is circuit-agnostic, we adopted the result of the existing community contributed [perpetual powers of tau](https://github.com/privacy-scaling-explorations/perpetualpowersoftau/tree/master). Our ceremony was the second phase, which is specific to the zkLogin circuit.

The MMORPG protocol is a sequential protocol, which allows an indefinite number of parties to participate in sequence, without the need of any prior synchronization or ordering. Each party needs to download the output of the previous party, generate entropy of its own and then layer it on top of the received result, producing its own contribution, which is then relayed to the next party. The protocol guarantees security, if at least one of the participants follows the protocol faithfully, generates strong entropy and discards it reliably.

### How was the ceremony performed?

We sent invitations to 100+ people with diverse backgrounds and affiliations: Sui validators, cryptographers, Web3 experts, world-renowned academicians, and business leaders. We planned the ceremony to take place on the dates September 12-18, 2023, but allowed participants to join when they wanted with no fixed slots.

Since the MPC is sequential, each contributor needed to wait till the previous contributor finished in order to receive the previous contribution, follow the MPC steps and produce their own contribution. Due to this structure, we provisioned a queue where participants waited, while those who joined before them finished. To authenticate participants, we sent a unique activation code to each of them. The activation code was the secret key of a signing key pair, which had a dual purpose: it allowed the coordination server to associate the participant's email with the contribution, and to verify the contribution with the corresponding public key.

Participants had two options to contribute: through a browser or a docker. The browser option was more user-friendly for contributors to participate as everything happens in the browser. The Docker option required Docker setup but is more transparentâ€”the Dockerfile and contributor source code are open-sourced and the whole process is verifiable. Moreover, the browser option utilizes [snarkjs](https://github.com/iden3/snarkjs) while the Docker option utilizes [Kobi's implementation](https://github.com/iseriohn/phase2-bn254). This provided software variety and contributors could choose to contribute by whichever method they trust. In addition, participants could generate entropy via entering random text or making random cursor movements.

The zkLogin circuit and the ceremony client [code](https://github.com/sui-foundation/zk-ceremony-client) were made open source and the links were made available to the participants to review before the ceremony. In addition, we also posted these developer docs and an [audit report](https://github.com/sui-foundation/security-audits/blob/main/docs/zksecurity_zklogin-circuits.pdf) on the circuit from zkSecurity. We adopted [challenge #0081](https://pse-trusted-setup-ppot.s3.eu-central-1.amazonaws.com/challenge_0081) (resulting from 80 community contributions) from [perpetual powers of tau](https://github.com/privacy-scaling-explorations/perpetualpowersoftau/tree/master/0080_carter_response) in phase 1, which is circuit agnostic. We applied the output of the [Drand](http://drand.love) random beacon at epoch #3298000 to remove bias. For phase 2, our ceremony had 111 contributions, 82 from browser and 29 from docker. Finally, we applied the output of the Drand random beacon at epoch #3320606 to remove bias from contributions. All intermediate files can be reproduced following instructions [here](https://github.com/sui-foundation/zklogin-ceremony-contributions/blob/main/phase1/README.md) for phase 1 and [here](https://github.com/sui-foundation/zklogin-ceremony-contributions/blob/main/phase2/README.md) for phase 2.

## Finalization

The final CRS along with the transcript of contribution of every participant is available in a public repository. Contributors received both the hash of the previous contribution they were working on and the resulting hash after their contribution, displayed on-screen and sent via email. They can compare these hashes with the transcripts publicly available on the ceremony site. In addition, anyone is able to check that the hashes are computed correctly and each contribution is properly incorporated in the finalized parameters.

Eventually, the final CRS was used to generate the proving key and verifying key. The proving key is used to generate zero knowledge proof for zkLogin, stored with the ZK proving service. The verifying key was [deployed](https://github.com/MystenLabs/sui/pull/13822) as part of the validator software (protocol version 25 in [release 1.10.1](https://github.com/MystenLabs/sui/releases/tag/mainnet-v1.10.1)) that is used to verify the zkLogin transaction on Sui.

## Security and privacy

The following sections walk through all zkLogin artifacts, their security assumptions, and the consequences of loss or exposure.

### JWT

The JWT's validity is scoped on the client ID (`aud`) to prevent phishing attacks. The same origin policy for the proof prevents the JWT obtained for a malicious application from being used for zkLogin. The JWT for the client ID is sent directly to the application frontend through the redirect URL. A leaked JWT for the specific client ID can compromise user privacy, as these tokens frequently hold sensitive information like usernames and emails. Furthermore, if a backend salt server is responsible for user salt management, the JWT could potentially be exploited to retrieve the user's salt, which introduces additional risks.

However, a JWT leak does not mean loss of funds as long as the corresponding ephemeral private key is safe.

### User salt

The user salt is required to get access to the zkLogin wallet. This value is essential for both ZK proof generation and zkLogin address derivation.

The leak of user salt does not mean loss of funds, but it enables the attacker to associate the user's subject identifier (i.e. `sub`) with the Sui address. This can be problematic depending on whether pairwise or public subject identifiers are in use. In particular, there is no problem if pairwise IDs are used (e.g., Facebook) as the subject identifier is unique per RP. However, with public reusable IDs (e.g., Google and Twitch), the globally unique sub value can be used to identify users.

### Ephemeral private key

The ephemeral private key's lifespan is tied to the maximum epoch specified in nonce for creating a valid ZK proof. Should it be misplaced, a new ephemeral private key can be generated for transaction signing, accompanied by a freshly generated ZK proof using a new nonce. However, if the ephemeral private key is compromised, acquiring the user salt and the valid ZK proof would be necessary to move funds.

### Proof

Obtaining the proof itself cannot create a valid zkLogin transaction because an ephemeral signature over the transaction is also needed.

### Privacy

By default, there is no linking between the OAuth subject identifier (i.e. `sub`) and a Sui address. This is the purpose of the user salt.
The JWT is not published on-chain by default. The revealed values include `iss`, `aud` and `kid` so that the public input hash can be computed, any sensitive fields such as `sub` are used as private inputs when generating the proof.

The ZK proving service and the salt service (if maintained) can link the user identity since the user salt and JWT are known, but the two services are stateless by design.

In the future, the user can opt in to verify their OAuth identity associated with an Sui address on-chain.

## FAQ

### What providers is zkLogin compatible with?

zkLogin can support providers that work with OpenID Connect built on top of the OAuth 2.0 framework. This is a subset of OAuth 2.0 compatible providers. See [latest table](#openid-providers) for all enabled providers. Other compatible providers will be enabled via protocol upgrades in the future.

### How is a zkLogin Wallet different from a traditional private key wallet?

Traditional private key wallets demand users to consistently recall mnemonics and passphrases, necessitating secure storage to prevent fund loss from private key compromise.

On the other hand, a zkLogin wallet only requires an ephemeral private key storage with session expiry and the OAuth login flow with expiry. Forgetting an ephemeral key does not result in loss of funds, because a user can always sign in again to generate a new ephemeral key and a new ZK proof.

### How is zkLogin different from MPC or Multisig wallets?

Multi-Party Computation (MPC) and Multisig wallets rely on multiple keys or distributing multiple key shares and then defining a threshold value for accepting a signature.

zkLogin does not split any individual private keys, but ephemeral private keys are registered using a fresh nonce when the user authenticates with the OAuth provider. The primary advantage of zkLogin is that the user does not need to manage any persistent private key anywhere, not even with any private keys management techniques like MPC or Multisig.

You can think of zkLogin as a 2FA scheme for an address, where the first part is user's OAuth account and the second is the user's salt.

Furthermore, because Sui native supports Multisig wallets, one can always include one or more zkLogin signers inside a Multisig wallet for additional security, such as using the zkLogin part as 2FA in k-of-N settings.

### If my OAuth account is compromised, what happens to my zkLogin address?

Because zkLogin is a 2FA system, an attacker that has compromised your OAuth account cannot access your zkLogin address unless they have separately compromised your salt.

### If I lose access to my OAuth account, do I lose access to my zkLogin address?

Yes. You must be able to log into your OAuth account and produce a current JWT in order to use zkLogin.

### Does losing my OAuth credential mean the loss of funds in the zkLogin wallet?

A forgotten OAuth credential can typically be recovered by resetting the password in that provider.
In the unfortunate event where user OAuth credentials get compromised, an adversary still requires to obtain `user_salt`, but also learn which wallet is used in order to take over that account. Modern `user_salt` providers might have additional 2FA security measures in place to prevent provision of user salt even to entities that present a valid, non-expired JWT.

It is also important to highlight that due to the fact that zkLogin addresses do not expose any information about the user identity or wallet used, targeted attacks by just monitoring the blockchain are more difficult.
Finally, on the unfortunate event where one loses access to their OAuth account permanently, access to that wallet is lost. But if recovery from a lost OAuth account is desired, a good suggestion for wallet providers is to support the native Sui Multisig functionality and add a backup method. It is even possible to have a Multisig wallet that all signers are using zkLogin, such as a 1-of-2 Multisig zkLogin wallet where the first part is Google and the second Facebook OAuth, respectively.

### Can I convert or merge a traditional private key wallet into a zkLogin one, or vice versa?

No. The zkLogin wallet address is derived differently compared to a private key address.

### Will my zkLogin address ever change?

zkLogin address is derived from `sub`, `iss`, `aud`, and `user_salt`.

The address does not change if the user logs in to the same wallet with the same OAuth provider, since `sub`, `iss`, `aud`, and `user_salt` (see definitions) remain unchanged in the JWT, even though the JWT itself might look different every time the user logs in.

However, if the user logs in with different OAuth providers, your address changes because the `iss` and `aud` are defined distinctly per provider.

In addition, each wallet or application maintains its own `user_salt`, so logging with the same provider for different wallets might also result in different addresses.

See more on address [definition](#address-definition).

### Can I have multiple addresses with the same OAuth provider?

Yes, this is possible by using a different wallet provider or different `user_salt` for each account. This is useful for separating funds between different accounts.

### Is a zkLogin Wallet custodial?

A zkLogin wallet is a non-custodial or unhosted wallet.

A custodial or hosted wallet is where a third party (the custodian) controls the private keys on behalf of a wallet user. No such third party exists for zkLogin wallets.

Instead, a zkLogin wallet can be viewed as a 2-of-2 Multisig where the 2 credentials are the user OAuth credentials (maintained by the user) and the salt. In other words, neither the OAuth provider, the wallet vendor, the ZK proving service, or the salt service provider is a custodian.

### Generating a ZK proof is expensive, is a new proof required to be generated for every transaction?

No. Proof generation is only required when ephemeral KeyPair expires. Since the nonce is defined by the ephemeral public key (`eph_pk`) and expiry (`max_epoch`), the ZK proof is valid until what the expiry is committed to nonce in the JWT. The ZK proof can be cached and the same ephemeral key can be used to sign transactions until it expires.

### Does zkLogin work on mobile?

zkLogin is a Sui native primitive and not a feature of a particular application or wallet. It can be used by any Sui developer, including on mobile.

### Is account recovery possible if the user loses the OAuth credentials?

Yes, the user can follow the OAuth providers recovery flow. The ephemeral private key can be refreshed and after completing a new OAuth login flow, the user can obtain new ZK proof and sign transactions with the refreshed key.

### What are some assumptions for the zkLogin circuit?

Due to the way Groth16 works, Sui imposes length restrictions on several fields in the JWT. Some of the fields that are length-restricted include aud, iss, the JWT header and payload. For example, zkLogin can currently only work with aud values of up to length 120 (this value is not yet final). In general, Sui tries to make sure that the restrictions are as generous as possible. Sui has decided on these values after looking at as many JWTs that could be obtained.

### How is zkLogin different from other solutions that support social login?

While providing social login with Web2 credentials for Web3 wallet is not a new concept, the existing solutions have one or more of the trust assumptions:

1. Trust a different network or parties to verify Web2 credentials other than the Blockchain itself, usually involving a JWK oracle posted on-chain by a trusted party.
1. Trust some parties to manage a persistent private key, whether it uses MPC, threshold cryptography, or secure enclaves.
1. Relying on smart contracts (account abstraction) to verify the JWT on-chain with revealing privacy fields, or to verify ZK proofs on-chain which can be expensive.

Some of the existing deployed solutions rely on some of these assumptions. Web3Auth and DAuth social login requires deployment of custom OAuth verifiers to Web3auth Auth Network nodes to verify the JWT. Magic Wallet and Privy also require custom OAuth identity issuer and verifiers to adopt the DID standard. All of the solutions still require persistent private keys management, either with trusted parties like AWS through delegation, Shamir Secret Sharing, or MPC.

The key differentiators that zkLogin brings to Sui are:

1. Native Support in Sui: Unlike other solutions that are blockchain agnostic, zkLogin is deployed just for Sui. This means a zkLogin transaction can be combined with Multisig and sponsored transactions seamlessly.

1. Self-Custodial without additional trust: Sui leverages the nonce field in JWT to commit to ephemeral public key, so no persistent private key management is required with any trusted parties. In addition, the JWK itself is an oracle agreed upon by the quorum of stakes by the validators with trusting any source of authority.

1. Full privacy: Nothing is required to submit on-chain except the ZK proof and the ephemeral signature.

1. Compatible with Existing Identity Providers: zkLogin is compatible with providers that adopt OpenID Connect. No need to trust any intermediate identity issuers or verifiers other than the OAuth providers themselves.

### How to verify a zkLogin signature off-chain?

The following options support a zkLogin signature over either transaction data or personal message using the JWK state on Sui and current epoch. 

1. Use Sui TypeScript SDK. This initializes a GraphQL client and calls the endpoint under the hood.

1. Use the GraphQL endpoint directly: `https://sui-[network].mystenlabs.com/graphql`, changing `[network]` to the appropriate value. See the <UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/operations/queries/verify-zk-login-signature.mdx">GraphQL documentation</UnsafeLink> for more details. This is recommended if you do not plan to run any servers or handle any JWK rotations. 

1. Use the [Sui Keytool CLI](../../references/cli/keytool.mdx). This is recommended for debug usage. 

   ```sh
   $ sui keytool zk-login-sig-verify --sig $ZKLOGIN_SIG --bytes $BYTES --intent-scope 3 --network devnet --curr-epoch 3
   ```

1. Use a self-hosted server endpoint and call this endpoint, as described in [zklogin-verifier](https://github.com/MystenLabs/zklogin-verifier). This provides logic flexibility.

### Can I use zkLogin inside a multisig wallet? 

Yes. See the [Multisig Guide](https://sdk.mystenlabs.com/typescript/cryptography/multisig#multisig-with-zklogin) for more details.

## Related links

<RelatedLink to="/guides/developer/cryptography/zklogin-integration.mdx" />
<RelatedLink to="/guides/developer/cryptography/zklogin-integration/zklogin-example.mdx" />
>>>> sui/docs/content/concepts/custom-indexer/pipeline-architecture.mdx
---
title: Indexer Pipeline Architecture
description: The `sui-indexer-alt-framework` provides two distinct pipeline architectures. Understand the differences between the sequential and concurrent pipelines that the `sui-indexer-alt-framework` provides to decide which best suits your project needs.
keywords: [ indexer, index data, sui-indexer, custom indexer, sequential pipeline, concurrent pipeline ]
---

The `sui-indexer-alt-framework` provides 2 distinct pipeline architectures. Understanding their differences is crucial for choosing the right approach.

## Sequential versus concurrent pipelines

[Sequential pipelines](#sequential-pipeline-architecture) commit complete checkpoints in order. Each checkpoint is fully committed before the next one, ensuring simple, consistent reads.

[Concurrent pipelines](#concurrent-pipeline-architecture) commit out-of-order and can commit individual checkpoints partially. This allows you to process multiple checkpoints simultaneously for higher throughput, but requires reads to check which data is fully committed to ensure consistency.

## When to use each pipeline

Both pipeline types can handle updates in place, aggregations, and complex business logic. While sequential pipelines have throughput limitations compared to concurrent, the decision to use one over the other is primarily about engineering complexity rather than performance needs.

### Recommended: Sequential pipeline

Start here for most use cases. Provides more straightforward implementation and maintenance.

<ul className="list-none pl-2">
<li><span className="text-sui-success-dark">âœ“</span> You want straightforward implementation with direct commits and simple queries.</li>
<li><span className="text-sui-success-dark">âœ“</span> Team prefers predictable, easy-to-debug behavior.</li>
<li><span className="text-sui-success-dark">âœ“</span> Current performance meets your requirements.</li>
<li><span className="text-sui-success-dark">âœ“</span> Operational simplicity is valued.</li>
</ul>

### Concurrent pipeline

Consider implementing a concurrent pipeline when:

<ul className="list-none pl-2">
<li><span className="text-sui-success-dark">âœ“</span> Performance optimization is essential.</li>
<li><span className="text-sui-success-dark">âœ“</span> Sequential processing cannot keep up with your data volume.</li>
<li><span className="text-sui-success-dark">âœ“</span> Your team is willing to handle the additional implementation complexity for the performance benefits.</li>
</ul>

Supporting out-of-order commits introduces a few additional complexities to your pipeline:

- Watermark-aware queries: All reads must check which data is fully committed. See [the watermark system](#watermark-system) section for details.
- Complex application logic: You must handle data commits in pieces rather than handling complete checkpoints.

## Decision framework

If you are unsure of which pipeline to choose for your project, start with a sequential pipeline as it is easier to implement and debug. Then, measure performance under a realistic load. If the sequential pipeline cannot meet your project's requirements, then switch to a concurrent pipeline.

While not an exhaustive list, some specific scenarios where a sequential pipeline might not meet requirements include:

- Your pipeline produces data in each checkpoint that benefits from chunking and out-of-order commits. Individual checkpoints can produce lots of data or individual writes that might add latency.
- You are producing a lot of data that needs pruning. In this case, you must use a concurrent pipeline.

Beyond the decision of which pipeline to use, you also need to consider scaling. If you are indexing multiple kinds of data, then consider using multiple pipelines and watermarks.

## The watermark system {#watermark-system}

For each pipeline, the indexer minimally tracks the highest checkpoint where all data up to that point is committed. Tracking is done through the `checkpoint_hi_inclusive` committer watermark. Both concurrent and sequential pipelines rely on `checkpoint_hi_inclusive` to understand where to resume processing on restarts.

Optionally, the pipeline tracks `reader_lo` and `pruner_hi`, which define safe lower bounds for reading and pruning operations, if pruning is enabled. These watermarks are particularly crucial for concurrent pipelines to enable out-of-order processing while maintaining data integrity. 

### Safe pruning

The watermark system creates a robust data lifecycle management system:

1. **Guaranteed data availability:** Enforcing checkpoint data availability rules ensures readers perform safe queries.    
1. **Automatic cleanup process:** The pipeline frequently cleans unpruned checkpoints to ensure storage does not grow indefinitely while maintaining the retention guarantee. The pruning process runs with a safety delay to avoid race conditions.
1. **Balanced approach:** The system strikes a balance between safety and efficiency.
    - Storage efficiency: Old data gets automatically deleted.
    - Data availability: Always maintains retention amount of complete data.
    - Safety guarantees: Readers never encounter missing data gaps.
    - Performance: Out-of-order processing maximizes throughput.

This watermark system is what makes concurrent pipelines both high-performance and reliable, enabling massive throughput while maintaining strong data availability guarantees and automatic storage management.

### Scenario 1: Basic watermark (no pruning)

With pruning disabled, the indexer reports each pipeline committer `checkpoint_hi_inclusive` only. Consider the following timeline, where a number of checkpoints are being processed and some are committed out of order.

```sh
Checkpoint Processing Timeline:

[1000] [1001] [1002] [1003] [1004] [1005]
  âœ“      âœ“      âœ—      âœ“      âœ—      âœ—
         ^
  checkpoint_hi_inclusive = 1001

âœ“ = Committed (all data written)
âœ— = Not Committed (processing or failed)
```

In this scenario, the `checkpoint_hi_inclusive` is at 1001, even though checkpoint 1003 is committed, because there is still a gap at 1002. The indexer must report the high watermark at 1001 to satisfy the guarantee that all data from start to `checkpoint_hi_inclusive` is available.

After the checkpoint 1002 is committed, you can safely read data up to 1003.

```sh
[1000] [1001] [1002] [1003] [1004] [1005]
  âœ“      âœ“      âœ“      âœ“      âœ—       âœ—
[---- SAFE TO READ -------]
(start   â†’   checkpoint_hi_inclusive at 1003)
```

### Scenario 2: Pruning enabled

Pruning is enabled for pipelines configured with a retention policy. For example, if your table is growing too large and you want to keep only the last 4 checkpoints, then `retention = 4`. This means that the indexer periodically updates `reader_lo` as the difference between `checkpoint_hi_inclusive` and the configured retention. A separate pruning task is responsible for pruning data between `[pruner_hi, reader_lo]`.

```sh
[998] [999] [1000] [1001] [1002] [1003] [1004] [1005] [1006]
 ðŸ—‘ï¸    ðŸ—‘ï¸     âœ“      âœ“      âœ“      âœ“      âœ—      âœ—      âœ—
              ^                    ^
       reader_lo = 1000       checkpoint_hi_inclusive = 1003

ðŸ—‘ï¸ = Pruned (deleted)
âœ“ = Committed  
âœ— = Not Committed
```

Current watermarks:

- `checkpoint_hi_inclusive` = 1003:
       - All data from start to 1003 is complete (no gaps).
       - Cannot advance to 1005 because 1004 is not committed yet (gap).

- `reader_lo` = 1000:
       - Lowest checkpoint guaranteed to be available.
       - Calculated as: `reader_lo = checkpoint_hi_inclusive - retention + 1`.
       - `reader_lo` = 1003 - 4 + 1 = 1000.

- `pruner_hi` = 1000:
       - Highest exclusive checkpoint that has been deleted.
       - Checkpoints 998 and 999 were deleted to save space.

Clear safe zones:

```sh
[998] [999] [1000] [1001] [1002] [1003] [1004] [1005] [1006]
 ðŸ—‘ï¸    ðŸ—‘ï¸     âœ“      âœ“      âœ“      âœ“      âœ—      âœ—      âœ“

[--PRUNED--][--- Safe Reading Zone ---] [--- Processing ---]             
```

### How watermarks progress over time

**Step 1:** Checkpoint 1004 completes.

```sh
[999] [1000] [1001] [1002] [1003] [1004] [1005] [1006] [1007]
 ðŸ—‘ï¸     âœ“      âœ“      âœ“      âœ“      âœ“      âœ—      âœ“      âœ—
        ^                           ^
 reader_lo = 1000           checkpoint_hi_inclusive = 1004 (advanced by 1)
 pruner_hi = 1000
```

With checkpoint 1004 now committed, `checkpoint_hi_inclusive` can advance from 1003 to 1004 because there are no gaps up to 1004. Note that `reader_lo` and `pruner_hi` have not changed yet.

**Step 2:** Reader watermark updates periodically.

```sh
[999] [1000] [1001] [1002] [1003] [1004] [1005] [1006] [1007]
 ðŸ—‘ï¸     âœ“      âœ“      âœ“      âœ“      âœ“      âœ—      âœ“      âœ—
               ^                   ^
        reader_lo = 1001    checkpoint_hi_inclusive = 1004
        (1004 - 4 + 1 = 1001)

pruner_hi = 1000 (unchanged as pruner hasn't run yet)
```

A separate reader watermark update task (running periodically, configurable) advances `reader_lo` to 1001 (calculated as `1004 - 4 + 1 = 1001`) based on the retention policy. However, the pruner hasn't run yet, so `pruner_hi` remains at 1000.

**Step 3:** Pruner runs after safety delay.

```sh
[999] [1000] [1001] [1002] [1003] [1004] [1005] [1006] [1007]
 ðŸ—‘ï¸     ðŸ—‘ï¸     âœ“      âœ“      âœ“      âœ“      âœ—      âœ“      âœ—
               ^                   ^
        reader_lo = 1001    checkpoint_hi_inclusive = 1004
        pruner_hi = 1001
```

Because `pruner_hi` (1000) < `reader_lo` (1001), the pruner detects that some checkpoints are outside of the retention window. It cleans up all elements up to `reader_lo` (deleting checkpoint 1000) and updates `pruner_hi` to `reader_lo` (1001).


:::info
Checkpoints older than `reader_lo` might still be temporarily available because of:
- Intentional delay protecting in-flight queries
- Pruner not completing cleanup yet
:::

## Sequential pipeline architecture {#sequential-pipeline-architecture}

Sequential pipelines provide a more straightforward yet powerful architecture for indexing that prioritizes ordered processing. While they sacrifice some throughput compared to concurrent pipelines, they offer stronger guarantees and are often easier to reason about.

### Architecture overview

The sequential pipeline consists of only two main components, making it significantly simpler than the concurrent pipeline's six-component architecture.

![Sequential pipeline diagram](./images/sequential.png)

The ingestion layer (`Regulator` + `Broadcaster`) and `Processor` components use identical backpressure mechanisms, `FANOUT` parallel processing, and `processor()` implementations to the concurrent pipeline.

The key difference is the dramatically simplified pipeline core with just a single `Committer` component that handles ordering, batching, and database commits. Concurrent pipelines, in contrast, have five separate components in addition to the `Processor`: `Collector`, `Committer`, `CommitterWatermark`, `ReaderWatermark`, and `Pruner`.

### Sequential pipeline components {#sequential-components}

There are two main components to sequential pipelines.

1. [`Processor`](#seq-processor)
1. [`Committer`](#seq-committer)

#### `Processor` {#seq-processor}

<ImportContent source="indexer-pipeline-processor.mdx" mode="snippet" />

#### `Committer` {#seq-committer}

The sequential `Committer` is the main component of the pipeline and your main customization point. At a high level, the `Committer` performs the following actions:

1. **Receives** out-of-order processed data from the processor.
1. **Orders** the data by checkpoint sequence.
1. **Batches** multiple checkpoints together using your logic.
1. **Commits** the batch to the database atomically.
1. **Signals** progress back to the ingestion layer.

To customize, your code uses two key functions that the committer calls:

`batch()`: Data merging logic.

<ImportContent source="crates/sui-indexer-alt-framework/src/pipeline/sequential/mod.rs" mode="code" fun="batch" noComments />

`commit()`: Database write logic.

<ImportContent source="crates/sui-indexer-alt-framework/src/pipeline/sequential/mod.rs" mode="code" fun="commit" noComments />

### Sequential pipeline backpressure mechanisms

Sequential pipelines use two layers of backpressure to prevent memory overflow and ordering-related deadlocks:

![Backpressure sequential pipeline architecture](./images/backpressure-sequential.png)

#### Channel-based backpressure

Sequential pipelines use the same channel-based flow control as concurrent pipelines (see [concurrent pipeline backpressure](#concurrent-backpressure) for detailed mechanics), but with a simpler topology due to fewer components:

- **Broadcaster â†’ Processor:** `checkpoint_buffer_size` slots.
- **Processor â†’ Committer:** `FANOUT + PIPELINE_BUFFER` slots.

#### Watermark-based regulation (sequential-specific) {#sequential-watermark-regulation}

Sequential pipelines must process checkpoints in strict order (N, then N+1, then N+2...). If checkpoint N is missing, they cannot commit later checkpoints, even if available.

Without regulation, missing checkpoints can cause deadlocks in situations such as:

1. Pipeline waits for checkpoint 100.
1. Checkpoint 100 gets dropped or delayed.
1. Ingestion fills buffer with 101, 102, 103...
1. Buffer becomes full and cannot refetch checkpoint 100 when available.
1. Pipeline becomes permanently stuck.

To avoid this pitfall, you can use watermark progress reporting. After successful commits, instruct the pipelines to send `(pipeline_name, highest_committed_checkpoint)` to the regulator via the `ingest_hi_tx` channel.

<ImportContent source="crates/sui-indexer-alt-framework/src/pipeline/sequential/committer.rs" tag="send" />
    
The `Regulator` receives updates by listening on `ingest_hi_rx`. It then calculates the ingestion boundary across all pipelines (`min_subscriber_watermark + buffer_size`).

<ImportContent source="crates/sui-indexer-alt-framework/src/ingestion/regulator.rs" tag="regulator" />

This approach prevents deadlocks in the following ways:

- The `Regulator` only fetches checkpoints up to the calculated boundary.
- No pipeline falls too far behind the ingestion front.
- Guarantees buffer space remains available to retry missing checkpoints.

Only sequential pipelines need this type of regulation, as concurrent pipelines can process checkpoints out-of-order and any missing checkpoints only delay watermark updates rather than halt overall progress.

### Performance tuning

Sequential pipelines have a more basic configuration but do require critical tuning parameters:

```rust
let config = SequentialConfig {
    committer: CommitterConfig {
        // Not applicable to sequential pipelines
        write_concurrency: 1,
        
        // Batch collection frequency in ms (default: 500)
        collect_interval_ms: 1000,
    },
    
    // Checkpoints to lag behind live data (default: 0)
    checkpoint_lag: 100,
};
```

- `collect_interval_ms`: Higher values allow more checkpoints per batch, improving efficiency.
- `checkpoint_lag`: Essential for live indexing to avoid processing incomplete data.
- `write_concurrency`: Not applicable to sequential pipelines (always single-threaded writes).

## Concurrent pipeline architecture {#concurrent-pipeline-architecture}

Before diving into the concurrent pipeline architecture, make sure you understand the watermark system covered in the [previous section](#watermark-system). The watermark concepts (`checkpoint_hi_inclusive`, `reader_lo`, `pruner_hi`, and `retention`) are fundamental to how every component in the concurrent pipeline operates and coordinates.

### Architecture overview

The concurrent pipeline transforms raw checkpoint data into indexed database records through a sophisticated multi-stage architecture designed for maximum throughput while maintaining data integrity:

![Concurrent Pipeline Diagram](./images/concurrent.png)

Key design principles:

- **Watermark coordination:** Safe out-of-order processing with consistency guarantees.
- **Handler abstraction:** Where your business logic plugs into the framework.
- **Automatic storage management:** Framework handles watermark tracking and data cleanup within the `Watermark` database.

### Concurrent pipeline components {#concurrent-components}

There are six components to concurrent pipelines.

1. [`Processor`](#con-processor)
1. [`Collector`](#con-collector)
1. [`Committer`](#con-committer)
1. [`CommitterWatermark`](#con-commit-watermark)
1. [`ReaderWatermark`](#con-reader-watermark)
1. [`Pruner`](#con-pruner)

#### `Processor` {#con-processor}

<ImportContent mode="snippet" source="indexer-pipeline-processor.mdx"/>

#### `Collector` {#con-collector}

The primary responsibility of the `Collector` is to buffer processed data and create user-configurable batches for database writes.

The `Collector` receives out-of-order processed data from multiple `Processor` workers. It then buffers data until reaching optimal batch size (`MIN_EAGER_ROWS`) or until a timeout is met (to preserve forward progress for quiet pipelines).

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/concurrent/mod.rs" variable="MIN_EAGER_ROWS" />
    
The `Collector` combines data from multiple checkpoints into single database write batches and applies backpressure when too much data is pending (`MAX_PENDING_ROWS`).

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/concurrent/mod.rs" variable="MAX_PENDING_ROWS" />
    
Database writes are expensive; batching dramatically improves throughput by reducing the number of database round trips.

#### `Committer` {#con-committer}

The `Committer` primarily writes batched data to the database using parallel connections with retry logic. It does this by receiving optimized batches from `Collector`, then spawns up parallel database writers to `write_concurrency`.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/mod.rs" struct="CommitterConfig" />

- Each writer calls your `Handler::commit()` method with exponential backoff retry.
- Reports successful writes to the `CommitterWatermark` component.

:::important

The `Committer` tasks don't actually perform database operations. Rather, it calls your handler's `commit()` method. You must implement the actual database logic.

:::

#### `CommitterWatermark` {#con-commit-watermark}

The primary responsibility of the `CommitterWatermark` is to track which checkpoints are fully committed and update `checkpoint_hi_inclusive` in the `Watermark` table.

The `CommitterWatermark` receives `WatermarkParts` from successful `Committer` writes.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/mod.rs" struct="WatermarkPart"/>
    
The `CommitterWatermark` maintains an in-memory map of checkpoint completion status, advancing `checkpoint_hi_inclusive` only when there are no gaps in the sequence. Periodically, it writes the new `checkpoint_hi_inclusive` to the `Watermark` database.

This component enforces the critical rule that `checkpoint_hi_inclusive` can advance only when all data up to that point is committed with no gaps. This component enforces that critical rule. See the [watermark system](#watermark-system) for details.

By using polling, updates happen on a configurable interval (`watermark_interval_ms`) rather than immediately, balancing consistency with performance.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/mod.rs" struct="CommitterConfig" highlight="watermark_interval_ms" />

#### `ReaderWatermark` {#con-reader-watermark}

The primary responsibility of the `ReaderWatermark` is to calculate and update `reader_lo` to maintain the retention policy and provide safe pruning boundaries.

The `ReaderWatermark` polls the `Watermark` database periodically (`interval_ms`) to check current `checkpoint_hi_inclusive`. It then calculates the new `reader_lo = checkpoint_hi_inclusive - retention + 1` value and updates the `reader_lo` and `pruner_timestamp` in the `Watermark` database. This behavior provides the safety buffer that prevents premature pruning.

The `reader_lo` value represents the lowest checkpoint guaranteed to be available. This component ensures your retention policy is maintained. See the [watermark system](#watermark-system) section for details.

#### `Pruner` {#con-pruner}

The primary responsibility of the `Pruner` is to remove old data based on retention policies and to update `pruner_hi`.

The `Pruner` waits for the safety delay (`delay_ms`) after `reader_lo` updates.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/concurrent/mod.rs" struct="PrunerConfig" highlight="delay_ms" />
    
The `Pruner` then calculates which checkpoints can be safely deleted and spawns up to `prune_concurrency` parallel cleanup tasks.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/concurrent/mod.rs" struct="PrunerConfig" highlight="prune_concurrency" />
    
Each task calls your `Handler::prune()` method for specific checkpoint ranges and updates `pruner_hi` as cleanup completes.

:::important

The `Pruner` tasks don't actually delete data. Rather, they call your handler's `prune()` method. You must implement the actual cleanup logic.

:::

The `Pruner` operates in the range between the current `pruner_hi` and the safe boundary determined by `reader_lo`, ensuring readers are never affected. See the [watermark system](#watermark-system) for details.

### Handler abstraction

The `Handler` is where you implement your indexing business logic. The framework calls three key methods:

```rust
trait Processor {
    // Called by Processor workers
    fn process(&self, checkpoint: &CheckpointData) -> Vec<Self::Value>;
}

trait Handler { 
    // Called by Committer workers  
    async fn commit(&[Self::Value], &mut Connection) -> Result<usize>;
    
    // Called by Pruner workers
    async fn prune(&self, from: u64, to: u64, &mut Connection) -> Result<usize>;
}
```

:::important

The framework components (`Committer`, `Pruner`) are orchestrators that manage concurrency, retries, and watermark coordination. The actual database operations happen in your `Handler` methods.

:::

### Watermark table management

The `Watermark` table manages all watermark coordination. It is critical for recovery, as the framework reads this table to resume from the correct checkpoint.

The framework automatically creates and manages a `Watermark` table in your database when you first run your indexer. The table might have only one row per pipeline, allowing multiple indexers to share the same database.

`Watermark` schema:

<ImportContent mode="code" source="crates/sui-pg-db/src/schema.rs" />

###  Concurrent pipeline backpressure mechanisms {#concurrent-backpressure}

With the component architecture detailed, let's examine how the pipeline prevents memory overflow through cascading backpressure using inter-component channels.
![Concurrent Backpressure Pipeline](./images/backpressure-concurrent.png)

#### Channel-level blocking with fixed sizes

Each channel has a fixed buffer size that automatically blocks when full:

**`Regulator` to `Broadcaster`**: `ingest_concurrency` slots â†’ `Regulator` stops signaling new fetches.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/ingestion/mod.rs" struct="IngestionConfig" highlight="ingest_concurrency" />
    
**`Broadcaster` to `Processor`**: `checkpoint_buffer_size` slots â†’ `Broadcaster` blocks, upstream pressure.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/ingestion/mod.rs" struct="IngestionConfig" highlight="checkpoint_buffer_size" />   
    
**`Processor` to `Collector`**: `FANOUT + PIPELINE_BUFFER` slots â†’ All workers block on `send()`.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/concurrent/mod.rs" variable="processor_tx" />
    
**`Collector` to `Committer`**: `write_concurrency + PIPELINE_BUFFER` slots â†’ `Collector` stops accepting.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/concurrent/mod.rs" tag="buff" /> 

When any channel fills, pressure automatically propagates backward through the entire pipeline.

#### Component-level blocking

At the component level, the `Collector` respects memory limits and stops accepting when `pending_rows â‰¥ MAX_PENDING_ROWS`.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/pipeline/concurrent/collector.rs" tag="collector" /> 
    
Database connection limits are also in place. The `Committer` blocks when all connections are busy.

#### Application-level coordination

`Watermark` feedback provides application-level coordination by reporting progress to the `Regulator` through `Watermark` updates. Further coordination is provided through bounded ingestion, where the `Regulator` only signals fetches within a bounded range ahead of the current watermark.

<ImportContent mode="code" source="crates/sui-indexer-alt-framework/src/ingestion/regulator.rs" tag="bound" /> 
    
Finally, memory protection ensures the entire system operates within predictable memory bounds.

#### Backpressure in practice

Basic example: Slow database scenario

1. **Initial state**: Your indexer is processing 100 checkpoints per second.
1. **Bottleneck appears**: Database becomes slow (because of high load, maintenance, or similar) and can now only handle 50 commits per second.
1. **Backpressure cascade**:
    - `Committer` channel fills up (cannot commit fast enough).
    - `Collector` stops sending to `Committer` (channel full).
    - `Processor` workers stop sending to `Collector` (channel full).
    - `Broadcaster` stops sending to `Processors` (channel full).
    - `Regulator` stops requesting new checkpoints (channel full).
1. **End result**:
    - Indexer automatically slows to 50 checkpoints per second, matching database capacity.
    - Memory stays bounded, no runaway growth.
    - No data loss as everything just processes slower.
    - System is stable at the bottleneck pace.
1. **Recovery**: When database speeds up, channels start draining and indexer automatically returns to full speed.

What happens:

- Slower checkpoint progress in logs and metrics.
- Stable memory usage (no growth).
- System remains responsive, just at reduced throughput.

### Performance tuning

The following sections detail the configuration settings you can implement for optimal performance.

#### Concurrent pipeline `Handler` constants

`Handler` constants are the most direct way to tune pipeline behavior. These are implemented as associated constants in your `Handler` trait implementation.

```rust
impl concurrent::Handler for MyHandler {
    type Store = Db;
    
    // Number of concurrent processor workers (default: 10)
    const FANOUT: usize = 20;
    
    // Minimum rows to trigger eager commit for committer (default: 50)
    const MIN_EAGER_ROWS: usize = 100;
    
    // Backpressure threshold on committer (default: 5000)
    const MAX_PENDING_ROWS: usize = 10000;
    
    // Maximum watermarks per batch (default: 10,000)
    const MAX_WATERMARK_UPDATES: usize = 5000;
}
```

Tuning guidelines: 

- **`FANOUT`:** Increase for CPU-intensive processing, decrease for memory-constrained environments.
- **`MIN_EAGER_ROWS`:** Lower values reduce data commit latency (individual data appears in database sooner), higher values improve overall throughput (more efficient larger batches).
- **`MAX_PENDING_ROWS`:** Controls how much data can accumulate when the committer falls behind. Higher values provide more buffer space but use more memory during bottlenecks.
- **`MAX_WATERMARK_UPDATES`:** Lower for sparse pipelines (rare events), keep default for dense pipelines.

#### `CommitterConfig` optimization

The `CommitterConfig` controls how data flows from collection to database commits:

```rust
let config = ConcurrentConfig {
    committer: CommitterConfig {
        // Number of parallel database writers (default: 5)
        write_concurrency: 10,
        
        // How often collector checks for batches in ms (default: 500)
        collect_interval_ms: 250,
        
        // How often watermarks are updated in ms (default: 500)
        watermark_interval_ms: 1000,
    },
    pruner: Some(pruner_config),
};
```

Tuning guidelines:

- **`write_concurrency`:** Higher values result in faster throughput but more database connections; `ensure total_pipelines Ã— write_concurrency < db_connection_pool_size`.
- **`collect_interval_ms`:** Lower values reduce latency but increase CPU overhead.
- **`watermark_interval_ms`:** Controls how often watermarks are updated. Higher values reduce database contention from frequent watermark writes but make the indexer slower to respond to pipeline progress.

### `PrunerConfig` settings

Configure data retention and pruning performance:

```rust
let pruner_config = PrunerConfig {
    // Check interval for pruning opportunities in ms (default: 300,000 = 5 min)
    interval_ms: 600_000, // 10 minutes for less frequent checks
    
    // Safety delay after reader watermark update in ms (default: 120,000 = 2 min)  
    delay_ms: 300_000, // 5 minutes for conservative pruning
    
    // How many checkpoints to retain (default: 4,000,000)
    retention: 10_000_000, // Keep more data for analytics
    
    // Max checkpoints to prune per operation (default: 2,000)
    max_chunk_size: 5_000, // Larger chunks for faster pruning
    
    // Parallel pruning tasks (default: 1)
    prune_concurrency: 3, // More parallelism for faster pruning
};
```

Tuning guidelines:

- **`retention`:** Balance storage costs versus data availability needs.
- **`max_chunk_size`:** Larger values faster pruning, but longer database transactions.
- **`prune_concurrency`:** Do not exceed database connection limits.
- **`delay_ms`:** Increase for safety, decrease for aggressive storage optimization.

## Related links

<RelatedLink to="/concepts/custom-indexing-framework.mdx" />
<RelatedLink to="/concepts/sui-architecture/transaction-lifecycle.mdx" />
<RelatedLink to="/guides/developer/advanced/custom-indexer.mdx" />
>>>> sui/docs/content/concepts/custom-indexing-framework.mdx
---
title: Custom Indexing Framework
description: The `sui-indexer-alt-framework` is a powerful Rust framework for building high-performance, custom blockchain indexers on Sui. It provides customizable, production-ready components for data ingestion, processing, and storage.
keywords: [ indexer, framework, indexer framework, dex, events, framework architecture ]
pagination_prev: null
---

Sui generates rich, complex data, including transactions, events, object changes, and more. While Sui provides standard APIs to access this data, many applications need customized data processing for workflows such as tracking specific events, aggregating analytics, building dashboards, or creating specialized databases.

A custom indexer can be used to extract, transform, and store the specific blockchain data you need. Instead of querying Sui APIs repeatedly or building complex filtering logic, you process the raw blockchain data once and store it in your preferred format.

To create a custom indexer, the `sui-indexer-alt-framework` Rust framework can be used. It provides production-ready components for data ingestion, processing, and storage while giving you full control over your indexing logic.

Leveraging the custom indexing framework is necessary for projects and use cases such as:

- Tracking DEX trading volumes
- Monitoring NFT collection activity
- Building analytics dashboards
- Creating specialized search indexes
- Aggregating cross-chain bridge data

## Framework architecture

At a high level, the indexing framework is a streaming pipeline that continuously polls for the latest available checkpoints from a pre-defined data source and streams that checkpoint data to your pipeline's processing logic.

Checkpoints on Sui are batches of transactions that represent consistent blockchain state snapshots. Each checkpoint contains complete transaction details, events, object changes, and execution results with guaranteed ordering. See [Life of a Transaction](./sui-architecture/transaction-lifecycle.mdx#checkpoints) for more information on checkpoints.

![Overview](./custom-indexer/images/overview.png)

## Detailed architecture

The following diagram details the custom indexer architecture.

![Custom indexer architecture](./custom-indexer/images/architecture.png)

### Data sources

Checkpoint data comes from various data sources, including:

- **Remote stores** connect to public checkpoint stores like [`https://checkpoints.mainnet.sui.io`](https://checkpoints.mainnet.sui.io/). This is the most straightforward way to get started without running your own infrastructure.
- **Local files** allow you to process checkpoint files dumped by a local Sui full node, providing the lowest latency, but should be used for testing only as these files are not automatically cleaned up.
- **RPC endpoints** enable direct connection to a Sui full node RPC endpoint, allowing you to use a trusted data source that you control or to connect to networks (like Devnet) that lack a remote store.
The indexing framework supports multiple data sources to maximize flexibility.

### Ingestion layer

The indexing framework manages the ingestion layer, which handles the complex task of reliably fetching and distributing checkpoint data. The `Broadcaster` receives checkpoints from data sources and efficiently distributes them to multiple processing pipelines running in parallel. This is essential for indexers that run multiple different data processing workflows simultaneously. 

The `Regulator` acts as a smart coordinator, controlling data flow rates by directing the `Broadcaster` on which checkpoints to fetch. It's backpressured by the high watermarks reported by subscribers, so that the `Broadcaster` doesn't fetch too many.

### Processing layer

Both the indexing framework and your code manage the processing layer, which is where your custom logic integrates with the framework. The pipeline framework components are the heart of the system, as they orchestrate checkpoint processing, manage concurrency to maximize throughput, maintain watermarks to track progress and ensure data consistency, and coordinate the entire data flow from ingestion to storage. The framework components adapt based on your chosen pipeline type: 

- **Sequential pipelines** use different components optimized for in-order processing with batching capabilities.
- **Concurrent pipelines** use components like `Collector`, `Committer`, and `Pruner` for high-throughput out-of-order processing.

The framework then exposes specific interfaces that you implement to define your data processing logic. Some common APIs include:

- `process()`: Transform raw checkpoint data (transactions, events, object changes) into your desired database rows. This is where you extract meaningful information, filter relevant data, and format it for storage.
- `commit()`: Store your processed data to the database with proper transaction handling. The framework calls this with batches of processed data for efficient bulk operations.
- `prune()`: Clean up old data based on your retention policies (optional). Useful for managing database size by removing outdated records while preserving recent data.

Sequential and concurrent pipeline types and their trade-offs are detailed in [Pipeline Architecture](./custom-indexer/pipeline-architecture.mdx).

<details>

<summary>

`CheckpointData` struct

</summary>

<ImportContent source="crates/sui-types/src/full_checkpoint_content.rs" mode="code" struct="CheckpointData" />

</details>

### Storage layer

The indexing framework abstracts database operations through a flexible storage layer. PostgreSQL comes with built-in support using Diesel ORM, providing production-ready database operations, connection pooling, migrations, and watermark management out of the box. For custom database implementations, you can implement the framework's storage interfaces to use any database, for example, [MongoDB](https://www.mongodb.com/) for document storage or [ClickHouse](https://clickhouse.com/) for analytics.

## Single program, multiple threads

Your indexer runs as one executable program with multiple coordinated background tasks (threads). The ingestion layer polls for new checkpoints while your processing pipelines transform and store data - all within the same process.

## Related links

<RelatedLink to="/concepts/custom-indexer/pipeline-architecture.mdx" />
<RelatedLink to="/concepts/sui-architecture/transaction-lifecycle.mdx" />
<RelatedLink to="/guides/developer/advanced/custom-indexer.mdx" />
>>>> sui/docs/content/concepts/dynamic-fields.mdx
---
title: Dynamic (Object) Fields
description: Dynamic fields and dynamic object fields on Sui are added and removed dynamically, affect gas only when accessed, and store heterogeneous values.
keywords: [ dynamic fields, dynamic object fields, adding dynamic fields, field names, adding dynamic object fields, accessing dynamic fields, accessing dynamic object fields, deleting an object with dynamic fields ]
---

There are various ways to use object fields to store primitive data and other objects (wrapping), but there are a few limitations to these:

1. Object's have a finite set of fields keyed by identifiers that are fixed when you publish its module (limited to the fields in the `struct` declaration).
1. An object can become very large if it wraps several other objects. Larger objects can lead to higher gas fees in transactions. In addition, there is an upper bound on object size.
1. There are use cases where you need to store a collection of objects of heterogeneous types. Because the Move `vector` type must be instantiated with one single type `<T>`, it is not suitable for this.

Fortunately, Sui provides *dynamic fields* with arbitrary names (not just identifiers), added and removed on-the-fly (not fixed at publish), which only affect gas when they are accessed, and can store heterogeneous values. Use the libraries in this topic to interact with this kind of field.

## Fields versus object fields

There are two flavors of dynamic field: fields and object fields, which differ based on how you store their values:

| Type | Description | Module |
| --- | --- | --- |
| Fields | Can store any value that has `store`, however an object stored in this kind of field is considered wrapped and is not accessible via its ID by external tools (explorers, wallets, and so on) accessing storage.| [`dynamic_field`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/dynamic_field.move) |
| Object field | Values must be objects (have the `key` ability, and `id: UID` as the first field), but are still accessible at their ID to external tools.| [`dynamic_object_field`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/dynamic_object_field.move) |

## Field names

Unlike an object's regular fields where names must be Move identifiers, dynamic field names can be any value that has `copy`, `drop`, and `store`. This includes all Move primitives (integers, Booleans, byte strings), and structs whose contents all have `copy`, `drop`, and `store`.

## Adding dynamic fields

Use the `add` function from the relevant Sui framework module to add dynamic fields:

**Dynamic field**

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/dynamic_field.move" mode="code" fun="add" noComments />

**Dynamic object field**

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/dynamic_object_field.move" mode="code" fun="add" noComments />

These functions add a field with name `name` and value `value` to `object`. To see it in action, consider these code snippets:

First, define two object types for the parent and the child:

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" struct="Parent" noComments />

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" struct="Child" noComments />

Next, define an API to add a `Child` object as a dynamic field of a `Parent` object:

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" fun="add_child" />

This function takes the `Child` object by value and makes it a dynamic field of `parent` with name `b"child"` (a byte string of type `vector<u8>`). This call results in the following ownership relationship:

1. Sender address (still) owns the `Parent` object.
1. The `Parent` object owns the `Child` object, and can refer to it by the name `b"child"`.

It is an error to overwrite a field (attempt to add a field with the same `<Name>` type and value as one that is already defined), and a transaction that does this fails. You can modify fields in-place by borrowing them mutably and you can overwrite them safely (such as to change its value type) by removing the old value first.

## Accessing dynamic fields

You can reference dynamic fields by reference using the following APIs:

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/dynamic_field.move" mode="code" fun="borrow" noComments />

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/dynamic_field.move" mode="code" fun="borrow_mut" noComments />

Where `object` is the UID of the object the field is defined on and `name` is the field's name.

:::info

`sui::dynamic_object_field` has equivalent functions for object fields, but with the added constraint `Value: key + store`.

:::

To use these APIs with the `Parent` and `Child` types defined earlier:

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" fun="mutate_child" noComments />

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" fun="mutate_child_via_parent" noComments />

The first function accepts a mutable reference to the `Child` object directly, and you can call it with `Child` objects that haven't been added as fields to `Parent` objects.

The second function accepts a mutable reference to the `Parent` object and accesses its dynamic field using `borrow_mut`, to pass to `mutate_child`. This can only be called on `Parent` objects that have a `b"child"` field defined. A `Child` object that has been added to a `Parent` must be accessed via its dynamic field, so it can only be mutated using `mutate_child_via_parent`, not `mutate_child`, even if its ID is known.

:::tip

A transaction fails if it attempts to borrow a field that does not exist.

:::

The `<Value>` type passed to `borrow` and `borrow_mut` must match the type of the stored field, or the transaction aborts.

You must access dynamic object field values through these APIs. A transaction that attempts to use those objects as inputs (by value or by reference), is rejected for having invalid inputs.

## Removing a dynamic field

Similar to unwrapping an object held in a regular field, you can remove a dynamic field, exposing its value:

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/dynamic_field.move" mode="code" fun="remove" noComments />

This function takes a mutable reference to the ID of the `object` the field is defined on, and the field's `name`.  If a field with a `value: Value` is defined on `object` at `name`, it is removed and `value` returned, otherwise it aborts. Future attempts to access this field on `object` will fail.

:::tip

`sui::dynamic_object_field` has an equivalent function for object fields.

:::

The value that is returned can be interacted with just like any other value (because it is any other value). For example, removed dynamic object field values can then be `delete`-d or `transfer`-ed to an address (back to the sender):

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" fun="delete_child" noComments />

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" fun="reclaim_child" noComments />

Similar to borrowing a field, a transaction that attempts to remove a non-existent field, or a field with a different `Value` type, fails.

## Deleting an object with dynamic fields

It is possible to delete an object that has (potentially non-`drop`) dynamic fields still defined on it. Because field values can be accessed only via the dynamic field's associated object and field name, deleting an object that has dynamic fields still defined on it renders them all inaccessible to future transactions. This is true regardless of whether the field's value has the `drop` ability. This might not be a concern when adding a small number of statically known additional fields to an object, but is particularly undesirable for on-chain collection types that could be holding unboundedly many key-value pairs as dynamic fields.

Sui provides `Table` and `Bag` collections built using dynamic fields, but with additional support to count the number of entries they contain to protect against accidental deletion when non-empty. To learn more, see [Tables and Bags](./dynamic-fields/tables-bags.mdx).

## Related links

<RelatedLink href="https://move-book.com/programmability/dynamic-fields.html" label="Dynamic fields" desc="Learn more about Dynamic Fields in The Move Book. The Move Book is a comprehensive guide to the Move programming language and the Sui blockchain." />
<RelatedLink href="https://move-book.com/programmability/dynamic-object-fields.html" label="Dynamic Object Fields" desc="Learn more about Dynamic Object Fields in The Move Book." />
<RelatedLink to="/concepts/dynamic-fields/tables-bags" />


>>>> sui/docs/content/concepts/dynamic-fields/tables-bags.mdx
---
title: Table and Bag
description: Sui provides `Table` and `Bag` collections built using dynamic fields, but with additional support to count the number of entries they contain to protect against accidental deletion when non-empty.
---

You can extend existing objects using [dynamic fields](/concepts/dynamic-fields.mdx). It is possible to delete an object that still has (potentially non-drop) dynamic fields. This might not be a concern when adding a small number of statically known additional fields to an object, but is particularly undesirable for on-chain collection types that could be holding unboundedly many key-value pairs as dynamic fields.

This topic describes 2 such collections, table and bag, built using dynamic fields, but with additional support to count the number of entries they contain, and protect against accidental deletion when non-empty.

The types and function discussed in this section are built into the Sui framework in modules [`table`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/table.move) and [`bag`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/bag.move). As with dynamic fields, there is also an `object_` variant of both: `ObjectTable` in [`object_table`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/object_table.move) and `ObjectBag` in [`object_bag`](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources/object_bag.move). The relationship between `Table` and `ObjectTable`, and `Bag` and `ObjectBag` is the same as between a field and an object field: The former can hold any `store` type as a value, but objects stored as values are hidden when viewed from external storage. The latter can only store objects as values, but keeps those objects visible at their ID in external storage.


## Tables

```move
module sui::table;

public struct Table<K: copy + drop + store, V: store> has key, store { /* ... */ }

public fun new<K: copy + drop + store, V: store>(
    ctx: &mut TxContext,
): Table<K, V>;
```

`Table<K, V>` is a *homogeneous* map, meaning that all its keys have the same type as each other (`K`), and all its values have the same type as each other as well (`V`). It is created with `sui::table::new`, which requires access to a `&mut TxContext` because `Table`s are objects themselves, which can be transferred, shared, wrapped, or unwrapped, just like any other object.

See `sui::object_table::ObjectTable` for the object-preserving version of `Table`.

## Bags

```move
module sui::bag;

public struct Bag has key, store { /* ... */ }

public fun new(ctx: &mut TxContext): Bag;
```

`Bag` is a heterogeneous map, so it can hold key-value pairs of arbitrary types (they do not need to match each other). The `Bag` type does not have any type parameters for this reason. Like `Table`, `Bag` is also an object, so creating one with `sui::bag::new` requires supplying a `&mut TxContext` to generate an ID.

See `sui::bag::ObjectBag` for the object-preserving version of `Bag`.

---

The following sections explain the collection APIs. They use `sui::table` as the basis for code examples, with explanations where other modules differ.

## Interacting with collections

All collection types come with the following functions, defined in their respective modules:

```move
module sui::table;

public fun add<K: copy + drop + store, V: store>(
    table: &mut Table<K, V>,
    k: K,
    v: V,
);

public fun borrow<K: copy + drop + store, V: store>(
    table: &Table<K, V>,
    k: K
): &V;

public fun borrow_mut<K: copy + drop + store, V: store>(
    table: &mut Table<K, V>,
    k: K
): &mut V;

public fun remove<K: copy + drop + store, V: store>(
    table: &mut Table<K, V>,
    k: K,
): V;
```

These functions add, read, write, and remove entries from the collection, respectively, and all accept keys by value. `Table` has type parameters for `K` and `V` so it is not possible to call these functions with different instantiations of `K` and `V` on the same instance of `Table`, however `Bag` does not have these type parameters, and so does permit calls with different instantiations on the same instance.

:::info

Like with dynamic fields, it is an error to attempt to overwrite an existing key, or access or remove a non-existent key.

:::

The extra flexibility of `Bag` heterogeneity means the type system does not statically prevent attempts to add a value with one type, and then borrow or remove it at another type. This pattern fails at runtime, similar to the behavior for dynamic fields.

## Querying length

It is possible to query all collection types for their length and check whether they are empty using the following family of functions:

```move
module sui::table;

public fun length<K: copy + drop + store, V: store>(
    table: &Table<K, V>,
): u64;

public fun is_empty<K: copy + drop + store, V: store>(
    table: &Table<K, V>
): bool;
```

`Bag` has these functions, but they are not generic on `K` and `V` because `Bag` does not have these type parameters.

## Querying for containment

Tables can be queried for key containment with:

```move
module sui::table;

public fun contains<K: copy + drop + store, V: store>(
    table: &Table<K, V>
    k: K
): bool;
```

The equivalent functions for `Bag` are:

```move
module sui::bag;

public fun contains<K: copy + drop + store>(bag: &Bag, k: K): bool;

public fun contains_with_type<K: copy + drop + store, V: store>(
    bag: &Bag,
    k: K
): bool;
```

The first function tests whether `bag` contains a key-value pair with key `k: K`, and the second function additionally tests whether its value has type `V`.

## Clean-up

Collection types protect against accidental deletion when they might not be empty. This protection comes from the fact that they do not have `drop`, so must be explicitly deleted, using this API:

```move
module sui::table;

public fun destroy_empty<K: copy + drop + store, V: store>(
    table: Table<K, V>,
);
```

This function takes the collection by value. If it contains no entries, it is deleted, otherwise the call fails. `sui::table::Table` also has a convenience function:

```move
module sui::table;

public fun drop<K: copy + drop + store, V: drop + store>(
    table: Table<K, V>,
);
```

You can call the convenience function only for tables where the value type also has `drop` ability, which allows it to delete tables whether they are empty or not.

Note that `drop` is not called implicitly on eligible tables before they go out of scope. It must be called explicitly, but it is guaranteed to succeed at runtime.

`Bag` and `ObjectBag` cannot support `drop` because they could be holding a variety of types, some of which might have `drop` and some which might not.

`ObjectTable` does not support `drop` because its values must be objects, which cannot be dropped (because they must contain an `id: UID` field and `UID` does not have `drop`).

## Equality

Equality on collections is based on identity, for example, an instance of a collection type is only considered equal to itself and not to all collections that hold the same entries:

```move
use sui::table;

let t1 = table::new<u64, u64>(ctx);
let t2 = table::new<u64, u64>(ctx);

assert!(&t1 == &t1, 0);
assert!(&t1 != &t2, 1);
```

This is unlikely to be the definition of equality that you want.

## Related links

<RelatedLink href="https://move-book.com/programmability/dynamic-collections.html" label="Dynamic Collections" desc="The Move Book is a comprehensive guide to the Move programming language and the Sui blockchain. This page explores using dynamic collections, including tables and bags, in your Move development." />
>>>> sui/docs/content/concepts/gaming.mdx
---
title: Gaming on Sui
description: Sui offers features like dynamic NFTs, kiosks, soulbound assets, and on-chain randomness, to provide builders with the tools to create immersive, transparent, and fair gaming experiences.
keywords: [ gaming, game components, game features, game nfts, soulbound assets, create games on sui, build games on sui, sui Object Display, game economics, kiosk, sui kiosk, token economics ]
---

Gaming on Sui leverages blockchain technology to enhance in-game economies, ownership, and interactions. With features like dynamic NFTs, kiosks, soulbound assets, and on-chain randomness, Sui provides builders with the tools to create immersive, transparent, and fair gaming experiences. Players benefit from true asset ownership, decentralized marketplaces, and seamless Web3 integration without compromising usability.

This topic explores the key features of Sui for gaming, real-world use cases, and essential tools for builders. Whether you're building an RPG, a racing game, or a digital card game, Sui provides the Web3 infrastructure to power your next-generation gaming projects.

## Representing in-game objects on chain

One of the aspects that defines a Web3 game is having objects within the game reside on a blockchain. Whether it's in-game currency, battle passes, skins, or any number of other objects, knowing how to create and integrate these items is the first step in building the desired user experience on Sui.

### In-game currencies

In-game currencies allow users to purchase game features like items, upgrades, and premium content. Before Web3, these currencies remained only in the game and their values were set by the game developers. 

Using Sui, players can now have true ownership of their in-game currency. The currency exists as a token on the Sui blockchain, where players can conceivably buy, sell, or swap that currency for anything else that also lives on chain. If you create an ecosystem of games, players can purchase currency in one of your games but spend it in another one that also uses that same currency. The possibilities are vast, but you must first learn how to create the currency. The following topics can get you started.

- [Currency Standard](/standards/currency.mdx)
- [In-Game Currency](/guides/developer/coin/in-game-token.mdx)

### Tokens

Similar to in-game currencies, tokens provide a level of engagement and control integrated into the game experience that isn't possible without Web3. For example, you can create tokens associated with your game that reward loyalty amongst your user base. You can also produce regulated tokens that allow the bearer of a specific capability to control the addresses that have access to the token, facilitating gated access to special events, leagues, or other game features. The following topics provide more insight into tokens on Sui.

- [Regulated Coin and Deny List](../guides/developer/coin/regulated.mdx)
- [Loyalty Tokens](../guides/developer/coin/loyalty.mdx)
- [Closed-Loop Token](../standards/closed-loop-token.mdx)

### Game features

NFTs are able to represent many traditional game features. For example, in-game objects, battle passes, rewards, skins, game cards or keys, and loot boxes are just a few of the features that you can create using NFTs on Sui. The following topics and sections provide more details.

- [Create a Non-Fungible Token](../guides/developer/nft.mdx)
- [Soulbound assets](#soulbound-assets)
- [Game economies](#game-economies)
- [Sui Object Display](#sui-object-display) 

### Dynamic assets {#dynamic-assets}

On Sui, everything is an object and all objects are NFTs. For the purpose of the gaming discussion, you can also think of these NFTs as game assets. 

You can view an object on Sui as a key-value pair data structure. In Move, the smart contract language of Sui, objects are defined as a `struct`. As an example, consider the game board of a tic-tac-toe game: 

<ImportContent source="examples/tic-tac-toe/move/sources/owned.move" mode="code" struct="Game" noComments />

The first key-value pair for any object is `id: address`, which is a unique value of type `UID`. Every object has a different address, which is why every object is an NFT because this mandatory key-value pair sets each object apart and makes it unique.

#### Creating assets

Smart contracts contain the functions that create objects. Using the previous example, the function (`new`) that creates the object represented (a digital tic-tac-toe gameboard) provides the values for each attribute. The Sui framework creates the UID that uniquely identifies this particular game.

<ImportContent source="examples/tic-tac-toe/move/sources/owned.move" mode="code" fun="new" noComments />

This is an on-chain action, or transaction. In this case, the transaction is a request to the chain to create an object. You provide the necessary data to the function and pay the gas fee for the computation effort of the network validators. The result is the creation of a new NFT that exists on the Sui blockchain at the address (`id`).

#### Updating assets

On Sui, you can update an NFT asset using a separate transaction, provided the smart contract that defines the NFT allows it. Similar to creation, you provide data to the relevant update function and pay the gas fee, and the smart contract updates the object at the correct address with the new information. 

Using the tic-tac-toe example, you might instruct the smart contract to update the gameboard object to place an `x` on an available square. Because the computation effort required for most updates is less than the effort to create the original object, the resulting gas fees are typically less, as well.

For more information on the computation of gas fees, see [Sui Gas Pricing](./tokenomics/gas-pricing.mdx).

#### Composing assets

On Sui, you can include one object inside of another (dynamic fields). For example, an object named `Parent` might contain objects of type `Child`. The smart contract can provide the necessary functions to add and remove the child objects from their parents. 

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" struct="Parent"/>

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" struct="Child"/>

The function to add child objects to a parent might resemble the following. In this case, `ofield` is an alias for the `sui::dynamic_object_field` package.

<ImportContent source="examples/move/dynamic_fields/sources/example.move" mode="code" fun="add_child"/>

You can apply dynamic fields to many use cases. An object named `TicketBooth`, for example, could contain objects of type `ConcertTicket`. An object of type `Car` might have a field named `is_functioning` that is `false` until all necessary objects (`Engine`, `Tires`, `Body`, `Wheel`) are present, at which point it can automatically update its `is_functioning` field to `true`.

Composability is a really important feature of Sui. While it provides many options when developing an idea on Sui, it also allows building on top of existing projects, using third-party assets in your project. This can range from â€œ*Only users who own a particular NFT are eligible for a discount*â€ to full collaboration between two distinct projects and everything in between on the smart contract level.

#### Transfer to object

Sui enables more use cases with the transfer to object feature, which allows an owned object to be sent to another object (shared or owned). In this case, the sent object appears as owned by the parent object. In the above examples, the objects are wrapped inside other objects and this can be seen in the parent object's metadata when inspecting the parent object.

When an object is sent to another object, the metadata of the parent object remain the same, but its `id` has a new object. This feature can enable use cases such as on-chain wallets where a `Wallet` object is used to deposit other objects. Combining this with transfer to object can lead to complex and exciting use cases.

See [Transfer to Object](./transfers/transfer-to-object.mdx) for more details on how to effectively transfer objects to other objects on Sui.

#### Deleting assets

On Sui, you can delete an object if the smart contract allows the operation. If the correct smart contract function is present, then you can delete the object in a single transaction. This results in a gas-fee rebate, which happens whenever bytes are freed on chain. The transaction's gas payer receives a rebate to account for the future storage of the object no longer being necessary but having already been paid for. See the [Storage fund](./tokenomics#storage-fund) section in Tokenomics to learn more about rebates. 

### Soulbound assets {#soulbound-assets}

A soulbound asset is an NFT that belongs to an address and cannot be transferred or deleted. On Sui, assets are usually freely transferable between addresses, but this is undesirable behavior in some cases.

Assets such as game season passes, loyalty accrual assets, avatars, identification assets for a product, and assets that grant certain privileges at the smart contract level are well-suited to be bound to an address without the option of transfer or deletion.

On Sui, it is straightforward to implement such an asset, and the infrastructure guarantees that the desired behavior always holds.

You define an NFT asset as soulbound at the contract level. After designated as soulbound, it cannot be converted to a normal transferable asset. Changing it would require creating a new asset with the same name and a migration strategy, such as deleting the soulbound asset and creating a normal one to take its place.

Soulbound assets are created by omitting the `store` ability. Without this ability, you cannot store soulbound assets inside other objects. Keep this behavior in mind when deciding the asset type. This means that Soulbound assets are not fully composable; they can store other assets but cannot be stored inside other assets.

The same pattern can be used to implement NFT assets that are transferable/burnable only under certain circumstances. You can define these circumstances at the smart contract level by making the asset soulbound and defining custom transfer and burn functions.

### Sui Object Display {#sui-object-display}

The Sui Object Display standard is a tool that helps define how objects appear in apps and interfaces. It works like a template where you can insert data from an object to control how it's displayed. Use it to manage how different types of data are shown, even if the data itself is stored on chain while the display happens off-chain (in apps or websites).

The Sui Object Display standard provides several key benefits and components:

- Controlled representation: Manages how assets are displayed online without directly interacting with the underlying asset. You can make updates to the display independent of the assets and affect how all assets of type `<T>` are displayed.
- Flexibility: No limits on the fields you can customize.
- Enhancing asset information: Similar to enhancing ERC721 or ERC1155 NFTs with extra details, the Sui Object Display allows you to add specific details to your digital items, such as names, descriptions, images, and more.
- Stored data and off-chain representation: Manages stored data based on metadata standards and controls how it's represented off-chain.
- Dynamic display: Ensures a uniform presentation of shared attributes across all NFTs of type `<T>`, maintaining a consistent representation of common fields (such as image URLs derived from unique IDs) and a cohesive display format across the asset collection.

There are a few limitations to be aware of. First, the current structure of Sui Object Display is per type, limiting its scope. Secondly, its structure does not allow for nested attributes or enums.

#### Implementation overview

At a high level, you implement this feature using the following steps:

1. Use a `Publisher` object you own to set `sui::display` for a specific type.
2. Sui Move's `Display<T>` defines how different types look. For example, `Display<0x2::capy::Capy>` shapes the appearance of a type.
3. Sui Full nodes use Display definitions to organize data when requested with `{ showDisplay: true }` in queries.

A display is a map of keys and values, both strings. Values allow for string interpolation, meaning the value changes dynamically depending on the NFT being viewed.

A basic example is to create a `Display` for `Asset` objects:

```move
public struct Asset has key, store {
  id: "0x3301",
  expiration: 123456789
}

public struct Display has store {
  "random_field": "The ID is {id} and it expires at {expiration}"
}
```

The above `Display` as is defined, for the example `Asset` will become:

```jsx
Display
{
  "random_field": "The ID is 0x3301 and it expires at 123456789"
}
```

For another Asset, the `id` and `expiration` values change according to the new `Asset`s values.

An app can use the `Display` object, where any custom keys can be understood. By default, most third-party apps like explorers or wallets recognize the attributes described below.

- `name`: A name for the object, displayed when users view the object.
- `description`: A description for the object, displayed when users view the object.
- `link`: A link to the object for use in an application.
- `image_url`: A URL or a blob with the image for the object.
- `thumbnail_url`: A URL to a smaller image for use in wallets, explorers, and other products as a preview.
- `project_url`: A link to a website associated with the object or creator.
- `creator`: A string indicating the object creator.


See [Sui Object Display](../standards/display) for more details on the standard.
 
## Game economies

Designing and managing tokens and coins on the Sui blockchain is crucial to creating a viable game economy. 

### GameFi

GameFi (Gaming Finance) combines gaming with blockchain-based financial incentives. It provides players with economic benefits through token rewards for in-game achievements. The recent rise of GameFi has led to significant growth in token launches to support gaming ecosystems.

The terms that follow are frequently used when discussing GameFi, so it's important to make sure your definition of the terms match the documentation.

- Token generation event (TGE): The first creation and distribution of tokens.
- Initial coin offering (ICO): An early fundraising model using token sales.
- Vesting: The gradual release of tokens over time.
- Staking: Locking tokens to participate in network operations and earn rewards.
- Cliff: An initial waiting period before token vesting begins.
- Annual percentage yield (APY): The effective return on a staked asset over a year.
- Decentralized autonomous organization (DAO): A governance model where decisions are made using smart contracts and tokens.
- Governance token: A token granting voting power in decentralized networks.

### Token economics (Tokenomics)

Tokenomics refers to the model and design of the rules that govern tokens for a Web3 ecosystem. In the case of GameFi, it defines how a token is created, distributed, utilized, and maintained within your gaming platform. Some of the features that comprise a token's economics include supply details, distribution mechanisms, staking and vesting.

There are several types of token supply that are considered when discussing tokenomics for an on-chain ecosystem.

| Supply type | Description |
| --- | --- |
| Total supply | Maximum number of tokens that will ever exist. |
| Circulating supply | Tokens currently in use and available for trading. |
| Adjusted supply | Tokens adjusted after burning or minting events. |
| Fixed supply | A predetermined number of tokens with no future changes. |

There is more than one type of distribution mechanics, but they are not necessarily all used.

| Distribution mechanisms | Description |
| --- | --- |
| Initial distribution | Through ICO, TGE, airdrops, or private sales. |
| Ongoing distribution | Through staking, liquidity mining, or incentive programs. |

Ongoing distribution refers to staking and vesting of GameFi tokens. Not all game economies include staking or vesting models. When deciding whether yours should, consider the benefits:

- Encourages long-term participation.
- Reduces circulating supply, potentially stabilizing token prices.
- Rewards active participants in the ecosystem.
- Rewards team members over the course of their involvement. 

To learn more about token vesting strategies, see [Token Vesting Strategies](./tokenomics/vesting-strategies.mdx).

When deciding how best to launch your tokens, it's important to consider some key points:

- Should you go with a fixed or adjusted supply of coins? A fixed supply means all tokens mint at the TGE. Adjusted supply requires careful control over minting and burning functions.
- Does your token need to be regulated? A regulated coin provides greater control over who has access to your token but comes at the cost of additional maintenance of a deny list. You can learn more about regulated tokens at [Regulated Coin and Deny List](../guides/developer/coin/regulated.mdx).
- Consider your metadata requirements, as well.
    - Decimal places: Predefine precision of the token.
    - Metadata management: Determine if metadata should be immutable.
    - Burning mechanisms: Define rules for token burning.

### Kiosk

On Sui, owned objects are either freely transferable or non-transferable. To ensure royalties, Sui provides a standard called Kiosk. A kiosk is a shared object that restricts access to a single address or user. See [Sui Kiosk](../standards/kiosk.mdx) for an in-depth look at the Kiosk standard. 

The kiosk owner (although a shared object has no owner from the perspective of Sui, the smart contract ensures that only one address is permitted to access it) is allowed to:

- Place assets from their address inside the Kiosk.
- Take assets from the Kiosk back to their address.
- Lock assets from their address or already placed inside the Kiosk, making the â€œtakeâ€ operation impossible.
- Destroy a Kiosk that has no assets inside.
- List an asset for sale with a price denoted in SUI.
- List an asset for sale only to a specific address, with the price denoted in SUI.

Any other address is allowed to:

- Buy an item that has undergone the â€œlistâ€ operation.
- Buy an item meant for a specific address if the asset was â€œlistedâ€ in such a way.

The adoption of Kiosks implies that marketplaces become aggregators of â€œlistedâ€ items inside different Kiosks.

An Asset that has undergone the â€œlockâ€ operation cannot undergo the â€œtakeâ€ operation anymore; it can only undergo the â€œlistâ€ operation.

### Transfer policy

The â€œbuyâ€ operation requires the use of another object called transfer policy. This is usually a shared object and contains rules that govern the â€œbuyâ€ operation, the most common rule being â€œRoyalties.â€

A â€œbuyâ€ operation cannot be completed for an Asset without a defined transfer policy.

An empty transfer policy, one that does not have rules, means that the asset is freely tradable. Since Kiosk only allows the â€œlistâ€ and â€œbuyâ€ pair of operations, a transfer is possible by setting the price to 0 SUI.

Rules can be anything programmable with Move. To use marketplaces, an Asset creator should use rules defined in https://github.com/MystenLabs/apps/tree/main/kiosk/sources/rules

Common rules include:

- **Royalty rule:** A percentage of the price that goes to the asset creator (practically it goes inside the transfer policy and the creator may transfer it at any point in time).
- **Floor price rule:** A minimum price that an Asset may be â€œlistedâ€ for.
- **Lock rule:** Enforce the asset to be locked inside a Kiosk after a â€œbuyâ€ operation.

The combination of the lock rule and the royalty rule enforces royalties to be paid to the creator. The lock rule ensures an asset cannot be â€œtakenâ€ out of a Kiosk (to be freely traded), while the royalty rule ensures that any asset traded through Kiosk will have royalties deducted from the transaction.

Adding the lock rule is recommended when royalties are a strict requirement. As long as marketplaces support only Kiosk on Sui, even without the lock rule, users may not have other options. It is safe to assume that peer-to-peer trading is unsafe, and most, if not all, users will avoid it since there is no way to ensure the transaction will take place smoothly. In peer-to-peer transactions, someone has to initiate either the asset transfer or the payment transfer, and there are no guarantees that the follow-up will take place.

The most important thing is during the initial airdrop or minting of the asset to ensure the asset is put inside a Kiosk and not sent to an address directly.

## Tools

There are a number of tools available in the Sui ecosystem to help you realize your Sui game vision.

<Tabs>

<TabItem label="Playtron GameOS" value="playtron-os" >

Playtron GameOS is a Linux-based operating system that seeks to turn PCs, handhelds, and desktops into dedicated gaming consoles. It supports multiple game stores like Steam and Epic Games, offering a seamless gaming experience across devices such as Steam Deck, ROG Ally, and Lenovo Legion Go. 

https://www.playtron.one/playtron-os 

</TabItem>

<TabItem label="E4C: Ludus" value="ludus" >

E4C: Ludus is a cross-platform gaming layer designed to unify Web2 and Web3 gaming experiences on a single platform. Leveraging the Sui blockchain, it offers developers access to dynamic NFTs and zkLogin, facilitating integration of blockchain features into games across various platforms. The native E4C token is its primary currency, enabling in-game purchases and transactions. E4C: Ludus also provides a unified frontend for players to access a range of games, with the aim to enhance user engagement and simplify the gaming experience. The platform is set to launch globally in 2025, with a demo currently available for users to explore. 

https://ludus.ambrus.studio/ 

</TabItem>

<TabItem label="Sui Coins" value="suicoins" >

Sui Coins is the utility layer for tokens and NFTs on the Sui network, offering asset management tools that include token swaps, automated dollar-cost averaging, airdrops, an incinerator for deleting assets, zkSend for private transfers, and a merger tool to consolidate small balances. Sui Coins also features an open source SuiCoins Terminal for integrating crypto swaps across platforms.

https://www.suicoins.com/ 
https://terminal.suicoins.com/

</TabItem>

<TabItem label="Beamable" value="beamable" >

Beamable is a development platform that helps you integrate live services and backend features into your games. It offers SDKs for both Unity and Unreal Engine, facilitating development and deployment of online game functionalities. You can incorporate features such as player authentication, inventory management, and microservices within the environments of your chosen game engines. Beamable provides support for the Sui blockchain, allowing for the integration of Web3 elements like NFTs and on-chain assets into games. The Beamable SDKs offer tools and sample projects to help you build on the Sui network.

https://beamable.com/ 

</TabItem>

<TabItem label="Forge.gg" value="forge" >

Forge is a platform that enables game developers to create custom loyalty programs, rewarding players for engaging in community activities and in-game challenges. Players earn loyalty points by completing actions you define, which can be redeemed for in-game items and digital content. Forge also offers analytics tools to help developers understand their audience and improve monetization strategies.

https://forge.gg/
</TabItem>

<TabItem label="Snag Solutions" value="snagsolutions" >

Snag Solutions provides white-label loyalty and marketplace platforms to enhance community engagement and control your digital ecosystems. Their solutions enable you to track and reward user contributions, create customizable marketplaces, and integrate social features like peer-to-peer trading and user profiles. Snag Solutions offers customization options, APIs, and SDKs to align with your brand's identity.

https://www.snagsolutions.io/ 

</TabItem>

<TabItem label="Venly" value="venly" >

Venly is a developer platform that aids blockchain integration for businesses through secure digital wallets, tokenization services, and payment solutions. It offers APIs and SDKs for management of digital assets. Venly enables you to create, trade, and manage NFTs, tokens, and payments securely while maintaining full ownership of your assets.

https://www.venly.io/ 

</TabItem>

</Tabs>

<!---- 

## Videos

Cycle through the available videos using the thumbnails, then tap or click the video to play.

<YTCarousel ids={["qnnXCO5cXu4","h-csO8Z9g3o","uwtF8jFXX1U","OBNbxqoLPiw","udzx0vXEpjc","6mjj3isfrs0","K2ufEN6zzpM","P70R_p0xQEg","e4FWIupRehA"]}/>
--->

## Example integrations

There aren't real-world implementations for the integrations described in this section. These examples are meant to be a thought exercise to showcase the possibilities for viable game integration on the Sui network. 

<Tabs>

<TabItem label="ShadowQuest" value="shadowquest">

ShadowQuest is a multiplayer game that combines fantasy with RPG battle mechanics. To enhance the gaming experience with Web3 technologies, ShadowQuest is integrating with Sui offering seamless blockchain interactions to players without compromising the overall gaming experience.

**Seamless player onboarding and wallet integration**
    
ShadowQuest wants to onboard players without adding complexity, especially those unfamiliar with Web3. By using [zkLogin](../concepts/cryptography/zklogin.mdx), users can sign in using social platforms like Google, Facebook, Twitch, and Apple. This automatically creates a Sui wallet linked to their ShadowQuest account, making blockchain interactions seamless.
    
**Simplified transaction handling**
    
Players in ShadowQuest earn or use in-game assets such as NFTs or $SHADOW tokens. To attract users unfamiliar with Web3, ShadowQuest manages game transactions to avoid Web3 friction, like wallets popping up for signing transactions. By sponsoring user transactions, the friction is minimized because ShadowQuest users do not directly pay for transaction costs and gas fees.
    
Enoki transactions can be signed without requiring confirmation from the user to approve the transaction.
    
ShadowQuest uses Enoki Gas Pool to sponsor transactions, covering gas fees for players. This ensures all in-game transactions are seamless and cost-free for players, providing a better user experience.
    
**NFT marketplace and royalty enforcement**
    
ShadowQuest allows players to buy, sell, or trade in-game items, such as weapons, armor, and cosmetics. The items should respect royalties to ensure that creators benefit from each transaction.
    
Kiosk provides a decentralized marketplace solution, ensuring royalties are enforced on all NFT trades. This helps both the game developers and creators maintain control over secondary sales, ensuring revenue generation throughout the asset's lifecycle.
    
**NFT usage for game access**
    
ShadowQuest uses NFTs as entry tickets for different game modes and events. Players can acquire or earn various Runes, which grant access to specific game challenges or seasonal competitions. These NFTs cannot be traded or transferred to other players.
    
Soulbound NFTs represent different Runes that are either earned through gameplay or purchased. These NFTs grant exclusive access to matches and seasonal challenges but cannot be traded after bound to a player.

</TabItem>

<TabItem label="Sui for Speed" value="sui-for-speed">

Sui for Speed is a racing game set in the Sui ecosystem. Players pilot customizable vehicles through fantastical terrains, competing in races, time trials, and exploration challenges. By integrating with the Sui network's blockchain technologyâ€”including features such as Walrus, dynamic NFTs, SuiNS, and asset tokenizationâ€”the game offers players true ownership of their vehicles and in-game assets, along with a vibrant, player-driven economy.

**Customizable vehicles with dynamic NFTs**

In Sui for Speed, players own racing vehicles represented by dynamic NFTs that you can upgrade and customize with new parts, skins, and abilities. As players progress and win races, their vehicles evolve, reflecting their achievements and style.

Dynamic NFTs on the Sui network allow vehicles to securely update attributes and metadata over time. Every upgrade and customization is recorded on-chain, ensuring each vehicle's uniqueness and authenticity.

**SuiNS: Personalized racer profiles and teams**

Players can register unique names for their racer profiles and teams using SuiNS, like speedster@suiforspeed.sui or dragonracer@suiforspeed.sui. This simplifies social interactions, team coordination, and improves the community aspect of the game.

SuiNS provides a decentralized domain naming system, allowing memorable and personalized names on the blockchain.

**Tokenized circuits and earnings from circuit usage**

Race circuits are tokenized as unique NFTs allowing players to own, design, and vote to enable track customization and drive better changes. When other players race on these circuits, the owners earn $RALLY tokens as usage fees or royalties. This system incentivizes creativity and allows players to monetize their track designs.

Asset tokenization on the Sui network enables minting of circuits as unique assets with secure ownership. Smart contracts automatically distribute earnings to circuit owners when their tracks are used, enhancing the game's economy through player-driven content.

**Decentralized storage for game data**

The game world includes extensive data such as track designs and leaderboards. Leveraging decentralized and efficient storage, combined with asset tokenization, enables true decentralization of these terrains and models.

Walrus offers scalable off-chain storage for large amounts of game data. This ensures high availability and security, protecting against data loss and enhancing player trust.

**Competitive events and betting mechanisms**

The game hosts regular competitive events and tournaments where players can participate individually or as teams. Additionally, players can place bets on race outcomes using $RALLY tokens, adding an extra layer of excitement and engagement.

On-chain logic enables secure and transparent management of events and betting systems. The Sui network ensures fairness, with immutable records of bets and outcomes.

</TabItem>

<TabItem label="ArcaneBattles" value="arcanebattles">

ArcaneBattles is a strategic, multiplayer card game inspired by classics like Hearthstone. Players collect, trade, and battle with a variety of magical cards representing spells, creatures, and heroes. By integrating with the Sui blockchain, ArcaneBattles aims to enrich the gameplay experience through decentralized features that promote true ownership, fairness, and a dynamic in-game economy.

**Dynamic in-game economy with two closed loop tokens**

ArcaneBattles implemented two stable in-game currencies to facilitate various transactions, enhancing player engagement and economic depth.

**Closed loop token (CLT)**
    
ArcaneBattles utilizes two Closed Loop Tokens within its ecosystem:

1. Arcane Gems: The primary in-game currency used to purchase card packs and enter tournaments. Players earn Arcane Gems through gameplay achievements, daily quests, and participating in events. This token ensures that all players have access to essential game features without exposure to external market volatility.
2. Mystic Dust: A secondary token obtained by discarding unwanted cards. Mystic Dust is used to craft new cards and upgrade existing ones to gold versions, which have enhanced visuals and possibly minor gameplay benefits. This mirrors the crafting system in games like Hearthstone, allowing players to strategically manage their collections and customize their decks.

The dual-token system adds depth to the in-game economy, encouraging players to engage in various activities and make strategic decisions about resource allocation.

**True ownership and NFT card rental**

ArcaneBattles allows players to own their cards as NFTs and provide a rental marketplace for rare or powerful cards.
    
Each card in ArcaneBattles is represented as an NFT on the Sui blockchain, granting players true ownership of their digital assets. The NFT Rental feature allows players to rent out their rare or high-level cards to others for a fee. This creates a community-driven economy where new or casual players can access powerful cards temporarily, while owners earn passive income from their collections.

**Fair and unpredictable gameplay**

ArcaneBattles ensures randomness in card draws and in-game events to prevent manipulation and enhance fairness.
    
By leveraging Sui's on-chain randomness, ArcaneBattles introduces unpredictable elements such as random card draws, critical hit chances, and random effects from certain cards. This randomness is verifiable and secure, preventing manipulation by any party and maintaining fairness across all gameplay aspects.
    
**Enhanced card visualization and dynamic wear mechanism**

ArcaneBattles provides rich, dynamic displays of card information and introduces a wear-and-tear mechanic to simulate card degradation over time.
    
ArcaneBattles uses Sui's Display Standard to offer detailed metadata for each card NFT, including stats, abilities, and artwork. Beyond static information, the game introduces a dynamic display mechanism where cards visually show signs of wear as they are used in battles. Over time, frequently used cards may appear scratched, faded, or have other visual cues indicating wear. After extensive use, cards have a chance to be destroyed entirely.

This wear-and-tear mechanic simulates the experience of physical card games, where rare cards are often kept in pristine condition and used sparingly. It encourages players to strategically decide when to use their valuable cards and adds a layer of depth to the game's economy and strategy.

Players can mitigate or repair wear on their cards by using **Mystic Dust** to restore them or upgrade them to gold versions, which are more durable and feature enhanced visuals. This system adds a strategic resource management element, as players must balance the benefits of using powerful cards against the potential cost of their degradation.

By integrating these Sui blockchain features, ArcaneBattles not only enhances the gaming experience but also pioneers the next generation of digital card games. The dual-token economy adds complexity and depth to in-game transactions, encouraging strategic decision-making. The wear-and-tear mechanic introduces a novel layer of strategy and realism, as players must consider the longevity of their cards. Together, these features create a rich, engaging, and immersive experience that leverages the full potential of blockchain technology within a gaming context.

</TabItem>

</Tabs>

## Related links

<RelatedLink to="/standards/currency.mdx" />
<RelatedLink to="/guides/developer/currency.mdx" />
<RelatedLink to="/guides/developer/nft.mdx" />
<RelatedLink to="/guides/developer/nft/asset-tokenization.mdx" />
<RelatedLink to="/guides/developer/nft/nft-rental.mdx" />
<RelatedLink to="/standards/kiosk.mdx" />
<RelatedLink to="/standards/kiosk-apps.mdx" />
<RelatedLink to="/concepts/cryptography/zklogin.mdx" />
<RelatedLink href="https://blog.sui.io/tag/gaming/" label="Sui Foundation blog" desc="Blog posts from the Sui Foundation with the `gaming` tag." />
<RelatedLink to="/guides/developer/app-examples/coin-flip.mdx" />
<RelatedLink to="/guides/developer/app-examples/blackjack.mdx" />
<RelatedLink to="/guides/developer/app-examples/plinko.mdx" />
<RelatedLink href="https://github.com/MystenLabs/mysticon-legends" label="Mysticon Legends" desc="GitHub repo for a blockchain-based game where players collect, train, and battle with mythical creatures called Mysticons." />
<RelatedLink href="https://mini-games.sui.io/" label="Web3 Mini Games built on Sui" desc="A collection of mini games, to inspire the community of Sui." />

>>>> sui/docs/content/concepts/graphql-indexer.mdx
---
title: GraphQL and General-Purpose Indexer (Beta)
description: The GraphQL RPC Beta service offers a structured way for your clients to interact with data on the Sui blockchain. It accesses data processed by a general-purpose indexer and can connect to an archival store for historical network state.
beta: devnet, testnet, mainnet
keywords: [ indexer, archival store, graphql, custom indexer ]
---

<ImportContent source="indexer-graphql.mdx" mode="snippet" />

## Key components

The key components of the stack include the following:

- **General-purpose Indexer:** Ingests and transforms Sui checkpoint data using configurable and parallel pipelines, and writes it into a Postgres-compatible database. Can be configured to use the Sui remote checkpoint store and a full node as its sources.
- **Postgres-compatible database:** Stores indexed data for GraphQL queries. Tested using [GCP AlloyDB](https://cloud.google.com/products/alloydb), but you can run any Postgres-compatible database. You're encouraged to test alternative databases and share feedback on performance, cost, and operational characteristics.
- **GraphQL service:** Serves structured queries over indexed data. Follows the [GraphQL specification](https://graphql.org/) and the supported schema is documented in the [GraphQL API reference](/references/sui-graphql). Also take a look at the [getting started guide](/guides/developer/advanced/graphql-rpc).
- **Archival Service:** Enables point lookups for historical data from a key-value store. If unavailable, the GraphQL service falls back to the Postgres-compatible database for lookups, which might be limited by that database's retention policy. See [Archival Store and Service](./archival-store.mdx) for more information.
- **Consistent Store:** Answers questions about the latest state of the network within the last hour (objects owned by addresses, objects by type, balances by address and type). Consistency is guaranteed by pinning queries to a specific (recent) checkpoint.
- **Full node:** Enables transaction execution and simulation. Currently, JSON-RPC is used but there will be a switch to [gRPC](/concepts/grpc-overview) soon as the long-term full node API in the future.

## When to use GraphQL 

Use [GraphQL](/concepts/graphql-rpc) if your application:

- Requires historical (with configurable retention) or filtered access to data (e.g., all transactions sent by an address)
- Needs to display structured results in a frontend (e.g., wallets, dashboards)
- Benefits from flexible, composable queries that reduce overfetching
- Relies on multiple data entities (e.g., transactions + objects + events) in a single request, or in a consistent fashion when spread over multiple requests (as if the responses came from a snapshot at some checkpoint).

## Deployment options

You can run or use the GraphQL and Indexer data stack in the following configurations:

### Fully managed service

As a developer, you can access GraphQL as a service from an indexer operator or data provider who runs and operates the full stack behind the scenes. Reach out to your data provider and ask if they already offer or plan to offer this service.

### Partial self-managed

As a developer, you can:

- Run the Indexer pipelines and GraphQL service, while using the Archival Service and a full node from an RPC provider or indexer operator.
- Configure and manage a Postgres-compatible database (local Postgres, AlloyDB, and so on) as the primary data store.
- Deploy the self-managed components on cloud infrastructure or baremetal.

:::info

You cannot run and operate the GraphQL service in self-managed configurations just yet. The functionality will become available after required changes are made to how the GraphQL service integrates with the Archival Service.

:::

### Fully self-managed

As a developer, indexer operator, or RPC provider, you can:

- Run the complete stack: Indexer pipelines, GraphQL service, Postgres-compatible database, Archival Service, Consistent Store and full node on cloud infrastructure or bare metal.
- Serve GraphQL to your own applications or to other builders and third-party services.

Refer to [For RPC providers and Data operators](#for-rpc-providers-and-data-operators) for relevant information.

## Working with the GraphQL service

The GraphQL service exposes a query surface conforming to [GraphQL concepts](/concepts/graphql-rpc). It allows pagination, filtering, and consistent snapshot queries. The service also supports runtime configuration for schema, query cost limits, and logging.

The GraphQL schema is defined in the [GraphQL reference](/references/sui-graphql). You can explore supported types and fields there, use the GraphiQL IDE to test queries, and read documentation on the up-to-date schema.

The GraphQL service is deployed as a single binary implementing a stateless, horizontally scalable service. Queries are served with data from one or more of a Postgres-compatible database (filters over historical data), Archival Service (point lookups), Consistent Store (live data), or full node (execution and simulation), based on need. Access to these stores must be configured with the service on start-up, otherwise the service might fail to respond correctly to requests. More details on how to set-up, configure, and run the service is available in its [README](https://github.com/MystenLabs/sui/tree/main/crates/sui-indexer-alt-graphql).

Requests to GraphQL are subject to various limits, to ensure resources are shared fairly between clients. Each limit is configurable, and the values configured for an instance can be queried through [`Query.serviceConfig`](/references/sui-api/sui-graphql/beta/reference/operations/queries/service-config). Requests that do not meet limits return with an error. The following limits are in effect:

- **Request size:** Requests may not limit a certain size in bytes. The limit is spread across a transaction payload limit, which applies to all values and variable bindings that are parameters to transaction signing, execution, and simulation fields (default: 175KB), and a query payload limit which applies to all other parts of the query (default: 5KB).
- **Request timeout:** Time spent on each request is bounded, with different bounds for execution (default: 74s) and regular reads (default: 40s).
- **Query input nodes and depth:** The query cannot be too complex, meaning it cannot contain too many input nodes or field names (default: 300) or be too deeply nested (default: 20).
- **Output nodes:** The service estimates the maximum number of output nodes the query might produce, assuming every requested field is present, every paginated field returns full pages, and every multi-get finds all requested keys. This estimate must be bounded (default: 1,000,000).
- **Page and multi-get size:** Each paginated field (default: 50) and multi-get (default: 200) is subject to a maximum size. Certain paginated fields might override this to provide a higher or lower maximum.
- **(TBD) Rich queries:** A request can contain only a bounded number (default: 5) of queries that require dedicated access to the database (cannot be grouped with other requests).

## Working with General-purpose Indexer

General-purpose indexer fetches checkpoints data from either a remote object store, local files, or a full node RPC, and indexes data into multiple database tables via a set of specialized pipelines. Each pipeline is responsible for extracting specific data and writing to its target tables.

<details>
<summary>
Full list of tables and their schemas
</summary>
<ImportContent source="crates/sui-indexer-alt-schema/src/schema.rs" mode="code" />
</details>

Below are brief descriptions of the various categories of pipelines based on the type of data they handle:

### Blockchain raw content pipelines

**Tables:** 

- `kv_checkpoints`
- `kv_transactions`
- `kv_objects`
- `kv_packages` 

These pipelines capture the core blockchain data in its raw form, preserving complete checkpoint information, full transaction and objects contents, and Move package bytecode and metadata. They ensure the complete blockchain state is available for direct lookup by key (for example, object ID and version, transaction digest, checkpoint sequence number). Some production deployments use the Archival Store for looking up checkpoints, transactions, and objects contents instead of the corresponding `kv_` tables.

The following pipelines create indexed views that allow efficient filtering and querying based on different attributes (for example, object owner, transaction type, affected addresses, event type). These indexes help identify the keys of interest, which can then fetch detailed content from the raw content `kv_` tables:

### Transaction pipelines

**Tables** 

- `tx_digests`
- `tx_kinds`
- `tx_calls`
- `tx_affected_addresses`
- `tx_affected_objects`
- `tx_balance_changes`

These pipelines extract and index key transaction attributes to support efficient filtering and querying. `tx_kinds`, `tx_calls`, `tx_affected_addresses`, and `tx_affected_objects` enable fast lookups of transactions based on types, function calls, sender and receiver addresses, and changed objects. `tx_digests` enable conversions between transaction sequence numbers and transaction digests needed for looking up transactions in `kv_` tables by digests and `tx_balance_changes` stores balance changes information of each transaction.

### Object pipelines

**Tables**

- `obj_info`
- `obj_versions`
- `coin_balance_buckets`

These pipelines manage current and historical object information. They store active object metadata, maintain version histories for each object, and categorize coin balances into buckets for efficient coin queries sorted by balances. `obj_versions` table is particularly important for the GraphQL service. It tracks the version history of all blockchain objects, storing object ID, version number, digest, and checkpoint sequence number. The GraphQL service uses this table as an efficient index to resolve object queries by version bounds, checkpoint bounds, or exact versions without loading full object data, enabling features like version pagination and temporal consistency.

Pruning policies can be configured for `obj_info` and `coin_balance_buckets` to retain historical data within a specified time range, balancing query needs with storage management. This allows supporting use cases that require querying recent object history without retaining all historical data indefinitely.

### Epoch information pipelines

**Tables**

- `kv_epoch_starts`
- `kv_epoch_ends`
- `kv_feature_flags`
- `kv_protocol_configs`

These pipelines capture protocol upgrades and epoch transition points. They track the system state, reward distribution, validator committee and protocol configurations of each epoch, providing a historical record of network evolution.

### Event processing pipelines

**Tables**

- `ev_emit_mod`
- `ev_struct_inst`

These pipelines index blockchain events for efficient querying by sender, emitting module, or event type.

### Utility and support pipelines

**Tables**

- `cp_sequence_numbers`
- `watermarks`

These pipelines provide support infrastructure, such as checkpoint sequence number tracking for pruning and watermark tracking for ensuring consistent reads across different tables in a GraphQL query.

### Other pipelines

**Tables**

- `sum_displays` 

`sum_displays` tables stores the latest version of the `Display` object for each object type, used for rendering [the off-chain representation (display) for a type](/standards/display).

### Indexer pipeline architecture and deployment

General-purpose indexer is built using the Indexer framework, where each pipeline is structured as a set of layered components that interact with each other. Each layer has a distinct role in the data processing flow:

- **Ingestion layer:** Fetches checkpoint data and distributes it to pipelines with back pressure management.
- **Process layer:** Transforms checkpoint data into structured records specific to each pipelineâ€™s purpose.
- **Committer layer:** Writes processed data into the database while tracking progress through watermarks.
- **Optional pruner layer:** Manages data retention by removing old records from pipelines that support pruning operations. It operates independently from the main processing pipeline and runs at configurable intervals to delete data older than the specified retention period.

Each Indexer instance can run one or more pipelines, allowing deployments to be scaled and tuned according to workload. In some deployments, the pipelines described previously (except `kv_` checkpoints, objects, and transactions) are spread across a number of pods, grouping lightweight pipelines together and isolating heavyweight pipelines in their own deployments. This grouping helps mitigate ingestion bottlenecks, as all pipelines within a pod share the same ingestion service, and the slowest pipeline limits the overall throughput for that pod.

The pipeline composition, concurrency, and deployment grouping is configured via a TOML config file. A built-in [`GenerateConfig` command](https://github.com/MystenLabs/sui/blob/58eabc882671ceb6266473a5531253a90b22a66f/crates/sui-indexer-alt/src/main.rs#L109) is provided to output sample configuration files for different deployment setups. The configuration generated by this command includes all pipelines in a single indexer deployment.

As an example, the following configuration is used to run separate indexer deployments for each of the following pipelines:

#### coin_balance_buckets

```toml
[ingestion]
checkpoint-buffer-size = 10000
ingest-concurrency = 200
retry-interval-ms = 200

[pruner]
retention = 14400
max-chunk-size = 2000
prune-concurrency = 2

[committer]
write-concurrency = 5
collect-interval-ms = 500
watermark-interval-ms = 500

[pipeline.coin_balance_buckets.pruner]
```

#### cp_sequence_numbers

```toml
[ingestion]
checkpoint-buffer-size = 10000
ingest-concurrency = 200
retry-interval-ms = 200

[committer]
write-concurrency = 10
collect-interval-ms = 500
watermark-interval-ms = 500

[pipeline.cp_sequence_numbers]
```

#### obj_info

```toml
[ingestion]
checkpoint-buffer-size = 10000
ingest-concurrency = 200
retry-interval-ms = 200

[pruner]
interval-ms = 30000
retention = 14400
max-chunk-size = 500
prune-concurrency = 20

[committer]
write-concurrency = 10
collect-interval-ms = 500
watermark-interval-ms = 500

[pipeline.obj_info.pruner]
```

#### obj_versions

```toml
[ingestion]
checkpoint-buffer-size = 5000
ingest-concurrency = 200
retry-interval-ms = 200

[committer]
write-concurrency = 10
collect-interval-ms = 500
watermark-interval-ms = 500

[pipeline.obj_versions]
```

#### kv_packages

```toml
[ingestion]
checkpoint-buffer-size = 5000
ingest-concurrency = 200
retry-interval-ms = 200

[committer]
write-concurrency = 5
collect-interval-ms = 500
watermark-interval-ms = 500

[pipeline.kv_packages]
```

#### tx_affected_addresses

```toml
[ingestion]
checkpoint-buffer-size = 5000
ingest-concurrency = 200
retry-interval-ms = 200

[committer]
write-concurrency = 10
collect-interval-ms = 500
watermark-interval-ms = 500

[pipeline.tx_affected_addresses]
```

#### tx_balance_changes

```toml
[ingestion]
checkpoint-buffer-size = 5000
ingest-concurrency = 200
retry-interval-ms = 200

[committer]
write-concurrency = 10
collect-interval-ms = 500
watermark-interval-ms = 500

[pipeline.tx_balance_changes]
```

#### Remaining tables

And a single additional deployment that handles all the remaining tables:

```toml
[ingestion]
checkpoint-buffer-size = 5000
ingest-concurrency = 200
retry-interval-ms = 200

[committer]
write-concurrency = 5
collect-interval-ms = 500
watermark-interval-ms = 500

[pipeline.sum_displays]

[pipeline.kv_epoch_ends]

[pipeline.kv_epoch_starts]

[pipeline.kv_feature_flags]

[pipeline.kv_protocol_configs]

[pipeline.tx_digests]
```

### When to build a custom indexer

This document focuses on the general-purpose Indexer that powers GraphQL. If you want to build your own pipelines for application-specific data (for example, Deepbook order books, Walrus blob metadata, Seal access events, and so on), refer to the [Build Your First Custom Indexer](/guides/developer/advanced/custom-indexer/build).

You can run custom indexers separately to populate an app-specific database. You can then build your own lightweight RPC server with your choice of query mechanism (GraphQL, gRPC, or JSON-RPC) to serve app-specific data from that database.

## Working with Consistent Store

The Consistent Store is a combined indexer and RPC service that is responsible for indexing live data on-chain, and serving queries about it for recent checkpoints. Retention (the number of checkpoints to serve information for) is configurable and is typically measured in minutes or hours. Its indexer fetches checkpoints from the same sources as the general-purpose Indexer, and writes data to an embedded RocksDB store, while requests are served through gRPC, answering the following queries:

- Owner's live objects at a recent checkpoint, optionally filtered by type.
- Live objects for a given type at a recent checkpoint.
- Address balance at a recent checkpoint.

This service is not stateless as it maintains its own database. A new instance can be spun up similar to the indexer, by syncing it from genesis, or possibly by restoring it from a formal snapshot.

## For RPC providers and data operators

If you're running the GraphQL RPC + General-purpose Indexer stack as a service, here are a few key considerations for configuring your setup to offer builders a performant and cost-effective experience.

### How much data to index and retain

You should retain **30 to 90 days** of recent checkpoint data in your Postgres-compatible database. This provides a strong default for most apps without incurring the high storage costs of full historical indexing.

- **30 days** is a great baseline for dashboards and explorers that need recent activity and assets.
- **90 days** improves support for longer-range pagination, historical lookups, or dApps with slower engagement cycles.

You can configure your indexing pipelines to scope which data you include (such as events, objects, and transactions), and disable any components that arenâ€™t needed.

:::note

Retaining long-term historical data in Postgres is not recommended unless required for specific apps.

:::

### Use the Archival Service and Store for historical lookups

For all production deployments, you are strongly encouraged to pair Postgres with the [Archival Service](./archival-store.mdx) to support point lookups of transactions, objects, and checkpoints when relevant data does not exist in Postgres.

- The Archival Service serves as the backend for historical versions and checkpoint data, reducing pressure on your Postgres instance.
- While not strictly required, it is strongly recommended that you use the Archival Service in any production setup that aims to support `high-retention` GraphQL or gRPC workloads.

Current implementation supports [GCP Bigtable](https://cloud.google.com/bigtable) which is a highly scalable and performant data store. If you plan to operate your own archival store, refer to `sui-kvstore` and `sui-kv-rpc` for indexer setup and RPC service implementation respectively. For the indexer setup, make sure to use the [custom indexing framework](../guides/developer/advanced/custom-indexer). If you're interested in contributing support for other scalable data stores, reach out on GitHub by creating a new issue.

<details>
<summary>
`main.rs` in `sui-kvstore`
</summary>
<ImportContent source="crates/sui-kvstore/src/main.rs" mode="code" />
</details>

<details>
<summary>
`main.rs` in `sui-kv-rpc`
</summary>
<ImportContent source="crates/sui-kv-rpc/src/main.rs" mode="code" />
</details>

### Deployment strategies and trade-offs

You donâ€™t need to index everything to provide a reliable and performant GraphQL RPC service. In fact, many developers might need only the latest object and transaction data plus a few weeks to months of history. You can reduce operational overhead and improve query performance by:

- Configuring a clear retention window (such as 30â€“90 days) in Postgres.
- Using the Archival Service to handle deep historical queries, rather than retaining all versions in Postgres.

When designing your deployment, consider the trade-offs between cost, reliability, and feature completeness:

- Postgres-only with short-retention results in lower storage cost and faster performance, but limited historical coverage.
- Postgres-only with high retention results in broader data coverage, but relatively higher storage cost and slower performance at scale.
- Postgres with short-retention + Archival Service results in optimization for cost and completeness, ideal for production deployments.

To improve performance and reliability, also consider these operational best practices:

- Try and co-locate your database, indexing pipelines, GraphQL RPC service, and archival service in the same region as your users to minimize latency.
- Use replication and staged deployments to ensure SLA during upgrades or failures.
- Consider offering different tiers of service to meet different developer needs. For example:
    - A basic tier that serves recent data (30 days, for example) via GraphQL RPC or gRPC.
    - A premium tier with full GraphQL / gRPC + Archival Service access, suited to apps that need historical lookups.
    - Optionally offer region-specific instances or throughput-based pricing to support diverse client footprints.

## Related links

<RelatedLink to="/concepts/graphql-rpc" />
<RelatedLink to="/concepts/custom-indexing-framework" />
<RelatedLink to="/concepts/custom-indexer/pipeline-architecture" />
<RelatedLink to="/concepts/archival-store" />
<RelatedLink to="/guides/operator/indexer-stack-setup" />
<RelatedLink to="/guides/developer/advanced/custom-indexer" />
<RelatedLink href="https://github.com/MystenLabs/sui/tree/main/crates/sui-indexer-alt" label="Sui Indexer Alt" desc="The `sui-indexer-alt` crate in the Sui repo." />
<RelatedLink href="https://github.com/MystenLabs/mvr/tree/main/crates/mvr-indexer" label="Move Registry" desc="The indexer that the Move Registry (MVR) implements." />
<RelatedLink href="https://github.com/MystenLabs/deepbookv3/tree/main/crates/indexer" label="DeepBook Indexer" desc="The indexer that DeepBook implements." />
<RelatedLink href="/references/sui-api/sui-graphql/beta/reference" label="GraphQL Beta schema" desc="Schema documentation for GraphQL Beta" />

>>>> sui/docs/content/concepts/graphql-rpc.mdx
---
title: GraphQL for Sui RPC (Beta)
beta: devnet, testnet, mainnet
description: Use GraphQL to make Sui RPC calls. This feature is currently in Beta. 
keywords: [ graphql, graphql headers, x-sui-rpc-version, x-sui-rpc-show-usage, variables, fragments, pagination, graphql limits, make rpc call, sui rpc calls ]
---

This section explains some of the common concepts when working with GraphQL, such as altering behavior using HTTP headers, re-using query snippets with variables and fragments, consuming paginated queries, and understanding and working within the limits enforced by the service.

Jump to the following sections for more details:

- [Headers](#headers)
- [Variables](#variables)
- [Fragments](#fragments)
- [Pagination](#pagination)
- [Limits](#limits)
- [Retention](#retention)

For more details on GraphQL fundamentals, see the introductory documentation from [GraphQL](https://graphql.org/learn/) and [GitHub](https://docs.github.com/en/graphql/guides/introduction-to-graphql).

:::info

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

<ImportContent source="data-serving-gql-alpha.mdx" mode="snippet" />

:::

:::caution

Switch any apps that still use the GraphQL Alpha endpoints (`https://sui-mainnet.mystenlabs.com/graphql`, `https://sui-testnet.mystenlabs.com/graphql`, and `https://sui-devnet.mystenlabs.com/graphql`) to the GraphQL Beta endpoints as soon as possible to avoid disruption of service.

- GraphQL Beta Mainnet: https://graphql.mainnet.sui.io/graphql
- GraphQL Beta Testnet: https://graphql.testnet.sui.io/graphql
- GraphQL Beta Devnet: https://graphql.devnet.sui.io/graphql

:::

## Headers

The service accepts the following optional HTTP request headers:

- `x-sui-rpc-version` to specify which RPC version to use (currently only one version is supported),
- `x-sui-rpc-show-usage` returns the response with extra query complexity information.

By default, each response contains the following HTTP response headers:
- `x-sui-rpc-request-id` a unique identifier for the request; appears in application logs for debugging.
- `x-sui-rpc-version` the version of the service that handled the request.

```sh
$ curl -i -X POST https://graphql.testnet.sui.io/graphql\
     --header 'x-sui-rpc-show-usage: true'                 \
     --header 'Content-Type: application/json'             \
     --data '{
          "query": "query { epoch { referenceGasPrice } }"
     }'
```

The response for the previous request looks similar to the following:

```sh
HTTP/2 200 
content-type: application/json
content-length: 179
x-sui-rpc-request-id: f5442058-47ab-4360-8295-61c009f38516
x-sui-rpc-version: 1.56.1-
vary: origin, access-control-request-method, access-control-request-headers
access-control-allow-origin: *
date: Tue, 09 Sep 2025 23:34:04 GMT
via: 1.1 google
alt-svc: h3=":443"; ma=2592000,h3-29=":443"; ma=2592000

{
  "data": { 
    "epoch": { 
      "referenceGasPrice": "1000" 
    } 
  },
  "extensions": {
    "usage": {
      "input": { 
        "nodes": 2, 
        "depth": 2 
      },
      "payload": { 
        "query_payload_size": 67, 
        "tx_payload_size": 0 
      },
      "output": { 
        "nodes": 2 
      }
    }
  }
}
```

## Variables

Variables offer a way to introduce dynamic inputs to a re-usable/static query. Declare variables in the parameters to a `query` or `mutation`, using the `$` symbol and its type (in this example `Int`), which must be a `scalar`, `enum`, or `input` type. In the query body, refer to it by its name (prefixed with the `$` symbol).

If you declare a variable but don't use it or define it (supply a value) in the query, the query fails to execute.

To learn more, read the GraphQL documentation on [Variables](https://graphql.org/learn/queries/#variables).

In the following example, a variable supplies the ID of the epoch being queried.

```graphql
query ($epochID: Int) {
  epoch(id: $epochID) {
    referenceGasPrice
  }
}
```

**Variables**:
```json
{
   "epochID": 100
}
```

### In the IDE

When using the online IDE, supply variables as a JSON object to the query in the **Variables** pane at the bottom of the main editing window. You receive a warning if you supply a variable but don't declare it.

### In requests

When making a request to the GraphQL service (for example, using `curl`), pass the query and variables as two fields of a single JSON object:

```sh
$ curl -X POST https://sui-testnet.mystenlabs.com/graphql \
    --header 'Content-Type: application/json' \
    --data '{
      "query": "query ($epochID: Int) { epoch(id: $epochID) { referenceGasPrice } }",
      "variables": { "epochID": 100 }
  }'
```

## Fragments

Fragments are reusable units that you can include in queries as needed. To learn more, consult the official GraphQL [documentation](https://graphql.org/learn/queries/#fragments). The following example uses fragments to factor out a reusable snippet representing a Move value.

```graphql
query DynamicField {
  object(
    address: "0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac"
  ) {
    dynamicField(
      name: {
        type: "0x2::kiosk::Lock",
        bcs: "NLArx1UJguOUYmXgNG8Pv8KbKXLjWtCi6i0Yeq1Vhfw=",
      }
    ) {
      ...DynamicFieldSelect
    }
  }
}

fragment DynamicFieldSelect on DynamicField {
  name {
    ...MoveValueFields
  }
  value {
    ...DynamicFieldValueSelection
  }
}

fragment DynamicFieldValueSelection on DynamicFieldValue {
  __typename
  ... on MoveValue {
    ...MoveValueFields
  }
  ... on MoveObject {
    hasPublicTransfer
    contents {
      ...MoveValueFields
    }
  }
}

fragment MoveValueFields on MoveValue {
  type {
    repr
  }
  json
  bcs
}
```

## Pagination

GraphQL supports queries that fetch multiple kinds of potentially nested data. For example, the following query retrieves the first 10 transactions in epoch `97` along with the:

- Digest
- Sender's address
- Gas object returned after paying for the transaction
- Gas price
- Gas budget

```graphql
query {
  epoch(epochId: 97) {
    transactions(first: 10) {
      pageInfo {
        hasNextPage
        endCursor
      }
      nodes {
        digest
        sender {
          address
        }
        effects {
          gasEffects {
            gasObject {
              address
            }
          }
        }
        gasInput {
          gasPrice
          gasBudget
        }
      }
    }
  }
}
```

If there are too many transactions to return in a single response, the service applies a [limit](#limits) on the maximum page size for variable size responses (like the `transactionBlock` query) and you must fetch further results through [pagination](https://graphql.org/learn/pagination/).

### Connections

Fields that return a paginated response accept at least the following optional parameters:

- `first`, a limit on page size that is met by dropping excess results from the end.
- `after`, a cursor that bounds the results from below, exclusively.
- `last`, a limit on page size that is met by dropping excess results from the start.
- `before`, a cursor that bounds the results from above, exclusively.

They also return a type that conforms to the [GraphQL Cursor Connections Specification](https://relay.dev/graphql/connections.htm), meaning its name ends in `Connection`, and it contains at least the following fields:

- `pageInfo`, of type <UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/types/objects/page-info">PageInfo</UnsafeLink>, which indicates whether there are more pages before or after the page returned.
- `nodes`, the content of the paginated response, as a list of the type being paginated (`TransactionBlock` in the previous example).
- `edges`, similar to `nodes` but associating each node with its [cursor](#cursors).

### Cursors

Cursors are opaque identifiers for paginated results. The only valid source for a cursor parameter (like `after` and `before`) is a cursor field from a previous paginated response (like `PageInfo.startCursor`, `PageInfo.endCursor`, or `Edge.cursor`). The underlying format of the cursor is an implementation detail, and is not guaranteed to remain fixed across versions of the GraphQL service, so do not rely on it -- generating cursors out of thin air is not expected or supported.

Cursors are used to bound results from below (with `after`) and above (with `before`). In both cases, the bound is exclusive, meaning it does not include the result that the cursor points to in the bounded region.

#### Consistency

Cursors for queries that paginate live objects also guarantee **consistent** pagination. 

If a paginated query reads the state of the network at a specific checkpoint (i.e., checkpoint `X`), the query returns cursors that can be used by subsequent requests. When a future call fetches the next page of results, it uses the previous query's cursors and continues reading from the network as it existed at checkpoint `X`, even if newer checkpoints are available. Currently, the available range offers roughly 1 hour to finish pagination.

This property requires that cursors that are used together (for example when supplying an `after` and `before` bound) are fixed on the same checkpoint, otherwise the query produces an error.

### Page limits

After results are bounded using cursors, a page size limit is applied using the `first` and `last` parameters. The service requires these parameters to be less than or equal to the max page size [limit](#limits), and if you provide neither, it selects a default. In addition to setting a limit, `first` and `last` control where excess elements are discarded from. For example, if there are `10` potential results -- `R0`, `R1`, ..., `R9` -- after cursor bounds have been applied, then

- a limit of `first: 3` would select `R0`, `R1`, `R2`, and
- a limit of `last: 3` would select `R7`, `R8`, `R9`.

:::info

It is an error to apply both a `first` and a `last` limit.

:::

### Examples

To see these principles put into practice, consult the examples for [paginating forwards](../guides/developer/advanced/graphql-rpc.mdx#page-forward) and [paginating backwards](../guides/developer/advanced/graphql-rpc.mdx#page-back) in the getting started guide.

## Limits

The GraphQL service for Sui RPC is rate-limited on all available instances to keep network throughput optimized and to protect against excessive or abusive calls to the service.

### Rate limits

Queries are rate-limited at the number of attempts per minute to ensure high availability of the service to all users.

### Query limits

In addition to rate limits, queries are also validated against a number of rules on their complexity, such as the number of nodes, the depth of the query, or their payload size. Query the `serviceConfig` field to retrieve these limits. An example of how to query for some of the available limits follows:

```graphql
{
  serviceConfig {
    maxQueryDepth
    maxQueryNodes
    maxOutputNodes
    defaultPageSize
    maxPageSize
    queryTimeoutMs
    maxQueryPayloadSize
    maxTypeArgumentDepth
    maxTypeArgumentWidth
    maxTypeNodes
    maxMoveValueDepth
  }
}
```

## Retention

Different queries are subject to their own retention policies. For example, live object set queries work only for recent checkpoints (measured in minutes or hours), while transaction pagination may be available only back to certain checkpoints (measured in weeks or months), depending on the filters applied. Data outside these ranges is pruned. You can query the upper- and lower-bounds of that range for your query as follows:

```graphql
{
  serviceConfig {
    retention(type: "Query", field: "transactions", filter: "affectedAddress") {
      first { sequenceNumber }
      last { sequenceNumber }
    }
  }
}
```

The results are the first and last checkpoint for which pagination continues to work and produce a consistent result.

## Related links

<RelatedLink to="/guides/developer/advanced/graphql-rpc.mdx" />
<RelatedLink to="/references/sui-graphql.mdx" />
<RelatedLink to="/concepts/graphql-indexer" />

>>>> sui/docs/content/concepts/grpc-overview.mdx
---
title: gRPC Overview
description: Overview of the gRPC API to access Sui network data.
keywords: [ grpc, g rpc, RPC, sui full node grpc, full node rpc, what is grpc, grpc on sui ]
---

The [Sui Full Node gRPC API](../references/fullnode-protocol.mdx) provides a fast, type-safe, and efficient interface for interacting with the Sui blockchain. Designed for power users, indexers, explorers, and decentralized apps, this API enables access to Sui data with high performance and low latency.

:::info

<ImportContent source="json-rpc-deprecation.mdx" mode="snippet" />

:::

:::info

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::

## What is gRPC?

gRPC offers a high-performance, efficient communication protocol that uses [Protocol Buffers](https://protobuf.dev/overview/) for fast, compact data serialization. Its strongly typed interfaces reduce runtime errors and simplify client/server development across multiple languages. With built-in support for code generation, you can scaffold clients in TypeScript, Go, Rust, and more. This makes it ideal for scalable backend systems like indexers, blockchain explorers, and data-intensive decentralized apps.

In addition to request-response calls, gRPC supports server-side streaming, enabling real-time data delivery without constant polling. This is especially useful in environments where you need to track events and transactions live. gRPC's binary format is significantly faster and lighter than JSON, saving bandwidth and improving latency.

Refer to [when to use gRPC vs GraphQL](../guides/developer/sui-101/data-serving#when-to-use-grpc-vs-graphql-with-general-purpose-indexer) to access Sui data.

## gRPC on Sui

Protocol buffers define the gRPC interface. You can find the relevant `.proto` files at [sui-apis on Github](https://github.com/MystenLabs/sui-apis/tree/main/proto), which apart from the gRPC messages (request and response payloads) include the following services:

| Service | Proto | Purpose |
| --- | --- | --- |
| `TransactionExecutionService` | `sui/rpc/v2/transaction_execution_service.proto` | Submit and execute signed transactions on the Sui network. Wallets and apps use the service to send user actions to the network. |
| `LedgerService` | `sui/rpc/v2/ledger_service.proto` | Lookup specific checkpoints, transactions, objects and more from the current state and recent history of the Sui network. â€œHistoryâ€ here refers to the recent past - limited to what a full node retains. |
| `StateService` | `sui/rpc/v2/state_service.proto` | Query up-to-date on-chain data like balances, coin metadata, dynamic fields, or owned objects. Also supports dry-run simulations for transactions. |
| `SubscriptionService` | `sui/rpc/v2/subscription_service.proto` | Stream live updates for checkpoints. Ideal for building reactive systems such as indexers, bots, and dashboards. Refer to [Subscriptions for streaming data](#subscriptions-for-streaming-data). |
| `MovePackageService` | `sui/rpc/v2/move_package_service.proto` | Access metadata and content of Move packages deployed on the Sui network. Useful for tooling, analysis, and smart contract introspection. |
| `SignatureVerificationService` | `sui/rpc/v2/signature_verification_service.proto` | Validate signatures outside transaction execution. Helps pre-verify payloads that may include [zklogin](./cryptography/zklogin.mdx) or other signatures, simulate authentication, or build custom signing workflows. |
| `NameService` | `sui/rpc/v2/name_service.proto` | Resolve human-readable SuiNS names to their underlying name records, and perform reverse lookups from Sui addresses back to linked names. |

Use these definitions to generate client libraries in various programming languages.

:::info

If you were using the `v2beta2` proto files previously, note that the latest definitions are now under the `v2` version. Also, the `LiveDataService` has been renamed to `StateService`, and the `SimulateTransaction` API has been moved to the `TransactionExecutionService`.

:::

### Field masks

A [`FieldMask` in Protocol Buffers](https://protobuf.dev/reference/protobuf/google.protobuf/#field-mask) is a mechanism used to specify a subset of fields within a message that should be read, updated, or returned. Instead of retrieving the entire object, a client can request only the specific fields they need by providing a list of field paths. This improves performance and reduces unnecessary data transfer.

In the Sui gRPC API, `FieldMask`s are used in requests like `GetTransaction`, `GetObject`, and so on to control which parts are included in the response (such as, `effects` and `events` of a transaction).

Key behaviors:

- Field masks are defined using `google.protobuf.FieldMask` and typically appear in the request message as `read_mask`.
- You can pass an explicit value of `*` to request all fields.
- If you omit `read_mask`, it defaults to `*` (all fields), unless documented otherwise.
- Each field path in the mask must match the field structure of the response proto message. Nested fields are supported using dot notation.
- In batch APIs, only the top-level `read_mask` is respected â€” the API ignores any masks inside sub-requests.
- In some cases, non-terminal repeated fields might be supported in the mask (even if this is atypical per standard `FieldMask` behavior).

### Field presence

When using gRPC with Sui, it's important to understand how [field presence](https://github.com/protocolbuffers/protobuf/blob/main/docs/field_presence.md) works, especially when dealing with `proto3` syntax. In `proto3`, primitive fields (like numbers, booleans, and strings) are always initialized to a default value if not present in the message â€” this means you canâ€™t tell whether a value is explicitly set or just left out. To give you that distinction, Sui marks all fields as `optional`, even if theyâ€™re required by the API.

As a user of the API, this lets you:

- Detect whether a field value is actually provided or just defaulted.
- Write clients that can perform partial updates or simulate intent (for example, distinguish between an explicitly empty input versus a missing one).

:::info

Remember that if a field is marked `optional` in the proto, it might still be **required** for the request to be valid â€” this is a protobuf quirk, not an indication of actual business logic.

:::

### Encoding

In the Sui gRPC API, identifiers with standard human-readable formats are represented as `string`s in the proto schema:

- `Address` and `ObjectId`: Represented as 64 hexadecimal characters with a leading `0x`.
- `Digest`s: Represented as [Base58](https://learnmeabitcoin.com/technical/keys/base58/).
- `TypeTag` and `StructTag`: Represented in their canonical string format (for example, `0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI>`)

### Pagination

When using gRPC APIs that return lists of data â€” such as account balances, owned objects, and so on â€” you typically need to handle pagination. These APIs return results in chunks and include tokens to help you request the next batch.

Hereâ€™s how it works:

- In the request, provide a `page_size` to control how many items you want returned. If you leave this unset or set it to 0, the API uses a sensible default.
- You can also include a `page_token` in the request, which tells the server where to continue from. You get this token from the previous response.
- The response includes a list of results and a `next_page_token` value, which you can pass into your next request to get the next page.
- When the server returns an empty `next_page_token`, youâ€™ve reached the end of the list.

Make sure to keep all other parameters in your request the same between paginated calls â€” otherwise, the server might reject the request with an `INVALID_ARGUMENT` error.

### Errors

The Sui gRPC services follow the [richer error model](https://grpc.io/docs/guides/error/#richer-error-model) defined in [AIP-193](https://google.aip.dev/193). When an RPC returns a non-OK status code, detailed error information is typically included in the `grpc-status-details-bin` header. This header contains a `google.rpc.Status` message encoded in Base64.

You can decode this message to access structured error details, which might include specific causes, context, or metadata. This makes it easier to understand and handle errors programmatically in your client applications.

### HTTP headers

In many gRPC responses, the Sui API includes additional metadata in the form of HTTP headers. These headers provide contextual information about the current network state and might be useful for debugging, telemetry, or understanding the dataâ€™s freshness.

Here are the headers you might encounter:

- `x-sui-chain-id`: The chain ID of the current network.
- `x-sui-chain`: A human-readable name for the current network (such as `mainnet` or `testnet`).
- `x-sui-checkpoint-height`: The height of the latest checkpoint at the time of the response.
- `x-sui-lowest-available-checkpoint`: The earliest checkpoint for which transaction and checkpoint data can still be queried.
- `x-sui-lowest-available-checkpoint-objects`: The earliest checkpoint from which object data (input/output) is available.
- `x-sui-epoch`: The current epoch of the network.
- `x-sui-timestamp-ms`: The network timestamp in milliseconds since the Unix epoch.
- `x-sui-timestamp`: The network timestamp in milliseconds since the Unix epoch in human-readable [RFC 3339](https://datatracker.ietf.org/doc/html/rfc3339) format.

Not all headers are guaranteed to be present in every API response â€” they are only included when applicable to the given RPC.

## Subscriptions for streaming data

The `SubscriptionService` provides real-time streaming updates for on-chain activity via gRPC server-side streaming APIs.

For example, the `SubscribeCheckpoint` RPC lets you subscribe to the global stream of executed checkpoints. When a subscription is initialized, the stream begins at the latest checkpoint known to the server. Checkpoints are guaranteed to arrive in order and without gaps. This allows clients to track exactly which checkpoint they last processed.

If the stream is interrupted â€” for example, due to client disconnect or network error â€” you can resume from the last known checkpoint using other APIs to backfill any missed data before resubscribing.

Streaming APIs are useful for building indexers, dashboards, or bots that need to react to real-time Sui activity with minimal latency. Refer to [Access streaming data with buf](#access-streaming-data-with-buf) for information on how to test.

## Handling pruned data

If a full node doesnâ€™t return a specific object, transaction, or event, itâ€™s likely that the data has been pruned based on the nodeâ€™s retention configuration. In that case, use a fallback mechanism in your application to query the same data from the [Archival Store & Service](/concepts/archival-store.mdx). The Archival Store retains historical data for the network.

You can reuse the same gRPC `LedgerService` methods for this lookup. Simply change the endpoint in your client from the full nodeâ€™s address to the archival service endpoint.

This ensures that your application can access both recent and historical data reliably, regardless of a full nodeâ€™s pruning settings.

## Developer access and usage recipes

The following recipes show how to accomplish some common tasks using gRPC. 

:::info

Refer to the [list of RPC or data providers](https://www.notion.so/mystenlabs/RPC-providers-offering-future-Sui-data-primitives-2466d9dcb4e980a99a36e9aafd8c17e0?source=copy_link) that have enabled gRPC on their full nodes. Contact a provider directly to request access. If your RPC or data provider doesnâ€™t yet support gRPC, ask them to enable support or contact the Sui Foundation team on Discord or Telegram for help.

:::

### Access using grpcurl

Simplest way to experiment with gRPC is by using [grpcurl](https://github.com/fullstorydev/grpcurl).

:::note

Your results might differ from the examples that follow, depending on the breadth, maturity, and data retention of the gRPC APIs available on the Sui full node you use.

:::

#### List available gRPC services

```shell
$ grpcurl <full node URL:port> list
```

where the port on Sui Foundation managed Full nodes is `443`. It should return something like:

```shell
grpc.health.v1.Health
grpc.reflection.v1.ServerReflection
sui.rpc.v2.LedgerService
sui.rpc.v2.MovePackageService
sui.rpc.v2.NameService
sui.rpc.v2.SignatureVerificationService
sui.rpc.v2.StateService
sui.rpc.v2.SubscriptionService
sui.rpc.v2.TransactionExecutionService
```

#### List available APIs in the LedgerService

```shell
$ grpcurl <full node URL:port> list sui.rpc.v2.LedgerService
```

which should return something like:

```shell
sui.rpc.v2.LedgerService.BatchGetObjects
sui.rpc.v2.LedgerService.BatchGetTransactions
sui.rpc.v2.LedgerService.GetCheckpoint
sui.rpc.v2.LedgerService.GetEpoch
sui.rpc.v2.LedgerService.GetObject
sui.rpc.v2.LedgerService.GetServiceInfo
sui.rpc.v2.LedgerService.GetTransaction
```

#### Get the `events` and `effects` details of a particular transaction

```shell
$ grpcurl -d '{ "digest": "J4NvV5iQZQFm1xKPYv9ffDCCPW6cZ4yFKsCqFUiDX5L4" }' <full node URL:port> sui.rpc.v2.LedgerService/GetTransaction
```

#### Get the transactions in a particular checkpoint

```shell
$ grpcurl -d '{ "sequence_number": "164329987", "read_mask": { "paths": ["transactions"]} }' <full node URL:port> sui.rpc.v2.LedgerService/GetCheckpoint
```

#### Get the latest information for a coin type

```shell
$ grpcurl -d '{ "coin_type": "0x2::sui::SUI" }' <full node URL:port> sui.rpc.v2.StateService/GetCoinInfo
```

#### List the objects owned by a particular address

```shell
$ grpcurl -d '{ "owner": "0x94096a6a54129234237759c66e6ef1037224fb3102a0ae29d33b490281c8e4d5" }' <full node URL:port> sui.rpc.v2.StateService/ListOwnedObjects
```

#### List the dynamic fields in a particular object

```shell
$ grpcurl -d '{ "parent": "0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac" }' <full node URL:port> sui.rpc.v2.StateService/ListDynamicFields
```

### Access streaming data with buf

`grpcurl` does not support server-side streaming RPCs. To test or experiment with `SubscriptionService`, use the [buf CLI](https://buf.build/docs/cli/) instead.

```shell
$ buf curl --protocol grpc https://<full node URL>/sui.rpc.v2.SubscriptionService/SubscribeCheckpoints -d '{ "readMask": "sequenceNumber,digest,summary.timestamp" }'  --timeout 1m
```

which should return something like:

```json
{
  "cursor": "164324277",
  "checkpoint": {
    "sequenceNumber": "164324277",
    "digest": "AJsK688sDPbzWro1VSN3gVPxR1hfM9v3Bk1M9EhPBc3A",
    "summary": {
      "timestamp": "2025-07-05T16:49:09.788Z"
    }
  }
}
{
  "cursor": "164324278",
  "checkpoint": {
    "sequenceNumber": "164324278",
    "digest": "J35nDAwZm9YRZ4kHJH9oSqCMQ2ZrkbpmshCTi6N5TCpV",
    "summary": {
      "timestamp": "2025-07-05T16:49:10.032Z"
    }
  }
}
{
  "cursor": "164324279",
  "checkpoint": {
    "sequenceNumber": "164324279",
    "digest": "DgoaWNGtWojozP88AnmHskkDbdvyMApP1jVz2wRzPsC5",
    "summary": {
      "timestamp": "2025-07-05T16:49:10.292Z"
    }
  }
}
...
...
...
```

### Sample clients in different programming languages

:::info

For Rust, consider using the [Sui-Rust-Sdk](https://github.com/MystenLabs/sui-rust-sdk).

:::

<Tabs groupId="language">

<TabItem value="typescript" label="TypeScript">

This is an example to build a TypeScript client for Sui gRPC API. If you want to use a different set of tools or modules that youâ€™re comfortable with, you can adjust the instructions accordingly.

**Install dependencies**

```shell
npm init -y
```
```shell
npm install @grpc/grpc-js @grpc/proto-loader
```
```shell
npm i -D tsx
```

**Project structure**

```shell
.
â”œâ”€â”€ protos/
â”‚   â””â”€â”€ sui/
â”‚       â””â”€â”€ node/
â”‚           â””â”€â”€ v2/
â”‚               â”œâ”€â”€ ledger_service.proto
â”‚               â””â”€â”€ *.proto
â”œâ”€â”€ client.ts
â”œâ”€â”€ package.json
```

Download all the `sui/rpc/v2` proto files from [Github](https://github.com/MystenLabs/sui-apis/tree/main/proto) in the same folder.

**Sample client.ts to get `events` and `effects` details of a particular transaction**

```ts
import * as grpc from '@grpc/grpc-js';
import * as protoLoader from '@grpc/proto-loader';
import * as path from 'path';

const PROTO_PATH = path.join(__dirname, 'protos/sui/rpc/v2/ledger_service.proto');

// Load proto definitions
const packageDefinition = protoLoader.loadSync(PROTO_PATH, {
  keepCase: true,
  longs: String,
  enums: String,
  defaults: true,
  oneofs: true,
  includeDirs: [path.join(__dirname, 'protos')],
});

const suiProto = grpc.loadPackageDefinition(packageDefinition) as any;
const LedgerService = suiProto.sui.rpc.v2.LedgerService;

// Create gRPC client
const client = new LedgerService(
  '<full node URL>:443',
  grpc.credentials.createSsl()
);

// Sample transaction digest in Base58 format
const base58Digest = '3ByWphQ5sAVojiTrTrGXGM5FmCVzpzYmhsjbhYESJtxp';

// Construct the request
const request = {
  digest: base58Digest,
  read_mask: {
    paths: ['events', 'effects'],
  },
};

// Make gRPC call
client.GetTransaction(request, (err: any, response: any) => {
  if (err) {
    console.error('Error:', err);
  } else {
    console.log('Response:', JSON.stringify(response, null, 2));
  }
});
```

**Run the sample client**

```shell
npx tsx c
```

:::info

- `proto-loader` handles any nested `.proto` files - just make sure paths and imports are correct.
- The example assumes that gRPC is available on port `443` which requires SSL.
- Digest in the request is directly provided in the `Base58` format, but check if you need to decode from your source format.

:::

</TabItem>

<TabItem value="golang" label="Golang">

This is an example to build a golang client for Sui gRPC API. Feel free to use another set of tools or modules that youâ€™re comfortable with.

**Install dependencies**

First make sure you have `go` and `protoc` installed in your environment, and then install:

```shell
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
```
```shell
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```

In your `go.mod`, add the following (make sure to update the version numbers to the latest versions):

```
require (
  google.golang.org/grpc v1.60.0
  google.golang.org/protobuf v1.33.0
)
```

**Generate Golang code from proto files**

Assuming you have the `v2` proto files from [Github](https://github.com/MystenLabs/sui-apis/tree/main/proto), run:

```shell
protoc --proto_path=./protos --go_out=. --go-grpc_out=. protos/sui/rpc/v2/ledger_service.proto
```

**Sample main.go to get `events` and `effects` details of a particular transaction**

```go
package main

import (
    "context"
    "crypto/tls"
    "fmt"
    "log"
    "time"

    "google.golang.org/grpc"
    "google.golang.org/grpc/credentials"
    
    pb "your_project/sui/rpc/v2" // adjust path based on where your generated .pb.go files are
)

func main() {
    // Set up gRPC connection with TLS (port 443)
		creds := credentials.NewTLS(&tls.Config{})
		conn, err := grpc.Dial("<full node URL>:443", grpc.WithTransportCredentials(creds))
		if err != nil {
			log.Fatalf("failed to connect: %v", err)
		}
		defer conn.Close()

    client := pb.NewLedgerServiceClient(conn)
    
    // Sample transaction digest in Base58 format
    base58Digest := "3ByWphQ5sAVojiTrTrGXGM5FmCVzpzYmhsjbhYESJtxp"

    // Build request
		req := &pb.GetTransactionRequest{
			Digest: base58Digest,
			ReadMask: &pb.TransactionReadMask{
				Paths: []string{"events", "effects"},
			},
		}

    // Make the request
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    resp, err := client.GetTransaction(ctx, req)
    if err != nil {
        log.Fatalf("GetTransaction failed: %v", err)
    }

    // Print the response
    fmt.Printf("Response:\n%+v\n", resp)
}
```

**Run the sample client**

If your `go.mod` is properly set up, and you've already generated the gRPC code (`*.pb.go`, `*_grpc.pb.go`), simply run:

```shell
go run main.go
```

:::info

- If you see errors like `cannot find package`, ensure youâ€™ve generated the proto files and imported them correctly.
- If your generated files are in a nested directory like `sui/rpc/v2`, your import in `main.go` should match:
```go
import pb "your_project/sui/rpc/v2"
```
You can replace `your_project` with a module name or relative import path depending on how your `go.mod` is defined.
- The example assumes that gRPC is available on port `443` which requires SSL.
- Digest in the request is directly provided in the `Base58` format, but check if you need to decode from your source format.

:::

</TabItem>

<TabItem value="python" label="Python">

This is an example to build a python client for Sui gRPC API. Feel free to use another set of tools or modules that youâ€™re comfortable with. You can optionally refer to [pysui](https://github.com/FrankC01/pysui/) which is a community contributed SDK.

**Install dependencies**

First make sure you have `python` and `protoc` installed in your environment, and then install:

```shell
pip install grpcio grpcio-tools protobuf
```

**Generate Python code from proto files**

Assuming you have the `v2` proto files from [Github](https://github.com/MystenLabs/sui-apis/tree/main/proto), run:

```shell
python -m grpc_tools.protoc -I./protos --python_out=. --grpc_python_out=. ./protos/sui/rpc/v2/ledger_service.proto
```

**Sample client.py to get `events` and `effects` details of a particular transaction**

```python
import grpc
from sui.rpc.v2 import ledger_service_pb2, ledger_service_pb2_grpc

def main():
    # Create secure channel to port 443
    channel = grpc.secure_channel("<full node URL>:443", grpc.ssl_channel_credentials())
    stub = ledger_service_pb2_grpc.LedgerServiceStub(channel)

    # Sample transaction digest in Base58 format
    base58_digest = "3ByWphQ5sAVojiTrTrGXGM5FmCVzpzYmhsjbhYESJtxp"

    # Build the request
    request = ledger_service_pb2.GetTransactionRequest(
        digest=base58_digest,
        read_mask=ledger_service_pb2.TransactionReadMask(paths=["events", "effects"])
    )

    # Make the RPC call
    response = stub.GetTransaction(request)

    # Print response
    print(response)

if __name__ == "__main__":
    main()
```

**Run the sample client**

```shell
python client.py
```

:::info

- The import paths like `sui.rpc.v2.ledger_service_pb2` depend on your proto structure.
- You might need to adjust `__init__.py` files or PYTHONPATH to ensure proper module resolution.
- The example assumes that gRPC is available on port `443` which requires SSL.
- Digest in the request is directly provided in the `Base58` format, but check if you need to decode from your source format.

:::

</TabItem>

</Tabs>

### Best practices

- Always use [field masks](#field-masks) when applicable to reduce response size and latency, especially for large resources.
- Use `TLS (port 443)` for production traffic to ensure encrypted transport and prevent downgrade attacks.
- Use [streaming subscriptions](#subscriptions-for-streaming-data) for real-time use cases instead of polling repeatedly.
- Generate client code from the official `.proto` definitions in [sui-apis](https://github.com/MystenLabs/sui-apis/tree/main/proto) to ensure compatibility and type safety.
- [Paginate](#pagination) carefully â€” always check `next_page_token` and do not assume all data is returned at once.
- Retry transient failures with [exponential backoff](https://en.wikipedia.org/wiki/Exponential_backoff), especially for streaming APIs or busy public nodes.
- Validate all input data, including encodings and message formats, to prevent hard-to-debug API rejections.

### Frequently asked questions

- Q: Can I use field masks in batch requests?
  - A: Only the top-level `read_mask` field is respected in batch requests like `BatchGetObjects`. Any [field masks](#field-masks) within individual `GetObjectRequest` items are ignored.

- Q: Why does the API return fewer results than the requested `page_size`?
  - A: Even if you request a specific `page_size`, the server might return fewer items. This could be due to full node specific limits, filtered results, or reaching the end of available data.

- Q: Why do some fields say `optional` if they're required?
  - A: In `proto3`, marking a field as `optional` gives the API the ability to detect [field presence](#field-presence) â€” that is, whether a field value is explicitly set or simply defaulted. This doesn't mean the field is optional in practice. You still need to follow the API contract to ensure the request is valid.

- Q: Are all services and related data guaranteed to be available on all Full nodes?
  - A: Full nodes may vary in which services and retention they support. Some services might not be supported yet or some APIs may return `NOT_FOUND` depending on the node's configuration and data availability.

## Full node operator configuration

Refer to [Considerations to enable gRPC](/guides/operator/sui-full-node.mdx#considerations-to-enable-grpc).

>>>> sui/docs/content/concepts/object-model.mdx
---
title: Object Model
description: Everything on the Sui blockchain is an object, with metadata, type of ownership, and a referencing scheme. 
keywords: [ object model, objects on sui, sui move package, sui move object, move objects, move packages, objects, packages, referring to objects, object metadata, transaction-objects, transaction objects, relating objects and transactions ]
---

The basic unit of storage in Sui is the object. In contrast to many other blockchains where storage is centered around accounts containing key-value stores, Sui's storage is centered around objects addressable on-chain by unique IDs. A smart contract is an object (called a Sui Move package), and these smart contracts manipulate objects on the Sui network:

- Sui Move package: A set of Sui Move bytecode modules. Each module has a name that's unique within the containing package. The combination of the package's on-chain ID and the name of a module uniquely identify the module. When you publish smart contracts to Sui, a package is the unit of publishing. After you publish a package object, it is immutable and can never be changed or removed. A package object can depend on other package objects that were previously published to Sui.
- Sui Move object: Typed data governed by a particular Sui Move module from a Sui Move package. Each object value is a struct with fields that can contain primitive types (such as integers and addresses), other objects, and non-object structs. 

## Object metadata 

Each Sui object has the following metadata:

- A 32-byte globally unique ID. An object ID is derived from the digest of the transaction that created the object and from a counter encoding the number of IDs generated by the transaction.
- An 8-byte unsigned integer version that monotonically increases with every transaction that modifies it (see [Object and Package Versioning](./versioning.mdx)).
- A 32-byte transaction digest indicating the last transaction that included this object as an output.
- A 32-byte owner field that indicates how this object can be accessed. See [Object Ownership](./object-ownership.mdx) for more information.

In addition to common metadata, objects have a category-specific, variable-sized contents field containing a [Binary Canonical Serialization (BCS)](https://docs.rs/bcs/latest/bcs/)-encoded payload.

- Move objects contain their Move type, whether the object can be transferred using `public_transfer`, and its fields, again encoded as BCS.
- Move packages contain the bytecode modules in the package, a table identifying which versions of a package introduced each of its types (the type origin table), and a table mapping each of its transitive dependencies to a specific version of that package to use (the linkage table).

## Referring to objects 

There are a few different ways to concisely refer to an object without specifying its entire contents and metadata, each with slightly different use cases:
- **ID:** The globally unique ID of the object mentioned above. ID is a stable identifier for the object across time and is useful for querying the current state of an object or describing which object was transferred between two addresses.
- **Versioned ID:** An (ID, version) pair. Versioned ID describes the state of the object at a particular point in the object's history and is useful for asking what the value of the object was at some point in the past or determining how fresh some view of an object is now.
- **Object reference:** An (ID, version, object digest) triple. The object digest is the hash of the object's contents and metadata. An object reference provides an authenticated view of the object at a particular point in the object's history. Transactions require object inputs to be specified via object references to ensure the transaction's sender and a validator processing the transaction agree on the contents and metadata of the object.

## The transaction-object DAG: Relating objects and transactions 

Transactions take objects as input, read/write/mutate these inputs, and produce mutated or freshly created objects as output. Each object knows the (hash of the) last transaction that produced it as an output. Thus, a natural way to represent the relationship between objects and transactions is a directed acyclic graph (DAG) where:

- Nodes are transactions.
- Directed edges go from transaction `A` to transaction `B` if an output object of `A` is an input object of `B`. They are labeled by the reference of the object in question (which specifies the exact version of the object created by `A` and used by `B`).

The root of this DAG is a genesis transaction that takes no inputs and produces the objects that exist in the system's initial state. The DAG can be extended by identifying mutable transaction outputs that have not yet been consumed by any committed transaction and sending a new transaction that takes these outputs (and optionally, immutable transaction outputs) as inputs.

The set of objects that are available to be taken as input by a transaction are the live objects, and the global state maintained by Sui consists of the totality of such objects. The live objects for a particular Sui address A are all objects owned by A, along with all shared and immutable objects in the system.

When this DAG contains all committed transactions in the system, it forms a complete (and cryptographically auditable) view of the system's state and history. In addition, you can use the scheme above to construct a DAG of the relevant history for a subset of transactions or objects (for example, the objects owned by a single address).

## Limits on transactions, objects, and data 

Sui has some limits on transactions and data used in transactions, such as a maximum size and number of objects used. For more information on limits, see [Building against Limits](https://move-book.com/guides/building-against-limits.html) in The Move Book.

The `ProtocolConfig` struct in the [`sui-protocol-config` crate](https://github.com/MystenLabs/sui/blob/main/crates/sui-protocol-config/src/lib.rs) itemizes these limits. Expand the following code to see the `ProtocolConfig` struct and the comments that explain each parameter.

<details>
<summary>

`lib.rs`

</summary>

<ImportContent source="crates/sui-protocol-config/src/lib.rs" mode="code" struct="ProtocolConfig" />

</details>

Select a network from the following tabs to see the currently configured limits and values.

<ProtocolConfig fields="[max_accumulated_randomness_txn_cost_per_object_in_mysticeti_commit, max_accumulated_txn_cost_per_object_in_mysticeti_commit, max_accumulated_txn_cost_per_object_in_narwhal_commit, max_arguments, max_input_objects, max_gas_computation_bucket, max_gas_payment_objects, max_gas_price, max_move_object_size, max_num_event_emit, max_transactions_per_checkpoint, max_tx_gas, max_tx_size_bytes, max_txn_cost_overage_per_object_in_commit, max_type_argument_depth, max_type_arguments, max_type_nodes, max_type_to_layout_nodes, max_value_stack_size]"/>

## Related links

<RelatedLink to="/concepts/versioning.mdx" />
<RelatedLink to="/concepts/object-ownership.mdx" />
<RelatedLink href="https://github.com/MystenLabs/sui/blob/main/crates/sui-protocol-config/src/lib.rs" label="`sui-protocol-config`" desc=" Crate that defines the `ProtocolConfig` struct with limit definitions." />
<RelatedLink href="https://move-book.com/guides/building-against-limits.html" label="Building against Limits" desc=" The Move Book provides a concise overview for limits most projects deal with." />
<RelatedLink href="https://move-book.com/" label="The Move Book" desc=" A comprehensive guide to the Move programming language used on the Sui network." />
<RelatedLink href="https://move-book.com/reference/" label="The Move Reference" desc=" Reference guide for the Move language." />
>>>> sui/docs/content/concepts/object-ownership.mdx
---
title: Object Ownership
description: Every object has an owner field that dictates how you can use it in transactions. Each object is either address-owned, dynamic fields, immutable, shared, or wrapped.
keywords: [ object ownership, how objects are owned, address-owned, address-owned objects, immutable objects, immutable, shared objects, shared, wrapped objects, wrapped ]
---

Every object has an owner field that dictates how you can use it in transactions. Objects can have the following types of ownership:


<Cards>
<Card title="Address-Owned" href="/concepts/object-ownership/address-owned">
An address-owned object is owned by a specific 32-byte address that is either an account address (derived from a particular signature scheme) or an object ID. An address-owned object is accessible only to its owner and no others. 
</Card>
<Card title="Immutable" href="/concepts/object-ownership/immutable">
An immutable object is an object that can't be mutated, transferred, or deleted. Immutable objects have no owner, so anyone can use them.
</Card>
<Card title="Party" href="/concepts/object-ownership/party">
A party object is an object that is transferred using the `0x2::transfer::party_transfer` or `0x2::transfer::public_party_transfer` function and is accessible by the `Party` to which it is transferred. Party objects can be singly owned, but unlike address-owned objects, they are versioned by consensus.
</Card>
<Card title="Shared" href="/concepts/object-ownership/shared">
A shared object is an object that is shared using the `0x2::transfer::share_object` function and is accessible to everyone. Unlike owned objects, anyone can access shared ones on the network.
</Card>
<Card title="Wrapped" href="/concepts/object-ownership/wrapped">
In Move, you can organize data structures by putting a field of `struct` type in another.
</Card>
</Cards>
>>>> sui/docs/content/concepts/object-ownership/address-owned.mdx
---
title: Address-Owned Objects
description: Address-owned objects are owned by a Sui 32-byte address, which can either be an account address or an object ID. Learn how to create and access these objects.
keywords: [ address-owned objects, address-owned, owned objects, objects owned by address, accessing objects, accessing owned objects, address ownership ]
---

An address-owned object is owned by a specific 32-byte address that is either an account address (derived from a particular signature scheme) or an object ID. An address-owned object is accessible only to its owner and no others.

As the owner of the address that holds an address-owned object, you can transfer that object to different addresses. Because only one owner can access an object, transactions must use different owned objects to run in parallel without having to go through consensus.

## Creating address-owned objects

Use these [transfer module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move) functions to create address-owned objects:

```move
public fun transfer<T: key>(obj: T, recipient: address)
public fun public_transfer<T: key + store>(obj: T, recipient: address)
```

Use the `sui::transfer::transfer` function if you are defining [custom transfer rules](/concepts/transfers/custom-rules.mdx) for the object. Use the `sui::transfer::public_transfer` function to create an address-owned object if the object has the `store` capability.

After you declare an object as address-owned, its ownership can change over the life of that object - either by adding it as a dynamic object field, transferring it to a different address, or making it immutable. Importantly though, after you create an object and set its ownership, it cannot be shared.

## Accessing address-owned objects

You can access address-owned objects in 2 different ways, depending on whether or not the address owner of the object corresponds to an object ID.

If the address owner of the object corresponds to an object ID, then you must access and dynamically authenticate it during the execution of the transaction using the mechanisms defined in [Transfer to Object](/concepts/transfers/transfer-to-object.mdx).

If the address owner of the object is a signature-derived address (an account address), then you can use and access it directly as an owned object during the execution of a transaction that address signs. Other addresses cannot access owned objects in any way in a transaction - even to just read the object.

## When to use address-owned objects

Use address-owned objects when you need:
- Single ownership at any time
- Better performance than shared objects
- Avoidance of consensus sequencing

## Example

An example of an object that is frequently address-owned is that of a [Coin object](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/coin.move). If address `0xA11CE` had a coin `C` with 100 SUI and wanted to pay address `0xB0B` 100 SUI, `0xA11CE` could do so by transferring `C` to `0xB0B`.

```move
transfer::public_transfer(C, @0xB0B);
```

This results in `C` having a new address owner of `0xB0B`, and `0xB0B` can later use that 100 SUI coin.
>>>> sui/docs/content/concepts/object-ownership/immutable.mdx
---
title: Immutable Objects
description: Immutable objects cannot be changed, transferred, or deleted. Immutable objects cannot have an owner and anyone can use them.
keywords: [ immutable objects, objects immutable, create immutable object, convert object, use immutable object, test immutable object ]
---

Objects in Sui have different ownership types, with 2 main categories: immutable objects and mutable objects. An immutable object cannot be mutated, transferred, or deleted. These objects have no owner and are freely accessible to everyone.

## Create immutable object

To make an object immutable, call the `public_freeze_object` function from the [transfer module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move):

```move
public native fun public_freeze_object<T: key>(obj: T);
```

This call permanently makes the object immutable. The operation cannot be reversed. Only freeze objects when you are certain they will never need modification.

You can see this function use in one of the [color_object example module](https://github.com/MystenLabs/sui/blob/main/examples/move/color_object/sources/example.move) tests. The test creates a new (owned) `ColorObject`, then calls `public_freeze_object` to turn it into an immutable object.

```move
{
    ts.next_tx(alice);
    // Create a new ColorObject
    let c = new(255, 0, 255, ts.ctx());
    // Make it immutable.
    transfer::public_freeze_object(c);
};
```

In this test, you must own a `ColorObject` initially. After freezing, the object becomes immutable and ownerless.

The `transfer::public_freeze_object` function requires that you pass the object by value. If you are allowed to pass the object by a mutable reference, you could still mutate the object after the `public_freeze_object` call. This contradicts the fact that it should have become immutable.

Alternatively, you can also provide an API that creates an immutable object at creation:

```move
public fun create_immutable(red: u8, green: u8, blue: u8, ctx: &mut TxContext) {
    let color_object = new(red, green, blue, ctx);
    transfer::public_freeze_object(color_object)
}
```

This function creates a new `ColorObject` and immediately makes it immutable before it has an owner.

## Use immutable object

After an object becomes immutable, the rules of who can use this object in Sui Move calls change:
You can only pass an immutable object as a read-only, immutable reference to Sui Move entry functions as `&T`.

All network participants can access immutable objects.

Consider a function that copies the value of one object to another:

```move
public fun copy_into(from: &ColorObject, into: &mut ColorObject);
```

In this function, anyone can pass an immutable object as the first argument, `from`, but not the second argument.
Because you can never mutate immutable objects, there is no data race, even when multiple transactions are using the same immutable object at the same time. Hence, the existence of immutable objects does not pose any requirement on consensus.

## Test immutable object

You can interact with immutable objects in unit tests using `test_scenario::take_immutable<T>` to take an immutable object wrapper from global storage, and `test_scenario::return_immutable` to return the wrapper back to the global storage.

The `test_scenario::take_immutable<T>` function is required because you can access immutable objects solely through read-only references. The `test_scenario` runtime keeps track of the usage of this immutable object. If the compiler does not return the object through `test_scenario::return_immutable` before the start of the next transaction, the test stops.

To see it work in action:

```move
let sender1 = @0x1;
let scenario_val = test_scenario::begin(sender1);
let scenario = &mut scenario_val;
{
    let ctx = test_scenario::ctx(scenario);
    color_object::create_immutable(255, 0, 255, ctx);
};
scenario.next_tx(sender1);
{
    // has_most_recent_for_sender returns false for immutable objects.
    assert!(!test_scenario::has_most_recent_for_sender<ColorObject>(scenario))
};
```

This test submits a transaction as `sender1`, which tries to create an immutable object.

The `has_most_recent_for_sender<ColorObject>` function no longer returns `true`, because the object is no longer owned. To take this object:

```move
// Any sender can work.
let sender2 = @0x2;
scenario.next_tx(sender2);
{
    let object = test_scenario::take_immutable<ColorObject>(scenario);
    let (red, green, blue) = color_object::get_color(object);
    assert!(red == 255 && green == 0 && blue == 255)
    test_scenario::return_immutable(object);
};
```

To show that this object is indeed not owned by anyone, start the next transaction with `sender2`. Note that it used `take_immutable` and succeeded. This means that any sender can take an immutable object. To return the object, call the `return_immutable` function.

To verify immutability, create a function attempting to modify a `ColorObject`:

```move
public fun update(
    object: &mut ColorObject,
    red: u8, green: u8, blue: u8,
) {
    object.red = red;
    object.green = green;
    object.blue = blue;
}
```

As you have learned, the function fails when the `ColorObject` is immutable.

## On-chain interactions

First, view the objects you own:

```sh
$ export ADDR=`sui client active-address`
```
```sh
$ sui client objects $ADDR
```

Publish the `ColorObject` code on-chain using the Sui Client CLI:

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client publish $ROOT/examples/move/color_object --gas-budget <GAS-AMOUNT>
```

Set the package object ID to the `$PACKAGE` environment variable, if you have it set. Then create a new `ColorObject`:

```sh
$ sui client call --gas-budget <GAS-AMOUNT> --package $PACKAGE --module "color_object" --function "create" --args 0 255 0
```

Set the newly created object ID to `$OBJECT`. To view the objects in the current active address:

```sh
$ sui client objects $ADDR
```

You should see an object with the ID you used for `$OBJECT`. To turn it into an immutable object:

```sh
$ sui client call --gas-budget <GAS-AMOUNT> --package $PACKAGE --module "color_object" --function "freeze_object" --args \"$OBJECT\"
```

View the list of objects again:

```sh
$ sui client objects $ADDR
```

`$OBJECT` is no longer listed. It is no longer owned by anyone. You can see that it is now immutable by querying the object information:

```sh
$ sui client object $OBJECT
```

The response includes:

```sh
Owner: Immutable  // This field shows the object's immutable status
```

If you try to mutate it:

```sh
$ sui client call --gas-budget <GAS-AMOUNT> --package $PACKAGE --module "color_object" --function "update" --args \"$OBJECT\" 0 0 0
```

The response indicates that you cannot pass an immutable object to a mutable argument.
>>>> sui/docs/content/concepts/object-ownership/party.mdx
---
title: Party Objects
description: Party objects are owned by a specified party at the time of transfer and versioned by consensus. Learn how to create and access these objects.
---

A party object is an object that is transferred using the `sui::transfer::party_transfer` or `sui::transfer::public_party_transfer` function. It is accessible to the `Party` to which it is transferred.


Party objects combine some properties of address-owned objects and shared objects. Like address-owned objects, they can be owned by a single address. Like shared objects, they are versioned by consensus. Unlike shared objects, they can be transferred to and from other ownership types and wrapped.

:::info

Currently, single ownership is the only supported mode for party objects. This topic will be updated if support for multiple owners or more granular permissions is added.

:::

## When to use party objects

Use party objects when you want an object to be versioned by consensus, such as for operational convenience. If an object is only used with other party or shared objects, converting it to a party object has no additional performance cost.

Party objects can be used by multiple inflight transactions at the same time. This contrasts with address-owned objects, which only allow a single inflight transaction. Many applications can benefit from the ability to pipeline multiple transactions on the same party object.

:::info

`Coin`s can be party objects, including `Coin<SUI>`. However, you cannot use a party object `Coin<SUI>` for gas payment. To use a party object `Coin<SUI>` for gas, you must first transfer it back to address-owned.

:::

## Creating party objects

Use one of the following functions (defined in the [transfer module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/transfer.move)) to create party objects:

```move
public fun party_transfer<T: key>(obj: T, party: sui::party::Party)
public fun public_party_transfer<T: key + store>(obj: T, party: sui::party::Party)
```

Use the `sui::transfer::party_transfer` function if you are defining a [custom transfer policy](../transfers/custom-rules.mdx) for the object. Use the `sui::transfer::public_party_transfer` function if the object has the `store` capability.

A party object's ownership can change over its lifetime. For example, by adding it as a dynamic object field, transferring it to a different address or ownership type, or making it immutable. One exception: after you create an object and set its ownership, you cannot later share it.

## Accessing party objects

You can specify party objects as input to a transaction in the same way as shared objects. Sui validators ensure that the sender of the transaction can access the object. The validator might abort a transaction at execution time if the owner of an input party object has changed due to an earlier, conflicting transaction.

Party objects whose owning address corresponds to an object ID are not supported for access through the [transfer to object](/concepts/transfers/transfer-to-object.mdx) mechanism.
>>>> sui/docs/content/concepts/object-ownership/shared.mdx
---
title: Shared Objects
description: Anyone can access shared objects on the Sui network, so care must be taken to secure access, if needed.
keywords: [ shared objects, sharing objects, objects that are shared, public objects, accessing shared objects, accessing public objects ]
---

Use the `sui::transfer::share_object` function to create a shared object, making it publicly accessible on the network. Extended functionality and accessibility of shared objects requires additional effort by securing access, if needed.

Shared objects require the `key` ability.

## Usage example

The following example creates a shop to sell digital donuts. Everyone needs access to the shop to purchase donuts from it, so the example creates the shop as a shared object using `sui::transfer::share_object`.

```move
module examples::donuts;

use sui::sui::SUI;
use sui::coin::{Self, Coin};
use sui::balance::{Self, Balance};

/// For when Coin balance is too low.
const ENotEnough: u64 = 0;

/// Capability that grants an owner the right to collect profits.
public struct ShopOwnerCap has key { id: UID }

/// A purchasable Donut. For simplicity's sake we ignore implementation.
public struct Donut has key { id: UID }

/// A shared object. `key` ability is required.
public struct DonutShop has key {
    id: UID,
    price: u64,
    balance: Balance<SUI>
}

/// Init function is often ideal place for initializing
/// a shared object as it is called only once.
fun init(ctx: &mut TxContext) {
    transfer::transfer(ShopOwnerCap {
        id: object::new(ctx)
    }, ctx.sender());

    // Share the object to make it accessible to everyone!
    transfer::share_object(DonutShop {
        id: object::new(ctx),
        price: 1000,
        balance: balance::zero()
    })
}

/// Entry function available to everyone who owns a Coin.
public fun buy_donut(
    shop: &mut DonutShop, payment: &mut Coin<SUI>, ctx: &mut TxContext
) {
    assert!(coin::value(payment) >= shop.price, ENotEnough);

    // Take amount = `shop.price` from Coin<SUI>
    let paid = payment.balance_mut.split(shop.price);

    // Put the coin to the Shop's balance
    shop.balance.join(paid);

    transfer::transfer(Donut {
        id: object::new(ctx)
    }, ctx.sender())
}

/// Consume donut and get nothing...
public fun eat_donut(d: Donut) {
    let Donut { id } = d;
    id.delete();
}

/// Take coin from `DonutShop` and transfer it to tx sender.
/// Requires authorization with `ShopOwnerCap`.
public fun collect_profits(
    _: &ShopOwnerCap, shop: &mut DonutShop, ctx: &mut TxContext
) {
    let amount = shop.balance.value();
    let profits = shop.balance.split(amount).into_coin(ctx);

    transfer::public_transfer(profits, ctx.sender())
}
```

>>>> sui/docs/content/concepts/object-ownership/wrapped.mdx
---
title: Wrapped Objects
description: Wrapped objects are object data structures nested inside of another object data structure. Objects can be wrapped directly, through `Option`, or through `vector` fields. 
keywords: [ wrapped objects, wrapping objects, unwrapping objects, direct wrapping, wrap directly, wrap object directly, wrap object option, option wrap, vector wrap, wrap object vector ]
---

You can nest structs to organize data structures in Move. This example shows a basic wrapper pattern:

```move
public struct Foo has key {
    id: UID,
    bar: Bar,
}

public struct Bar has store {
    value: u64,
}
```

To embed a struct type in a Sui object struct (with a `key` ability), the struct type must have the `store` ability.

In the preceding example, `Bar` is a normal struct, but it is not a Sui object since it doesn't have the `key` ability.

The following code turns `Bar` into an object, which you can still wrap in `Foo`:

```move
public struct Bar has key, store {
    id: UID,
    value: u64,
}
```

Now `Bar` is also a Sui object type. If you put a Sui object of type `Bar` into a Sui object of type `Foo`, the object type `Foo` wraps the object type `Bar`. The object type `Foo` is the wrapper or wrapping object.

There are some interesting consequences of wrapping a Sui object into another. When an object is wrapped, the object no longer exists independently on-chain. You can no longer look up the object by its ID. The object becomes part of the data of the object that wraps it. Most importantly, you can no longer pass the wrapped object as an argument in any way in Sui Move calls. The only access point is through the wrapping object.

It is not possible to create circular wrapping behavior, where A wraps B, B wraps C, and C also wraps A.

At some point, you can then take out the wrapped object and transfer it to an address, modify it, delete it, or freeze it. This is called **unwrapping**. When an object is **unwrapped**, it becomes an independent object again, and can be accessed directly on-chain. There is also an important property about wrapping and unwrapping: the object's ID stays the same across wrapping and unwrapping.

There are a few ways to wrap a Sui object into another Sui object, and their use cases are typically different. This section describes three different ways to wrap a Sui object with typical use cases.

### Direct wrapping

**Direct wrapping** occurs when a Sui object type contains another Sui object type as a direct field. The most important properties achieved through direct wrapping are:

- The wrapped object cannot be extracted without destroying the wrapper
- Provides strong encapsulation guarantees
- Ideal for implementing object locking patterns
- Requires explicit contract calls to modify access

The following example implementation of a trusted swap demonstrates how to use direct wrapping. Assume there is an NFT-style `Object` type that has `scarcity` and `style`. In this example, `scarcity` determines how rare the object is (presumably the more scarce the higher its market value), and `style` determines the object content/type or how it's rendered. If you own some of these objects and want to trade your objects with others, you want to make sure it's a fair trade. You are willing to trade an object only with another one that has identical `scarcity`, but want a different `style` (so that you can collect more styles).

First, define such an object type:

```move
public struct Object has key, store {
    id: UID,
    scarcity: u8,
    style: u8,
}
```

In a real application, you might make sure that there is a limited supply of the objects, and there is a mechanism to mint them to a list of owners. For simplicity and demonstration purposes, this example simplifies creation:

```move
public fun new(scarcity: u8, style: u8, ctx: &mut TxContext): Object {
    Object { id: object::new(ctx), scarcity, style }
}

```

You can also enable a swap or trade between your object and others' objects. For example, define a function that takes two objects from two addresses and swaps their ownership. This doesn't work in Sui. Only object owners can send a transaction to mutate the object. One person cannot send a transaction that would swap their own object with someone else's object.

Another common solution is to send your object to a pool, such as an NFT marketplace or a staking pool, and perform the swap in the pool, either right away, or later when there is demand. Transactions using only owned objects are faster and less expensive (in terms of gas) than using shared objects, because they do not require consensus in Sui.

To swap objects, the same address must own both objects. Anyone who wants to swap their object can send their objects to the third party, such as a site that offers swapping services, and the third party helps perform the swap and send the objects to the appropriate owner. To ensure that you retain custody of your objects (such as coins and NFTs) and not give full custody to the third party, use direct wrapping. To define a wrapper object type:

```move
public struct SwapRequest has key {
    id: UID,
    owner: address,
    object: Object,
    fee: Balance<SUI>,
}
```

`SwapRequest` defines a Sui object type, wraps the `object` to swap, and tracks the original `owner` of the object. You might need to also pay the third party some fee for this swap. To define an interface to request a swap by someone who owns an `Object`:

```move
public fun request_swap(
    object: Object,
    fee: Coin<SUI>,
    service: address,
    ctx: &mut TxContext,
) {
    assert!(coin::value(&fee) >= MIN_FEE, EFeeTooLow);

    let request = SwapRequest {
        id: object::new(ctx),
        owner: ctx.sender(),
        object,
        fee: coin::into_balance(fee),
    };

    transfer::transfer(request, service)
}

```

In the preceding function, you must pass the object by value so that it's fully consumed and wrapped into `SwapRequest` to request swapping an `object`. The example also provides a fee (in the type of `Coin<SUI>`) and checks that the fee is sufficient. The example turns `Coin` into `Balance` when it's put into the `wrapper` object. This is because `Coin` is a Sui object type and used only to pass around as Sui objects (such as transaction inputs or objects sent to addresses). For coin balances that need to be embedded in other structs, use `Balance` instead because to avoid the overhead of carrying around an unnecessary `UID` field.

The wrapper object is then sent to the service operator, with the address specified in the call as `service`.

The function interface for the function that the service operator can call to perform a swap between two objects sent from two addresses resembles:

```move
public fun execute_swap(s1: SwapRequest, s2: SwapRequest): Balance<SUI>;
```

Where `s1` and `s2` are two wrapped objects that were sent from different object owners to the service operator. Both wrapped objects are passed by value because they eventually need to be [unpacked](https://move-book.com/move-basics/struct.html#destructing-structures).

First, unpack the two object to obtain the inner fields:

```move
let SwapRequest {id: id1, owner: owner1, object: o1, fee: fee1} = s1;
let SwapRequest {id: id2, owner: owner2, object: o2, fee: fee2} = s2;
```

Then, check that the swap is legitimate (the two objects have identical scarcity and different styles):

```move
assert!(o1.scarcity == o2.scarcity, EBadSwap);
assert!(o1.style != o2.style, EBadSwap);
```

To perform the actual swap:

```move
transfer::transfer(o1, owner2);
transfer::transfer(o2, owner1);
```

The preceding code sends `o1` to the original owner of `o2`, and sends `o2` to the original owner of `o1`. The service can then delete the wrapping `SwapRequest` objects:

```move
id1.delete();
id2.delete();
```

Finally, the service merges together the `fee1` and `fee2`, and returns it.  The service provider can then turn it into a coin, or merge it into some larger pool where it collects all fees:

```move
fee1.join(fee2);
```

After this call, the 2 objects are swapped and the service provider takes the service fee.

Because the contract defined only one way to deal with `SwapRequest` (`execute_swap`), there is no other way the service operator can interact with `SwapRequest` despite its ownership.

Find the full source code in the [trusted_swap](https://github.com/MystenLabs/sui/blob/main/examples/move/trusted_swap) example.


### Wrapping through `Option`

When Sui object type `Bar` is directly wrapped into `Foo`, there is not much flexibility: a `Foo` object must have a `Bar` object in it, and to take out the `Bar` object you must destroy the `Foo` object. However, for more flexibility, the wrapping type might not always have the wrapped object in it, and the wrapped object might be replaced with a different object at some point.


To demonstrate this use case, design a simple game character: A warrior with a sword and shield. A warrior might have a sword and shield, or might not have either. The warrior should be able to add a sword and shield, and replace the current ones at any time. To design this, define a `SimpleWarrior` type:

```move
public struct SimpleWarrior has key {
    id: UID,
    sword: Option<Sword>,
    shield: Option<Shield>,
}
```

Each `SimpleWarrior` type has an optional `sword` and `shield` wrapped in it, defined as:

```move
public struct Sword has key, store {
    id: UID,
    strength: u8,
}

public struct Shield has key, store {
    id: UID,
    armor: u8,
}
```

When you create a new warrior, set the `sword` and `shield` to `none` to indicate there is no equipment yet:

```move
public fun create_warrior(ctx: &mut TxContext) {
    let warrior = SimpleWarrior {
        id: object::new(ctx),
        sword: option::none(),
        shield: option::none(),
    };
    transfer::transfer(warrior, ctx.sender())
}
```

You can then define functions to equip new swords or new shields:

```move
public fun equip_sword(warrior: &mut SimpleWarrior, sword: Sword, ctx: &mut TxContext) {
    if (warrior.sword.is_some()) {
        let old_sword = warrior.sword.extract();
        transfer::transfer(old_sword, ctx.sender());
    };
    warrior.sword.fill(sword);
}
```

The function in the preceding example passes a `warrior` as a mutable reference of `SimpleWarrior`, and passes a `sword` by value to wrap it into the `warrior`.

Note that because `Sword` is a Sui object type without `drop` ability, if the warrior already has a sword equipped, the warrior can't drop that sword. If you call `option::fill` without first checking and taking out the existing sword, an error occurs. In `equip_sword`, first check whether there is already a sword equipped. If so, remove it out and send it back to the sender. To a player, this returns an equipped sword to their inventory when they equip the new sword.

Find the source code in the [simple_warrior](https://github.com/MystenLabs/sui/tree/main/examples/move/simple_warrior) example.

To view a more complex example, see [hero](https://github.com/MystenLabs/sui/tree/main/examples/move/hero).

### Wrapping through `vector`

The concept of wrapping objects in a vector field of another Sui object is very similar to wrapping through `Option`: an object can contain 0, 1, or many of the wrapped objects of the same type.
Wrapping through vector resembles:

```move
public struct Pet has key, store {
    id: UID,
    cuteness: u64,
}

public struct Farm has key {
    id: UID,
    pets: vector<Pet>,
}
```

The preceding example wraps a vector of `Pet` in `Farm`, and can be accessed only through the `Farm` object.

>>>> sui/docs/content/concepts/research-papers.mdx
---
title: Sui-Related Research Papers
sidebar_label: Research Papers
description: Research papers that are relevant to Sui and that one or more Sui team members have co-authored.
keywords: [ research papers, sui papers, academic papers, research, sui research, sui publications, published papers, published research ] 
pagination_prev: null
---

This document contains a list of research papers that are relevant to Sui and that one or more Sui team members have co-authored.
Some of the ideas of these papers are currently being integrated into Sui, others are in our roadmap, and others are not in our roadmap
but could be integrated in the future. Start with the [Sui Smart Contract Platform](/doc/sui.pdf) white paper, which contains
our latest design inspired by previous works below.

<div class="bg-sui-blue-light dark:bg-sui-gray-95 p-8 rounded-lg border border-solid border-sui-blue-dark">

<p class="text-sui-gray-80 text-xl font-bold italic">Latest</p>

## Mysticeti: Reaching the Limits of Latency with Uncertified DAGs {#mysticeti}

- **Link:** https://arxiv.org/pdf/2310.14821
- **Publication:** Network and Distributed System Security Symposium (NDSS), accepted for 2025
- **Relevance:** We introduce Mysticeti-C, the first DAG-based Byzantine consensus protocol to achieve the lower bounds of latency of 3 message rounds. Since Mysticeti-C is built over DAGs it also achieves high resource efficiency and censorship resistance. Mysticeti-C achieves this latency improvement by avoiding explicit certification of the DAG blocks and by proposing a novel commit rule such that every block can be committed without delays, resulting in optimal latency in the steady state and under crash failures. We further extend Mysticeti-C to Mysticeti-FPC, which incorporates a fast commit path that achieves even lower latency for transferring assets. Unlike prior fast commit path protocols, Mysticeti-FPC minimizes the number of signatures and messages by weaving the fast path transactions into the DAG. This frees up resources, which subsequently result in better performance. We prove the safety and liveness in a Byzantine context. We evaluate both Mysticeti protocols and compare them with state-of-the-art consensus and fast path protocols to demonstrate their low latency and resource efficiency, as well as their more graceful degradation under crash failures. Mysticeti-C is the first Byzantine consensus protocol to achieve WAN latency of 0.5s for consensus commit while simultaneously maintaining state-of-the-art throughput of over 200k TPS. Finally, we report on integrating Mysticeti-C as the consensus protocol into the Sui blockchain, resulting in over 4x latency reduction.

## Sui Lutris: A Blockchain Combining Broadcast and Consensus

- **Link:** https://arxiv.org/pdf/2310.18042
- **Publication:** Conference on Computer and Communications Security (CCS), 2024
- **Relevance:** Sui Lutris is the first smart-contract platform to sustainably achieve sub-second finality. It achieves this significant decrease by employing consensusless agreement not only for simple payments but for a large variety of transactions. Unlike prior work, Sui Lutris neither compromises expressiveness nor throughput and can run perpetually without restarts. Sui Lutris achieves this by safely integrating consensuless agreement with a high-throughput consensus protocol that is invoked out of the critical finality path but ensures that when a transaction is at risk of inconsistent concurrent accesses, its settlement is delayed until the total ordering is resolved. Building such a hybrid architecture is especially delicate during reconfiguration events, where the system needs to preserve the safety of the consensusless path without compromising the long-term liveness of potentially misconfigured clients. We thus develop a novel reconfiguration protocol, the first to provably show the safe and efficient reconfiguration of a consensusless blockchain. Sui Lutris is currently running in production and underpins the Sui smart-contract platform. Combined with the use of Objects instead of accounts it enables the safe execution of smart contracts that expose objects as a first-class resource. In our experiments Sui Lutris achieves latency lower than 0.5 seconds for throughput up to 5,000 certificates per second (150k ops/s with transaction blocks), compared to the state-of-the-art real-world consensus latencies of 3 seconds. Furthermore, it gracefully handles validators crash-recovery and does not suffer visible performance degradation during reconfiguration.

## zkLogin: Privacy-Preserving Blockchain Authentication with Existing Credentials

- **Link:** https://arxiv.org/pdf/2401.11735
- **Publication:** Not published
- **Relevance:** For many users, a private key based wallet serves as the primary entry point to blockchains. Commonly recommended wallet authentication methods, such as mnemonics or hardware wallets, can be cumbersome. This difficulty in user onboarding has significantly hindered the adoption of blockchain-based applications.
We develop zkLogin, a novel technique that leverages identity tokens issued by popular platforms (any OpenID Connect enabled platform e.g. Google, Facebook, etc.) to authenticate transactions. At the heart of zkLogin lies a signature scheme allowing the signer to sign using their existing OpenID accounts and nothing else. This improves the user experience significantly as users do not need to remember a new secret and can reuse their existing accounts.
zkLogin provides strong security and privacy guarantees. By design, zkLogin builds on top of the underlying platform's authentication mechanisms, and derives its security from there. Unlike prior related works however, zkLogin avoids the use of additional trusted parties (e.g., trusted hardware or oracles) for its security guarantees. zkLogin leverages zero-knowledge proofs (ZKP) to ensure that the link between a user's off-chain and on-chain identities is hidden, even from the platform itself.
zkLogin is implemented and deployed on the Sui blockchain as an alternative to traditional digital signature-based addresses. Due to the ease of Web3 on-boarding just with social login, without requiring mnemonics, many hundreds of thousands zkLogin accounts have already been generated in various industries such as gaming, DeFi, direct payments, NFT collections, ride sharing, sports racing and many more.
</div>

## Be Aware of Your Leaders {#awareness}

- **Link:** https://arxiv.org/abs/2110.00960
- **Publication:** Financial Cryptography and Data Security (FC), 2022
- **Relevance:** Provides a performant leader election algorithm for partially-synchronous consensus protocol (such as Bullshark). Sui may want to use it
  alongside Bullshark to support shared objects.
- **Summary:** Advances in blockchains have influenced the State-Machine-Replication (SMR) world and many state-of-the-art blockchain-SMR solutions are
  based on two pillars: Chaining and Leader-rotation. A predetermined round-robin mechanism used for Leader-rotation, however, has an undesirable behavior:
  crashed parties become designated leaders infinitely often, slowing down overall system performance. In this paper, we provide a new Leader-Aware SMR
  framework that, among other desirable properties, formalizes a Leader-utilization requirement that bounds the number of rounds whose leaders are faulty
  in crash-only executions. We introduce Carousel, a novel, reputation-based Leader-rotation solution to achieve Leader-Aware SMR. The challenge in adaptive
  Leader-rotation is that it cannot rely on consensus to determine a leader, since consensus itself needs a leader. Carousel uses the available on-chain
  information to determine a leader locally and achieves Liveness despite this difficulty. A HotStuff implementation fitted with Carousel demonstrates
  drastic performance improvements: it increases throughput over 2x in faultless settings and provides a 20x throughput increase and 5x latency reduction
  in the presence of faults.

## Bullshark: DAG BFT Protocols Made Practical {#bullshark}

- **Link:** https://arxiv.org/abs/2201.05677
- **Publication:** Not published yet (under submission)
- **Relevance:** Provides a partially-synchronous consensus protocol running over Narwhal. Sui may want to use it instead of Tusk.
- **Summary:** We present Bullshark, the first directed acyclic graph (DAG) based Byzantine Fault Tolerant (BFT) protocol that is optimized for partial synchrony.
  Bullshark inherits all the desired properties of its predecessor (DAG-Rider) such as optimal amortized complexity, asynchronous liveness, zero-overhead,
  and post-quantum safety; but at the same time Bullshark provides a practical low-latency fast-path that exploits synchronous periods. In addition, we introduce
  a standalone partially synchronous version of Bullshark and evaluate it against the state of the art. The resulting protocol is embarrassingly simple 20 LOC
  on top of a DAG-based mempool implementation) and highly efficient, achieving for example, 125k transactions per second and 2 seconds latency with 50 nodes.

## FastPay: High-Performance Byzantine Fault Tolerant Settlement {#fastpay}

- **Link:** https://arxiv.org/abs/2003.11506
- **Publication:** ACM Conference on Advances in Financial Technologies (AFT), 2020
- **Relevance:** FastPay describes the core protocol at the heart of Sui.
- **Summary:** FastPay allows a set of distributed validators, some of which are Byzantine, to maintain a high-integrity and availability
  settlement system for pre-funded payments. It can be used to settle payments in a native unit of value (crypto-currency), or as a financial
  side-infrastructure to support retail payments in fiat currencies. This is not the protocol Sui uses, yet it proposes the basic safety mechanism
  that Sui extends. FastPay is based on Byzantine Consistent Broadcast as its core primitive, foregoing the expenses of full atomic commit channels
  (consensus). The resulting system has low-latency for both confirmation and payment finality. Remarkably, each validator can be sharded across many
  machines to allow unbounded horizontal scalability.

## HammerHead: Score-based Dynamic Leader Selection

- **Link:** https://arxiv.org/pdf/2309.12713
- **Publication:** IEEE International Conference on Distributed Computing Systems (ICDCS), 2024
- **Relevance:** The need for high throughput and censorship resistance in
blockchain technology has led to research on DAG-based consensus. The
Sui blockchain protocol uses a variant of the Bullshark consensus
algorithm due to its lower latency, but this leader-based protocol causes
performance issues when candidate leaders crash. In this paper, we explore the ideas pioneered by Carousel on providing Leader-Utilization
and present HammerHead. Unlike Carousel, which is built with a chained
and pipelined consensus protocol in mind, HammerHead does not need
to worry about chain quality as it is directly provided by the DAG, but
needs to make sure that even though validators might commit blocks
in different views the safety and liveness is preserved. Our implementation of HammerHead shows a slight performance increase in a faultless
setting, and a drastic 2x latency reduction and up to 40% throughput
increase when suffering faults (100 validators, 33 faults).

## Narwhal and Tusk: A DAG-based Mempool and Efficient BFT Consensus {#narwhal-and-tusk}

- **Link:** https://arxiv.org/abs/2105.11827
- **Publication:** EuroSys, 2022
- **Relevance:** The consensus system that we will likely use to support shared-objects in Sui.
- **Summary:** We propose separating the task of reliable transaction dissemination from transaction ordering to enable high-performance Byzantine
  fault-tolerant quorum-based consensus. We design and evaluate a mempool protocol, Narwhal, specializing in high-throughput reliable dissemination
  and storage of causal histories of transactions. Narwhal tolerates an asynchronous network and maintains high performance despite failures. Narwhal
  is designed to easily scale-out using multiple workers at each validator, and we demonstrate that there is no foreseeable limit to the throughput we
  can achieve. Composing Narwhal with a partially synchronous consensus protocol (Narwhal-HotStuff) yields significantly better throughput even in the
  presence of faults or intermittent loss of liveness due to asynchrony. However, loss of liveness can result in higher latency. To achieve overall
  good performance when faults occur we design Tusk, a zero-message overhead asynchronous consensus protocol, to work with Narwhal. We demonstrate its
  high performance under a variety of configurations and faults. As a summary of results, on a WAN, Narwhal-Hotstuff achieves more than 130,000 tx/sec at
  less than 2-sec latency compared with 1,800 tx/sec at 1-sec latency for Hotstuff. Additional workers increase throughput linearly to 600,000 tx/sec
  without any latency increase. Tusk achieves 160,000 tx/sec with about 3 seconds latency. Under faults, both protocols maintain high throughput, but
  Narwhal-HotStuff suffers from increased latency.

## SybilQuorum: Open Distributed Ledgers Through Trust Networks {#sybilquorum}

- **Link:** https://arxiv.org/abs/1906.12237
- **Publication:** Not published
- **Relevance:** Less related to Sui than the other papers, and the paper is in its early stages. It presents an algorithm to strengthen proof-of-Stake systems (like Sui). The paper is, however, theoretical and not on our roadmap.
- **Summary:** The Sybil attack plagues all peer-to-peer systems, and modern open distributed ledgers employ a number of tactics to prevent it from proof
  of work, or other resources such as space, stake or memory, to traditional admission control in permissioned settings. With SybilQuorum we propose an
  alternative approach to securing an open distributed ledger against Sybil attacks, and ensuring consensus amongst honest participants, leveraging social
  network based Sybil defenses. We show how nodes expressing their trust relationships through the ledger can bootstrap and operate a value system, and
  general transaction system, and how Sybil attacks are thwarted. We empirically evaluate our system as a secure Federated Byzantine Agreement System, and
  extend the theory of those systems to do so.

## Twins: BFT Systems Made Robust {#twins}

- **Link:** https://arxiv.org/abs/2004.10617
- **Publication:** International Conference on Principles of Distributed Systems (OPODIS), 2021
- **Relevance:** Less related to Sui than the other papers, this provides a way to test implementations of consensus systems, such as Tusk and Bullshark.
  The paper is, however, theoretical and not on our roadmap.
- **Summary:** This paper presents Twins, an automated unit test generator of Byzantine attacks. Twins implements three types of Byzantine behaviors: (i)
  leader equivocation, (ii) double voting, and (iii) losing internal state such as forgetting 'locks' guarding voted values. To emulate interesting attacks
  by a Byzantine node, it instantiates twin copies of the node instead of one, giving both twins the same identities and network credentials. To the rest of
  the system, the twins appear indistinguishable from a single node behaving in a 'questionable' manner. Twins can systematically generate Byzantine attack
  scenarios at scale, execute them in a controlled manner, and examine their behavior. Twins scenarios iterate over protocol rounds and vary the communication
  patterns among nodes. Twins runs in a production setting within DiemBFT where it can execute 44M Twins-generated scenarios daily. Whereas the system at hand
  did not manifest errors, subtle safety bugs that were deliberately injected for the purpose of validating the implementation of Twins itself were exposed
  within minutes. Twins can prevent developers from regressing correctness when updating the codebase, introducing new features, or performing routine
  maintenance tasks. Twins requires only a thin wrapper over DiemBFT; we thus envision other systems using it. Building on this idea, one new attack and
  several known attacks against other BFT protocols were materialized as Twins scenarios. In all cases, the target protocols break within fewer than a dozen
  protocol rounds. Hence it is realistic for the Twins approach to expose the problems.

## Zef: Low-latency, Scalable, Private Payments {#zef}

- **Link:** https://arxiv.org/abs/2201.05671
- **Publication:** Not published yet (under submission)
- **Relevance:** Extends the FastPay design to support objects (rather than accounts), what Sui actually uses. An additional contribution of this paper is
  to add strong privacy to FastPay transactions (but Sui does not plan to do this).
- **Summary:** We introduce Zef, the first Byzantine-Fault Tolerant (BFT) protocol to support payments in anonymous digital coins at arbitrary scale. Zef
  follows the communication and security model of FastPay: both protocols are asynchronous, low-latency, linearly-scalable, and powered by partially-trusted
  sharded validators. Zef further introduces opaque coins represented as off-chain certificates that are bound to user accounts. In order to hide the face
  values of coins when a payment operation consumes or creates them, Zef uses random commitments and NIZK proofs. Created coins are made unlinkable using the
  blind and randomizable threshold anonymous credentials of [Coconut](https://arxiv.org/pdf/1802.07344.pdf). To control storage costs associated with coin
  replay prevention, Zef accounts are designed so that data can be safely removed once an account is deactivated. Besides the specifications and a detailed
  analysis of the protocol, we are making available an open source implementation of Zef in Rust. Our extensive benchmarks on AWS confirm textbook linear
  scalability and demonstrate a confirmation time under one second at nominal capacity. Compared to existing anonymous payment systems based on a blockchain,
  this represents a latency speedup of three orders of magnitude, with no theoretical limit on throughput.

>>>> sui/docs/content/concepts/sui-architecture.mdx
---
title: Sui Architecture
description: Use the topics in this section to understand the components of the Sui network.
keywords: [ sui architecture, sui security, sui transactions, consensus, sui consensus, mysticeti, sui indexer, indexers, protocol upgrades, sui upgrades ]
pagination_prev: null
---

Sui shares some similarities with other blockchains but is unique in many ways. Use the topics in this section to understand the features that define the Sui network.

<Cards>
<Card title="Understand Sui security" href="/concepts/sui-architecture/sui-security">
</Card>
<Card title="Life of a Transaction" href="/concepts/sui-architecture/transaction-lifecycle">
</Card>
<Card title="Consensus" href="/concepts/sui-architecture/consensus">
</Card>
<Card title="Sui Indexer" href="/concepts/sui-architecture/indexer-functions">
</Card>
<Card title="Sui Storage Cost" href="/concepts/sui-architecture/sui-storage">
</Card>
<Card title="Protocol Upgrades" href="/concepts/sui-architecture/protocol-upgrades">
</Card>
</Cards>

>>>> sui/docs/content/concepts/sui-architecture/consensus.mdx
---
title: Consensus
sidebar_label: Consensus
description: Overview of the Sui consensus mechanism.
---

The purpose of consensus in blockchains is to agree on a consistent order and ensure the availability of transactions.

On Sui, consensus has a straightforward API. Validators submit different user transactions to consensus concurrently. The consensus outputs a consistent stream of transactions across all well-behaving validators.

Sui uses the Mysticeti protocol to optimize for both low latency and high throughput. Mysticeti provides the following benefits:

- Supports multiple validators proposing blocks in parallel, which uses the full bandwidth of the network and provides censorship resistance. These are features of DAG-based consensus protocols.
- Requires only three rounds of messages to commit blocks from the DAGs. This is the same as practical Byzantine Fault Tolerance and matches the theoretical minimum.
- Allows voting and certifying leaders on blocks in parallel, which reduces median and tail latencies.
- Tolerates unavailable leaders without significantly increasing commit latencies.

## Transaction throughput

Compared to other state-of-the-art consensus protocols, Mysticeti can theoretically handle more than twice as many transactions with half the observed latency. In a controlled environment using 10 nodes, Mysticeti handles 300,000 transactions per second (TPS) before latency crosses the one-second marker. With 50 nodes, test results show 400,000 TPS before latency exceeds one second. In the same tests, other top performing consensus mechanisms do not reach 150,000 TPS and their observed latency starts at about two seconds.

On average, testing shows Mysticeti reaches consensus commitment in about **0.5 seconds** with a sustained throughput of **200,000 TPS**.

![Throughput and latency graph](./images/thruput_latency.png)

## Decision rule

The decision rule at the core of Mysticeti optimizes operational efficiency. Traditional consensus decision rules require explicit block validation and certification. This process increases communication overhead because validators must sign and broadcast votes to reach consensus. By contrast, Mysticeti provides implicit commitment, which reduces inter-node communication and lowers bandwidth usage.

## Finality

Finality is the guarantee that a transaction or block, after confirmation, is permanently added to the network and cannot be altered or reversed. In traditional blockchain consensus, confirming transactions can take time because they rely on other transactions to reference them before they are considered final. This process slows down if network activity decreases or if there are many competing transactions. Mysticeti simplifies this process by finalizing transactions immediately upon inclusion in the structure. As a result, there is no need to wait for additional confirmations or network activity, which makes Mysticeti faster and more reliable for confirming transactions in less active or challenging network conditions.

For more details, including correctness proofs, see the [MYSTICETI: Reaching the Latency Limits with Uncertified DAGs](/paper/mysticeti.pdf) whitepaper.

## Related links

<RelatedLink to="/concepts/sui-architecture/transaction-lifecycle.mdx" />
<RelatedLink to="/concepts/sui-architecture/sui-security.mdx" />
<RelatedLink href="https://docs.sui.io/paper/mysticeti.pdf" label="MYSTICETI: Reaching the Latency Limits with Uncertified DAGs" desc="Whitepaper that documents the Mysticeti protocol." />
>>>> sui/docs/content/concepts/sui-architecture/data-management-things.mdx
---
title: Archival, Snapshots, Pruning Policies, Indexing
draft: true
---

Content coming soon
>>>> sui/docs/content/concepts/sui-architecture/epochs.mdx
---
title: Epochs and Reconfiguration
draft: true
---

In a simplified view, epochs are to the Sui network what individual days are to a calendar. Reconfiguration, then, is a process at the end of each epoch where that day's activity is tallied and the next day's parameters are set.

## Epoch

An epoch is a duration of time where the Sui validator set and their stakes remain unchanged. On both Mainnet and Testnet, an epoch is about 24 hours. This timeframe allows validators to process transactions efficiently without worrying about ad hoc validator changes during the middle of an epoch.

Epoch values are included in the metadata of transactions on the Sui network, but the average user is unaffected by its value. The only time a user might need to know about epochs is in the case of expiring transactions, where a transaction is only valid if executed before a set epoch. See [Transactions](../transactions.mdx) for more information about transactions on Sui.

## Reconfiguration

Reconfiguration is a critical process occurring at the end of each epoch. It involves several key steps to adjust the network for the upcoming epoch:

1. **Finalizing transactions and checkpoints**
    - The network reaches consensus on the final set of transactions and checkpoints for the current epoch. This ensures all validators have an identical state at epoch conclusion.
    - **Synchronous moment:** This is the only fully synchronous event in the network, crucial for maintaining consistency.
1. **Distribution of gas rewards**
    - Computation gas fees are distributed to the validator staking reward pool, from which stakers can withdraw.
    - Storage fees are allocated to a storage fund, playing a vital role in the Sui tokenomics, as explained in [Tokenomics](../tokenomics.mdx).
1. **Validator set change**
    - Any pending staking and unstaking requests during the epoch are finalized and reflected in validators stake distribution.
    - Any pending validator change requests are also processed, including adding new validators and removing existing validators. This is the sole opportunity for altering the validator set and stake distribution.
1. **Protocol upgrade**
    - If agreed upon by 2f+1 validators, the network might upgrade to a new protocol version, encompassing new features, bug fixes, and updates to Move framework libraries.
>>>> sui/docs/content/concepts/sui-architecture/high-level.mdx
---
title: High Level Diagram
draft: true
---

Content coming soon
>>>> sui/docs/content/concepts/sui-architecture/indexer-functions.mdx
---
title: Sui Indexer
description: Sui Indexer is an off-full node data service that serves data from the Sui protocol, including both data directly generated from chain and derivative data.
---

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

>>>> sui/docs/content/concepts/sui-architecture/protocol-upgrades.mdx
---
title: Protocol Upgrades
description: The Sui protocol, framework, and execution engine are frequently extended to include new functionality and bug fixes. The upgrade process ensures all clients use the same source.
---

The Sui protocol, framework, and execution engine are frequently extended to include new functionality and bug fixes. This functionality is added as new code released to validator operators as part of regular software releases. The Sui protocol requires that all validators agree on the results of executing each transaction.

This creates a challenge: how is code released that changes transaction execution, given that operators cannot all upgrade at the same instant? Further, how is it ensured that all transaction history can be replayed even after functionality has changed?

To solve this, Sui uses a process called protocol upgrades.

## Protocol upgrade process

The process for protocol upgrades includes these steps:

1. A developer codes the new feature but restricts access to it with a feature flag, a boolean configuration variable initially set to false.
1. The value of the feature flag is retrieved from a struct called `ProtocolConfig`.
1. The developer creates a new version of the `ProtocolConfig` struct where the feature flag is set to true.
1. A new release of the Sui validator software is built and released to validator and full node operators.
1. When the validator process starts, it continues to use the previous version of `ProtocolConfig` (flag set to false). All validators behave identically regardless of whether they have the new software.
1. As validators are upgraded, they signal to the validator committee that they are prepared to switch to the new version of the configuration (flag enabled).
1. If enough validators vote to switch to the new protocol version, the new version takes effect at the beginning of the next epoch.
1. The new feature becomes active.

Full node operators follow a similar process but do not participate in voting. They follow the actions recorded by validators.

When validators switch to a new protocol version, they record the new version number in the special end-of-epoch transaction. Full nodes execute this transaction as they replay the chain history, allowing them to switch to the new protocol version at the correct time.

## Framework upgrades

Not all new Sui functionality comes from validator code changes. Developers also extend the Sui framework. For example, they might add new native functions to expose functionality to smart contracts. The process for framework updates is similar to protocol upgrades.

Instead of feature flags, Sui objects coordinate framework changes. The Sui framework is a special object with ID `0x2`. The Move source code for the framework is built into the validator binary.

If a validator notices that its built-in framework differs from the framework in object `0x2`, it signals to other validators that it wants to upgrade the framework to a new version. As with `ProtocolConfig`, if enough validators agree, the new framework object is written at the end of the current epoch. Transactions executed in the new epoch then use the new version of the framework.
>>>> sui/docs/content/concepts/sui-architecture/staking-rewards.mdx
---
title: Validator Staking and Rewards
draft: true
---

Sui uses a delegated proof-of-stake (DPoS) system, where validators receive voting power from SUI token holders who delegate their stake. At the end of each epoch, validators receive rewards based on their performance and commission rate. Rewards auto-compound because validator staking pools receive new delegated stakes.

## Staking on Sui compared to other blockchains

The Sui staking mechanism includes features that might differ from other blockchains:

- Staking is self-custodial. Stakers keep their staked SUI tokens in an owned object.
- Staking rewards auto-compound due to the liquidity-pool-inspired design.
- A new stake begins contributing to a validator's voting power starting the epoch after it is created. Similarly, a withdrawn stake stops contributing starting the epoch after withdrawal.

<ImportContent source="staking-pool-reqs.mdx" mode="snippet" />

## Rewards distribution

At the end of each epoch, gas fees collected and stake subsidies are distributed among validators and stakers as staking rewards. The rewards a validator receives depend on:

- **Performance:** If a validator does not operate performantly, other validators can report them through the tallying rule. The validator's staking rewards for that epoch are then slashed.
- **Commission rate:** The commission rate determines the portion of staking rewards the validator keeps. For example, if a validator has a 10% commission rate, then 10% of the staking rewards of their stakers go to the validator each epoch as new stake objects owned by the validator.

## Rewards withdrawal

Validator rewards are distributed as regular stake objects, so withdrawal works the same for validators and stakers. A validator can call the [`request_withdraw_stake` function](https://github.com/MystenLabs/sui/blob/6234ae2cc8137f3a2a34cd0aa1ac4fd5f31260e2/crates/sui-framework/packages/sui-system/sources/sui_system.move#L272) in the `sui_system` module to withdraw stake and receive rewards.
>>>> sui/docs/content/concepts/sui-architecture/sui-security.mdx
---
title: Understand Sui Security
description: Sui is designed to provide very high security guarantees to asset owners. Assets on Sui can be used only by their owners, according to the logic pre-defined by smart contracts that can be audited, and that the network will be available to process them correctly despite some of the validators operating Sui not following the protocol correctly (fault tolerance).
---

This page provides an overview of the major guarantees Sui provides in terms of security.

Sui asset owners and smart contract designers can start learning here about the mechanisms available to secure their assets, and the assurances Sui provides for them. Smart contract designers can also learn about the overall Sui security architecture to ensure the asset types they design leverage Sui to provide a secure experience to the asset holders.

## Security features {#security-features}

Sui is designed to provide very high security guarantees to asset owners. Assets on Sui can be used only by their owners, according to the logic pre-defined by smart contracts that can be audited, and that the network is available to process them correctly despite some of the validators operating Sui not following the protocol correctly (fault tolerance).

The security features of the Sui system ensure a number of properties:

- Only the owner of an owned asset can authorize a transaction that operates on this asset. Authorization is performed through the use of a private signature key that is known only to the asset owner.
- Everyone can operate on shared assets or immutable assets, but additional access control logic can be implemented by the smart contract.
- Transactions operate on assets according to predefined rules set by the smart contract creator that defined the asset type. These are expressed using the Move language.
- Once a transaction is finalized, its effects, namely changes to the assets it operates on or new assets created, are persisted. The resulting assets are available for further processing.
- The Sui system operates through a protocol between a set of independent validators. Yet all its security properties are preserved when a small subset of the validators do not follow the protocol.
- All operations in Sui can be audited to ensure any assets have been correctly processed. This implies all operations on Sui are visible to all, and users might wish to use multiple different addresses to protect their privacy.
- Validators are determined periodically through users of Sui locking and delegating SUI tokens to one or more validators.

## Security architecture {#security-architecture}

The Sui system is operated by a set of validators that process transactions. They implement the Sui protocol that allows them to reach agreement on valid transactions submitted and processed in the system.

The agreement protocols Sui uses tolerate a fraction of validators not following the Sui protocol correctly, through the use of Byzantine fault tolerant broadcast and consensus. Specifically, each validator has some voting power, assigned to it through the process of users staking and voting for them using their SUI tokens. Sui maintains all its security properties if over 2/3 of the stake is assigned to validators that follow the protocol. However, a number of auditing properties are maintained even if more validators are faulty.

### Addresses and ownership {#addresses-and-ownership}

A Sui transaction is valid and can proceed only if the owner of all owned assets it operates on digitally signs it with their private signature key. This signature key can be kept private by the user and not be shared with anyone else. As a result, it is not feasible for any other party to operate on an owned asset of a user undetected, even if all validators do not follow the protocol.

A private signature key also corresponds to a public address on the Sui network that can be used to send a user assets or allow smart contracts to define custom access control logic. A user might have one or more addresses corresponding to multiple signature keys for convenience or privacy reasons. An address does not need any pre-registration, and sending an asset to an address automatically creates this address on the network. However, this means that users should be careful to check the recipient address of transfers, or parties involved in any other operations, as sending assets to an incorrect address might have irrevocable effects.

### Smart contracts define asset types and their logic {#smart-contracts}

All assets have a type that is defined within a Sui smart contract. Sui provides a few system contracts, such as those used to manage the SUI native token, yet also allows anyone to write and submit custom smart contracts. A transaction on an asset type can call operations defined in only the smart contract that defined the asset type, and is constrained by the logic in the contract.

For this reason, users are encouraged to operate on their assets using smart contracts they trust, that they or others they trust have audited, and understand the logic they define for operations on their assets. Sui smart contracts are defined as immutable assets to allow third parties to audit them and also prevent their modification to increase assurance.

The Move smart contract language is designed with ease of audit and verification in mind. You might be interested in our introduction to smart contracts in Move.

Shared assets allow multiple users to operate on them through transactions; that might include some of their owned assets as well as one or more shared assets. These shared assets represent data and logic used to implement protocols that mediate between different users in a safe way, according to the smart contract that defined the type of the shared asset. Sui allows all users to create transactions involving shared assets. But the smart contract type might define additional restrictions on which address and how the shared assets might be used.

### Transaction finality {#transaction-finality}

A valid transaction submitted to all validators has to be certified and its certificate also has to be submitted to all validators to be finalized. Even if a subset of validators do not follow the protocol, the transaction can be finalized through the remaining validators that correctly follow the Sui protocol. This is achieved through the use of cryptographic Byzantine fault tolerant agreement protocols for broadcast and consensus defined by the Sui protocol. These protocols ensure both safety, meaning that the incorrect validators cannot convince correct clients of incorrect state, and liveness, meaning that incorrect validators cannot prevent transaction processing.

All transactions in Sui have to be associated with a gas asset to cover the cost of processing by Sui. A valid transaction might result in successful execution or an aborted execution. An execution might abort due to a condition within the smart contract defining the asset, or because it has ran out of sufficient gas to pay for the cost of execution. In cases of success, the effects of the operation are finalized; otherwise, the state of assets in the transaction is not changed. However, the gas asset is always charged some amount of gas, to alleviate denial-of-service attacks on the system as a whole.

A user client can perform the process of submitting the transaction and certificate itself or rely on third party services to submit the transaction and interact with validators. Such third parties need not have user private signature keys and cannot forge transactions on the users' behalf. They can reassure a user client a transaction has been finalized through a set of signatures from validators attesting to the transactions finality and its effects. After that point, the users can be assured that changes the transaction resulted in persist on the state of Sui.

### Auditing and privacy {#auditing-and-privacy}

Sui validators provide facilities for users to read all assets they store, as well as the historical record of transactions they have processed that led to these assets. Validators also provide cryptographic evidence of the full chain of transactions that contributed to an asset state. User clients can request and validate this chain of evidence to ensure all operations were correct and the result of the collective agreement between validators. Services that operate full replicas, mirroring the state of one or more validators, perform such audits routinely.

The public auditability of Sui also implies that all transactions and assets within Sui are publicly visible. Users that are mindful of their privacy might use multiple addresses to benefit from some degree of pseudonymity, or third-party custodial or non-custodial services. Specific smart contracts with additional cryptographic privacy protections can also be provided by third parties.

### Censorship-resistance and openness {#censorship-resistance-openness}

Sui uses the established Delegated proof-of-stake model to periodically determine its set of validators. Users can lock and delegate their SUI tokens in each epoch to determine the committee of validators that operate the Sui network in the next epoch. Anyone with over a minimum amount of delegated stake can operate a Sui validator.

Validators operate the network and provide rewards to users that stake their Sui to support them as validators, through gas fee income. Validators with poor reliability, and in turn the users that delegated their stake to them, might receive a lower reward. But user stake cannot be confiscated away either by malicious validators or anyone in the network.

This mechanism ensures that validators are accountable to Sui users and can be rotated out at the first sign of unreliability or misbehavior, including noticed attempts to censor valid transactions. Through choices of validators, and the protocol they are willing to operate, Sui users also have a meaningful say on the future evolution of the Sui system.

## Further reading {#further-reading}

If you are looking for an in-depth technical explanation of the computer science behind Sui security, you might have a look at our white paper on the [Sui Smart Contracts Platform](/doc/sui.pdf).
>>>> sui/docs/content/concepts/sui-architecture/sui-storage.mdx
---
title: Sui Storage Cost
description: Historical data and storage pricing provide insights into the cost of operations on the Sui network.
---

The cost of operating on any blockchain has two main components: **compute**, the power required to process logic, and **storage**, the digital space needed to store data and results.

Compute is relatively fixed on Sui, with hundreds of validators running 24-core, 128GB RAM machines.

Because Sui achieves high throughput compared to other blockchains, storage costs can vary significantly.

The following table summarizes the main storage components:

| Storage category    | Storage type         | Usage description                                                                                                                                                            | Mainnet storage needs (as of May 2024) |
| ------------------- | -------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------- |
| Validators          | RocksDB, SSD storage | Validators store the latest consensus data on high-performance NVMe disks.                                                                                                   | ~200GB                                 |
| Pruning full nodes  | RocksDB, SSD storage | Pruning full nodes maintain unpruned RocksDB indexes for efficient querying.                                                                                                 | ~1.6TB                                 |
| Unpruned full nodes | RocksDB, SSD storage | Unpruned full nodes retain full object and transaction history for complete archival.                                                                                        | ~4.9TB                                 |
| Full node snapshots | Cloud storage        | Snapshots of full node data are stored in cloud storage for validator or full node backup and recovery.                                                                      | ~1.6TB                                 |
| State-sync archival | Cloud storage        | State-sync archival stores blockchain state data in cloud storage to support syncing of historical objects that might have been pruned.                                        | ~1.3TB                                 |

## Validators

Validators should enable pruning to limit database growth. Transaction-per-second (TPS) rates affect growth, but storing full transaction and object history is the main factor. Transaction type also influences data growth.

![Storage](./images/storage.png)

The image above shows Mainnet growth in 2024:

- Over a 90-day period with ~18 TPS, disk usage increased from 203GB to 215GB (~130MB per day).
- Over a two-week period with ~183 TPS, disk usage grew from 215GB to 271GB (~4GB per day).

These results show storage growth increases relative to TPS rates.

## Pruning full nodes

Pruning full nodes are similar in disk usage to validators because pruning settings are the same. There are two exceptions:

- Full nodes keep a `consensus_db`, which accounts for about half of validator disk usage.
- If the node serves RPC queries, the `indexes/` directory in Mainnet consumes significant space. Currently, `indexes/` is 1.5TB and grows with TPS.

The total disk usage of a pruned full node with indexes is ~1.6TB. With indexing disabled, usage is ~100GB.

## Unpruned full nodes

Unpruned full nodes are uncommon and apply to a few use cases:

1. You need the entire chain state on one machine.
2. You want to enable state-sync without using a cloud archival fallback. Using an unpruned node as a peer avoids configuring an archival bucket.

Growth examples:

- Over a 90-day period with ~18 TPS, usage increased from 3.4TB to 4.34TB (~10GB per day).
- Over a two-week period with ~183 TPS, usage grew from 4.34TB to 4.92TB (~40GB per day).

## Full node snapshots

There are two types of [snapshots](/guides/operator/snapshots.mdx):

- **Database snapshots:** Equal in size to the database of the full node that produced them (1:1 copy).
- **Formal snapshots:** Lightweight, ~30GB for recent Mainnet epochs (as of May 2024).

## State-sync archival

State-sync archival stores blockchain state data in a cloud storage bucket written by a full node or ingestion daemon.

Growth examples:

- Over a 90-day period, usage increased from 867GB to 1.18TB (~3GB per day).
- Over a two-week period, usage grew from 1.18TB to 1.32TB (~10GB per day).

## Related links

<RelatedLink to="/guides/developer/advanced/custom-indexer.mdx" />
<RelatedLink to="/guides/operator/snapshots.mdx" />
<RelatedLink to="/guides/operator/archives.mdx" />
>>>> sui/docs/content/concepts/sui-architecture/transaction-lifecycle.mdx
---
title: Life of a Transaction
description: The life of a transaction on the Sui network has some differences compared to those from other blockchains.
---

A transaction on the Sui network goes through many different steps during its life cycle.

## Life cycle overview

At a high level, the following figure outlines the life cycle of a transaction on the Sui blockchain.

![Transaction life cycle](./images/txn-lifecycle.png)

The following steps align with those in the preceding image.

1. The first step of the process is the creation of a transaction. A user with a private key creates and signs a user transaction to either mutate objects they own, or a mix of objects they own and [shared objects](/concepts/object-ownership/shared.mdx).

1. Sui sends the transaction to each validator (often through a full node). Validators perform a series of validity and safety checks, sign it, and return the signed transaction to the client.

1. The client then collects the responses from a set of validators that account for at least 2/3 stake on Sui (a supermajority) to form a transaction certificate. As a result, unlike consensus-based blockchains, Sui validators do not need to propagate signatures on a best-effort basis (gossip signatures) or aggregate certificates. This effort is now the responsibility of the client or gateway.

1. After assembling the certificate, the client sends it back to all validators, who check its validity and acknowledge its receipt to the client. If the transaction involves owned objects exclusively, Sui can process the transaction certificate immediately and execute it without waiting for the [consensus engine](./consensus.mdx) (**direct fast path**). All certificates are forwarded to the Sui DAG-based consensus protocol (also operated by the Sui validators).

1. Consensus eventually outputs a total order of certificates; the validators check and execute those that contain shared objects.

1. Clients can collect a supermajority of validator responses, assemble them into an effect certificate, and use it as proof of the settlement of the transaction.

1. Subsequently, Sui forms checkpoints for every consensus commit, which it also uses to drive the reconfiguration protocol.

The complete [Sui Lutris](https://docs.sui.io/paper/sui-lutris.pdf) paper provides additional detail on how the safety and liveness protocols operate, as well as proofs of security for them in the standard distributed systems model with Byzantine participants in partial synchrony. The following sections provide more detail on the various stages in the life of a transaction.

## Submission

All transactions on Sui begin when they are submitted to the network. For example, imagine you want to transfer an NFT that you own in your wallet to your friend. First, you would create a transaction using a wallet or some other app. The transaction includes your gas payment object and a command to transfer the NFT object to your friend's address. Before the wallet or app submits the transaction to the network, it must also sign it.

After the transaction is signed, the wallet or app submits the transaction to a Sui full node on behalf of the user.

## Certification

Certification happens after a transaction gets submitted to a full node. Upon submission, the full node begins the process of certifying the transaction. The full node cannot certify the transaction on its own because it does not have a complete view of transactions across the network. Consequently, the full node must send the transaction to a validator. The validator performs a validity check on the transaction and signs it if it passes. To be considered valid, the transaction must pass the following checks:

- The transaction has a valid user signature.
- The initiator of the transaction must have access to all the owned input objects the transaction uses. In the previous NFT example, the validity check makes sure you own the NFT you're trying to send to a friend.
- All the shared input objects used by the transaction exist.
- The gas coin is a `Coin<SUI>` object, and it contains at least as much gas as specified in the transaction's gas budget.

If all the validity checks pass, the validator then attempts to lock all the owned input objects to the given transaction digest. This ensures each owned input object can only be used by one transaction at a time and is the way that Sui prevents double-spending. In other words, this makes sure that you send your NFT to only one friend instead of trying to send the same NFT to all your friends.

If the locking succeeds, the validator signs the transaction using its BLS private key and returns the signature to the full node. A single validator signature is not enough, though. The full node must collect signatures from enough validators to form a supermajority.

:::info

Full nodes collect signatures from validators in parallel to minimize latency.

:::

After the full node collects a supermajority, or quorum, of validator signatures, the transaction is considered certified. To be precise, the full node has formed a _transaction certificate_.

Because of the locking step described previously, it is impossible to concurrently form certificates for two different transactions that attempt to use the same owned object. This is true even if there are some dishonest validators that illegally sign both transactions, because of a principle in distributed computing called _quorum intersection_.

If fewer than 1/3rd of the validators are dishonest (Byzantine), then the set of signers for any two certificates must have an overlap that includes at least one honest validator. And, crucially, because that validator is honest, it never signs two transactions that attempt to access the same input object at the same version. After the transaction completes, the input object version changes and can be accessed again by subsequent transactions.

## Execution

Full nodes send transactions that have a certificate to validators for execution. Each validator verifies the signatures on the certificate.
If the certificate signatures are valid, then the validator can be sure that the transaction is valid and is not attempting to double-spend any objects.

Then, each validator does the following, based on whether the transaction:

- Does not access any shared input objects, in which case it executes it immediately.
- Does access shared input objects, in which case it submits the object to Sui's consensus layer, which orders the transaction with respect to other transactions using the same shared objects and then executes it.

## Certified Effects

After the transaction executes, the validator signs the effects of the transaction and returns them to the full node.
The transaction effects are essentially a list of all the actions that the transaction took, which mainly include:

- All the objects that were mutated, created, wrapped, unwrapped, or deleted.
- The gas that was spent.
- The execution status (Success or an error code) of the transaction.

Eventually, the full node collects effects signatures from a supermajority of validators. This collection of signatures, plus the effects themselves, is called an _effects certificate_.

:::tip

An effects certificate is a guarantee of transaction finality.

:::

After you or a full node observes an effects certificate, you are guaranteed that the transaction is going to be included in a checkpoint, which means that the transaction cannot be reverted.

If you wanted, you could present the effects certificate to your friend to prove that you sent them the NFT. The presence of the validator signatures means that an effects certificate cannot be forged.

## Checkpoints

Inclusion in a checkpoint is the final stage in the life of a transaction. As validators execute transactions, they submit them to consensus.

While transactions that use shared input objects must be sent to consensus before they are executed, owned-input-only transactions are also sent to consensus. The difference is that owned-input-only transactions are executed first.

The consensus layer produces a universally agreed-upon ordering of transactions. This ordering is the starting point for the creation of checkpoints.

The validators take chunks of ordered transactions from the consensus layer and use them to form a checkpoint. Each chunk of transactions is first made causally complete and causally ordered - this means that the validators add any missing dependencies to the list of transactions and order them so that dependencies always appear before dependents in checkpoints.

Then the validator constructs a checkpoint, which (among other data) contains a list of transaction digests as well as the digests of the transaction effects of each transaction. Because checkpoints must be complete, the network sometimes has to wait for the availability of all transactions to form the checkpoints, which might take a couple of commits to process. This process typically completes in the order of a few seconds.

At this point, the transaction has reached the end of its life cycle and is included in the permanent record of transaction activity on the Sui network.

## Transaction finality

Transaction finality is the point at which the execution of a transaction becomes irreversible and its details cannot be altered or changed.

The network round trip of sending a transaction and receiving a validator signature takes less than half a second to complete. At this point the sender knows the transaction is irrevocable and is going to be processed within the epoch, no matter what. The transaction has reached finality; honest validators deem invalid any subsequent transactions using the same owned input objects during the same epoch.

## Settlement finality

After a validator executes a transaction, it returns signed effects from that transaction to the network.

After the supermajority of validators have executed the transaction, and an effects certificate exists, the effects of the transaction (transfers, newly minted objects, and so on) have been implemented. At this point, the network can process transactions that depend on those effects.

For transactions that involve owned objects only, this happens before consensus in under half a second. If a transaction includes shared objects, it happens shortly after consensus, which can take a few seconds. At this point, the transaction reached settlement finality because now you can process more transactions on the same input objects. See [Object Ownership](../../concepts/object-ownership.mdx) for more information.

## An example path to an effects certificate

As a real-world example, suppose you want to pay the local coffee shop 10 SUI for your morning coffee. How can the coffee shop be sure that the payment is complete and allow you to take your coffee?

Step 1: Transaction creation

You open the wallet app on your phone, scan the coffee shop's QR code that contains the recipient on-chain address. The wallet app constructs a transaction that transfers 10 Sui from your Sui address to the coffee shop's address. You review the transaction details and approve it. The wallet app then signs the transaction with your private key. Now you have a signed transaction.

Step 2: Transaction broadcast

Your wallet app submits the signed transaction to a full node. The full node broadcasts the transaction to all validators in the network.

Step 3: Transaction certification

Validators receive the transaction from the full node. After examining its validity, a validator locks the referenced owned objects, and returns its signature of the transaction to the full node.

After the full node collects a quorum of signatures, it forms a transaction certificate. The transaction certificate contains the transaction and signatures from the supermajority of validators.

Step 4: Transaction finalization

The full node broadcasts the transaction certificate to all validators. Validators receive the transaction certificate, verify its validity (for example, there are indeed enough signatures), execute the transaction, and unlock the previously locked owned objects. Transaction effects are the output of an executed transaction. Validators sign the transaction effects and return them to the full node, along with their signatures.

The full node verifies that effects returned from validators are identical. After it collects a supermajority of signatures, it forms an `EffectsCertificate` object. The effects certificate contains the transaction effects and signatures from a supermajority of validators.

At this point, as your wallet app gets back the effects certificate from the full node, you can share this effect certified transaction with the coffee shop. The coffee shop can then be sure that the transaction is executed and irreversible.

### Checkpoint processing

The process in the previous section demonstrates a finalized transaction through an effects certificate. As the process shows, the full node plays the quorum driving role.

What if the full node goes offline before it collects a quorum of validator-signed effects? Your wallet app probably retries the process with a different full node. Unfortunately, your phone runs out of battery before it sends the signed transaction to a new full node.

No worries. The coffee shop shortly notices your payment arrive in its terminal, connected to a different full node. This full node learns about your transaction through checkpoints.

As mentioned, a checkpoint contains a list of transactions. If a transaction appears in a certified checkpoint (a checkpoint that has been signed by a supermajority of validators), it is considered finalized.

The full node that the coffee shop's terminal connects to knows about your transaction through state sync. In this case, as long as one validator receives the transaction certificate from your original full node, the transaction highly likely finalizes even without an effects certificate. The coffee shop is assured of payment and can give you your coffee.

### Local execution on full node

Before the full node sends back an effects certificate to your wallet app, it might try to execute the transaction locally, if the request asks it to.

The purpose of this extra step is to keep the full node up to date as much as possible, especially when the wallet app frequently hits the same full node. In this coffee shop example, this might be trivial, but for a high frequency application, such as gaming, it could be important.

When an app constructs a transaction, it typically requests that the full node choose a gas object for it. Gas objects are owned objects, meaning that if the full node is stale and not aware of the right version of the object, it could lead to invalid transactions, or worse, client equivocation if the client software does not handle it properly. Executing on full node before returning `EffectsCertificate` is one way to avoid this situation. A request can ask for such behavior by using the `WaitForLocalExecution` parameter. See [Sponsored Transactions](../transactions/sponsored-transactions.mdx) for more on client equivocation.

Using `WaitForLocalExecution` is not always the best choice, however. For example, with this coffee payment it adds a layer of end-to-end latency without significant benefits. In this case, using the `WaitForEffects` parameter instead to have a slightly shorter user-perceived latency.

### Epoch change

Periodically (~24 hours), the Sui network enters the process of epoch change. During epoch change, the network calculates and distributes staking rewards, validators metadata take effect, and other network processes are performed. All user transactions are delayed until the new epoch begins.

If your transaction is submitted at epoch boundary, in rare perfect timing, it is possible that a quorum of validators already decided to not accept any new transaction certificates in the current epoch. Of course, this means your coffee purchase is not checkpointed either. For any transactions that are certified but not finalized, they are reverted if executed, or its owned objects are unlocked and not yet executed. In this case, the transaction certificate does not guarantee finality. In the new epoch, this transaction certificate becomes void because validator signatures are signed over epoch ID. To continue this transaction, a new transaction certificate is necessary with the new epoch ID. The standard full node implementation handles this automatically.

### Verifying finality

Assume your wallet app crashed during the original transaction. If the app stores the signed transaction locally before sending it to the full node, which is best practice, then when the app restarts it tries to verify if the transaction has been finalized first. If it has, then no other steps are necessary. If it hasn't, then the app needs to resubmit the transaction.

The wallet app can query the full node with the `getTransactionBlock` method. Assuming the full node is honest:

- If the response contains transaction details, the transaction must have been finalized. It is either executed with `WaitForLocalExecution`, or executed as a checkpointed transaction.
- If the response is `None`, it could mean the transaction was dropped in some step, or is already finalized but this full node does not know yet. In this scenario, the safer option is to resubmit the transaction.

Before a transaction is locally executed, its effects are not reflected on the full node. The same idea applies to the coffee shop's full node. Your transaction was not submitted through this full node, hence it does not have a chance to locally execute it before it's included in a checkpoint. This full node must wait for the transaction to be checkpointed and state synced, which normally takes a few seconds. After the full node receives this transaction in a checkpoint, it is executed and has effects updated locally, for example the coffee shop's balance increases.

## Summary

1. A transaction certificate does not always guarantee finality, even though it's highly likely. Specifically, a transaction certificate might become void after an epoch change.

1. An effects certificate guarantees finality. It takes a supermajority of validators to execute the transaction and commit to the effects.

1. An inclusion in a certified checkpoint guarantees finality. It takes a supermajority of validators to certify the checkpoint, in which every transaction is executed and effects-committed.
>>>> sui/docs/content/concepts/sui-for-ethereum.mdx
---
title: Ethereum -> Sui
description: Build your first dApp on Sui if you have EVM experience
keywords: [ ethereum, solidity, EVM,  ]
pagination_prev: null
---

If you have worked with Ethereum Virtual Machine (EVM) before, the biggest difference when developing on Sui is the programming language. Sui uses **Move** and EVM uses **Solidity**.

| Topic | Solidity | Move |
|------|------|---------|
| Account vs object-centric models | Custom ownership logic written within contracts typically using _mappings_. Only Ethereum coins are first class citizens with global APIs. All ownership APIs are contract specific. | Object ownership inherent to Sui, objects are first class citizens and encompass everything _owned_ on Sui. |
| Data storage | Data is stored in the smart contract. | Data is stored in Move objects. |
| Inheritance | Supports multiple inheritance, including polymorphism. | No interfaces, no polymorphism. However, Move has generics, like `Type<T>`. |
| Dynamic dispatch | Allowed | Not allowed |
| Asset/Token accessibility | Bound to smart contract. | Anyone can access shared objects. Owned objects can only be accessed by object owner. |
| Access control | Identity/role-based access control through `Ownable` and `AccessControl` contract. | Mostly [capability based access control](https://move-book.com/programmability/capability.html) through owned objects. Identity/role-based access control is possible. |
| Contract upgrades | Proxy contract forwards user transactions. | New contracts must be [layout-compatible](/concepts/sui-move-concepts/packages/upgrade#upgrade-requirements) with the old one. Need to consider versioning shared objects. |
| Development environment | Hardhat, Foundry | [Move VSCode extension](https://marketplace.visualstudio.com/items?itemName=mysten.move). |
| Mutate contract state | Sending transactions through compile time ABI interface. | Sending transaction through runtime [programmable transaction block](/concepts/transactions/prog-txn-blocks.mdx) (PTB) construction. |

## Object model

Objects store data in Move and everything in Move is an object. This includes the smart contracts (Move packages), on-chain addresses, coins, and NFTs.

For simplicity, you can think of objects as _assets_ or NFTs. Objects have ownerships.

## Ownership

There are some nuances to object ownership, but key types include:

- **Address-owned objects:** These objects are owned by a single address. You can transfer or receive these objects without interacting with a smart contract. For example, currency, NFTs, or tokens gating access to certain functions.
- **Shared objects:** Publicly accessible objects that anyone can use. Mutating the data stored in these objects typically involves defining rules in the smart contract.

For all types of ownership on Sui, see [Object Ownership](/concepts/object-ownership.mdx).

## Access control

Identity or role-based access control is widely used through OpenZeppelin's `Ownable` and `AccessControl` contracts in Solidity.

Because object ownership is inherent in Sui, access to contract functions are typically gated through [capability object](https://move-book.com/programmability/capability/).

These objects are issued to users and thus grant them the rights to call certain functions. Function calls fail if a user does not own the object a function expects.

You can still implement address-based checks. However, the recommendation is to use capability objects as much as possible for better security.

You can read more in [The Move Book](https://move-book.com/programmability/capability/#address-check-vs-capability).

In this example, a new user can only be created by presenting an `AdminCap` object during the function call.

```Move
/// Grants the owner the right to create new users in the system.
public struct AdminCap {}

/// Creates a new user in the system. Requires the `AdminCap` capability to be
/// passed as the first argument.
public fun new(_: &AdminCap, ctx: &mut TxContext): User {
    User { id: object::new(ctx) }
}
```

## Mutating objects

In Solidity, data structures such as `Mapping` are defined and stored in a contract. Mutating the data involves signing a transaction regardless of whether the signer owns the data or not.

In Move, the logic that mutates the data is defined in the contract, but the data is stored in Move objects.

To mutate the data, the owner of the objects needs to call the contract functions using a PTB. The ownership check is done at a protocol level so transactions fail if the signer does not have access to the referenced objects.

## Programmable transaction blocks

In Solidity, if you want to do something that chains together the results of multiple contract calls or across different contracts, you need to have a function in the smart contract that composes other function calls. Chaining function calls with atomicity guarantees is not available on the client side.

In Move, PTBs solve this problem. PTBs give builders the ability to chain contract calls together with atomicity guarantees during runtime. A Sui PTB can have up to 1,024 different contract calls in it, or other actions. PTBs effectively provide a limited scripting language that is straightforward yet expressive, powerful, and secure.

Builders on Sui leverage PTBs to provide experiences that would otherwise be intractable. A good example is a DeFi aggregator that routes token swaps across multiple DeFi protocols with the best price. On Sui, the aggregator would use a single PTB with the guarantee that the transaction would execute at the displayed price or it would revert completely. The PTB is one of the most powerful Sui features. Experience shows builders who are most successful on Sui are the ones who learn to leverage this feature early and often, leaning into it rather than treating it just as a way to batch transactions.

See [Programmable Transaction Blocks](/concepts/transactions/prog-txn-blocks.mdx) for details on PTBs.

## More comparison

| Topic | Sui | Ethereum |
|-------|-----|----------|
| Digital signature algorithm | `Ed25519`, `secp256k1`, `secp256r1` | `secp256k1` |
| Consensus mechanism | DPoS | PoS |
| VM and its languages | MoveVM, Move Lang | EVM, Solidity, Vyper |
| Chain data structure | DAG | Blocks |
| Common standards (coin, token, NFT, and so on) | Currency Standard, Closed-Loop Token | ERC-20, ERC-721, ERC-1155 |
| Coin names, name of the smallest unit | SUI, MIST | ETH, Wei |
| Available frameworks for development | Sui CLI | Foundry, Hardhat |
| L1/L2 | No L2, relies on fast L1 | Many L2s |
| Governance | On-chain governance | EIP + Node Operator consensus |
| Bridges | Supported | Supported |
| Network security (stake required for control) | 66% of total stake | 51% of total stake |
| Smart contract auditing | Less auditing required, language does some of the lifting (object model). | Solidity provides less protection requiring greater auditing. |
| Private transactions | Public by design. | Public by design, L2 and third party supports private transactions. |
| TVL | ~1 billion | ~46 billion |
| Implementation languages for clients | Rust, TypeScript | Many |
| Eventing | Indexed by sender, object ID, type, timestamp. | Indexed by topic. |
| Indexing | High level transaction data + objects, coins, and so on. | High level transaction data. |
| Oracles | Third party | Third party |
| Network upgrade strategy | Protocol flags and framework upgrades are voted on by validators then enabled. | EIPs + Hardforking, no on-chain mechanism. |
| IDE | VSCode | Many |
| Transaction lifecycle | Two round trips from client to validators to generate a transaction certificate (guaranteeing execution) another round trip for shared objects to ensure ordering. Very low latency. | Transaction gossiped to network, verified added to mempool, validators select transactions from mempool. Random validator proposes a block, other validators vote yes or no on block. After a sufficient number of blocks have passed a transaction is considered final. High latency due to block height requirement for finality. |
| Parallel execution vs Ethereum serial execution, fast path | Transactions that can be parallel are run in parallel. | Every transaction is sequentially run. |
| Storage fees, storage rebates, storage accounts to pay for fees over time | Low, rebates on destroying objects. | High, no rebates. |
| Contract immutability | Native mutable and immutable support using upgrade capabilities. | Not native, requires auditing the Solidity code deployed. Can be discerned by some operation codes. |
| Contract upgrading | Native, upgrade capability mediated. | Achieved using proxy pattern to delegate calls. Upgrades change where calls are directed to. |
| Composability | Call any number of functions within a single transaction using PTBs. Compose by taking the output of one contract call and passing it into another. Ensures atomic execution. | Each call is its own transaction that must be processed individually and serialized by the chain. Requires careful publishing to ensure execution. Not atomic. |
| Token royalties | Enforced by the chain. | Only enforceable by marketplaces. |

## Related links

<RelatedLink to="/concepts/sui-move-concepts" />
<RelatedLink to="/concepts/object-ownership" />
<RelatedLink to="/concepts/transactions/prog-txn-blocks" />
<RelatedLink href="https://move-book.com/programmability/dynamic-object-fields.html)" label="Dynamic Object Fields" desc="Learn more about Dynamic Object Fields in The Move Book." />

>>>> sui/docs/content/concepts/sui-move-concepts.mdx
---
title: Move Concepts
description: Move is an open source language for writing safe packages to manipulate on-chain objects.
keywords: [ move on sui, move language, what is move, move objects, move smart contracts, move objects, move packages, move, move concepts ]
---

<ImportContent source="move-summary.mdx" mode="snippet" />

You can use Move to define, create, and manage programmable Sui objects representing user-level assets. Sui's object system is implemented by adding new functionality to Move while also imposing additional restrictions. See [Object Model](./object-model.mdx) for more details.

## Move on Sui

Move on Sui contains some important differences from Move on other blockchains. Sui takes advantage of Move's security and flexibility and enhances it with the features to vastly improve throughput, reduce delays in finality, and make Move programming more approachable. For full details, see the [Sui Smart Contracts Platform](/doc/sui.pdf) whitepaper.

:::tip

Where the Sui documentation refers to the Move language, the content is documenting the specific Move implementation on the Sui blockchain. If relevant, the documentation expressly refers to the original use case for the Move language as Move on Diem.

:::

## Key differences {#differences}

Key differences with Move on Sui include:

- Sui uses its own [object-centric global storage](#global-storage)
- Addresses represent [Object IDs](#object-ids)
- Sui objects have [globally unique IDs](#global-unique)
- Sui has [module initializers](#module-initializers) (init)
- Sui has unique use cases for the [`entry` keyword](#entry-functions)

### Object-centric global storage {#global-storage}

In Move on Diem, global storage is part of the programming model. Resources and modules are held in global storage, owned by an account which has an address. Transactions are free to access resources from any account in global storage when they run, using special operations such as `move_to` and `move_from`.

This approach introduces a scaling issue, as it is not possible to statically determine which transactions are contending over the same resource and which are not.  This is similar to the scaling issues faced by other blockchains where smart contracts typically store account information in large, internal mappings, which limit throughput.

Move on Sui addresses the scaling issue by not having global storage, or its related operations. When objects (in contrast to resources) and packages (sets of modules) are stored on Sui, they are each given unique identifiers. All a transaction's inputs are explicitly specified up-front using these unique identifiers, to allow the chain to schedule transactions with non-overlapping inputs in parallel.

### Addresses represent Object IDs {#object-ids}

In Move on Diem, there is a 16-byte `address` type used to represent account addresses in global storage. A 16 byte address is sufficient for the Move on Diem security model.

Sui doesn't have global storage, so `address` is re-purposed as a 32-byte identifier used for both objects and accounts. Each transaction is signed by an account (the sender) that is accessible from the transaction context, and each object stores its `address` wrapped in its `id: UID` field. 

See [Address](https://move-book.com/reference/primitive-types/address.html) in The Move Book for an overview on addresses and refer to <UnsafeLink href="/references/framework/sui-framework/sui_sui/object">object.move</UnsafeLink> in the Sui Framework for implementation details.

### Object with key ability, globally unique IDs {#global-unique}

In Move on Diem, the `key` ability indicates that the type is a resource, meaning it (along with an account address) can be used as a key in global storage.

On Sui, the `key` ability indicates that a struct is an object type and comes with an additional requirement that the first field of the struct has signature `id: UID`, to contain the object's unique address on-chain. Sui's bytecode verifier ensures that new objects are always assigned fresh `UID`s (identifiers are never re-used).

### Module initializers {#module-initializers}

As described in [Object-centric global storage](#global-storage), you publish Move modules into Sui storage. The Sui runtime executes a special initializer function you optionally define in a module only once at the time of module publication to pre-initialize module-specific data (for example, creating singleton objects). See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in The Move Book for more information.

### Entry functions {#entry-functions}

The `entry` keyword has a specific use case in Move on Sui. Use `entry` when you want some functionality to be usable by anyone on chain, but not be wrapped around other Move logic. In other words, a function can be called in [PTBs](/concepts/transactions/prog-txn-blocks) but not in other Sui packages. For example, this is utilized when using Sui's on-chain randomness standard to prevent other smart contract engineers from creating logic to essentially front- or back-run the randomness generation. Find more information about this in the [on-chain randomness page](/guides/developer/advanced/randomness-onchain.mdx#use-non-public-entry-functions). 

Make your function private (don't add the `public` visibility keyword) and mark it with the `entry` keyword, as in `entry fun example_function`.

In addition to this Sui-specific use case, there are other rules and restrictions for `entry` functions. 
- `entry` functions can only return types with the `drop` ability. 
- `entry` functions can only take objects as inputs if they weren't used as inputs in any non-`entry` functions in the same PTB. 

## Related links

<RelatedLink href="https://move-book.com" label="The Move Book" desc="A comprehensive guide to the Move programming language on the Sui blockchain." />
<RelatedLink href="https://move-book.com/reference" label="The Move Reference" desc="Language reference for Move on Sui." />

>>>> sui/docs/content/concepts/sui-move-concepts/conventions.mdx
---
title: Move Conventions
description: Recommended Move 2024 best practices for Sui development.
---

This guide outlines recommended conventions and best practices for writing Move smart contracts on Sui. Following these guidelines helps create more maintainable, secure, and composable code that aligns with ecosystem standards.

While these conventions are recommendations rather than strict rules, they represent patterns that have proven effective across many Sui projects. They help create consistency across the ecosystem and make code easier to understand and maintain.

## Organization principles

### Package

A Sui package consists of:
- `sources` directory containing the Move code to be uploaded to the blockchain.
- `Move.toml` manifest file that declares dependencies and other information about the package.
- `Move.lock` file that the Sui Move toolchain automatically generates to lock the versions of the dependencies and track the different published and upgraded versions of the package that exist on the different networks.

For this reason, the `Move.lock` file should always be part of the package (don't add it to the `.gitignore` file). Use the [automated address management](/concepts/sui-move-concepts/packages/automated-address-management.mdx) instead of the old `published-at` field in the manifest file.

Optionally, you can add a `tests` directory to contain the tests for the package and an `examples` directory to provide use cases for the package. Neither directory is uploaded on chain when you publish the package.

```
sources/
    my_module.move
    another_module.move
    ...
tests/
    my_module_tests.move
    ...
examples/
    using_my_module.move
Move.lock
Move.toml
```

In your package manifest, the package name should be in PascalCase: `name = "MyPackage"`. Ideally, the named address representing the package should be the same as the package name, but in snake_case: `my_package = 0x0`.

### Modules

Modules are the main building blocks of your Move code. They are used to organize and encapsulate related functionality. Design your modules around one object or data structure. A variant structure should have its own module to avoid complexity and bugs.

Module declarations don't need to use brackets anymore and the compiler provides default `use` statements for widely used modules, so you don't need to declare all of them.

```move
module conventions::wallet;

public struct Wallet has key, store {
    id: UID,
    amount: u64
}
```

### Body

Structure your code using comments to create sections for your Move code files. Structure your titles using `===` on either side of the title.

```move
module conventions::comments;

// === Imports ===

// === Errors ===

// === Constants ===

// === Structs ===

// === Events ===

// === Method Aliases ===

// === Public Functions ===

// === View Functions ===

// === Admin Functions ===

// === Package Functions ===

// === Private Functions ===

// === Test Functions ===
```

Here, public functions are the functions modifying state and view functions are often on-chain getters or off-chain helpers. The latter are not necessary because you can query objects to read their data. The `init` function should be the first function in the module, if it exists.

Try to sort your functions by their purpose and according to the user flow to improve readability. You can also use explicit function names like `admin_set_fees` to make it clear what the function does.

Ideally, test functions should only consist of `[test_only]` helpers for the actual tests that are located in the `tests` directory.

Group imports by dependency, for example:

```move
use std::string::String;
use sui::{
    coin::Coin,
    balance,
    table::Table
};
use my_dep::battle::{Battle, Score};
```

## Naming conventions

Adhering to naming conventions in your code helps readability and ultimately makes your codebase easier to maintain. The following sections outline the key naming conventions to follow when writing Move code.

### Constants

Constants should be uppercase and formatted as snake case. Errors are specific constants that use PascalCase and start with an E. Make them descriptive.

```move
module conventions::constants;

// correct non-error constant
const MAX_NAME_LENGTH: u64 = 64;

// correct error constant
const EInvalidName: u64 = 0;

// wrong error constant
const E_INVALID_NAME: u64 = 0;
```

### Structs

Always declare struct abilities in this order: `key`, `copy`, `drop`, `store`.

Do not use 'potato' in the name of structs. The lack of abilities define it as a potato pattern.

Structs support positional fields that can be used for simple wrappers, dynamic field keys, or as tuples.

Use the `Event` suffix to name structs that emit events.

```move
module conventions::request;

// dynamic field keys
public struct ReceiptKey(ID) has copy, drop, store;

// dynamic field
public struct Receipt<Data> has key, store {
    id: UID,
    data: Data
}

// right naming
public struct Request();

// wrong naming
public struct RequestPotato {}
```

### CRUD function names

The following functions follow standard CRUD (Create, Read, Update, Delete) naming conventions:

- `new`: Creates an empty object.
- `empty`: Creates an empty struct.
- `create`: Creates an initialized object or struct.
- `add`: Adds a value.
- `remove`: Removes a value.
- `exists`: Checks if a key exists.
- `contains`: Checks if a collection contains a value.
- `borrow`: Returns an immutable reference of a struct or object.
- `borrow_mut`: Returns a mutable reference of a struct or object.
- `property_name`: Returns an immutable reference or a copy of a field.
- `property_name_mut`: Returns a mutable reference of a field.
- `drop`: Drops a struct.
- `destroy`: Destroys an object or data structure that has values with the **drop** ability.
- `destroy_empty`: Destroys an empty object or data structure that has values with the **drop** ability.
- `to_name`: Transforms a Type X to Type Y.
- `from_name`: Transforms a Type Y to Type X.

### Generics

Declare generics using single letter names or full names. By convention, developers use `T` and `U` for generic types, but you can use a more descriptive name if it is not confusing with other types. Always prioritize readability.

```move
module conventions::generics;

// single letter name
public struct Receipt<T> has store { ... }

// full name
public struct Receipt<Data> has store { ... }
```

## Code Structure

The following section covers common patterns and best practices specific to Move development on Sui, including object ownership models and function design principles.

### Shared objects

Library modules that share objects should provide two functions: one to instantiate and return the object, and another one to share it. It allows the caller to pass it to other functions and run custom functionality before sharing it.

```move
module conventions::shop;

public struct Shop has key {
    id: UID
}

public fun new(ctx: &mut TxContext): Shop {
    Shop {
        id: object::new(ctx)
    }
}

public fun share(shop: Shop) {
    transfer::share_object(shop);
}
```

### Pure functions

Keep your functions pure to maintain composability. Do not use `transfer::transfer` or `transfer::public_transfer` inside core functions, except in specific cases where the object is not transferable and shouldn't be modified.

```move
module conventions::amm;

use sui::coin::Coin;

public struct Pool has key {
    id: UID
}

// right -> returns the excess coins even if they have zero value.
public fun add_liquidity<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>): (Coin<LpCoin>, Coin<CoinX>, Coin<CoinY>) {
    // Implementation omitted.
    abort(0)
}

// right but not recommended
public fun add_liquidity_and_transfer<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>, recipient: address) {
    let (lp_coin, coin_x, coin_y) = add_liquidity<CoinX, CoinY, LpCoin>(pool, coin_x, coin_y);
    transfer::public_transfer(lp_coin, recipient);
    transfer::public_transfer(coin_x, recipient);
    transfer::public_transfer(coin_y, recipient);
}

// wrong
public fun impure_add_liquidity<CoinX, CoinY, LpCoin>(pool: &mut Pool, coin_x: Coin<CoinX>, coin_y: Coin<CoinY>, ctx: &mut TxContext): Coin<LpCoin> {
    let (lp_coin, coin_x, coin_y) = add_liquidity<CoinX, CoinY, LpCoin>(pool, coin_x, coin_y);
    transfer::public_transfer(coin_x, tx_context::sender(ctx));
    transfer::public_transfer(coin_y, tx_context::sender(ctx));

    lp_coin
}
```

### Coin argument

Pass the `Coin` object by value with the exact right amount directly to improve transaction readability from the frontend.

```move
module conventions::amm;

use sui::coin::Coin;

public struct Pool has key {
    id: UID
}

// right
public fun swap<CoinX, CoinY>(coin_in: Coin<CoinX>): Coin<CoinY> {
    // Implementation omitted.
    abort(0)
}

// wrong
public fun exchange<CoinX, CoinY>(coin_in: &mut Coin<CoinX>, value: u64): Coin<CoinY> {
    // Implementation omitted.
    abort(0)
}
```

### Access control

To maintain composability, use capability objects instead of arrays of addresses for access control.

```move
module conventions::access_control;

use sui::sui::SUI;
use sui::balance::Balance;
use sui::coin::{Self, Coin};
use sui::table::{Self, Table};

public struct Account has key, store {
    id: UID,
    balance: u64
}

public struct State has key {
    id: UID,
    // field not necessary as the state lives in the Account objects
    accounts: Table<address, u64>,
    balance: Balance<SUI>
}

// right -> with this function, another protocol can hold the `Account` on behalf of a user.
public fun withdraw(state: &mut State, account: &mut Account, ctx: &mut TxContext): Coin<SUI> {
    let authorized_balance = account.balance;

    account.balance = 0;

    coin::take(&mut state.balance, authorized_balance, ctx)
}

// wrong -> this is less composable.
public fun wrong_withdraw(state: &mut State, ctx: &mut TxContext): Coin<SUI> {
    let sender = tx_context::sender(ctx);

    let authorized_balance = table::borrow_mut(&mut state.accounts, sender);
    let value = *authorized_balance;
    *authorized_balance = 0;
    coin::take(&mut state.balance, value, ctx)
}
```

### Data storage in owned vs shared objects

If your dApp data has a one to one relationship, it's best to use owned objects.

```move
module conventions::vesting_wallet;

use sui::sui::SUI;
use sui::coin::Coin;
use sui::table::Table;
use sui::balance::Balance;

public struct OwnedWallet has key {
    id: UID,
    balance: Balance<SUI>
}

public struct SharedWallet has key {
    id: UID,
    balance: Balance<SUI>,
    accounts: Table<address, u64>
}


// A vesting wallet releases a certain amount of coin over a period of time.
// If the entire balance belongs to one user and the wallet has no additional functionalities, it is best to store it in an owned object.
public fun new(deposit: Coin<SUI>, ctx: &mut TxContext): OwnedWallet {
    // Implementation omitted.
    abort(0)
}

// If you wish to add extra functionality to a vesting wallet, it is best to share the object.
// For example, if you wish the issuer of the wallet to be able to cancel the contract in the future.
public fun new_shared(deposit: Coin<SUI>, ctx: &mut TxContext) {
    // Implementation omitted.
    // shares the `SharedWallet`.
    abort(0)
}
```

### Admin capability

In admin-gated functions, the capability should be placed as the second parameter. This keeps the capability visible in method signatures and maintains method associativity.

```move
module conventions::social_network;

use std::string::String;

public struct Account has key {
    id: UID,
    name: String
}

public struct Admin has key {
    id: UID,
}

// right -> account.set(&cap, b"jose".to_string()); (normal method associativity)
public fun set(account: &mut Account, _: &Admin, new_name: String) {
    // Implementation omitted.
    abort(0)
}

// wrong -> cap.update(&mut account, b"jose".to_string()); (reversed associativity)
public fun update(_: &Admin, account: &mut Account, new_name: String) {
    // Implementation omitted.
    abort(0)
}
```

## Documentation

There is nothing more pleasant than a well-written and well-documented codebase. While some argue that clean code is self-documenting, well-documented code is self-explanatory.

### Comments

Document your code by explaining functions and structs in simple terms using the `///` syntax (doc comment). If you want to add technical insights for developers that might use your code, use the `//` syntax (regular comment).

Use field comments to describe the properties of your structs. In complex functions, you can also describe the parameters and return values.

```move
module conventions::hero;

use std::string::String;
use sui::kiosk::{Kiosk, KioskOwnerCap};

public struct Hero has key, store {
    id: UID,
    // power of the nft
    power: u64
}

/// Creates and returns a new Hero object
public fun new(ctx: &mut TxContext): Hero {
    Hero {
        id: object::new(ctx),
        power: 0
    }
}

// should be initialized before being shared
public fun initialize_hero(hero: &mut Hero) {
    hero.power = 100;
}

public fun start_battle(
    self: &mut Kiosk, // user kiosk
    cap: &KioskOwnerCap, // user kiosk owner cap
    _policy: &TransferPolicy<Hero>, // transfer policy for the game
    hero_id: ID, // hero to use
    battle_id: String // id of the battle to start
) {
    // Implementation omitted.
    abort(0)
}
```

### README

Create a `README.md` file in the root of the package. Include a description of the package, the purpose of the package, and how to use it.
>>>> sui/docs/content/concepts/sui-move-concepts/derived-objects.mdx
---
title: Derived Objects
description: Derived objects enable deterministic object addresses, Transfer-to-Object capabilities, guaranteed uniqueness, and native parallelization for building scalable composable systems on Sui.
keywords: [ Derived objects, deterministic addresses, Transfer-to-Object, TTO, parallelization, object composition, scalability ]
---

Sui objects get a unique ID assigned to them upon object creation. However, a **derived object** does not technically have an assigned ID; instead it has a _claimed_ ID created through the mapping of a parent object to a key. The parent object's unique ID that exists on-chain is mapped to an individual key, ensuring that the derived object's claimed ID is both deterministic and unique. You can deterministically compute derived object IDs using the parent ID and a key, both on- and off-chain. This means you can compute the ID of a derived object before you ever actually create it on the network.

<iframe width="560" height="315" src="https://www.youtube.com/embed/dJl1zlP_YR4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

To claim an ID using the `derived_object` module, pass the parent object and key. The parent object might already exist on-chain, either through a published package or through a transaction. An existing parent object is not a requirement, however, as you could create a new parent object in a function and immediately claim a derived object UID from a provided key. This workflow would not support off-chain determinism, though, because you could not know the parent UID beforehand.

:::info

Parent objects can be [shared, owned, party, or wrapped](../object-ownership.mdx).

:::

The key can be an address or object ID, but using a unique value is not required. You could use, for example, a finite array of numbers (`[1, 2, 3]`) as your possible keys. Doing so means that more than one derived object might attempt to claim an ID using the same digit as their key. The `derived_object` module prevents duplication in such situations through the use of a `ClaimedStatus` enum, setting its value to `Reserved` when an ID is claimed. If two transactions tried to claim an ID, each using the same digit as its key, the second transaction fails because the first transaction already reserved the ID.

Claiming the ID of derived objects requires a parent object, but the derived objects are not children of that parent. This is an important distinction because the lack of a hierarchal relationship means that using a derived object as input to a transaction does not require sequential processing through the parent. The derived object is its own entity; the parent only exists to ensure its uniqueness. This relationship provides parallelization that is not possible with parent-child relationships.

If you know the parent ID, you can compute the ID of the derived object through off-chain logic using the [TypeScript](https://sdk.mystenlabs.com/typescript/utils/derived_objects) or [Rust SDK](https://mystenlabs.github.io/sui/sui_types/derived_object/index.html) helper functions. This functionality means your client logic can treat unclaimed IDs as if they already exist.

<details>
<summary>
`derived_object` package source
</summary>
<ImportContent source="crates/sui-framework/packages/sui-framework/sources/derived_object.move" mode="code" />
</details>

## Core capabilities

Derived objects provide four fundamental capabilities: deterministic addresses, Transfer-to-Object compatibility, one-per-key uniqueness, and native parallelization.

### Deterministic addresses

You can compute derived object IDs ahead of time using the `derived_object::derive_address(parent_id, key)` function. This means applications can predict where objects are going to live before they exist, enabling sophisticated coordination patterns and reducing the need for on-chain lookups.

### Transfer-to-Object (TTO) compatibility

Because the ID of a derived object can exist before the object does, derived objects can also receive transfers before they exist. This enables you to send assets to a derived address, then create the object later for claiming. This enables patterns like:

- Pre-funding accounts before user onboarding.
- Conditional object creation based on received assets, such as creation of an object only after receiving SUI.
- Cross-chain bridging to deterministic destinations.

### One-per-key uniqueness

Each `(parent, key)` pair maps to exactly one object address. This gives you registry-like uniqueness guarantees without the registry bottleneck. Example use cases include:

- Soulbound tokens
- Per-user configurations
- Any scenario requiring unique slots

### Native parallelization

In contrast to dynamic fields, which route operations through a parent object, derived objects function autonomously after you create them. Unrelated keys update in parallel, avoiding consensus hotspots while maintaining namespace guarantees.

These capabilities combine to enable entirely new design patterns that were previously impossible or inefficient.

**On-chain benefits**

- Less contention and better parallelism: No parent bottleneck for unrelated keys.
- Deterministic uniqueness: One object per `(parent, key)` without manual bookkeeping.
- Top-level object ergonomics: Clean capability patterns, Object Display, and simpler permissioning.

**Off-chain benefits**

- Fewer hops: Clients can compute or look up the derived object ID directly without requiring a sequential operation to find it through the parent.
- Better discoverability and indexing: SDKs can compute objects with fewer sequential queries.
- Lean SDK calls: Fewer queries minimizes the SDK codebase and improves performance through reduced network traffic (object lookups can be bundled in multiGet queries).

## Derived objects and dynamic fields matrix

The following matrix highlights some of the differences between using dynamic fields versus derived objects. Considering the tradeoffs helps you select the optimal approach for your project.

| Aspect | Derived objects | Dynamic fields |
| --- | --- | --- |
| Address predictability | âœ… Yes | âœ… Yes |
| Parent required? | Only to create | âœ… Yes |
| Ownership type | Any. Can be wrapped or shared, owned, party, or frozen. | Cannot be independently owned. Owner is always the parent. |
| Supports receiving objects? | âœ… Yes | âŒ No |
| Object parallelism | âœ… Yes | Limited. All writes sequenced through parent. |
| Loading type | Static. Direct access after creation. | Dynamic. They are loaded through the parent. |
| Supports deletion? | âœ… Yes | âœ… Yes |
| Supports reclaiming? | âŒ Currently no | âœ… Yes |

## Registries {#registries}

The derived object model defines a broad design space, enabling implementation of a wide range of patterns. Registry structures are patterns that work particularly well with derived objects because they manage key-value mappings efficiently and avoid centralized bottlenecks. The following sections compare different registry implementations to illustrate the inherent trade-offs to each pattern.

### Classic registry

Perhaps the biggest advantage for classic registries are the straightforward queries. This increased discoverability comes at the cost of parallelization, however, as all operations must go through the parent object.

```move
const EVaultAlreadyExists: u64 = 0;

public struct VaultRegistry has key {
  id: UID,
  vaults: Table<address, Vault>,
}

public struct Vault has key, store {
  id: UID,
}

// Creating a vault goes through the registry and is stored there.
public fun new(registry: &mut VaultRegistry, ctx: &mut TxContext) {
  assert!(!registry.vaults.contains(ctx.sender()), EVaultAlreadyExists);

  let vault = Vault {
    id: object::new(ctx),
  };

  registry.vaults.add(ctx.sender(), vault);
}

// Access vault through parent
public fun receive_from_vault<T key + store>(
  registry: &mut VaultRegistry,
  receiving: Receiving<T>,
  ctx: &mut TxContext,
): T {
  let vault = registry.vaults.borrow_mut(ctx.sender());

  let obj = transfer::public_receive(&mut vault.id, receiving);

  obj
}
```

### Registry with pointer

If parallelization is an important aspect for your project, you could create a registry that uses a pointer. This approach provides good parallelization, but requires 2 sequential network hops to discover. To find a vault, you first have to find its pointer.

```move
const EVaultAlreadyExists: u64 = 0;

public struct VaultRegistry has key {
  id: UID,
  vaults: Table<address, Vault>,
}

public struct Vault has key, store {
  id: UID,
}

// Creating a vault goes through the registry but only a pointer to the vault is stored there.
public fun new(registry: &mut VaultRegistry, ctx: &mut TxContext) {
  assert!(!registry.vaults.contains(ctx.sender()), EVaultAlreadyExists);

  let vault = Vault {
    id: object::new(ctx),
  };

  registry.vaults.add(ctx.sender(), vault.id.to_inner());

  transfer::transfer(vault, ctx.sender());
}

// Access vault without relying on parent
public fun receive_from_vault<T key + store>(
  vault: &mut Vault,
  receiving: Receiving<T>,
  ctx: &mut TxContext,
): T {

  let obj = transfer::public_receive(&mut vault.id, receiving);

  obj
}
```

### Derived objects

Using derived objects doesn't require a tradeoff between discoverability and parallelization.

```move
const EVaultAlreadyExists: u64 = 0;

public struct VaultRegistry has key {
  id: UID,
  vaults: Table<address, Vault>,
}

public struct Vault has key, store {
  id: UID,
}

// Creating a unique soulbound vault from address.
public fun new(registry: &mut VaultRegistry, ctx: &mut TxContext) {
  assert!(!derived_object::exists(&registry.id, ctx.sender()), EVaultAlreadyExists);

  let vault = Vault {
    id: derived_object::claim(&mut registry.id, ctx.sender()),
  };

  transfer::transfer(vault, ctx.sender());
}

// Access vault without relying on parent
public fun receive_from_vault<T key + store>(
  vault: &mut Vault,
  receiving: Receiving<T>,
): T {

  let obj = transfer::public_receive(&mut vault.id, receiving);

  obj
}

```

## Related links

<RelatedLink to="/concepts/dynamic-fields" />
<RelatedLink to="/concepts/object-ownership" />
<RelatedLink to="/concepts/transfers/transfer-to-object" />
<RelatedLink href="https://github.com/MystenLabs/sui/tree/main/examples/move/profiles" label="Profiles example" desc="An example smart contract that creates profiles using derived objects." />
<RelatedLink href="https://sdk.mystenlabs.com/typescript/utils/derived_objects" label="TypeScript SDK docs" desc="Documentation for deriving addresses using the TypeScript SDK." />
<RelatedLink href="https://mystenlabs.github.io/sui/sui_types/derived_object/index.html" label="Rust SDK helper" desc="Helper function for the Rust SDK." />
<RelatedLink href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/derived_object.move" label="`derived_object` module" desc="The code that defines derived objects on Sui." />
>>>> sui/docs/content/concepts/sui-move-concepts/packages.mdx
---
title: Packages
description: A Move package on Sui includes one or more modules that define that package's interaction with on-chain objects. Upgrading packages lets you improve code or add features without breaking packages that depend on them.
---

A Move package on Sui includes one or more modules that define the package's interaction with on-chain objects. You develop the logic for those modules in Move, compile them into an object, and publish that package object to a Sui network. On-chain, anyone can view a package's contents and see how its logic manipulates objects using a Sui Explorer.

## Packages are immutable

After you publish a package object to a network, it lives there permanently. You cannot directly change the code of an on-chain package. Once published, other packages can import and use the modules it provides.

If developers could modify on-chain packages after publication, downstream behavior could change in unexpected ways. For example, a developer fixing an overlooked bug could unintentionally change the execution of every dependent package.

## Upgrading packages

Although you cannot edit a published package directly, you can **upgrade** it. Upgrading creates a new package object on-chain, leaving the original intact. This lets you add features or fix issues without breaking existing dependencies.

See [Upgrading packages](/concepts/sui-move-concepts/packages/upgrade.mdx) for details on the process.

## Using the Sui Client CLI

The [Sui Client CLI](/references/cli/client.mdx) provides an approachable way to upgrade packages. If the CLI's active address owns the `UpgradeCap` for a package, you can use the `upgrade` command to perform an upgrade.

This workflow is convenient when you're starting development or iterating quickly. However, protecting package upgrades with a single private key poses security risks:

<ImportContent source="upgrade-single-key-risk.mdx" mode="snippet" />

### Making packages immutable

You can call the Move function `sui::package::make_immutable` to destroy a package's `UpgradeCap` and make the package permanently immutable. This eliminates single-key risk but also prevents all future bug fixes and feature additions.

For a more flexible approach, use [custom upgrade policies](/concepts/sui-move-concepts/packages/custom-policies.mdx) to protect `UpgradeCap` access without giving up the ability to upgrade.
>>>> sui/docs/content/concepts/sui-move-concepts/packages/automated-address-management.mdx
---
title: Automated Address Management
description: Packages published across Mainnet, Testnet, and Devnet each have different addresses. Automated address management tracks these addresses for you.
keywords: [ track address, track package address, package addresses, managing package addresses, managing addresses, tracking addresses, tracking packages, tracking mainnet address, track mainnet address, track testnet address, tracking testnet address, track devnet address, tracking devnet address, conflicting addresses, conflicting package addresses ]
---

When you publish or upgrade a package, its address (also called the package ID) is tracked in the `Move.lock` file. This happens automatically, so you do not need to manually record or update hex addresses (for example, in the `Move.toml` file).

When you publish or upgrade your package on multiple Sui networks (Mainnet, Testnet, Devnet), automated address management tracks separate addresses for each chain. Tracking is based on your active environment (run `sui client active-env` if unsure). For example, if your active environment is set to an RPC connected to `testnet` and you publish a package, the `Move.lock` records the address for that package and associates it with `testnet`.

Automated address management works for one package published to one or more Sui networks. If a package is republished to a network, tracked addresses for that network are overwritten.

## Adopting automated address management

Previously, a `published-at` entry in `Move.toml` was **mandatory**. It is no longer required if the data is tracked in `Move.lock`. For an existing package, you can migrate to automated tracking as follows:

1. Switch to your active environment for the chain where your package is published:

   ```sh
   sui client --switch --env <YOUR-CHAIN-ENVIRONMENT>
   ```

2. Run the `manage-package` command with details of your published package:

   ```sh
   sui move manage-package --environment "$(sui client active-env)" \
                           --network-id "$(sui client chain-identifier)" \
                           --original-id 'ORIGINAL-ADDRESS' \
                           --latest-id 'LATEST-ADDRESS' \
                           --version-number 'VERSION-NUMBER'
   ```

   - `ORIGINAL-ADDRESS`: The address where your package was first published. If you never upgraded, this matches the `published-at` address in `Move.toml`.
   - `LATEST-ADDRESS`: The latest package address. If you never upgraded, this matches `ORIGINAL-ADDRESS`. If upgraded, it matches the current `published-at` address.
   - `VERSION-NUMBER`: `1` if you never upgraded. Otherwise, set to the upgrade count. Look up the package at `LATEST-ADDRESS` to confirm the version number.

3. Delete the `published-at` line in your `Move.toml`.
4. Set your package's address to `0x0` in the `[addresses]` section:

   ```toml
   [package]
   name = "Kiosk"

   [dependencies]
   # ... your dependencies ...

   [addresses]
   kiosk = "0x0"
   ```

Your package is now tracked. Repeat the steps to track addresses for additional environments.

## Package upgrade guidance

- When [upgrading](./upgrade#upgrade-requirements), you need the `UpgradeCap` ID of your package. Automated address management does not track `UpgradeCap`.
- When [upgrading](./upgrade#example), set the `[addresses]` value for your package to `0x0` in `Move.toml`, and restore it with the `ORIGINAL-ADDRESS` after upgrading.

## Troubleshooting

Conflicting addresses can occur if package data becomes inconsistent.

For example, a package might still have a `published-at` value in `Move.toml` while also being tracked in `Move.lock`. The mismatch causes an error when publishing or upgrading.

To fix conflicts:

- **For your own package:**
  - Delete the `published-at` value in `Move.toml` if it's no longer needed. Then set the package's address to `0x0` in `[addresses]`.
  - Or, follow the [adoption steps](#adopting-automated-address-management) above.

- **For a dependency package:**
  - Fix the issue locally using the same steps, or contact the package maintainer to update it upstream.

## Internal reference

This section explains the schema and internal operation of tracked addresses in `Move.lock`. Most developers do not need this detail.

Example schema in a `Move.lock` file:

```toml
[env]

[env.testnet]
chain-id = "4c78adac"
original-published-id = "0xa6041ac57f9151d49d00dcdc4f79f8c5ba1e399e1005dcb0fdd1c8632020d5a6"
latest-published-id = "0xa6041ac57f9151d49d00dcdc4f79f8c5ba1e399e1005dcb0fdd1c8632020d5a6"
published-version = "1"

[env.mainnet]
chain-id = "35834a8a"
original-published-id = "0xaee5759aedf6c533634cdd2de412f6e6dfc754a89b0ec554a73597348f334477"
latest-published-id = "0xaee5759aedf6c533634cdd2de412f6e6dfc754a89b0ec554a73597348f334477"
published-version = "1"
```

:::info

- Each `[env]` table entry represents an environment. When a package is published, its entry is added or updated.
- Entries are keyed by `chain-id`, not the `[env.NAME]`. This ensures addresses are resolved consistently even if users assign arbitrary environment names.
- Key-value pairs correspond to the data described in [adopting automated address management](#adopting-automated-address-management). Use the `sui move manage-package` command as the frontend to modify these values.

:::
>>>> sui/docs/content/concepts/sui-move-concepts/packages/custom-policies.mdx
---
title: Custom Upgrade Policies
description: Custom upgrade policies are used to upgrade live packages while addressing the security risks of single-key ownership upgrades.
keywords: [ upgrade policies, custom upgrade policies, immutable policy, dependency policy, additive policy, compatible policy, create an upgrade policy, isolate a policy ]
---

Protecting the ability to upgrade a package on-chain using a single key can pose a security risk for several reasons:

<ImportContent source="upgrade-single-key-risk.mdx" mode="snippet" />

To address the security risk of single-key upgrade ownership while still providing the opportunity to [upgrade live packages](./upgrade.mdx), Sui offers _custom upgrade policies_. These policies protect `UpgradeCap` access and issue `UpgradeTicket` objects that authorize upgrades on a case-by-case basis.

## Compatibility {#compatibility}

Sui comes with a set of built-in package compatibility policies, listed here from most to least strict:

| Policy          | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Immutable       | No one can upgrade the package.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| Dependency-only | You can modify the dependencies of the package only.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| Additive        | You can add new functionality to the package (for example, new public functions or structs) but you can't change any of the existing functionality (for example, the code in existing public functions cannot change).                                                                                                                                                                                                                                                                                                                                                                        |
| Compatible      | The most relaxed policy. In addition to what the more restrictive policies allow, in an upgraded version of the package: <ul><li>You can change all function implementations.</li><li>You can remove the ability constraints on generic type parameters in function signatures.</li><li>You can change, remove, or make `public` any `private`, `public(friend)`, and `entry` function signatures.</li><li>You cannot change `public` function signatures (except in the case of ability constraints mentioned previously).</li><li>You cannot change existing types.</li></ul> |

Each of these policies, in the order listed, is a superset of the previous one in the type of changes allowed in the upgraded package.

When you publish a package, by default it adopts the most relaxed, compatible policy. You can publish a package as part of a transaction that can change the policy before the transaction successfully completes, making the package available on chain for the first time at the desired policy level, rather than at the default one.

You can change the current policy by calling one of the functions in `sui::package` (`only_additive_upgrades`, `only_dep_upgrades`, `make_immutable`) on the package's `UpgradeCap` and a policy can become only more restrictive. For example, after you call `sui::package::only_dep_upgrades` to restrict the policy to become additive, calling `sui::package::only_additive_upgrades` on the `UpgradeCap` of the same package results in an error.

## Upgrade overview {#upgrade-overview}

Package upgrades must occur end-to-end in a single transaction and are composed of three commands:

1. **Authorization:** Get permission from the `UpgradeCap` to perform
   the upgrade, creating an `UpgradeTicket`.
1. **Execution:** Consume the `UpgradeTicket` and verify the package
   bytecode and compatibility against the previous version, and create
   the on-chain object representing the upgraded package. Return an
   `UpgradeReceipt` as a result on success.
1. **Commit:** Update the `UpgradeCap` with information about the
   newly created package.

While step 2 is a built-in command, steps 1 and 3 are implemented as Move functions. The Sui framework provides their most basic implementation:

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/package.move" mode="" fun="authorize_upgrade,commit_upgrade" noComments />

These are the functions that `sui client upgrade` calls for authorization and commit. Custom upgrade policies work by guarding
access to a package `UpgradeCap` (and therefore to calls of these functions) behind extra conditions that are specific to that policy
(such as voting, governance, permission lists, timelocks, and so on).

Any pair of functions that produces an `UpgradeTicket` from an `UpgradeCap` and consumes an `UpgradeReceipt` to update an
`UpgradeCap` constitutes a custom upgrade policy.

## UpgradeCap {#upgradecap}

The `UpgradeCap` is the central type responsible for coordinating package upgrades.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/package.move" mode="code" struct="UpgradeCap" noComments />

Publishing a package creates the `UpgradeCap` object and upgrading the package updates that object. The owner of this object has permission to:

- Change the compatibility requirements for future upgrades.
- Authorize future upgrades.
- Make the package immutable (not upgradeable).

And its API guarantees the following properties:

- Only the latest version of a package can be upgraded (a linear history is guaranteed).
- Only one upgrade can be in-flight at any time (cannot authorize multiple concurrent upgrades).
- An upgrade can only be authorized for the extent of a single transaction; no one can `store` the `UpgradeTicket` that proves authorization.
- Compatibility requirements for a package can be made only more restrictive over time.

## UpgradeTicket {#upgradeticket}

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/package.move" mode="code" struct="UpgradeTicket" noComments />

An `UpgradeTicket` is proof that an upgrade has been authorized. This authorization is specific to:

- A particular `package: ID` to upgrade from, which must be the latest package in the family identified by the `UpgradeCap` at `cap: ID`.
- A particular `policy: u8` that attests to the kind of compatibility guarantees that the upgrade expects to adhere to.
- A particular `digest: vector<u8>` that identifies the contents of the package after the upgrade.

When you attempt to run the upgrade, the validator checks that the upgrade it is about to perform matches the upgrade that was authorized along all those lines, and does not perform the upgrade if any of these criteria are not met.

After creating an `UpgradeTicket`, you must use it within that transaction (you cannot store it for later, drop it, or burn it), or the transaction fails.

### Package digest {#package-digest}

The `UpgradeTicket` `digest` field comes from the `digest` parameter to `authorize_upgrade`, which the caller must supply. While
`authorize_upgrade` does not process the `digest`, custom policies can use it to authorize only upgrades that it has seen the
bytecode or source code for ahead of time. Sui calculates the digest as follows:

- Take the bytecode for each module, represented as an array of bytes.
- Append the list of the package's transitive dependencies, each represented as an array of bytes.
- Sort this list of byte-arrays lexicographically.
- Feed each element in the sorted list, in order, into a `Blake2B` hasher.
- Compute the digest from this hash state.

Refer to the [implementation for digest calculation](https://github.com/MystenLabs/sui/blob/d8cb153d886d54752763fbdab631b062da7d894b/crates/sui-types/src/move_package.rs#L232-L251) for more information, but in most cases, you can rely on the Move toolchain to output the digest as part of the build, when passing the `--dump-bytecode-as-base64` flag:

```sh
$ sui move build --dump-bytecode-as-base64
```
```sh
FETCHING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test
{"modules":[<MODULE-BYTES-BASE64>],"dependencies":[<DEPENDENCY-IDS>],"digest":[59,43,173,195,216,88,176,182,18,8,24,200,200,192,196,197,248,35,118,184,207,205,33,59,228,109,184,230,50,31,235,201]}
```

## UpgradeReceipt {#upgradereceipt}

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/package.move" mode="code" struct="UpgradeReceipt" noComments />

The `UpgradeReceipt` is proof that the `Upgrade` command ran successfully, and Sui added the new package to the set of created
objects for the transaction. It is used to update its `UpgradeCap` (identified by `cap: ID`) with the ID of the latest package in its
family (`package: ID`).

After Sui creates an `UpgradeReceipt`, you must use it to update its `UpgradeCap` within the same transaction (you cannot store it for later, drop it, or burn it), or the transaction fails.

## Isolating policies {#isolating-policies}

When writing custom upgrade policies, prefer:

- separating them into their own package (not co-located with the code they govern the upgradeability of),
- making that package immutable (not upgradeable), and
- locking in the policy of the `UpgradeCap`, so that the policy cannot be made less restrictive later.

These best practices help uphold **informed user consent** and **bounded risk** by making it clear what a package's upgrade policy is
at the moment a user locks value into it, and ensuring that the policy does not evolve to be more permissive with time, without the package user realizing and choosing to accept the new terms.

## Example: Day of the week upgrade policy {#example-upgrade}

Time to put everything into practice by writing a toy upgrade policy that only authorizes upgrades on a particular day of the week (of the package creator's choosing).

### Creating an upgrade policy {#creating-upgrade-policy}

Start by creating a new Move package for the upgrade policy:

```sh
$ sui move new policy
```

The command creates a `policy` directory with a `sources` folder and `Move.toml` manifest.

In the `sources` folder, create a source file named `day_of_week.move`. Copy and paste the following code into the file:

```move
module policy::day_of_week;

use sui::package;

/// Day is not a week day (number in range 0 <= day < 7).
const ENotWeekDay: u64 = 1;

public struct UpgradeCap has key, store {
    id: UID,
    cap: package::UpgradeCap,
    day: u8,
}

public fun new_policy(
    cap: package::UpgradeCap,
    day: u8,
    ctx: &mut TxContext,
): UpgradeCap {
    assert!(day < 7, ENotWeekDay);
    UpgradeCap { id: object::new(ctx), cap, day }
}
```

This code includes a constructor and defines the object type for the custom upgrade policy.

You then need to add a function to authorize an upgrade, if on the correct day of the week. First, define a couple of constants, one for the error code that identifies an attempted upgrade on a day the policy doesn't allow, and another to define the number of milliseconds in a day (to be used shortly). Add these definitions directly under the current `ENotWeekDay` one.

```move
// Request to authorize upgrade on the wrong day of the week.
const ENotAllowedDay: u64 = 2;

const MS_IN_DAY: u64 = 24 * 60 * 60 * 1000;
```

After the `new_policy` function, add a `week_day` function to get the current weekday. As promised, the function uses the `MS_IN_DAY` constant you defined earlier.

```move
fun week_day(ctx: &TxContext): u8 {
    let days_since_unix_epoch = ctx.epoch_timestamp_ms() / MS_IN_DAY;
    // The unix epoch (1st Jan 1970) was a Thursday so shift days
    // since the epoch by 3 so that 0 = Monday.
    ((days_since_unix_epoch + 3) % 7 as u8)
}

```

This function uses the epoch timestamp from `TxContext` rather than `Clock` because it needs only daily granularity, which means the upgrade transactions don't require consensus.

Next, add an `authorize_upgrade` function that calls the previous function to get the current day of the week, then checks whether that value violates the policy, returning the `ENotAllowedDay` error value if it does.

```move
public fun authorize_upgrade(
    cap: &mut UpgradeCap,
    policy: u8,
    digest: vector<u8>,
    ctx: &TxContext,
): package::UpgradeTicket {
    assert!(week_day(ctx) == cap.day, ENotAllowedDay);
    cap.cap.authorize_upgrade(policy, digest)
}
```

The signature of a custom `authorize_upgrade` can be different from the signature of `sui::package::authorize_upgrade` as long as it returns an `UpgradeTicket`.

Finally, provide implementations of `commit_upgrade` and `make_immutable` that delegate to their respective functions in `sui::package`:

```move
public fun commit_upgrade(
    cap: &mut UpgradeCap,
    receipt: package::UpgradeReceipt,
) {
    cap.cap.commit_upgrade(receipt)
}

public fun make_immutable(cap: UpgradeCap) {
    let UpgradeCap { id, cap, day: _ } = cap;
    id.delete();
    cap.make_immutable()
}
```

The final code in your `day_of_week.move` file should resemble the following:

```move
module policy::day_of_week;

use sui::package;

// Day is not a week day (number in range 0 <= day < 7).
const ENotWeekDay: u64 = 1;
const ENotAllowedDay: u64 = 2;
const MS_IN_DAY: u64 = 24 * 60 * 60 * 1000;

public struct UpgradeCap has key, store {
    id: UID,
    cap: package::UpgradeCap,
    day: u8,
}

public fun new_policy(
    cap: package::UpgradeCap,
    day: u8,
    ctx: &mut TxContext,
): UpgradeCap {
    assert!(day < 7, ENotWeekDay);
    UpgradeCap { id: object::new(ctx), cap, day }
}

fun week_day(ctx: &TxContext): u8 {
    let days_since_unix_epoch = ctx.epoch_timestamp_ms() / MS_IN_DAY;
    // The unix epoch (1st Jan 1970) was a Thursday so shift days
    // since the epoch by 3 so that 0 = Monday.
    ((days_since_unix_epoch + 3) % 7 as u8)
}

public fun authorize_upgrade(
    cap: &mut UpgradeCap,
    policy: u8,
    digest: vector<u8>,
    ctx: &TxContext,
): package::UpgradeTicket {
    assert!(week_day(ctx) == cap.day, ENotAllowedDay);
    cap.cap.authorize_upgrade(policy, digest)
}

public fun commit_upgrade(
    cap: &mut UpgradeCap,
    receipt: package::UpgradeReceipt,
) {
    cap.cap.commit_upgrade(receipt)
}

public fun make_immutable(cap: UpgradeCap) {
    let UpgradeCap { id, cap, day: _ } = cap;
    id.delete();
    cap.make_immutable()
}
```

### Publishing an upgrade policy {#publishing-an-upgrade-policy}

Use the `sui client publish` command to publish the policy.

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client publish
```

<details>
  <summary>
  Console output
  </summary>

A successful publish returns the following:

```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING policy
Successfully verified dependencies on-chain against source.
Transaction Digest: 5BzYX5iV6GP2RaSkZ7JPBRmListD5cEVC7REoKsNoCYc
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Data                                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                                   â”‚
â”‚ Gas Owner: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                                â”‚
â”‚ Gas Budget: 11773600 MIST                                                                                    â”‚
â”‚ Gas Price: 1000 MIST                                                                                         â”‚
â”‚ Gas Payment:                                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                                         â”‚
â”‚  â”‚ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                                    â”‚
â”‚  â”‚ Version: 149516398                                                                                        â”‚
â”‚  â”‚ Digest: HRU5orvkMeouFUVf7MXUpJpXP6W7u8DBzhyMichbW8KP                                                      â”‚
â”‚  â””â”€â”€                                                                                                         â”‚
â”‚                                                                                                              â”‚
â”‚ Transaction Kind: Programmable                                                                               â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ Input Objects                                                                                            â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ 0   Pure Arg: Type: address, Value: "0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241" â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                  â”‚
â”‚ â”‚ Commands                                                                â”‚                                  â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                  â”‚
â”‚ â”‚ 0  Publish:                                                             â”‚                                  â”‚
â”‚ â”‚  â”Œ                                                                      â”‚                                  â”‚
â”‚ â”‚  â”‚ Dependencies:                                                        â”‚                                  â”‚
â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000001 â”‚                                  â”‚
â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000002 â”‚                                  â”‚
â”‚ â”‚  â””                                                                      â”‚                                  â”‚
â”‚ â”‚                                                                         â”‚                                  â”‚
â”‚ â”‚ 1  TransferObjects:                                                     â”‚                                  â”‚
â”‚ â”‚  â”Œ                                                                      â”‚                                  â”‚
â”‚ â”‚  â”‚ Arguments:                                                           â”‚                                  â”‚
â”‚ â”‚  â”‚   Result 0                                                           â”‚                                  â”‚
â”‚ â”‚  â”‚ Address: Input  0                                                    â”‚                                  â”‚
â”‚ â”‚  â””                                                                      â”‚                                  â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                  â”‚
â”‚                                                                                                              â”‚
â”‚ Signatures:                                                                                                  â”‚
â”‚    ijPCo4IFqacqAN64UAaJR+J5YhE3+IiEhXA5eEJiI0LZo1y3+byq1WHb3lgU8HLLJTgp+Cuv5GYHsBN5tofYAA==                  â”‚
â”‚                                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: 5BzYX5iV6GP2RaSkZ7JPBRmListD5cEVC7REoKsNoCYc                                              â”‚
â”‚ Status: Success                                                                                   â”‚
â”‚ Executed Epoch: 589                                                                               â”‚
â”‚                                                                                                   â”‚
â”‚ Created Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  â”‚
â”‚  â”‚ Version: 149516399                                                                             â”‚
â”‚  â”‚ Digest: HLSLcEb3S8t3Zb4cjjSw8dsYhExLyLJ3ParJt2fnoZUu                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xa864e0122efbd1755c387c31bf4ce45c649548d2238c8fcffab4f77cfdab7c1a                         â”‚
â”‚  â”‚ Owner: Immutable                                                                               â”‚
â”‚  â”‚ Version: 1                                                                                     â”‚
â”‚  â”‚ Digest: C9YEPnbCs8dtMUTPrXaSNziXkLWSEnz2zaZsxp1rYYCk                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Mutated Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  â”‚
â”‚  â”‚ Version: 149516399                                                                             â”‚
â”‚  â”‚ Digest: F4zEiy3eS1h9V2EfrV3WXWe8bktA28sbKxzNCqtTRK2T                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Object:                                                                                       â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  â”‚
â”‚  â”‚ Version: 149516399                                                                             â”‚
â”‚  â”‚ Digest: F4zEiy3eS1h9V2EfrV3WXWe8bktA28sbKxzNCqtTRK2T                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Cost Summary:                                                                                 â”‚
â”‚    Storage Cost: 9773600 MIST                                                                     â”‚
â”‚    Computation Cost: 1000000 MIST                                                                 â”‚
â”‚    Storage Rebate: 978120 MIST                                                                    â”‚
â”‚    Non-refundable Storage Fee: 9880 MIST                                                          â”‚
â”‚                                                                                                   â”‚
â”‚ Transaction Dependencies:                                                                         â”‚
â”‚    F2edqX6W9HXU7KzVmfwv9fhGMB6fbjrFo3gVd73S4tK5                                                   â”‚
â”‚    Gtwgse64nSVXhQvmqCpwCe5xJz9N4VypvEGJUy5DyG4e                                                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ No transaction block events â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Created Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0                  â”‚
â”‚  â”‚ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 ) â”‚
â”‚  â”‚ ObjectType: 0x2::package::UpgradeCap                                                          â”‚
â”‚  â”‚ Version: 149516399                                                                            â”‚
â”‚  â”‚ Digest: HLSLcEb3S8t3Zb4cjjSw8dsYhExLyLJ3ParJt2fnoZUu                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚ Mutated Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                  â”‚
â”‚  â”‚ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 ) â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    â”‚
â”‚  â”‚ Version: 149516399                                                                            â”‚
â”‚  â”‚ Digest: F4zEiy3eS1h9V2EfrV3WXWe8bktA28sbKxzNCqtTRK2T                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚ Published Objects:                                                                               â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ PackageID: 0xa864e0122efbd1755c387c31bf4ce45c649548d2238c8fcffab4f77cfdab7c1a                 â”‚
â”‚  â”‚ Version: 1                                                                                    â”‚
â”‚  â”‚ Digest: C9YEPnbCs8dtMUTPrXaSNziXkLWSEnz2zaZsxp1rYYCk                                          â”‚
â”‚  â”‚ Modules: day_of_week                                                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Balance Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  â”‚
â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
â”‚  â”‚ Amount: -9795480                                                                               â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

</details>

Following best practices, use the Sui Client CLI to call `sui::package::make_immutable` on the `UpgradeCap` to make the policy immutable. In your shell, create a variable `upgradecap` and set its value to the `UpgradeCap` object ID listed in the *Object Changes* section of your publish response. Of course, the object ID for your upgrade capability is different than the following example.

```sh
$ upgradecap=0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0

$ sui client call \
    --package 0x2 \
    --module 'package' \
    --function 'make_immutable' \
    --args $upgradecap
```

<details>
  <summary>
  Console output
  </summary>

A successful call returns a response similar to the following:

```sh
Transaction Digest: EuQYMunxnMUFedvXXPck9HrehQnNY4GJ27eFBD7ptk2H
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Data                                                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                      â”‚
â”‚ Gas Owner: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                   â”‚
â”‚ Gas Budget: 2000000 MIST                                                                        â”‚
â”‚ Gas Price: 1000 MIST                                                                            â”‚
â”‚ Gas Payment:                                                                                    â”‚
â”‚  â”Œâ”€â”€                                                                                            â”‚
â”‚  â”‚ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                       â”‚
â”‚  â”‚ Version: 149516399                                                                           â”‚
â”‚  â”‚ Digest: F4zEiy3eS1h9V2EfrV3WXWe8bktA28sbKxzNCqtTRK2T                                         â”‚
â”‚  â””â”€â”€                                                                                            â”‚
â”‚                                                                                                 â”‚
â”‚ Transaction Kind: Programmable                                                                  â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ Input Objects                                                                               â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ 0   Imm/Owned Object ID: 0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0 â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®            â”‚
â”‚ â”‚ Commands                                                                         â”‚            â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚ â”‚ 0  MoveCall:                                                                     â”‚            â”‚
â”‚ â”‚  â”Œ                                                                               â”‚            â”‚
â”‚ â”‚  â”‚ Function:  make_immutable                                                     â”‚            â”‚
â”‚ â”‚  â”‚ Module:    package                                                            â”‚            â”‚
â”‚ â”‚  â”‚ Package:   0x0000000000000000000000000000000000000000000000000000000000000002 â”‚            â”‚
â”‚ â”‚  â”‚ Arguments:                                                                    â”‚            â”‚
â”‚ â”‚  â”‚   Input  0                                                                    â”‚            â”‚
â”‚ â”‚  â””                                                                               â”‚            â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯            â”‚
â”‚                                                                                                 â”‚
â”‚ Signatures:                                                                                     â”‚
â”‚    TiJ5uDmG/d8Ca9xLWY0UEx8VnNO2Va6zBwHoFonWVdQNIgj4ghv+ZrbHW85zHw0WanM8hGebANTxrf12pmHmDQ==     â”‚
â”‚                                                                                                 â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: EuQYMunxnMUFedvXXPck9HrehQnNY4GJ27eFBD7ptk2H                                              â”‚
â”‚ Status: Success                                                                                   â”‚
â”‚ Executed Epoch: 589                                                                               â”‚
â”‚ Mutated Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  â”‚
â”‚  â”‚ Version: 149516400                                                                             â”‚
â”‚  â”‚ Digest: GVZLEsYEDuaZoFoTnvzoHsjGLuVYfZrZEomLRnSCFkzR                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Deleted Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x4de927a10f97520311239cadb7159d4b893275bc74ab4e0af1b16c41ba8275a0                         â”‚
â”‚  â”‚ Version: 149516400                                                                             â”‚
â”‚  â”‚ Digest: 7gyGAp71YXQRoxmFBaHxofQXAipvgHyBKPyxmdSJxyvz                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Object:                                                                                       â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  â”‚
â”‚  â”‚ Version: 149516400                                                                             â”‚
â”‚  â”‚ Digest: GVZLEsYEDuaZoFoTnvzoHsjGLuVYfZrZEomLRnSCFkzR                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Cost Summary:                                                                                 â”‚
â”‚    Storage Cost: 988000 MIST                                                                      â”‚
â”‚    Computation Cost: 1000000 MIST                                                                 â”‚
â”‚    Storage Rebate: 2595780 MIST                                                                   â”‚
â”‚    Non-refundable Storage Fee: 26220 MIST                                                         â”‚
â”‚                                                                                                   â”‚
â”‚ Transaction Dependencies:                                                                         â”‚
â”‚    5BzYX5iV6GP2RaSkZ7JPBRmListD5cEVC7REoKsNoCYc                                                   â”‚
â”‚    Gtwgse64nSVXhQvmqCpwCe5xJz9N4VypvEGJUy5DyG4e                                                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ No transaction block events â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Mutated Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0x057d71e1f7e8341c5f2b203ae5fcb33c024afcc7f1c8c264fe0fe74dddcd828c                  â”‚
â”‚  â”‚ Sender: 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 ) â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    â”‚
â”‚  â”‚ Version: 149516400                                                                            â”‚
â”‚  â”‚ Digest: GVZLEsYEDuaZoFoTnvzoHsjGLuVYfZrZEomLRnSCFkzR                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Balance Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  â”‚
â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
â”‚  â”‚ Amount: 607780                                                                                 â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

</details>

### Creating a package for testing {#creating-testing-package}

With a policy now available on chain, you need a package to upgrade. This topic creates a basic package and references it in the following scenarios, but you can use any package you might have available instead of creating a new one.

If you don't have a package available, use the `sui move new` command to create the template for a new package called `example`.

```sh
$ sui move new example
```

In the `example/sources` directory, create an `example.move` file with the following code:

```move
module example::example {
    struct Event has copy, drop { x: u64 }
    entry fun nudge() {
        sui::event::emit(Event { x: 41 })
    }
}
```

The instruction that follows publishes this example package and then upgrades it to change the value in the `Event` it emits. Because you are using a custom upgrade policy, you need to use the TypeScript SDK to build the package's publish and upgrade commands.

### Using TypeScript SDK {#using-typeccript-sdk}

Create a new directory to store a Node.js project. You can use the `npm init` function to create the `package.json`, or manually create the file. Depending on your approach to creating `package.json`, populate or add the following JSON to it:

```json
{ "type": "module" }
```

Open a terminal or console to the root of your Node.js project. Run the following command to add the Sui TypeScript SDK as a dependency:

```sh
$ npm install @mysten/sui
```

### Publishing a package with custom policy {#publishing-custom-policy}

In the root of your Node.js project, create a script file named `publish.js`. Open the file for editing and define some constants:

- `SUI`: the location of the `sui` CLI binary.
- `POLICY_PACKAGE_ID`: the ID of our published `day_of_week` package.

```js
const SUI = 'sui';
const POLICY_PACKAGE_ID = '<POLICY-PACKAGE>';
```

Next, add boilerplate code to get the signer key pair for the currently active address in the Sui Client CLI:

```js
import { execSync } from 'child_process';
import { readFileSync } from 'fs';
import { homedir } from 'os';
import path from 'path';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { fromBase64 } from '@mysten/sui/utils';

const sender = execSync(`${SUI} client active-address`, { encoding: 'utf8' }).trim();
const signer = (() => {
	const keystore = JSON.parse(
		readFileSync(path.join(homedir(), '.sui', 'sui_config', 'sui.keystore'), 'utf8'),
	);

	for (const priv of keystore) {
		const raw = fromBase64(priv);
		if (raw[0] !== 0) {
			continue;
		}

		const pair = Ed25519Keypair.fromSecretKey(raw.slice(1));
		if (pair.getPublicKey().toSuiAddress() === sender) {
			return pair;
		}
	}

	throw new Error(`key pair not found for sender: ${sender}`);
})();
```

Next, define the path of the package you are publishing. The following snippet assumes that the package is in a sibling directory to
`publish.js`, called `example`:

```js
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
// Location of package relative to current directory
const packagePath = path.join(__dirname, 'example');
```

Next, build the package:

```js
const { modules, dependencies } = JSON.parse(
	execSync(`${SUI} move build --dump-bytecode-as-base64 --path ${packagePath}`, {
		encoding: 'utf-8',
	}),
);
```

Next, construct the transaction to publish the package. Wrap its `UpgradeCap` in a "day of the week" policy, which permits upgrades on Tuesdays, and send the new policy back:

```js
import { Transaction } from '@mysten/sui/transactions';

const tx = new Transaction();
const packageUpgradeCap = tx.publish({ modules, dependencies });
const tuesdayUpgradeCap = tx.moveCall({
	target: `${POLICY_PACKAGE_ID}::day_of_week::new_policy`,
	arguments: [
		packageUpgradeCap,
		tx.pure(1), // Tuesday
	],
});

tx.transferObjects([tuesdayUpgradeCap], tx.pure(sender));
```

And finally, execute that transaction and display its effects to the console. The following snippet assumes that you're running your examples against a local network. Pass `devnet`, `testnet`, or `mainnet` to the `getFullnodeUrl()` function to run on Devnet, Testnet, or Mainnet respectively:

```js
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';

const client = new SuiClient({ url: getFullnodeUrl('localnet') });
const result = await client.signAndExecuteTransaction({
	signer,
	transaction: tx,
	options: {
		showEffects: true,
		showObjectChanges: true,
	},
});

console.log(result);
```

<details>

<summary>

`publish.js`

</summary>

```js
import { execSync } from 'child_process';
import { readFileSync } from 'fs';
import { homedir } from 'os';
import path from 'path';
import { fileURLToPath } from 'url';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import { fromBase64 } from '@mysten/sui/utils';

const SUI = 'sui';
const POLICY_PACKAGE_ID = '<POLICY-PACKAGE>';
const sender = execSync(`${SUI} client active-address`, { encoding: 'utf8' }).trim();
const signer = (() => {
	const keystore = JSON.parse(
		readFileSync(path.join(homedir(), '.sui', 'sui_config', 'sui.keystore'), 'utf8'),
	);

	for (const priv of keystore) {
		const raw = fromBase64(priv);
		if (raw[0] !== 0) {
			continue;
		}

		const pair = Ed25519Keypair.fromSecretKey(raw.slice(1));
		if (pair.getPublicKey().toSuiAddress() === sender) {
			return pair;
		}
	}

	throw new Error(`key pair not found for sender: ${sender}`);
})();

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const packagePath = path.join(__dirname, 'example');

const { modules, dependencies } = JSON.parse(
	execSync(`${SUI} move build --dump-bytecode-as-base64 --path ${packagePath}`, {
		encoding: 'utf-8',
	}),
);

const tx = new Transaction();
const packageUpgradeCap = tx.publish({ modules, dependencies });
const tuesdayUpgradeCap = tx.moveCall({
	target: `${POLICY_PACKAGE_ID}::day_of_week::new_policy`,
	arguments: [
		packageUpgradeCap,
		tx.pure(1), // Tuesday
	],
});

tx.transferObjects([tuesdayUpgradeCap], tx.pure(sender));

const client = new SuiClient({ url: getFullnodeUrl('localnet') });
const result = await client.signAndExecuteTransaction({
	signer,
	transaction: tx,
	options: {
		showEffects: true,
		showObjectChanges: true,
	},
});

console.log(result);
```

</details>

Save your `publish.js` file, and then use Node.js to run the script:

```sh
$ node publish.js
```

<details>
  <summary>
  Console output
  </summary>

If the script is successful, the console prints the following response:

```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING example
{
  digest: '9NBLe61sRqe7wS6y8mMVt6vhwA9W5Sz5YVEmuCwNMT64',
  effects: {
    messageVersion: 'v1',
    status: { status: 'success' },
    executedEpoch: '0',
    gasUsed: {
      computationCost: '1000000',
      storageCost: '6482800',
      storageRebate: '978120',
      nonRefundableStorageFee: '9880'
    },
    modifiedAtVersions: [ [Object] ],
    transactionDigest: '9NBLe61sRqe7wS6y8mMVt6vhwA9W5Sz5YVEmuCwNMT64',
    created: [ [Object], [Object] ],
    mutated: [ [Object] ],
    gasObject: { owner: [Object], reference: [Object] },
    dependencies: [
      'BMVXjS7GG3d5W4Prg7gMVyvKTzEk1Hazx7Tq4WCcbcz9',
      'CAFFD2HHnULQMCycL9xgad5JJpjFu2nuftf2xyugQu4t',
      'GGDUeVkDoNFcyGibGNeiaGSiKsxf9QLzbjqPzdqi3dNJ'
    ]
  },
  objectChanges: [
    {
      type: 'mutated',
      sender: '<SENDER>',
      owner: [Object],
      objectType: '0x2::coin::Coin<0x2::sui::SUI>',
      objectId: '<GAS>',
      version: '10',
      previousVersion: '9',
      digest: 'Dz38faAzFsRzKQyT7JTkVydCcvNNxbUdZiutGmA2Eyy6'
    },
    {
      type: 'published',
      packageId: '<EXAMPLE-PACKAGE>',
      version: '1',
      digest: '5JdU8hkFTjyqg4fHyC8JtdHBV11yCCKdFuyf9j4kKY3o',
      modules: [Array]
    },
    {
      type: 'created',
      sender: '<SENDER>',
      owner: [Object],
      objectType: '<POLICY-PACKAGE>::day_of_week::UpgradeCap',
      objectId: '<EXAMPLE-UPGRADE-CAP>',
      version: '10',
      digest: '3uAMFHFKunX9XrufMe27MHDbeLpgHBSsCPN3gSa93H3v'
    }
  ],
  confirmedLocalExecution: true
}
```

</details>

:::tip

If you receive a `ReferenceError: fetch is not defined` error, use Node.js version 18 or greater.

:::

Use the CLI to test that your newly published package works:

```sh
$ sui client call --gas-budget 10000000 \
    --package '<EXAMPLE-PACKAGE-ID>' \
    --module 'example' \
    --function 'nudge' \
```

<details>
  <summary>
  Console output
  </summary>

A successful call responds with the following:

```sh
----- Transaction Digest ----
Bx1GA8EsBjoLKvXV2GG92DC5Jt58dbytf6jFcLg18dDR
----- Transaction Data ----
Transaction Signature: [Signature(Ed25519SuiSignature(Ed25519SuiSignature([0, 92, 22, 253, 150, 35, 134, 140, 185, 239, 72, 194, 25, 250, 153, 98, 134, 26, 219, 232, 199, 122, 56, 189, 186, 56, 126, 184, 147, 148, 184, 4, 17, 177, 156, 231, 198, 74, 118, 28, 187, 132, 94, 141, 44, 55, 70, 207, 157, 143, 182, 83, 59, 156, 116, 226, 22, 65, 211, 179, 187, 18, 76, 245, 4, 92, 225, 85, 204, 230, 61, 45, 147, 106, 193, 13, 195, 116, 230, 99, 61, 161, 251, 251, 68, 154, 46, 172, 143, 122, 101, 212, 120, 80, 164, 214, 54])))]
Transaction Kind : Programmable
Inputs: []
Commands: [
  MoveCall(<EXAMPLE-PACKAGE>::example::nudge()),
]

Sender: <SENDER>
Gas Payment: Object ID: <GAS>, version: 0xb, digest: 93nZ3uLmLfJdHWoSHMuHsjFstEf45EM2pfovu3ibo4iH
Gas Owner: <SENDER>
Gas Price: 1000
Gas Budget: 10000000

----- Transaction Effects ----
Status : Success
Mutated Objects:
  - ID: <GAS> , Owner: Account Address ( <SENDER> )

----- Events ----
Array [
    Object {
        "id": Object {
            "txDigest": String("Bx1GA8EsBjoLKvXV2GG92DC5Jt58dbytf6jFcLg18dDR"),
            "eventSeq": String("0"),
        },
        "packageId": String("<EXAMPLE-PACKAGE>"),
        "transactionModule": String("example"),
        "sender": String("<SENDER>"),
        "type": String("<EXAMPLE-PACKAGE>::example::Event"),
        "parsedJson": Object {
            "x": String("41"),
        },
        "bcs": String("7rkaa6aDvyD"),
    },
]
----- Object changes ----
Array [
    Object {
        "type": String("mutated"),
        "sender": String("<SENDER>"),
        "owner": Object {
            "AddressOwner": String("<SENDER>"),
        },
        "objectType": String("0x2::coin::Coin<0x2::sui::SUI>"),
        "objectId": String("<GAS>"),
        "version": String("12"),
        "previousVersion": String("11"),
        "digest": String("9aNuZF63uBVaWF9L6cVmk7geimmpP9h9StigdNDPSiy3"),
    },
]
----- Balance changes ----
Array [
    Object {
        "owner": Object {
            "AddressOwner": String("<SENDER>"),
        },
        "coinType": String("0x2::sui::SUI"),
        "amount": String("-1009880"),
    },
]
```

</details>

If you used the example package provided, notice you have an `Events` section that contains a field `x` with value `41`.

### Upgrading a package with custom policy {#upgrading-custom-policy}

With your package published, you can prepare an `upgrade.js` script to perform an upgrade using the new policy. It behaves identically to `publish.js` up until building the package. When building the package, the script also captures its `digest`, and the transaction now performs the three upgrade commands (authorize, execute, commit). The full script for `upgrade.js` follows:

```js
import { execSync } from 'child_process';
import { readFileSync } from 'fs';
import { homedir } from 'os';
import path from 'path';
import { fileURLToPath } from 'url';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction, UpgradePolicy } from '@mysten/sui/transactions';
import { fromBase64 } from '@mysten/sui/utils';

const SUI = 'sui';
const POLICY_PACKAGE_ID = '<POLICY-PACKAGE>';
const EXAMPLE_PACKAGE_ID = '<EXAMPLE-PACKAGE>';
const CAP_ID = '<EXAMPLE-UPGRADE-CAP>';
const sender = execSync(`${SUI} client active-address`, { encoding: 'utf8' }).trim();
const signer = (() => {
	const keystore = JSON.parse(
		readFileSync(path.join(homedir(), '.sui', 'sui_config', 'sui.keystore'), 'utf8'),
	);

	for (const priv of keystore) {
		const raw = fromBase64(priv);
		if (raw[0] !== 0) {
			continue;
		}

		const pair = Ed25519Keypair.fromSecretKey(raw.slice(1));
		if (pair.getPublicKey().toSuiAddress() === sender) {
			return pair;
		}
	}

	throw new Error(`key pair not found for sender: ${sender}`);
})();

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const packagePath = path.join(__dirname, 'example');

const { modules, dependencies, digest } = JSON.parse(
	execSync(`${SUI} move build --dump-bytecode-as-base64 --path ${packagePath}`, {
		encoding: 'utf-8',
	}),
);

const tx = new Transaction();
const cap = tx.object(CAP_ID);
const ticket = tx.moveCall({
	target: `${POLICY_PACKAGE_ID}::day_of_week::authorize_upgrade`,
	arguments: [cap, tx.pure(UpgradePolicy.COMPATIBLE), tx.pure(digest)],
});

const receipt = tx.upgrade({
	modules,
	dependencies,
	packageId: EXAMPLE_PACKAGE_ID,
	ticket,
});

tx.moveCall({
	target: `${POLICY_PACKAGE_ID}::day_of_week::commit_upgrade`,
	arguments: [cap, receipt],
});

const client = new SuiClient({ url: getFullnodeUrl('localnet') });
const result = await client.signAndExecuteTransaction({
	signer,
	transaction: tx,
	options: {
		showEffects: true,
		showObjectChanges: true,
	},
});

console.log(result);
```

If today is not Tuesday, wait until next Tuesday to run the script, when your policy allows you to perform upgrades. At that point, update your `example.move` so the event is emitted with a different constant and use Node.js to run the upgrade script:

```sh
$ node upgrade.js
```

<details>
  <summary>
  Console output
  </summary>

If the script is successful (and today is Tuesday), your console displays the following response:

```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING example
{
  digest: 'EzJyH6BX231sw4jY6UZ6r9Dr28SKsiB2hg3zw4Jh4D5P',
  effects: {
    messageVersion: 'v1',
    status: { status: 'success' },
    executedEpoch: '0',
    gasUsed: {
      computationCost: '1000000',
      storageCost: '6482800',
      storageRebate: '2874168',
      nonRefundableStorageFee: '29032'
    },
    modifiedAtVersions: [ [Object], [Object] ],
    transactionDigest: 'EzJyH6BX231sw4jY6UZ6r9Dr28SKsiB2hg3zw4Jh4D5P',
    created: [ [Object] ],
    mutated: [ [Object], [Object] ],
    gasObject: { owner: [Object], reference: [Object] },
    dependencies: [
      '62BxVq24tgaRrFTXR3i944RRZ6x8sgTGbjFzpFDe2RAB',
      'BMVXjS7GG3d5W4Prg7gMVyvKTzEk1Hazx7Tq4WCcbcz9',
      'Bx1GA8EsBjoLKvXV2GG92DC5Jt58dbytf6jFcLg18dDR',
      'CAFFD2HHnULQMCycL9xgad5JJpjFu2nuftf2xyugQu4t'
    ]
  },
  objectChanges: [
    {
      type: 'mutated',
      sender: '<SENDER>',
      owner: [Object],
      objectType: '0x2::coin::Coin<0x2::sui::SUI>',
      objectId: '<GAS>',
      version: '13',
      previousVersion: '12',
      digest: 'DF4aebHRYrVdxtfAaFfET3hLHn5hqsoty4joMYxLDBuc'
    },
    {
      type: 'mutated',
      sender: '<SENDER>',
      owner: [Object],
      objectType: '<POLICY-PACKAGE>::day_of_week::UpgradeCap',
      objectId: '<EXAMPLE-UPGRADE-CAP>',
      version: '13',
      previousVersion: '11',
      digest: '5Wtuw9mAGBuP5qFdTzDCRxBF9LqJ7uZbpxk2UXhAkrXL'
    },
    {
      type: 'published',
      packageId: '<UPGRADED-EXAMPLE-PACKAGE>',
      version: '2',
      digest: '7mvnMEXezAGcWqYSt6R4QUpPjY8nqTSmb5Dv2SqkVq7a',
      modules: [Array]
    }
  ],
  confirmedLocalExecution: true
}
```

</details>

Use the Sui Client CLI to test the upgraded package (the package ID is **different** from the original version of your example package):

```sh
$ sui client call --gas-budget 10000000 \
    --package '<UPGRADED-EXAMPLE-PACKAGE>' \
    --module 'example' \
    --function 'nudge'
```

<details>
  <summary>
  Console output
  </summary>

If successful, the console prints the following response:

```sh
----- Transaction Digest ----
EF2rQzWHmtjPvkqzFGyFvANA8e4ETULSBqDMkzqVoshi
----- Transaction Data ----
Transaction Signature: [Signature(Ed25519SuiSignature(Ed25519SuiSignature([0, 88, 98, 118, 173, 218, 55, 4, 48, 166, 42, 106, 193, 210, 159, 75, 233, 95, 77, 201, 38, 0, 234, 183, 77, 252, 178, 22, 221, 106, 202, 42, 166, 29, 130, 164, 97, 110, 201, 153, 91, 149, 50, 72, 6, 213, 183, 70, 83, 55, 5, 190, 182, 5, 98, 212, 134, 103, 181, 204, 247, 90, 28, 125, 14, 92, 225, 85, 204, 230, 61, 45, 147, 106, 193, 13, 195, 116, 230, 99, 61, 161, 251, 251, 68, 154, 46, 172, 143, 122, 101, 212, 120, 80, 164, 214, 54])))]
Transaction Kind : Programmable
Inputs: []
Commands: [
  MoveCall(<UPGRADE-EXAMPLE-PACKAGE>::example::nudge()),
]

Sender: <SENDER>
Gas Payment: Object ID: <GAS>, version: 0xd, digest: DF4aebHRYrVdxtfAaFfET3hLHn5hqsoty4joMYxLDBuc
Gas Owner: <SENDER>
Gas Price: 1000
Gas Budget: 10000000

----- Transaction Effects ----
Status : Success
Mutated Objects:
  - ID: <GAS> , Owner: Account Address ( <SENDER> )

----- Events ----
Array [
    Object {
        "id": Object {
            "txDigest": String("EF2rQzWHmtjPvkqzFGyFvANA8e4ETULSBqDMkzqVoshi"),
            "eventSeq": String("0"),
        },
        "packageId": String("<UPGRADE-EXAMPLE-PACKAGE>"),
        "transactionModule": String("example"),
        "sender": String("<SENDER>"),
        "type": String("<EXAMPLE-PACKAGE>::example::Event"),
        "parsedJson": Object {
            "x": String("42"),
        },
        "bcs": String("82TFauPiYEj"),
    },
]
----- Object changes ----
Array [
    Object {
        "type": String("mutated"),
        "sender": String("<SENDER>"),
        "owner": Object {
            "AddressOwner": String("<SENDER>"),
        },
        "objectType": String("0x2::coin::Coin<0x2::sui::SUI>"),
        "objectId": String("<GAS>"),
        "version": String("14"),
        "previousVersion": String("13"),
        "digest": String("AmGocCxy6cHvCuGG3izQ8a7afp6qWWt14yhowAzBYa44"),
    },
]
----- Balance changes ----
Array [
    Object {
        "owner": Object {
            "AddressOwner": String("<SENDER>"),
        },
        "coinType": String("0x2::sui::SUI"),
        "amount": String("-1009880"),
    },
]
```

</details>

Now, the `Events` section emitted for the `x` field has a value of `42` (changed from the original `41`).

If you attempt the first upgrade before Tuesday or you change the constant again and try the upgrade the following day, the script receives a response that includes an error similar to the following, which indicates that the upgrade aborted with code `2` (`ENotAllowedDay`):

```sh
...
status: {
  status: 'failure',
  error: 'MoveAbort(MoveLocation { module: ModuleId { address: <POLICY-PACKAGE>, name: Identifier("day_of_week") }, function: 1, instruction: 11, function_name: Some("authorize_upgrade") }, 2) in command 0'
},
...
```
>>>> sui/docs/content/concepts/sui-move-concepts/packages/upgrade.mdx
---
title: Upgrading Packages
description: Sui provides a method of upgrading your packages while still retaining their immutable properties.
keywords: [ upgrading packages, upgrade considerations, how to upgrade a package, how to upgrade, update package, update, how to update ]
---

Sui smart contracts are immutable package objects consisting of a collection of Move modules. Because the packages are immutable, transactions can safely access smart contracts without full consensus (fastpath transactions). If someone could change these packages, they would become [shared objects](/concepts/object-ownership/shared.mdx#shared), which would require full consensus before completing a transaction.

The inability to change package objects, however, becomes a problem when considering the iterative nature of code development. Builders require the ability to update their code and pull changes from other developers while still being able to reap the benefits of fastpath transactions. Fortunately, the Sui network provides a method of upgrading your packages while still retaining their immutable properties.

## Upgrade considerations

There are some details of the process that you should consider before upgrading your packages.

For example, module initializers do not re-run with package upgrades. When you publish your initial package, Move runs the `init` function you define for the package once (and only once) at the time of the publish event. Any `init` functions you might include in subsequent versions of your package are ignored. See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in The Move Book for more information.

As alluded to previously, all packages on the Sui network are immutable. Because of this fact, you cannot delete old packages from the chain. As a result, there is nothing that prevents other packages from accessing the methods and types defined in the old versions of your upgraded packages. By default, users can choose to keep using the old version of a package, as well. As a package developer, you must be aware of and account for this possibility.

For example, you might define an `increment` function in your original package:

```move
public fun increment(c: &mut Counter) {
    c.value = c.value + 1;
}
```

Then, your package upgrade might add an emit event to the `increment` function:

```move
public struct Progress has copy, drop {
    reached: u64
}

public fun increment(c: &mut Counter) {
    c.value = c.value + 1;

    if (c.value % 100 == 0) {
        event::emit(Progress { reached: c.value });
    }
}
```

If there is a mix of callers for both the old and upgraded `increment` function, then the process fails because the old function is not aware of the `Progress` event.

Similar to mismatched function definitions, you might also run into issues maintaining dynamic fields that need to remain in sync with a struct's original fields. To address these issues, you can introduce a new type as part of the upgrade and port users over to it, breaking backwards compatibility. For example, if you're using owned objects to demonstrate proof, like proof of ownership, and you develop a new version of your package to address problematic code, you can introduce a new type in the upgraded package. You can then add a function to your package that trades old objects for new ones. Because your logic only recognizes objects with the new type, you effectively force users to update.

Another example of having users update to the latest package is when you have a bookkeeping shared object in your package that you discover has flawed logic so is not functioning as expected. As in the previous example, you want users to use only the object defined in the upgraded package with the correct logic, so you add a new type and migration function to your package upgrade. This process requires a couple of transactions, one for the upgrade and another that you call from the upgraded package to set up the new shared object that replaces the existing one. To protect the setup function, you would need to create an `AdminCap` object or similar as part of your package to make sure you, as the package owner, are the only authorized initiator of that function. Perhaps even more useful, you might include a flag in the shared object that allows you, as the package owner, to toggle the enabled state of that shared object. You can add a check for the enabled state to prevent access to that object from the on-chain public while you perform the migration. Of course, you would probably create this flag only if you expected to perform this migration at some point in the future, not because you're intentionally developing objects with flawed logic.

### Versioned shared objects

When you create packages that involve shared objects, you need to think about upgrades and versioning from the start given that **all prior versions of a package still exist on-chain**. A useful pattern is to introduce versioning to the shared object and using a version check to guard access to functions in the package. This enables you to limit access to the shared object to only the latest version of a package.

Considering the earlier `counter` example, which might have started life as follows:

```move
module example::counter;

public struct Counter has key {
    id: UID,
    value: u64,
}

fun init(ctx: &mut TxContext) {
    transfer::share_object(Counter {
        id: object::new(ctx),
        value: 0,
    })
}

public fun increment(c: &mut Counter) {
    c.value = c.value + 1;
}
```

To ensure that upgrades to this package can limit access of the shared object to the latest version of the package, you need to:

1. Track the current version of the module in a constant, `VERSION`.
2. Track the current version of the shared object, `Counter`, in a new `version` field.
3. Introduce an `AdminCap` to protect privileged calls, and associate the `Counter` with its `AdminCap` with a new field (you might already have a similar type for shared object administration, in which case you can re-use that). This cap is used to protect calls to migrate the shared object from version to version.
4. Guard the entry of all functions that access the shared object with a check that its `version` matches the package `VERSION`.

An upgrade-aware `counter` module that incorporates all these ideas looks as follows:

```move
module example::counter;

/// Not the right admin for this counter
const ENotAdmin: u64 = 0;

/// Calling functions from the wrong package version
const EWrongVersion: u64 = 1;

// 1. Track the current version of the module
const VERSION: u64 = 1;

public struct Counter has key {
    id: UID,
    // 2. Track the current version of the shared object
    version: u64,
    // 3. Associate the `Counter` with its `AdminCap`
    admin: ID,
    value: u64,
}

public struct AdminCap has key {
    id: UID,
}

fun init(ctx: &mut TxContext) {
    let admin = AdminCap { id: object::new(ctx) };

    transfer::share_object(Counter {
        id: object::new(ctx),
        version: VERSION,
        admin: object::id(&admin),
        value: 0,
    });

    transfer::transfer(admin, ctx.sender());
}

public fun increment(c: &mut Counter) {
    // 4. Guard the entry of all functions that access the shared object
    //    with a version check.
    assert!(c.version == VERSION, EWrongVersion);
    c.value = c.value + 1;
}
```

To upgrade a module using this pattern requires making two extra changes, on top of any implementation changes your upgrade requires:

1. Bump the `VERSION` of the package.
2. Introduce a `migrate` function to upgrade the shared object.

The following module is an upgraded `counter` that emits `Progress` events as originally discussed, but also provides tools for an admin (`AdminCap` holder) to prevent accesses to the counter from older package versions:

```move
module example::counter;

use sui::event;

/// Not the right admin for this counter
const ENotAdmin: u64 = 0;

/// Migration is not an upgrade
const ENotUpgrade: u64 = 1;

/// Calling functions from the wrong package version
const EWrongVersion: u64 = 2;

// 1. Bump the `VERSION` of the package.
const VERSION: u64 = 2;

public struct Counter has key {
    id: UID,
    version: u64,
    admin: ID,
    value: u64,
}

public struct AdminCap has key {
    id: UID,
}

public struct Progress has copy, drop {
    reached: u64,
}

fun init(ctx: &mut TxContext) {
    let admin = AdminCap {
        id: object::new(ctx),
    };

    transfer::share_object(Counter {
        id: object::new(ctx),
        version: VERSION,
        admin: object::id(&admin),
        value: 0,
    });

    transfer::transfer(admin, ctx.sender());
}

public fun increment(c: &mut Counter) {
    assert!(c.version == VERSION, EWrongVersion);
    c.value = c.value + 1;

    if (c.value % 100 == 0) {
        event::emit(Progress { reached: c.value })
    }
}

// 2. Introduce a migrate function
entry fun migrate(c: &mut Counter, a: &AdminCap) {
    assert!(c.admin == object::id(a), ENotAdmin);
    assert!(c.version < VERSION, ENotUpgrade);
    c.version = VERSION;
}
```

Upgrading to this version of the package requires performing the package upgrade, and calling the `migrate` function in a follow-up transaction. Note that the `migrate` function:

- Is an `entry` function and **not `public`**. This allows it to be entirely changed (including changing its signature or removing it entirely) in later upgrades.
- Accepts an `AdminCap` and checks that its ID matches the ID of the counter being migrated, making it a privileged operation.
- Includes a sanity check that the version of the module is actually an upgrade for the object. This helps catch errors such as failing to bump the module version before upgrading.

After a successful upgrade, calls to `increment` on the previous version of the package aborts on the version check, while calls on the later version should succeed.

### Extensions

This pattern forms the basis for upgradeable packages involving shared objects, but you can extend it in a number of ways, depending on your package's needs:

- The version constraints can be made more expressive:
  - Rather than using a single `u64`, versions could be specified as a `String`, or a pair of upper and lower bounds.
  - You can control access to specific functions or sets of functions by adding and removing marker types as dynamic fields on the shared object.
- The `migrate` function could be made more sophisticated (modifying other fields in the shared object, adding or removing dynamic fields, migrating multiple shared objects simultaneously).
- You can implement large migrations that need to run over multiple transactions in a three phase set-up:
  - Disable general access to the shared object by setting its version to a sentinel value (for example, `U64_MAX`), using an `AdminCap`-guarded call.
  - Run the migration over the course of multiple transactions (for example, if a large volume of objects need to be moved, it is best to do this in batches, to avoid hitting transaction limits).
  - Set the version of the shared object back to a usable value.

## Upgrade requirements

To upgrade a package, your package must satisfy the following requirements:

- You must have an `UpgradeTicket` for the package you want to upgrade. The Sui network issues `UpgradeCap`s when you publish a package, then you can issue `UpgradeTicket`s as the owner of that `UpgradeCap`. The Sui Client CLI handles this requirement automatically.
- Your changes must be layout-compatible with the previous version.
  - Existing `public` function signatures must remain the same.
  - Existing struct layouts (including struct abilities) must remain the same.
  - You can add new structs and functions.
  - You can remove generic type constraints from existing functions (public or otherwise).
  - You can change function implementations.
  - You can change non-`public` function signatures, including `friend` and `entry` function signatures.

:::info

If you have a package with a dependency, and that dependency is upgraded, your package does not automatically depend on the newer version. You must explicitly upgrade your own package to point to the new dependency.

:::

## Upgrading

Use the `sui client upgrade` command to upgrade packages that meet the previous requirements, providing values for the following flags:

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

- `--gas-budget`: The maximum number of gas units that can be expended before the network cancels the transaction.
- `--cap`: The ID of the `UpgradeCap`. You receive this ID as a return from the publish command.

Developers upgrading packages using Move code have access to types and functions to define custom upgrade policies. For example, a Move developer might want to disallow upgrading a package, regardless of the current package owner. The [`make_immutable` function](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/package.md#0x2_package_make_immutable) is available to them to create this behavior. More advanced policies using available types like `UpgradeTicket` and `Upgrade Receipt` are also possible. For an example, see this [custom upgrade policy](https://github.com/MystenLabs/sui/issues/2045#:~:text=Implement%20a%20custom%20upgrade%20policy) on GitHub.

When you use the Sui Client CLI, the `upgrade` command handles generating the upgrade digest, authorizing the upgrade with the `UpgradeCap` to get an `UpgradeTicket`, and updating the `UpgradeCap` with the `UpgradeReceipt` after a successful upgrade. To learn more about these processes, see the Move documentation for the [package module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/package.md).

## Example

You develop a package named `sui_package`. Its manifest looks like the following:

```toml
[package]
name = "sui_package"
version = "0.0.0"

[addresses]
sui_package = "0x0"
```

When your package is ready, you publish it:

```sh
$ sui client publish
```

<details>
<summary>Output</summary>

```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING my_first_package
Successfully verified dependencies on-chain against source.
Transaction Digest: GPSpH264CjQPaXQPpMHpkzyGidZnQFvd1yUH5s9ncesi
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Data                                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sender: PUBLISHER-ID                                                                                         â”‚
â”‚ Gas Owner: PUBLISHER-ID                                                                                      â”‚
â”‚ Gas Budget: 12298000 MIST                                                                                    â”‚
â”‚ Gas Price: 1000 MIST                                                                                         â”‚
â”‚ Gas Payment:                                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                                         â”‚
â”‚  â”‚ ID: GAS-COIN-ID                                                                                           â”‚
â”‚  â”‚ Version: 2                                                                                                â”‚
â”‚  â”‚ Digest: QDssxM4QKnhutWCYijiWWmYPtKWnHB9xVaLqPsDHiep                                                       â”‚
â”‚  â””â”€â”€                                                                                                         â”‚
â”‚                                                                                                              â”‚
â”‚ Transaction Kind: Programmable                                                                               â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ Input Objects                                                                                            â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ 0   Pure Arg: Type: address, Value: "PUBLISHER-ID"                                                       â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                  â”‚
â”‚ â”‚ Commands                                                                â”‚                                  â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                  â”‚
â”‚ â”‚ 0  Publish:                                                             â”‚                                  â”‚
â”‚ â”‚  â”Œ                                                                      â”‚                                  â”‚
â”‚ â”‚  â”‚ Dependencies:                                                        â”‚                                  â”‚
â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000001 â”‚                                  â”‚
â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000002 â”‚                                  â”‚
â”‚ â”‚  â””                                                                      â”‚                                  â”‚
â”‚ â”‚                                                                         â”‚                                  â”‚
â”‚ â”‚ 1  TransferObjects:                                                     â”‚                                  â”‚
â”‚ â”‚  â”Œ                                                                      â”‚                                  â”‚
â”‚ â”‚  â”‚ Arguments:                                                           â”‚                                  â”‚
â”‚ â”‚  â”‚   Result 0                                                           â”‚                                  â”‚
â”‚ â”‚  â”‚ Address: Input  0                                                    â”‚                                  â”‚
â”‚ â”‚  â””                                                                      â”‚                                  â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                  â”‚
â”‚                                                                                                              â”‚
â”‚ Signatures:                                                                                                  â”‚
â”‚    4NqP6CL1/LN1Ekr9NeL82PFGgVdEjrwsP82l/0mFvCd9TYO94CKBQAm8C/D6DsAuBrwu4cogQ3Mbh1huGc0yCg==                  â”‚
â”‚                                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: GPSpH264CjQPaXQPpMHpkzyGidZnQFvd1yUH5s9ncesi                                              â”‚
â”‚ Status: Success                                                                                   â”‚
â”‚ Executed Epoch: 285                                                                               â”‚
â”‚                                                                                                   â”‚
â”‚ Created Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: ORIGINAL-PACKAGE-ID                                                                        â”‚
â”‚  â”‚ Owner: Immutable                                                                               â”‚
â”‚  â”‚ Version: 1                                                                                     â”‚
â”‚  â”‚ Digest: 4ZvhnDgehkRmzo3mtHjCc6aQkEz1SA87rDpDS6pGarFR                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xaa06f409af7a36c20a552e729eb985a9979149ae9ada5ce3ed413836fd12ed16                         â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                        â”‚
â”‚  â”‚ Version: 3                                                                                     â”‚
â”‚  â”‚ Digest: 71G4PuCUoqx1KDTnt8zGMYUf6Qpf4CWgZsDxYN1d7mXE                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: UPGRADE-CAP-ID                                                                             â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                        â”‚
â”‚  â”‚ Version: 3                                                                                     â”‚
â”‚  â”‚ Digest: FNxdiGCk1fwXByda6Q2sx8RjuwUQBFYQk7C4Zr2H4qVw                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Mutated Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: GAS-COIN-ID                                                                                â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                        â”‚
â”‚  â”‚ Version: 3                                                                                     â”‚
â”‚  â”‚ Digest: 9Fet6LPSBsjYjVMEQxkB4LRHfAJDFCQQ2iUAiUQ5eygF                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Object:                                                                                       â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: GAS-COIN-ID                                                                                â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                        â”‚
â”‚  â”‚ Version: 3                                                                                     â”‚
â”‚  â”‚ Digest: 9Fet6LPSBsjYjVMEQxkB4LRHfAJDFCQQ2iUAiUQ5eygF                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Cost Summary:                                                                                 â”‚
â”‚    Storage Cost: 10298000 MIST                                                                    â”‚
â”‚    Computation Cost: 1000000 MIST                                                                 â”‚
â”‚    Storage Rebate: 978120 MIST                                                                    â”‚
â”‚    Non-refundable Storage Fee: 9880 MIST                                                          â”‚
â”‚                                                                                                   â”‚
â”‚ Transaction Dependencies:                                                                         â”‚
â”‚    3eHwwq6p2xQwBtXDE9KKNQwZFdHUGEKiJsR5LDmv4o7b                                                   â”‚
â”‚    7KAuWTJHCZmh2rMSAqobkhU5cuRBoVicwae78i9woDUK                                                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ No transaction block events â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object Changes                                                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Created Objects:                                                                                   â”‚
â”‚  â”Œâ”€â”€                                                                                               â”‚
â”‚  â”‚ ObjectID: 0xaa06f409af7a36c20a552e729eb985a9979149ae9ada5ce3ed413836fd12ed16                    â”‚
â”‚  â”‚ Sender: PUBLISHER-ID                                                                            â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                         â”‚
â”‚  â”‚ ObjectType: ORIGINAL-PACKAGE-ID::module::TYPE                                                   â”‚
â”‚  â”‚ Version: 3                                                                                      â”‚
â”‚  â”‚ Digest: 71G4PuCUoqx1KDTnt8zGMYUf6Qpf4CWgZsDxYN1d7mXE                                            â”‚
â”‚  â””â”€â”€                                                                                               â”‚
â”‚  â”Œâ”€â”€                                                                                               â”‚
â”‚  â”‚ ObjectID: UPGRADE-CAP-ID                                                                        â”‚
â”‚  â”‚ Sender: PUBLISHER-ID                                                                            â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                         â”‚
â”‚  â”‚ ObjectType: 0x2::package::UpgradeCap                                                            â”‚
â”‚  â”‚ Version: 3                                                                                      â”‚
â”‚  â”‚ Digest: FNxdiGCk1fwXByda6Q2sx8RjuwUQBFYQk7C4Zr2H4qVw                                            â”‚
â”‚  â””â”€â”€                                                                                               â”‚
â”‚ Mutated Objects:                                                                                   â”‚
â”‚  â”Œâ”€â”€                                                                                               â”‚
â”‚  â”‚ ObjectID: GAS-COIN-ID                                                                           â”‚
â”‚  â”‚ Sender: PUBLISHER-ID                                                                            â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                         â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                      â”‚
â”‚  â”‚ Version: 3                                                                                      â”‚
â”‚  â”‚ Digest: 9Fet6LPSBsjYjVMEQxkB4LRHfAJDFCQQ2iUAiUQ5eygF                                            â”‚
â”‚  â””â”€â”€                                                                                               â”‚
â”‚ Published Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                               â”‚
â”‚  â”‚ PackageID: ORIGINAL-PACKAGE-ID                                                                  â”‚
â”‚  â”‚ Version: 1                                                                                      â”‚
â”‚  â”‚ Digest: 4ZvhnDgehkRmzo3mtHjCc6aQkEz1SA87rDpDS6pGarFR                                            â”‚
â”‚  â”‚ Modules: example                                                                                â”‚
â”‚  â””â”€â”€                                                                                               â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Balance Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                        â”‚
â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
â”‚  â”‚ Amount: -10319880                                                                              â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

</details>

The result includes an **Object changes** section with two pieces of information you need for upgrading, an `UpgradeCap` ID and your package ID.

You can identify the different objects using the `Object.objectType` value in the response. The `UpgradeCap` entry has a value of `String("0x2::package::UpgradeCap")` and the `objectType` for the package reads `String("<PACKAGE-ID>::sui_package::<MODULE-NAME>")`

<Tabs>

<TabItem value="automated-address-management" label="Automated Addresses">

:::info

Beginning with the Sui `v1.29.0` release, published addresses are automatically managed in the `Move.lock` file and you do not need to take further action.

If the package was published or upgraded with a Sui version prior to `v1.29.0`, you can follow [the guide for adopting automated address management](automated-address-management#adopting-automated-address-management-for-published-packages). Alternatively, refer to the `Manual Addresses` tab above for further steps.

:::

After a while, you decide to upgrade your `sui_package` to include some requested features.

</TabItem>

<TabItem value="manual-address-management" label="Manual Addresses">

If your package has not [adopted automated address management](automated-address-management#adopting-automated-address-management-for-published-packages) you need to take the following manual steps.

To make sure your other packages can use this package as a dependency, you must update the `Move.toml` manifest file for your package to include published information.

Update the alias address and add a new `published-at` entry in the `[package]` section, both pointing to the value of the on-chain ID:

```toml
[package]
name = "sui_package"
version = "0.0.0"
published-at = "<ORIGINAL-PACKAGE-ID>"

[addresses]
sui_package = "<ORIGINAL-PACKAGE-ID>"
```

After a while, you decide to upgrade your `sui_package` to include some requested features. Before running the `upgrade` command, you need to edit the manifest again.

In the `[addresses]` section, you update the `sui_package` address value to `0x0` again so the validator issues a new address for the upgrade package. You can leave the `published-at` value the same, because it is only read by the toolchain when publishing a dependent package. The saved manifest now resembles the following:

```toml
[package]
name = "sui_package"
version = "0.0.1"
published-at = "<ORIGINAL-PACKAGE-ID>"

[addresses]
sui_package = "0x0"
```

With the new manifest and code in place, you can proceed.

</TabItem>

</Tabs>

Run `sui client upgrade` command to upgrade your package. Pass the `UpgradeCap` ID (the `<UPGRADE-CAP-ID>` value from the example) to the `--upgrade-capability` flag.

```sh
$ sui client upgrade --upgrade-capability <UPGRADE-CAP-ID>
```

The console alerts you if the new package doesn't satisfy [requirements](#requirements), otherwise the compiler publishes the upgraded package to the network and returns its result.

<details>
<summary>Output</summary>

```sh
Transaction Digest: 3NnJGryz2k2BJzjpndDVqVcdZmmefNMB8SJ9bCEQct22
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Data                                                                                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sender: PUBLISHER-ID                                                                                                                                         â”‚
â”‚ Gas Owner: PUBLISHER-ID                                                                                                                                      â”‚
â”‚ Gas Budget: 9684740 MIST                                                                                                                                     â”‚
â”‚ Gas Price: 1000 MIST                                                                                                                                         â”‚
â”‚ Gas Payment:                                                                                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                                                                                         â”‚
â”‚  â”‚ ID: GAS-COIN-ID                                                                                                                                           â”‚
â”‚  â”‚ Version: 3                                                                                                                                                â”‚
â”‚  â”‚ Digest: D2rpccs7eSw8gtb4T1K2bSVzF5eApC68xiHDtNGQEcEb                                                                                                      â”‚
â”‚  â””â”€â”€                                                                                                                                                         â”‚
â”‚                                                                                                                                                              â”‚
â”‚ Transaction Kind: Programmable                                                                                                                               â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ Input Objects                                                                                                                                            â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ 0   Imm/Owned Object ID: UPGRAD-CAP-ID                                                                                                                   â”‚ â”‚
â”‚ â”‚ 1   Pure Arg: Type: u8, Value: 0                                                                                                                         â”‚ â”‚
â”‚ â”‚ 2   Pure Arg: Type: vector<u8>, Value: [49,208,61,255,107,134,136,221,231,35,60,2,248,17,234,236,64,76,71,188,57,104,46,113,67,94,232,236,64,59,144,112] â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                                                â”‚
â”‚ â”‚ Commands                                                                                  â”‚                                                                â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                                                â”‚
â”‚ â”‚ 0  MoveCall:                                                                              â”‚                                                                â”‚
â”‚ â”‚  â”Œ                                                                                        â”‚                                                                â”‚
â”‚ â”‚  â”‚ Function:  authorize_upgrade                                                           â”‚                                                                â”‚
â”‚ â”‚  â”‚ Module:    package                                                                     â”‚                                                                â”‚
â”‚ â”‚  â”‚ Package:   0x0000000000000000000000000000000000000000000000000000000000000002          â”‚                                                                â”‚
â”‚ â”‚  â”‚ Arguments:                                                                             â”‚                                                                â”‚
â”‚ â”‚  â”‚   Input  0                                                                             â”‚                                                                â”‚
â”‚ â”‚  â”‚   Input  1                                                                             â”‚                                                                â”‚
â”‚ â”‚  â”‚   Input  2                                                                             â”‚                                                                â”‚
â”‚ â”‚  â””                                                                                        â”‚                                                                â”‚
â”‚ â”‚                                                                                           â”‚                                                                â”‚
â”‚ â”‚ 1  Upgrade:                                                                               â”‚                                                                â”‚
â”‚ â”‚  â”Œ                                                                                        â”‚                                                                â”‚
â”‚ â”‚  â”‚ Dependencies:                                                                          â”‚                                                                â”‚
â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000001                   â”‚                                                                â”‚
â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000002                   â”‚                                                                â”‚
â”‚ â”‚  â”‚ Current Package ID: ORIGINAL-PACKAGE-ID                                                â”‚                                                                â”‚
â”‚ â”‚  â”‚ Ticket: Result 0                                                                       â”‚                                                                â”‚
â”‚ â”‚  â””                                                                                        â”‚                                                                â”‚
â”‚ â”‚                                                                                           â”‚                                                                â”‚
â”‚ â”‚ 2  MoveCall:                                                                              â”‚                                                                â”‚
â”‚ â”‚  â”Œ                                                                                        â”‚                                                                â”‚
â”‚ â”‚  â”‚ Function:  commit_upgrade                                                              â”‚                                                                â”‚
â”‚ â”‚  â”‚ Module:    package                                                                     â”‚                                                                â”‚
â”‚ â”‚  â”‚ Package:   0x0000000000000000000000000000000000000000000000000000000000000002          â”‚                                                                â”‚
â”‚ â”‚  â”‚ Arguments:                                                                             â”‚                                                                â”‚
â”‚ â”‚  â”‚   Input  0                                                                             â”‚                                                                â”‚
â”‚ â”‚  â”‚   Result 1                                                                             â”‚                                                                â”‚
â”‚ â”‚  â””                                                                                        â”‚                                                                â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                                                â”‚
â”‚                                                                                                                                                              â”‚
â”‚ Signatures:                                                                                                                                                  â”‚
â”‚    nNJ8AiSAeV+NB3ayRTwcfaJHx3AzFHlZysbwda5e2jFBz5W9Z5EnzXV09xZMQYctUtW33jWpUFdK8hOJ9hZzDg==                                                                  â”‚
â”‚                                                                                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: 3NnJGryz2k2BJzjpndDVqVcdZmmefNMB8SJ9bCEQct22                                              â”‚
â”‚ Status: Success                                                                                   â”‚
â”‚ Executed Epoch: 1                                                                                 â”‚
â”‚                                                                                                   â”‚
â”‚ Created Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x5d49966433ebb423f5b40bfcd0ecfdc67f1527e3b9e3a433c4ec87ae63d54ed4                         â”‚
â”‚  â”‚ Owner: Immutable                                                                               â”‚
â”‚  â”‚ Version: 2                                                                                     â”‚
â”‚  â”‚ Digest: 6GmLYmCszFxbaLRLTyZdxTTfXG99iq8uVabfi2NaB5fQ                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Mutated Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: GAS-COIN-ID                                                                                â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                        â”‚
â”‚  â”‚ Version: 4                                                                                     â”‚
â”‚  â”‚ Digest: G5PBJjLKJWL2J3rb8ZR4uLNgFPpyJNNXfXNoh3FDo1zK                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x562408a381f3f2fce9c5ea27da42953e001760aa35dbadb273dca24166657516                         â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                        â”‚
â”‚  â”‚ Version: 4                                                                                     â”‚
â”‚  â”‚ Digest: 6B4pA1EcYek2pvrRoBv9jKhPmUGxhH1zZD3UcqPmxwDM                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Object:                                                                                       â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: GAS-COIN-ID                                                                                â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                        â”‚
â”‚  â”‚ Version: 4                                                                                     â”‚
â”‚  â”‚ Digest: G5PBJjLKJWL2J3rb8ZR4uLNgFPpyJNNXfXNoh3FDo1zK                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Cost Summary:                                                                                 â”‚
â”‚    Storage Cost: 9302400 MIST                                                                     â”‚
â”‚    Computation Cost: 1000000 MIST                                                                 â”‚
â”‚    Storage Rebate: 2595780 MIST                                                                   â”‚
â”‚    Non-refundable Storage Fee: 26220 MIST                                                         â”‚
â”‚                                                                                                   â”‚
â”‚ Transaction Dependencies:                                                                         â”‚
â”‚    7MdLdLYBhP6LKGf6gvuona2EQJZ1W7k3kRisrapmzQ5m                                                   â”‚
â”‚    8etH8jq78aKDHwL9ZnmAMhra62Q9vcPfyAcKJyXNPWvi                                                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ No transaction block events â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Mutated Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: GAS-COIN-ID                                                                         â”‚
â”‚  â”‚ Sender: PUBLISHER-ID                                                                          â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                       â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    â”‚
â”‚  â”‚ Version: 4                                                                                    â”‚
â”‚  â”‚ Digest: G5PBJjLKJWL2J3rb8ZR4uLNgFPpyJNNXfXNoh3FDo1zK                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0x562408a381f3f2fce9c5ea27da42953e001760aa35dbadb273dca24166657516                  â”‚
â”‚  â”‚ Sender: PUBLISHER-ID                                                                          â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                       â”‚
â”‚  â”‚ ObjectType: 0x2::package::UpgradeCap                                                          â”‚
â”‚  â”‚ Version: 4                                                                                    â”‚
â”‚  â”‚ Digest: 6B4pA1EcYek2pvrRoBv9jKhPmUGxhH1zZD3UcqPmxwDM                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚ Published Objects:                                                                               â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ PackageID: 0x5d49966433ebb423f5b40bfcd0ecfdc67f1527e3b9e3a433c4ec87ae63d54ed4                 â”‚
â”‚  â”‚ Version: 2                                                                                    â”‚
â”‚  â”‚ Digest: 6GmLYmCszFxbaLRLTyZdxTTfXG99iq8uVabfi2NaB5fQ                                          â”‚
â”‚  â”‚ Modules: example                                                                              â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Balance Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ Owner: Account Address ( PUBLISHER-ID )                                                        â”‚
â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
â”‚  â”‚ Amount: -7706620                                                                               â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

</details>

The result provides a new ID for the upgraded package.

<Tabs>

<TabItem value="automated-address-management" label="Automated Addresses">

:::info

Beginning with the Sui `v1.29.0` release, upgraded addresses are automatically managed in the `Move.lock` file and you do not need to take further action.

If the package was published or upgraded with a Sui version prior to `v1.29.0`, you might follow [the guide for adopting automated address management](automated-address-management#adopting-automated-address-management-for-published-packages). Alternatively, refer to the `Manual Addresses` tab above for further steps.

:::

</TabItem>

<TabItem value="manual-address-management" label="Manual Addresses">

So that packages that depend on your `sui_package` know where to find the on-chain bytecode for verification, edit your manifest again. Provide the upgraded package ID for the `published-at` value and return the original `sui_package` ID value in the `[addresses]` section:

```toml
[package]
name = "sui_package"
version = "0.0.1"
published-at = "<UPGRADED-PACKAGE-ID>"

[addresses]
sui_package = "<ORIGINAL-PACKAGE-ID>"
```

Note the `published-at` value changes with every upgrade and needs to be updated after every upgrade.

The ID for the `sui_package` in the `[addresses]` section always points to the original package ID after upgrading. You must always change that value back to `0x0`, however, before running the `upgrade` command so the validator knows to create a new ID for the upgrade.

</TabItem>

</Tabs>
>>>> sui/docs/content/concepts/tokenomics.mdx
---
title: Sui Tokenomics
description: Sui's tokenomics is designed to support the long-term financial needs of Web3. It uses the native SUI coin as the currency of the network and to pay for the network's gas fees. 
keywords: [ sui, SUI, sui coin, SUI token, sui tokenomics, sui economy, sui gas fees, sui coin purpose, sui coin uses, SUI token uses, SUI token purpose, unlocking schedules, sui unlock schedul, sui validator rewards, validator rewards, validator and staking pools, sui staking pools, sui staking ] 
pagination_prev: null
---

The term _tokenomics_ is a combination of two words: token and economics. It is generally used to describe the economic principles and behaviors of a blockchain. 

The _token_ part of the tokenomics portmanteau refers to the native token (or native coin) of the blockchain. On Sui, the native coin is SUI, which acts as the currency of the network. SUI also pays for the computational cost of transactions (gas fees) and storage on the network. 

## Proof of stake

Sui uses a proof-of-stake (PoS) consensus mechanism. This means that validators (entities that validate transactions) lock up a certain amount of SUI as collateral (stake). They then earn rewards for processing operations. Users of the network hold their own SUI, which they can delegate to the validators of their choice as part of the validators' stakes. In so doing, the validators reward users based on the amount of SUI they delegate. Users are free to withdraw their SUI or to change their selected validator when the epoch changes.

![Sui tokenomics flow](./images/sui-tokenomics-flow.png "Flowchart showing the tokenomics structure.")

## Stakeholders

Stakeholders in a blockchain's tokenomics have a vested interest in the viability of the blockchain economy. The Sui economy has three main groups of stakeholders:

- **Users** submit transactions to the Sui platform to create, mutate, and transfer digital assets or interact with more sophisticated applications enabled by smart contracts, interoperability, and composability.
- **SUI token holders** have the option of staking their tokens to validators and participating in the proof-of-stake mechanism. SUI owners also hold the rights to participate in Sui governance.
- **Validators** manage transaction processing and execution on the Sui platform.

## SUI coin

As mentioned, the native coin of Sui is SUI. The coin uses the capitalized version of SUI to distinguish the coin from the Sui network. A sound policy to govern the native coin on a blockchain ensures stability and encourages growth. The Sui tokenomics structure is designed to support the long-term financial needs of Web3, not get-rich-quick schemes that have plagued the industry in the past.

The SUI coin serves four purposes on the Sui network:

- You can stake SUI to participate in the proof-of-stake mechanism.
- SUI is the asset denomination needed to pay the gas fees required to execute and store transactions or other operations on the Sui network.
- You can use SUI as a versatile and liquid asset for various applications, including the standard features of money - a unit of account, a medium of exchange, or a store of value - and more complex functionality smart contracts enable, interoperability, and composability across the Sui ecosystem.
- SUI coins play an important role in governance by acting as a right to participate in on-chain voting on issues such as protocol upgrades.

### Supply

The total supply of SUI tokens on Mainnet is capped at 10,000,000,000 SUI (ten billion). This is the total number of SUI that can ever be minted, but the total supply is not available for transactions. Supply availability follows the designed unlocking schedules in place to enhance the tokenomics stability of the network and provide a long-term level of security. 

There is a finite supply of SUI. The balance must support all economic activities to scale as more and more people migrate to the Sui platform. In addition, the presence of a storage fund creates important monetary dynamics, in that higher on-chain data requirements translate into a larger storage fund, reducing the amount of SUI in circulation.

### Distribution

At the beginning of each epoch, three important events happen:

- SUI holders stake (some) of their tokens to validators and a new [committee](/guides/operator/validator/validator-committee) is formed.
- The reference gas prices are set as described in [Sui Gas Pricing](https://docs.sui.io/concepts/tokenomics/gas-pricing).
- The [storage fund](#storage-fund) size is adjusted using the net inflow of the previous epoch.

Following these actions, the protocol computes the total amount of stake as the sum of staked SUI plus the storage fund.

During each epoch, users submit transactions to the Sui platform and validators process them. For each transaction, users pay the associated computation and storage gas fees. In cases where users delete previous transaction data, users obtain a partial [rebate of their storage fees](#storage-fund-rewards). Validators observe the behavior of other validators and evaluate each other's performance.

At the end of each epoch, the protocol distributes stake rewards to participants of the PoS mechanism. This occurs through two main steps:

- The total amount of stake rewards is calculated as the sum of computation fees accrued throughout the epoch plus the epoch's stake reward subsidies. The latter component is temporary in that it will only exist in the network's first years and disappear in the long run as the amount of SUI in circulation reaches its total supply.
- The total amount of stake rewards is distributed across various entities. The storage fund is taken into account in the calculation of the epoch total stake, which is not owned by any entities in the way that staked SUI is. Instead, the Sui economic model distributes the stake rewards accruing to the storage fund to validators for compensation of their storage costs.

The distribution mechanisms built into Sui tokenomics encourages a healthy competition for fair prices where validators set low gas fees while operating with viable business models. Refer to the https://docs.sui.io/paper/tokenomics.pdf whitepaper for in-depth review of the mathematical proofs that support this structure.

### Unlocking schedules

Sui tokenomics design includes a vesting schedule (or unlock schedule) that dictates when certain blocks of SUI become accessible to the market. Like most blockchains concerned with stability and long-term commitment, Sui tokenomics design includes a multi-tiered SUI unlock schedule.

When Sui first launched its Mainnet network (initial SUI mint), there was a one-year cliff period. During this time, all initial investors were blocked from transferring their initial stake of SUI to the marketplace. A common practice for new cryptocurrency, the cliff period protected early network stability against large-scale sell-offs from early investors. The cliff period ended in May 2024.

### Airdrops

Often, when a new coin or token launches, its minters set aside a percentage of the sum to distribute to early adopters to drive interest in the associated blockchain project. This process is termed an â€œairdropâ€. 

There were no SUI airdrops to support the launch of Sui's Mainnet network. This was a publicly-stated, intentional decision for the following reasons: 

- Airdrops expose a potential for bad actors to take advantage of the excitement around a new launch. By publicly stating there would be no airdrops, Sui attempted to mitigate the risk its users faced.
- Cryptocurrency is regulated differently across the globe. Airdrops can be viewed as taxable events in some jurisdictions, creating legal or financial complications.
- Sui is committed to the long-term success of the network and its stakeholders. Airdrops might generate excitement early in a project's lifecycle, but the long-term benefits are minimal.

## Storage fund

As previously mentioned, SUI pays for the gas fees and data storage on the network. A potential problem arises, however, when new validators come on chain. Even though the validator is new, it still must pay the storage cost for activity that happened before it was part of the network.

Sui addresses this problem with the storage fund. The storage fund is essentially a cache of SUI that never fully depletes. Each on-chain transaction that adds data to the chain includes a fee for storage, which the protocol adds to the storage fund. The storage fund itself essentially has a stake in the network, so it collects rewards based on that stake, just like every other on-chain stakeholder. The protocol then regularly distributes those storage fund rewards to Sui validators to pay for storage. In this way, new validators to the network get paid for storing data from past transactions.

### Storage fund rewards

The Sui delegated proof-of-stake (PoS) mechanism calculates total stake as the sum of user stake plus the SUI tokens deposited in the storage fund. Hence, the storage fund receives a proportional share of the overall stake rewards depending on its size relative to total stake. The largest share of these stake rewards are paid out to current validators to compensate for storage costs. The rewards that remain are reinvested into the fund. In other words, stake rewards accruing to the storage fees submitted by past transactions are paid out to current validators to compensate them for data storage costs. When on-chain storage requirements are high, validators receive substantial additional rewards to compensate for their storage costs. Vice versa when storage requirements are low.

The storage fund includes three key features:

- The storage fund is funded by past transactions and functions as a tool for shifting gas fees across different epochs. This ensures that future validators are compensated for their storage costs by the past users who created those storage requirements in the first place.
- The storage fund pays out only the returns on its capital and does not distribute its principal. In practice, this essentially means validators borrow the storage fund's SUI as additional stake and keep the majority of stake rewards. Validators do not, however, receive funds directly from the storage fund. This guarantees the fund never loses its capitalization and can survive indefinitely. This feature is further buttressed by the stake rewards reinvested into the fund.
- The storage fund includes a *deletion option*. If you delete data, you get a partial refund of the storage fees paid originally.

### Deflation

The storage fund also contributes to the deflationary aspect of the network. Unlike traditional economics, deflation is a feature of Sui rather than a bug. The total supply of SUI is capped, so increased activity on the network has a deflationary effect as the storage fund grows in relation to the amount of data stored, which effectively takes more SUI out of circulation.  The store of value for SUI increases in relation to the decrease in circulating supply, promoting long-term investment in SUI for a strong network into the future. 

## Validator rewards

With traditional PoS blockchains, validator rewards are somewhat randomized based on the amount of stake a validator holds. As the validators reinvest their rewards, their stake compounds, as does the probability that they receive more rewards based on that growing stake.

Sui takes a novel approach to rewarding its validators to avoid this effect. All honest validators on Sui receive their staking rewards with full certainty. The rewards are based only on the amount of stake the validators hold, removing randomness from the equation. 

## Validators and staking pools

Each Sui validator maintains its own staking pool to track the amount of stake and to compound staking rewards. Validator pools operate together with a time series of exchange rates that are computed at each epoch boundary. These exchange rates determine the amount of SUI tokens that each past SUI staker can withdraw in the future. Importantly, the exchange rates increase as more rewards are deposited into a staking pool and the longer an amount of SUI is deposited in a staking pool, the more rewards it will accrue.

When SUI is deposited to the staking pool in epoch `E`, those SUI are converted into liquidity tokens at the epoch `E` exchange rate. As the staking pool earns rewards, the exchange rate appreciates. At epoch `E'`, those liquidity tokens are worth more and translate into more SUI.
The only difference between Sui staking pools and typical liquidity pools is that in Sui the liquidity tokens do not exist. Rather, the global exchange rate table is used to track the accounting. Because all SUI tokens in the staking pool are treated the same, regardless of whether they were originally deposited as new stake or as stake rewards, all SUI tokens immediately count as stake and thus compound rewards immediately.

The staking pool is implemented in a system-level smart contract ([staking_pool.move](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-system/sources/staking_pool.move)) and is part of the Sui framework.

### Validator pool exchange rate 

The exchange rate for each validator pool is calculated at each epoch boundary as follows:

Exchange rate at E+1 = ( 1 + ( third-party staker rewards at E / third-party stake at E )) ( exchange rate at E )

The distinction between third-party owned vs validator-owned rewards and stake is relevant in that validators earn commissions on the staking pool's tokens but third-party stakers do not. This accounting enables Sui to keep track of the rewards accrued by both validators and third-party token holders using a single global exchange rate table.

<ImportContent source="staking-pool-reqs.mdx" mode="snippet" />

#### Understanding the voting power formula

SIP-39 uses the following formula to determine if a validator can join the set:

```
S / (S + T) > V / 10000
```

Where:
- S = The validator candidate's stake amount
- T = Total amount already staked in the network
- V = Minimum voting power threshold (3 in the final phase)
- 10000 = Total voting power units in the Sui system

This formula checks if the validator would have at least V voting power after joining. Let's break it down:

1. S / (S + T) calculates what proportion of the total stake the validator would control
2. When multiplied by 10000, this gives their voting power in Sui's standardized units
3. The validator can join if this value is greater than or equal to the threshold V

For example, with a network stake of 7.69B SUI and V=3:
- A validator with 2.31M SUI would have: 2,310,000 / (2,310,000 + 7,694,950,773) â‰ˆ 0.0003 proportion
- Converting to voting power: 0.0003 Ã— 10000 â‰ˆ 3 units
- Since 3 â‰¥ 3, they meet the threshold to join

As the total network stake changes, the minimum required amount will adjust automatically.

## Related links

<RelatedLink href="https://docs.sui.io/paper/tokenomics.pdf" label="The Sui Smart Contracts Platform: Economics and Incentives" desc="Whitepaper that details Sui tokenomics." />
<RelatedLink to="/concepts/tokenomics/gas-in-sui" />

>>>> sui/docs/content/concepts/tokenomics/gas-in-sui.mdx
---
title: Gas in Sui
description: A Sui transaction must pay for both the computational cost of execution and the long-term cost of storing the objects a transaction creates or mutates.
keywords: [ sui gas, gas fees, sui gas tokens, pay for gas, how to pay gas, gas fee, sui gas fee, how much is gas, gas prices, price of gas ]
---

A Sui transaction must pay for both the computational cost of execution and the long-term cost of storing the objects a transaction creates or mutates. Specifically, [Sui Gas Pricing](gas-pricing.mdx) is such that any transaction pays the following gas fees:

`total_gas_fees = computation_units * reference_gas_price + storage_units * storage_price`

While computation and storage fees are separate, they are conceptually similar in that they each translate computation or storage into SUI terms by multiplying computation or storage units by the relevant price.

Finally, Sui storage mechanics provide storage fee rebates whenever a transaction deletes previously stored objects. Hence, the net fees that a user pays equals gas fees minus the rebates associated with data deletion:

`net_gas_fees = computation_gas_fee + storage_gas_fee - storage_rebate`

The information on net gas fees is displayed in a Sui network explorer for each transaction block:

![Gas Fees displayed on a Sui network explorer](images/gas-fees-explorer.png "The Gas Fees section displayed on a Sui network explorer")
_The Gas Fees section for a transaction block displayed on a Sui network explorer_

## Gas prices {#gas-prices}

The [reference gas price](gas-pricing.mdx#computation-gas-prices) translates the real-time cost of executing a transaction into SUI units and the validator set updates it at each epoch boundary. Similarly, the [storage price](gas-pricing.mdx#storage-gas-prices) translates the long-term cost of storing data on chain into SUI units and updates infrequently; often remaining constant for various consecutive epochs. During regular network operations, all Sui users can expect to pay the reference gas price and storage price for computation and storage, respectively.

## Gas units {#gas-units}

Gas units include both

- [Computation units](#computation)
- [Storage units](#storage)

### Computation units {#computation}

Different Sui transactions require varying amounts of computational time for processing and execution. Sui translates these varying operational loads into transaction fees by measuring each transaction in terms of computation units. In general, more complex transactions require more computation units.

Importantly, though, Sui computation gas schedule is built coarsely with a bucketing approach. Two relatively similar transactions translate into the exact same amount of computation units if they are in the same bucket, whereas two relatively different transactions translate into different amounts of computation units if they fall in separate buckets. The smallest bucket maps into 1,000 computation units, meaning that all transactions that fall into the smallest bucket cost 1,000 computation units. The largest bucket maps into 5,000,000 computation units; if a transaction requires more computation units, it aborts.

Using coarse bucketing accomplishes two important goals:

    - Frees you from optimizing your smart contracts to deliver marginal gains in gas costs via _gas golfing_. Instead, you can focus on step-function improvements in your products and services.
    - Gives you the freedom to adjust per-instruction gas costs and experiment with new gas metering schemes without creating significant development disruption. This can happen frequently, so it's important that you do not rely on per-instruction gas costs remaining stable over time.

| Bucket Lower Threshold | Bucket Upper Threshold | Computation Units      |
| ---------------------- | ---------------------- | ---------------------- |
| 0                      | 1,000                  | 1,000                  |
| 1,001                  | 5,000                  | 5,000                  |
| 5,001                  | 10,000                 | 10,000                 |
| 10,001                 | 20,000                 | 20,000                 |
| 20,001                 | 50,000                 | 50,000                 |
| 50,001                 | 200,000                | 200,000                |
| 200,001                | 1,000,000              | 1,000,000              |
| 1,000,001              | 5,000,000              | 5,000,000              |
| 5,000,001              | Infinity               | transaction will abort |

### Storage units {#storage}

Similarly, Sui transactions vary depending on the amount of new data written into on-chain storage. The variable storage units capture these differences by mapping the amount of bytes held in storage into storage units. The current Sui schedule is linear and maps each byte into 100 storage units. So, for example, a transaction that stores 25 bytes costs 2,500 storage units, while a transaction that stores 75 bytes costs 7,500 units.

Importantly, in the Sui [storage fund](../tokenomics.mdx#storage-fund) model users pay up front for the cost of storing data in perpetuity but can also get a partial rebate on previously stored data, if that data is deleted. Hence, the amount of storage fees that you pay can be split into a rebateable and non-rebateable amount. Initially, the rebateable amount equals 99% of the storage fees, while the non-rebateable amount equals the remaining 1%.

### Gas budgets {#gas-budgets}

You must submit all transactions need together with a gas budget. This provides a cap to the amount of gas fees you pay, especially because sometimes it might be hard to perfectly forecast how much a transaction costs before you submit it to the Sui network.

The gas budget for a Sui transaction is defined in SUI units and transactions are successfully executed if:

`gas_budget >= max{computation_fees,total_gas_fees}`

If the gas budget does not fulfill this condition, then the transaction fails and a portion of the gas budget is charged. In cases where the `gas_budget` is insufficient for covering `computation_fees`, then the entirety of the `gas_budget` is charged. In cases where `gas_budget` is sufficient for covering `computation_fees` but not the `total_gas_fees`, then a portion of the `gas_budget` corresponding to `computation_fees` and the fees associated with mutating the transaction's input objects are charged.

Ultimately, a successful transaction requires the end user to pay the transaction's `total_gas_fees`. However, since it is challenging to perfectly forecast computation time before the transaction is processed, the `gas_budget` condition also requires the `gas_budget` to be at least as large as the transaction's `computation_fees` in case the transaction aborts. In some cases -- especially in the presence of high storage rebates, and, thus negative net storage fees -- the gas budget might be higher than the total gas fees you pay.

Importantly, the minimum gas budget is 2,000 MIST (.000002 SUI). This ensures validators are compensated with at least 2,000 MIST even if the gas budget is incorrectly specified and the transaction aborts. Additionally, this protects the Sui network from being spammed with a large number of transactions with minimal gas budgets. The maximum gas budget is 50 billion MIST or 50 SUI. This protects the network against overflow of internal multiplications and gas limits for denial of service attacks.

As mentioned previously, the storage rebate currently equals 99% of the originally paid storage fees. Because the gas budget applies to the totality of gas fees, it is often the case that a transaction only goes through if the gas budget is considerably higher than the net gas fees that a user ultimately pays.

### Gas budget examples {#gas-budget-examples}

The following table provides some examples of gas accounting on the Sui network. Within the first two and last two rows, computation units are the same because transactions fall within the same bucket. However, the last two transactions are more complex than the first two and thus fall in a higher bucket. Finally, in the last transaction the storage rebate is large enough to fully offset the transaction gas fees and actually pays the user back a positive amount of SUI.

These examples showcase the importance of the gas budget. The minimum gas budget is the smallest amount a transaction can specify to successfully execute. Importantly, when there is a storage rebate, the minimum gas budget is larger than the amount of net gas fees a user ultimately pays â€” this is especially stark in the last example where the user receives a positive amount back for executing the transaction. This is because the minimum gas budget must be higher than a transaction's computation fees.

|                                                         | Reference Gas Price | Computation Units | Storage Price | Storage Units | Storage Rebate | Minimum Gas Budget | Net Gas Fees   |
| ------------------------------------------------------- | ------------------- | ----------------- | ------------- | ------------- | -------------- | ------------------ | -------------- |
| Simple transaction storing 10 bytes                     | 1,000 MIST          | 1,000             | 75 MIST       | 1,000         | 0 MIST         | 1,075,000 MIST     | 1,075,000 MIST |
| Simple transaction storing 10 bytes and deleting data   | 500 MIST            | 1,000             | 75 MIST       | 1,000         | 100,000 MIST   | 500,000 MIST       | 475,000 MIST   |
| Complex transaction storing 120 bytes                   | 1,000 MIST          | 5,000             | 200 MIST      | 12,000        | 0 MIST         | 7,400,000 MIST     | 7,400,000 MIST |
| Complex transaction storing 120 bytes and deleting data | 500 MIST            | 5,000             | 200 MIST      | 12,000        | 5,000,000 MIST | 2,500,000 MIST     | -100,000 MIST  |

>>>> sui/docs/content/concepts/tokenomics/gas-pricing.mdx
---
title: Sui Gas Pricing
description: Sui's gas pricing is designed to deliver low, predictable fees and protect against DDoS attacks while incentivizing validators to optimize processing operations. Separate gas fees are paid for computation and transaction data storage. 
keywords: [ sui gas pricing, how gas pricing works, computation gas prices, data storage prices, transaction execution pricing, transaction data storage pricing, transaction execution gas, gas for executing transactions, gas fees for executing transactions, gas fees for storing data, gas fees for transaction data storage, transaction data storage gas ]
---

The Sui gas-pricing mechanism achieves three outcomes: delivering low, predictable transaction fees, incentivizing the network's operators (validators) to optimize their transaction processing operations, and preventing denial of service attacks.

This enables you to focus on using the Sui network to provide the best user experience without needing to forecast the current market price of gas fees. Since validators agree on a network-wide reference price at the start of each epoch, you can use the reference price as a credible anchor when submitting transactions. Moreover, the price setting mechanism rewards good validator behavior, thus aligning incentives between SUI token holders, validators, and Sui users.

A unique feature of the Sui gas price mechanism is that users pay separate fees for transaction execution and for storing the data associated with each transaction. The gas fees associated with an arbitrary transaction $\tau$ equal:

$$
GasFees[\tau] \ = \ ComputationUnits[\tau] \times ComputationPrice[\tau] \ + \ StorageUnits[\tau] \times StoragePrice
$$

The gas functions $ComputationUnits[\tau]$ and $StorageUnits[\tau]$ measure the amount of computation and storage resources, respectively, required to process and store the data associated with $\tau$. The gas prices $ComputationPrice[\tau]$ and $StoragePrice$ translate the cost of computation and storage, respectively, into SUI units. The decoupling between gas units and gas prices is useful since SUI market price will fluctuate over time in accordance with supply and demand.

## Computation gas prices {#computation}

The computation gas price $ComputationPrice[\tau]$ captures the cost of one unit of computation in SUI units. This price is set at the transaction level and submitted by the user as the transaction's gas price. Conceptually, it is useful to think about this gas price in two parts:

$$
ComputationPrice[\tau] \ = \ ReferencePrice \ + \ Tip[\tau]
$$

On the Sui network, a single $ReferencePrice$ exists throughout each epoch, with Sui validators updating the $ReferencePrice$ at each epoch boundary. Hence, in practice, when a user submits a gas price above the $ReferencePrice$, it is useful to think of the difference as a tip paid to the network in order to get higher priority. During moments of regular network operations, users are not expected to pay tips and the vast majority of transactions have gas prices equal to $ReferencePrice$.

More generally, the Sui gas price mechanism makes the $ReferencePrice$ a credible anchor for you to reference when submitting transactions to the network. Providing reasonable confidence that transactions submitted with gas prices at or close to the reference price are executed in a timely manner. This is achieved through three core steps:

- **Gas price survey:** All validators are surveyed at the start of each epoch, and every validator submits their reservation price. That is, each validator states the minimum gas price at which they are willing to process transactions. The protocol orders these quotes and chooses the 2/3 percentile by stake as the reference price. The gas price survey goal is to set a reference price under which a [quorum](../../guides/operator/validator/validator-committee.mdx#quorums) of validators are willing to promptly process transactions.
- **Tallying rule:** Throughout the epoch, validators obtain signals over the operations of other validators. Each validator uses these signals to build a (subjective) evaluation over the performance of every other validator. Specifically, each validator constructs a multiplier for the stake rewards of every other validator such that validators who behave well receive boosted rewards, and validators who do not receive reduced rewards. The tallying rule goal is to create a community-enforced mechanism for encouraging validators to honor the reference gas price.
- **Incentivized stake reward distribution rule:** At the end of the epoch, the distribution of stake rewards across validators is adjusted using information from the tallying rule. Specifically, a global multiplier is built for every validator using the median value (weighted by stake) out of the set of individual multipliers constructed during the tallying rule. All else equal, validators that operated performantly receive their regular stake rewards, whereas validators who did not operate performantly at the reference gas price receive slashed rewards. Since stake rewards are influenced by the amount of stake each validator owns, validators are encouraged to obtain more stake by lowering gas fees and pricing out inefficient validators. This benefits Sui end users since the stake reward distribution rule incentivizes validators to deliver a more cost-efficient network.

In sum, the gas price mechanism has two main forces: the tallying rule incentivizes validators to honor the quotes submitted during the gas survey, while the distribution rule incentivizes validators to submit low reservations prices. The interaction of these two forces delivers a mechanism encouraging validators to set a low network-level reference gas price - but not too low, because they face penalties if they cannot honor their quotes. In other words, the gas price mechanism encourages a healthy competition for fair prices.

## Storage gas prices {#storage}

The storage gas price $StoragePrice$ captures the costs of covering one unit of storage in perpetuity, in SUI units. This price is set through governance proposals and is updated infrequently. The goal is to ensure Sui users pay for their use of on-chain data storage by depositing these fees into the storage fund and then redistributing these fees to future validators. In contrast to the computation gas price, storage prices are fixed and common for all transactions both within an epoch and across epochs until the storage price is updated.

The $StoragePrice$ is set exogenously through the governance proposal with the goal of targeting the off-chain dollar cost of data storage. In the long run, as the costs of storage fall due to technological improvements and the dollar price of the SUI token evolves, governance proposals will update the price in order to reflect the new dollar target price.

## Gas prices as a coordination mechanism {#coordination-mechanism}

Overall, when you submit transactions with computation gas prices at or close to the current epoch $ReferencePrice$ and storage gas prices at the targeted $StoragePrice$, you have the best user experience. The Sui gas price mechanism provides you with credible reference prices for submitting your transactions. By incentivizing validators to elicit their true reservation prices and honor these quotes, you can credibly assume your transactions are processed in a timely manner.

After Sui enables horizontal scaling, validators can add more workers as demand for on-chain activity scales. This increases their costs linearly at the same pace of network activity and lets them process more transactions at the same low gas prices. In cases of extreme network congestion where validators cannot scale fast enough, the tip presence provides a market-based congestion pricing mechanism that discourages further demand spikes by increasing the cost of transacting on the Sui platform.

In the long run, the Sui gas price mechanism creates incentives for validators to optimize their hardware and operations. Validators that invest in becoming more efficient are able to honor lower gas prices and obtain a stake reward boost. Sui validators are thus encouraged to innovate and improve the experience of end users.

>>>> sui/docs/content/concepts/tokenomics/staking-unstaking.mdx
---
title: Staking and Unstaking
description: Staking and unstaking SUI with validators earns a percentage of rewards they receive from gas fees.
keywords: [ token staking, token unstaking, SUI staking, SUI unstaking, unstake SUI, stake SUI, validator staking, validator unstaking ]
---

Sui uses a Delegated-Proof-of-Stake (DPoS) system to secure and operate the network, meaning that the voting power of a validator in the network is determined by the amount of stake delegated to them by SUI token holders. The more stake delegated to a validator, the more voting power they have. In exchange for processing transactions and performing consensus, validators earn rewards based on the amount of gas fees collected. These rewards are then shared among stakers as staking rewards.

## Staking

You stake your SUI tokens by sending a transaction to the network that calls the staking function implemented as part of the system Move package. This transaction wraps the SUI tokens in a self-custodial stake object. This stake object contains information including the validator staking pool ID and the activation epoch of the stake. With the introduction of [SIP-6](https://blog.sui.io/liquid-staking-coming-sui/), you can participate in liquid staking protocols using your staked objects.

Sui-compatible crypto wallets typically have functionality to initiate staking and unstaking from your Sui address. See the respective documentation for these tools to begin staking your SUI.

## Unstaking

Similar to staking, a user withdraws stake from a validator by sending a transaction that calls the unstaking function in the system Move package. This transaction unwraps the stake object, and sends both the principal and the accumulated rewards to the user as SUI tokens. You accrue rewards only during epochs where the stake is active for the entire epoch. The rewards withdrawn from the validator's rewards pool are calculated based on the activation epoch and unstaking epoch of the stake.

## Choosing a validator for staking

When you stake on Sui, you have to choose a specific validator you would like to stake with. The choice of validator can potentially impact the amount of staking rewards you receive. The factors determining this amount include, but are not limited to:

- Validator commission rate: a validator can choose to set a non-zero commission rate specifying the percentage of staking rewards they are taking from the stakers. For example, if a validator has a commission rate of 10%, then 10% of every staker's staking rewards is given to the validator. Understand that a validator can choose its commission at a future moment in time without prior notice.
- Validator performance: a validator with bad performance might be punished according to the [tallying rule](./gas-pricing.mdx#tallying-rule). Punished validators do not receive any staking rewards for the epoch during which they are punished, and you also do not receive that epoch's rewards when you withdraw your stake from that validator. 

Sui-compatible crypto wallets and explorers typically provide validator information such as commission and APY. See the respective documentation for these tools for information on how to retrieve this data.

>>>> sui/docs/content/concepts/tokenomics/sui-bridging.mdx
---
title: SUI Bridging
description: Moving tokens from one blockchain to another is called bridging. To bridge tokens from another blockchain to Sui, you can use the Sui Bridge, Wormhole Connect, Wormhole Portal Bridge, or ZetaChain.
keywords: [ bridge, sui bridge, wormhole connect, wormhole portal bridge, zetachain, bridging tokens to sui, how to bridge tokens, can you bridge tokens, how to bring token to sui, move token to sui, move tokens between blockchains, move tokens between chains, omnichain, cross-chain messaging ]
---

Bridging is the process of moving tokens from one blockchain to another. When you use a bridge to move tokens between blockchains that are incompatible, the tokens are wrapped and converted to a derivative token for the target blockchain. You can transfer tokens from other blockchains to Sui, or transfer SUI tokens to other blockchains.

Sui supports bridging through [Sui Bridge](#sui-bridge), [Wormhole Connect](#wormhole-connect), [Wormhole Portal Bridge](#wormhole-portal-bridge), and [ZetaChain](#zetachain).

## Sui Bridge

Sui Bridge is the native bridge for the Sui network. It is built into the core architecture of Sui, providing optimal integration and operation. Sui Bridge enables the movement of digital assets between Sui and other blockchains, preserving security and maintaining interoperability. It supports secure and efficient transfer of native and wrapped ETH to and from Sui. Sui Bridge leverages Suiâ€™s capabilities to offer fast transactions, lower costs, and a decentralized architecture.

You can bridge tokens at [bridge.sui.io](https://bridge.sui.io/).

### Operation and governance

Sui Bridge is operated and governed by Sui validators, the same set that secures the Sui network. Bridge transfers and other actions require validator signatures with a threshold of voting power. Governance is handled by validator voting.

To learn how to set up a Sui Bridge full node, see [Sui Bridge Validator Node Configuration](../../guides/operator/bridge-node-configuration.mdx).

### Supported chains and tokens

Sui Bridge supports bridging between Sui and other networks with the following assets:

| Asset | Description |
| --- | --- |
| Wrapped Bitcoin | Tokenized representation of Bitcoin. |
| Lightning Bitcoin (LBTC) | Decentralized Internet-of-value protocol for global payments. |
| Ethereum (ETH) | Native cryptocurrency of the Ethereum network. |
| Wrapped Ethereum (WETH) | Tokenized representation of native ETH. |
| Tether (USDT) | Stablecoin pegged to the US dollar. |

### Package IDs and contract addresses

The following package IDs and addresses are reserved for Sui Bridge:

| Asset | Address/ID |
| --- | --- |
| Sui Bridge package on Sui | [`0xb`](https://suiscan.xyz/mainnet/object/0x000000000000000000000000000000000000000000000000000000000000000b/txs) |
| Sui Bridge object on Sui | [`0x9`](https://suiscan.xyz/mainnet/object/0x0000000000000000000000000000000000000000000000000000000000000009) |
| Sui Bridge contract on Ethereum Mainnet | [`0xda3bD1fE1973470312db04551B65f401Bc8a92fD`](https://etherscan.io/address/0xda3bd1fe1973470312db04551b65f401bc8a92fd) |
| ETH on Sui | [`0xd0e89b2af5e4910726fbcd8b8dd37bb79b29e5f83f7491bca830e94f7f226d29::eth::ETH`](https://suiscan.xyz/mainnet/coin/0xd0e89b2af5e4910726fbcd8b8dd37bb79b29e5f83f7491bca830e94f7f226d29::eth::ETH/txs) |
| ETH on Ethereum | Native Ether |
| WETH on Ethereum | [`0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2`](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2) |

### Source code

Sui Bridge is open source:

- [Move](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/bridge)  
- [Solidity](https://github.com/MystenLabs/sui/tree/main/bridge/evm)  
- [Bridged ETH (Move)](https://github.com/MystenLabs/sui/tree/main/bridge/move/tokens/eth)  
- [Bridge node](https://github.com/MystenLabs/sui/tree/main/crates/sui-bridge)  
- [Bridge indexer](https://github.com/MystenLabs/sui/tree/main/crates/sui-bridge-indexer)  

### Audits

Audit reports:  
- [OtterSec](https://github.com/sui-foundation/security-audits/blob/main/docs/Sui_bridge_v1_OtterSec.pdf)  
- [Zellic](https://github.com/sui-foundation/security-audits/blob/main/docs/Sui_Bridge_v1_Zellic.pdf)  

### Global limiter {#global-limiter}

A limiter protects funds by constraining the total value of assets leaving Sui Bridge in a 24-hour window. It tracks value hourly and aggregates from the last 24 hours, refreshing every hour.  

The limit applies globally and varies by direction (Ethereum â†’ Sui vs. Sui â†’ Ethereum). It also caps the maximum single transfer.  

Limits are set by validator committee vote and announced in the [mn-validator-announcements channel](https://discord.com/channels/916379725201563759/1093852827627040768) on Discord.  

The global limit is currently $16 million from Ethereum to Sui and $7 million from Sui to Ethereum per 24 hours.

### Asset price

Sui Bridge v1 uses static pricing to calculate limits. ETH is priced at $2,600. One ETH consumes $2,600 of the limit. The validator committee governs pricing through voting.

### Transfer limit

There is no minimum transfer, but very small fractions can be rounded down. For ETH and WETH, reduced precision of eight decimals rounds 10.0000000000000001 down to 10.  

| Token | Minimal value | 
| --- | --- |
| ETH | 0.00000001 ETH |
| WETH | 0.00000001 ETH |

The maximum transfer equals the global USD limit. See [Global limiter](#global-limiter).

## Wormhole Connect {#wormhole-connect}

Wormhole Connect lets you bridge tokens from any supported Wormhole chain into Sui, with an extra drop of SUI for gas fees. Developers can also embed Connect in their own websites and dApps.

:::tip
See [Cross-Chain Token Transfers with Wormhole Connect](https://wormhole.com/docs/tutorials/messaging/sui-connect/) on the Wormhole website for a tutorial.
:::

### Wormhole Connect asset support {#asset-support}

Wormhole Connect supports lock-and-mint bridging for ETH, WETH, USDC, MATIC, WMATIC, BNB, WBNB, AVAX, WAVAX, FTM, WFTM, CELO, GLMR, WGLRM, and SOL across Ethereum, Polygon, BSC, Avalanche, Celo, Moonbeam, Solana, and Sui. Bridged tokens are received as Wormhole-minted tokens on the destination chain. See the [Wormhole token list](https://github.com/wormhole-foundation/wormhole-token-list). Some tokens support swapping on destination DEXs.

### Wormhole Connect automatic relay {#automatic-relay}

On EVM chains and Sui, Wormhole Connect can pay destination-chain gas automatically. Users only pay gas on the source chain.

### Wormhole Connect gas drop-off {#gas-drop-off}

Users can pay an extra fee on the source chain to receive a small amount of native gas on the destination chain. For example, bridging USDC from Ethereum to Sui can include a fee in USDC to receive SUI for gas. This feature is supported on EVM chains and Sui.  

See the [Wormhole FAQ](https://wormhole.com/docs/products/connect/overview/) for details.

## Wormhole Portal Bridge

The [Portal Bridge](https://www.portalbridge.com/sui), powered by Wormhole, supports bridging assets from any of the [22 supported Wormhole chains](https://www.wormhole.com/network).

## ZetaChain {#zetachain}

[ZetaChain](https://www.zetachain.com/) enables omnichain smart contracts and cross-chain messaging between Sui and other blockchains. The ZetaChain protocol supports bridging digital assets and sending arbitrary messages across Bitcoin, Ethereum, Polygon, BSC, Avalanche, and other major chains.

### Supported assets

ZetaChain supports native cross-chain transfers tokens such as:

- **Bitcoin (BTC)**: Native Bitcoin transfers via HTLC
- **Ethereum (ETH)**: Native ETH and ERC-20 tokens including USDC, USDT, WBTC
- **Polygon (MATIC)**: Native MATIC and Polygon tokens
- **BSC (BNB)**: Native BNB and BEP-20 tokens
- **Avalanche (AVAX)**: Native AVAX and Avalanche C-Chain tokens
- **Layer 2 chains**: Arbitrum, Optimism, Base

Assets bridged through ZetaChain are represented as ZRC-20 tokens on the ZetaChain network and can be transferred to any connected chain.

See the [ZetaChain supported networks](https://www.zetachain.com/docs/developers/chains/list) for the complete list.

### Omnichain messaging

Beyond asset transfers, ZetaChain's Universal App framework enables smart contracts to communicate across all connected chains. Developers can build applications that call functions on contracts across multiple blockchains, read and write state across chains through ZetaChain's validators, and execute complex multi-chain workflows in a single transaction.

### How it works

ZetaChain uses a proof-of-stake validator network to observe transactions on external chains and relay messages between them. When you initiate a cross-chain transaction:

1. You interact with a gateway contract on the source chain (Sui or any supported chain).
2. ZetaChain validators observe and verify the transaction.
3. The validators execute any omnichain contract logic on ZetaChain.
4. The validators trigger the corresponding action on the destination chain.

All cross-chain operations are handled automatically without manual intervention.

### Gas handling

ZetaChain provides flexible gas payment options:

- **Pay on source chain**: Pay all fees upfront on the source chain in ZETA, USDC, or USDT.
- **Automatic gas drop**: Receive native tokens on the destination chain for transaction fees.
- **Custom gas logic**: Implement application-specific gas payment models.

### Gateway contracts

Interact with ZetaChain through gateway contracts deployed on each supported chain:

**Athens Testnet**
- Sepolia (Ethereum): `0x0c487a766110c85d301d96e33579c5b317fa4995`
- Base Sepolia: `0x0c487a766110c85d301d96e33579c5b317fa4995`
- Amoy (Polygon): `0x0c487a766110c85d301d96e33579c5b317fa4995`
- BSC Testnet: `0x0c487a766110c85d301d96e33579c5b317fa4995`

Always verify gateway addresses from the [official ZetaChain documentation](https://www.zetachain.com/docs/reference/network/contracts) before integrating.

### Getting started

Install the ZetaChain CLI:

```bash
npm install -g zetachain
```

Explore example contracts and tutorials:
- [Universal Apps Tutorial](https://www.zetachain.com/docs/developers/tutorials/intro)
- [Cross-Chain Messaging Guide](https://www.zetachain.com/docs/developers/tutorials/messaging)
- [Example Contracts](https://github.com/zeta-chain/example-contracts)

View transactions on the ZetaChain explorers:
- [Testnet Explorer](https://testnet.zetascan.com/)
- [Mainnet Explorer](https://zetascan.com/)

## Token address list {#token-address-list}

The following table lists the address for each token type. Confirm token legitimacy by verifying the address matches.

| Token   | Address                                                            |
| ------- | ------------------------------------------------------------------ |
| CELO    | 0xa198f3be41cda8c07b3bf3fee02263526e535d682499806979a111e88a5a8d0f |
| WMATIC  | 0xdbe380b13a6d0f5cdedd58de8f04625263f113b3f9db32b3e1983f49e2841676 |
| WBNB    | 0xb848cce11ef3a8f62eccea6eb5b35a12c4c2b1ee1af7755d02d7bd6218e8226f |
| WETH    | 0xaf8cd5edc19c4512f4259f0bee101a40d41ebed738ade5874359610ef8eeced5 |
| USDC    | 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf |
| USDT    | 0xc060006111016b8a020ad5b33834984a437aaa7d3c74c18e09a95d48aceab08c |
| WBTC    | 0x027792d9fed7f9844eb4839566001bb6f6cb4804f66aa2da6fe1ee242d896881 |
| WAVAX   | 0x1e8b532cca6569cab9f9b9ebc73f8c13885012ade714729aa3b450e0339ac766 |
| WFTM    | 0x6081300950a4f1e2081580e919c210436a1bed49080502834950d31ee55a2396 |
| WGLMR   | 0x66f87084e49c38f76502d17f87d17f943f183bb94117561eb573e075fdc5ff75 |
| WSOL    | 0xb7844e289a8410e50fb3ca48d69eb9cf29e27d223ef90353fe1bd8e27ff8f3f8 |
| USDCsol | 0xb231fcda8bbddb31f2ef02e6161444aec64a514e2c89279584ac9806ce9cf037 |




>>>> sui/docs/content/concepts/tokenomics/vesting-strategies.mdx
---
title: Token Vesting Strategies
description: If you plan to launch a token on Sui, then you might consider implementing a vesting strategy to strengthen the long-term outlook of your token.
keywords: [ vesting strategies, token vesting strategies, designing a token launch, designing token vesting, how to design token vesting, vesting options, token vest strategies, how to vest tokens, how to design token vest ]
---

If you plan to launch a token on Sui, then you might consider implementing a vesting strategy to strengthen the long-term outlook of your token. A vesting strategy typically releases your tokens to team members, investors, or other early stakeholders over time, rather than releasing them all at once.

Implementing and publishing the details of your vesting strategy helps to:
  - Ensure long-term commitment of your token.
  - Prevent market dumps.
  - Allay fears of rug pulls (immediate withdraw of a large amount of early tokens that hurts token value).
  - Align stakeholder incentives with the project's success.

## Vesting options

There are different vesting strategies available for your token launch. The best option for your project depends on a number of factors unique to your project and its goals.

The following sections highlight some available options to consider when launching a token on the Sui network.

### Cliff vesting

Cliff vesting refers to a situation where the entire amount of tokens or assets becomes available after a specific period (the â€œcliffâ€). Until the cliff period is met, no tokens are released.

:::info Example scenario

Each of the ten employees of a project are granted 1,000 tokens with a one-year cliff. After one year, they receive the full 1,000 tokens. Before the year is up, they have no access to the tokens.

:::

The following smart contract implements a cliff vesting schedule for token releases. The module includes a `new_wallet` function that you pass the total sum of coins to vest and the cliff date as a timestamp. You can then call the `claim` function to retrieve the tokens from the wallet if the cliff date is in the past. 

Considering the example scenario, you would call `new_wallet` ten times so that a separate wallet existed for each employee. You would include 1,000 tokens in each call to load the wallet with the necessary funds. Subsequent calls to `claim` using the relevant wallet would compare the cliff time (`cliff_time` in the `Wallet` object) against the current time, returning tokens from the wallet if the cliff time is later than the current time. 

<details>

<summary> 

`cliff.move`

</summary>

<ImportContent source="examples/vesting/sources/cliff.move" mode="code" />

</details>

### Graded vesting

Graded vesting allows tokens to be gradually released over time, often in equal portions, during the vesting period.

:::info Example scenario

An employee receives 1,200 tokens, with 300 tokens vesting every year over four years. At the end of each year, 300 tokens become available.

:::

The following [Hybrid vesting](#hybrid-vesting) section includes a smart contract that demonstrates how to perform graded vesting. 

### Hybrid vesting

Hybrid vesting combines different vesting models, such as cliff and graded vesting. This allows flexibility in how tokens are released over time.

:::info Example scenario

50% of tokens are released after a one-year cliff, and the rest are distributed linearly over the next three years.

:::

The following smart contract creates a hybrid vesting model. Like the cliff vesting smart contract, the hybrid model defines a `Wallet` struct to hold all the tokens for each stakeholder. This wallet, however, actually contains two different wallets that each follow a different set of vesting rules. When you call the `new_wallet` method for this contract, you provide the cliff cutoff timestamp, the timestamp for when the linear schedule begins, and a timestamp for when the linear vesting should end. Calls to `claim` then return the sum of tokens that fall within those parameters.

<details>

<summary>

`hybrid.move`

</summary>

<ImportContent source="examples/vesting/sources/hybrid.move" mode="code" />

</details>

### Backloaded vesting

Backloaded vesting distributes the majority of tokens near the end of the vesting period, rather than evenly over time. This approach can help an ecosystem become more mature before large amounts of tokens become unlocked. Team members and stakeholders can be rewarded early but save the biggest rewards for those that remain with the project for a greater length of time.

:::info Example scenario

An employee's tokens release under the following schedule: 
  - 10% in the first three years 
  - 90% in the fourth year

:::

The smart contract for backloaded vesting creates two `Wallet` objects inside a parent wallet, which contains all the tokens to be vested. Each of the child wallets is responsible for its own vesting schedule. You call `new_wallet` with the coins to vest and `start_front`, `start_back`, `duration`, and `back_percentage` values. Based on the values you provide, the contract determines how many tokens to return when the wallet owner calls the `claim` function.

For the example scenario, you could pass the start timestamp for the frontload and the start timestamp for the backload (three years after the frontload start). You would also pass the duration of four years (`126230400000`) and `90` for the `back_percentage` value. 

<details>

<summary>

`backloaded.move`

</summary>

<ImportContent source="examples/vesting/sources/backloaded.move" mode="code" />

</details>

### Milestone- or performance-based vesting {#milestone}

With performance-based vesting, achieving specific goals or metrics trigger vest events, such as hitting revenue targets or progressing through project stages.

:::info Example scenario

A team's tokens vest in relation to the number of monthly active users (MAUs). All tokens become vested after the platform reaches its goal of 10 million MAUs.

:::

Similarly, milestone-based vesting creates vest events when specific project or personal milestones are achieved, rather than being tied to time-based conditions.

:::info Example scenario

Tokens unlock when Mainnet of a blockchain project launches.

:::

Like the other examples, the following smart contract creates a wallet to hold the coins to be distributed. Unlike the others, however, this `Wallet` object includes a `milestone_controller` field that you set to the address of the account that has the authority to update the milestone progress. The call to the `new_wallet` function aborts with an error if the wallet has the same address as the entity with milestone update privileges as an integrity check. 

The milestone update authority can call `update_milestone_percentage` to update the percentage-to-complete value. The owner of the vested token wallet can call `claim` to retrieve the tokens that are unlocked based on the current percentage-to-complete value. Considering the first example scenario, you could update the milestone value by ten percent for every million MAUs the project achieves. You could use the same contract for the second scenario, updating the percentage one time to 100 only after mainnet launches.

<details>

<summary>

`milestone.move` 

</summary>

<ImportContent source="examples/vesting/sources/milestone.move" mode="code" />

</details>

### Linear vesting

With linear vesting, tokens are released gradually over a set time period. 

:::info Example scenario

An employee is granted 1,000 tokens to be gradually released over a one-year period.

:::

The linear vesting smart contract creates a `Wallet` object with `start` and `duration` fields. The contract uses those values along with the current time to determine the number of tokens that are vested. The current time, in this case, is the time at which the wallet owner calls the `claim` function.

For the example scenario, you create the wallet (call `new_wallet`) with 1,000 tokens, the timestamp for the employee start date, and one year (`31557600000`) as the duration.

<details>

<summary>

`linear.move`

</summary>

<ImportContent source="examples/vesting/sources/linear.move" mode="code" />

</details>

### Immediate vesting

All tokens vest immediately, meaning they are fully available as soon as they are allocated.

:::info Example scenario

An early investor receives their full allocation of tokens at the time of purchase.

:::

With immediate investing, you could always just transfer tokens to an address. Opting for a smart contract approach provides several advantages over a manual transfer, however.
   - Enhanced transparency and accountability because the transaction is stored on chain for any interested parties to verify. The smart contract logic identifies the exact purpose of the transaction.
   - Possible to enforce specific conditions. For example, you could create a [milestone-based vesting](#milestone) contract that you update to 100% complete only after some conditions are met, like accepting terms of an agreement.
   - Provides an auditable record for compliance and reporting.
   - Allows flexibility to perform other actions as the terms of an agreement change, like conversion to another token before claiming.

The following test leverages the [linear vesting](#linear-vesting) smart contract example to demonstrate how to use one of the other vesting strategy smart contracts to support immediate vesting. The test uses the `Wallet` object and `new_wallet` function from `vesting::linear` to perform (or test) an immediate vest scenario. The test accomplishes this by setting the `duration` value to 0.

<details>

<summary>

`immediate_tests.move`

</summary>

<ImportContent source="examples/vesting/tests/immediate_tests.move" mode="code" />

</details>

>>>> sui/docs/content/concepts/transactions.mdx
---
title: Transactions
description: Updates on Sui are executed in the form of transactions. There are two types of transactions, programmable transaction blocks and system transactions.
keywords: [ types of transactions, transactions on sui, system transactions, programmable transaction blocks, ptbs, transaction metadata, transaction flow]
---

All updates to the Sui database happen via transactions. This topic describes the transaction types supported by Sui and explains how their execution changes the ledger.  There are only two kinds of transactions on Sui:

- Programmable transaction blocks, which anyone can submit on the network.  For information on these transactions, see [Programmable Transaction Blocks](./transactions/prog-txn-blocks.mdx).
- System transactions, which only validators can directly submit and are responsible for keeping the network running (changing epochs, starting checkpoints, and so on).

## Transaction metadata

All Sui transactions have the following common metadata:

- **Sender address:** The [address](guides/developer/getting-started/get-address.mdx) of the user sending this transaction.
- **Gas input:** An object reference pointing to the object that will be used to pay for this transaction's execution and storage. This object must be owned by the user and must be of type `sui::coin::Coin<SUI>` (i.e., the Sui native currency).
- **Gas price:** An unsigned integer specifying the number of native tokens per gas unit this transaction will pay. The gas price must always be nonzero.
- **Maximum gas budget:** The maximum number of gas units that can be expended by executing this transaction. If this budget is exceeded, transaction execution will abort and have no effects other than debiting the gas input object. Consequently, the gas input object must have a value higher than the gas price multiplied by the max gas, and this product is the maximum amount that the gas input object will be debited for the transaction.
- **Epoch:** The Sui epoch this transaction is intended for.
- **Type:** A call, publish, or native transaction and its type-specific-data (see below).
- **Authenticator:** A cryptographic signature and a public key that both verifies against the signature and is cryptographically committed to by the sender address.
- **Expiration:** An epoch reference that sets a deadline after which validators will no longer consider the transaction valid. The optional expiration epoch reference enables users to define transactions that either execute and commit by a set time (current epoch less than or equal to expiration epoch), or never execute after the deadline passes. By default, there is no deadline for when a transaction must execute. 

## Example of a transaction flow

Here's an example showing how objects and transactions are connected to each other in Sui.

In the following example there are two objects:
- Object A is a coin of type SUI with a total balance of 5 SUI
- Object B with 2 SUI coins that belongs to John

Tom decides to send 1 SUI coin to Alice. In this case, Object A is the input to this transaction and 1 SUI coin is debited from this object. The output of the transaction is two objects: 
- Object A with 4 SUI coins that still belongs to Tom
- new created Object C with 1 SUI coin that belongs now to Alice

At the same time, John decides to send 2 SUI coins to Anna. Because the relationship between objects and transactions is written in a directed acyclic graph (DAG), and both transactions interact with different objects, this transaction executes in parallel with the transaction that sends coins from Tom to Alice. This transaction changes only the owner of Object B from John to Anna.

After receiving 2 SUI coins, Anna sent them immediately to Tom. Now Tom has 6 SUI coins (4 from Object A and 2 from Object B).

Finally, Tom sends all of his SUI coins to John. For this transaction, the input is actually two objects (Object A and Object B). Object B is destroyed, and its value is added to Object A. As a result, the transaction's output is only Object A with a value of 6 SUI.

```mermaid
flowchart LR
    id1(Object A
    fa:fa-coins 5 SUI
    fa:fa-person Tom):::object-a;
    id2(Object C
    fa:fa-coins 1 SUI
    fa:fa-person Alice);
    id3(Object A
    fa:fa-coins 4 SUI
    fa:fa-person Tom):::object-a;
    id4(Object B
    fa:fa-coins 2 SUI
    fa:fa-person John):::object-b;
    id5(Object B
    fa:fa-coins 2 SUI
    fa:fa-person Anna):::object-b;
    id6(Object B
    fa:fa-coins 2 SUI
    fa:fa-person Tom):::object-b;
    id7(Object A
    fa:fa-coins 6 SUI
    fa:fa-person John):::object-a;
    id1-->|tx-1|id2;
    id1-->|tx-1|id3;
    id4-->|tx-2|id5;
    id5-->|tx-3|id6;
    id3-->|tx-4|id7;
    id6-->|tx-4|id7;
    classDef object-a fill:#f225;
    classDef object-b fill:#ff43;
```

## Limits on transactions, objects, and data

Sui has some limits on transactions and the data used in them, such as a maximum size and number of objects used. You can find these limits in the [`sui-protocol-config` crate](https://github.com/MystenLabs/sui/blob/main/crates/sui-protocol-config/src/lib.rs) of the Sui repo. The limits are defined in the `ProtocolConfig` struct and values set in the `get_for_version_impl` function.

>>>> sui/docs/content/concepts/transactions/gas-smashing.mdx
---
title: Gas Smashing
description: Sui optimizes coin management by combining multiple coins into a single object to pay for gas fees.
keywords: [ gas smashing, smash gas, combine coins, combine coins into one object, create ptb for coins, create coin ptb, group coins together, group coins into ptb, create ptb with multiple coins, coin management, multiple coin management ]
---

Every transaction on Sui has a gas fee that must be paid for successful execution. Gas smashing lets you pay this fee using multiple coins instead of a single one. This is useful when you have many smaller denomination coins or want to reduce the number of coins in your account. Gas smashing is most powerful when paired with the `GasCoin` programmable transaction block (PTB) argument.

## Smashing gas

Gas smashing happens automatically in a transaction if you provide multiple coins to pay for the gas fee. When Sui executes a transaction, Sui combines, or _smashes_, all of the coins you provide to pay for the gas into a single coin. The smashing occurs regardless of coin amounts or the gas budget provided with the transaction (as long as it is within the minimum and maximum gas budgets). Sui deducts the gas fee from the single coin regardless of the execution status of the transaction. In particular, this means that even if the transaction fails to execute for some reason (such as an execution error) the coins that you provided as gas coins remain smashed after the transaction's execution.

Key points:  
- The transaction deducts gas from the smashed coin whether execution succeeds or fails.  
- If execution fails, the gas coins remain combined after the transaction.  
- The smashed coin can then be used in the same PTB for other operations, such as transferring the remaining SUI after gas is deducted.  

This design makes gas smashing a practical way to both manage coins and pay gas in the same transaction. For example, you can combine many small coins while simultaneously executing unrelated operations in one PTB.

Limitations and effects:  
- You can smash at most 256 coins in a single PTB. Transactions with more than 256 gas coins fail.  
- All but the first coin are deleted, often generating a storage rebate.  
- Rebates cannot be applied to pay for gas in the same transaction. Instead, the rebate and the remaining balance after gas deduction are credited to the first coin once execution completes.  

## Running out of gas with a refund

Because smashing always occurs, storage rebates can lead to unusual outcomes where a transaction both runs out of gas and still produces a net refund.  

Example:  
- Transaction `T` has a gas budget of `5000`.  
- You provide five coins with balances: `C1 = 1000`, `C2 = 2000`, `C3 = 3000`, `C4 = 4000`, `C5 = 5000`.  
- The storage rebate per coin is `2000`.  
- If the gas cost exceeds the `5000` budget, `T` fails with `OutOfGas`.  

However, after smashing and rebates:  

```
Final balance in C1 =
  (1000 + 2000 + 3000 + 4000 + 5000)   // all coin balances
  - 5000                               // gas cost
  + (2000 * 4)                         // rebates for deleted coins
= 15000 - 5000 + 8000
= 18000
```

In this case, `T` fails but you still receive a net refund of `3000`.  

>>>> sui/docs/content/concepts/transactions/prog-txn-blocks.mdx
---
title: Programmable Transaction Blocks
description: Programmable transaction blocks are a group of commands that complete a transaction on Sui.
keywords: [ programmable transaction blocks, transaction blocks, program transaction blocks, PTB, PTBs, what are PTBs, what is PTB, transaction group, programmable group of transactions, program transaction block, block of transactions, group of transactions ]
---

On Sui, a transaction is more than a basic record of the flow of assets. Transactions on Sui are composed of a number of commands that execute on inputs to define the result of the transaction. Termed programmable transaction blocks (PTBs), these groups of commands define all user transactions on Sui. PTBs allow a user to call multiple Move functions, manage their objects, and manage their coins in a single transaction--without publishing a new Move package. Designed with automation and transaction builders in mind, PTBs are a lightweight and flexible way of generating transactions. More intricate programming patterns, such as loops, are not supported, however, and in those cases you must publish a new Move package.

As mentioned, each PTB is comprised of individual transaction commands (sometimes referred to simply as transactions or commands). Each transaction command executes in order, and you can use the results from one transaction command in any subsequent transaction command. The effects, specifically object modifications or transfers, of all transaction commands in a block are applied atomically at the end of the transaction. If one transaction command fails, the entire block fails and no effects from the commands are applied.

A PTB can perform up to 1,024 unique operations in a single execution, whereas transactions on traditional blockchains would require 1,024 individual executions to accomplish the same result. The structure also promotes cheaper gas fees. The cost of facilitating individual transactions is always more than the cost of those same transactions blocked together in a PTB.

The remainder of this topic covers the semantics of the execution of the transaction commands. It assumes familiarity with the Sui object model and the Move language. For more information on those topics, see the following documents:

- [Object model](../object-model.mdx)
- [Move concepts](../sui-move-concepts.mdx)

## Transaction type

There are two parts of a PTB that are relevant to execution semantics. Other transaction information, such as the transaction sender or the gas limit, might be referenced but are out of scope. The structure of a PTB is:

```rust
{
    inputs: [Input],
    commands: [Command],
}
```

Looking closer at the two main components:

- The `inputs` value is a vector of arguments, `[Input]`. These arguments are either objects or pure values that you can use in the commands. The objects are either owned by the sender or are shared/immutable objects. The pure values represent simple Move values, such as `u64` or `String` values, which you can be construct purely from their bytes. For historical reasons, `Input` is `CallArg` in the Rust implementation.
- The `commands` value is a vector of commands, `[Command]`. The possible commands are:
  - `TransferObjects` sends multiple (one or more) objects to a specified address.
  - `SplitCoins` splits off multiple (one or more) coins from a single coin. It can be any `sui::coin::Coin<_>` object.
  - `MergeCoins` merges multiple (one or more) coins into a single coin. Any `sui::coin::Coin<_>` objects can be merged, as long as they are all of the same type.
  - `MakeMoveVec` creates a vector (potentially empty) of Move values. This is used primarily to construct vectors of Move values to be used as arguments to `MoveCall`.
  - `MoveCall` invokes either an `entry` or a `public` Move function in a published package.
  - `Publish` creates a new package and calls the `init` function of each module in the package.
  - `Upgrade` upgrades an existing package. The upgrade is gated by the `sui::package::UpgradeCap` for that package.

## Inputs and results

Inputs and results are the two types of values you can use in transaction commands. Inputs are the values that are provided to the PTB, and results are the values that are produced by the PTB commands. The inputs are either objects or simple Move values, and the results are arbitrary Move values (including objects).

The inputs and results can be seen as populating an array of values. For inputs, there is a single array, but for results, there is an array for each individual transaction command, creating a 2D-array of result values. You can access these values by borrowing (mutably or immutably), by copying (if the type permits), or by moving (which takes the value out of the array without re-indexing).

### Inputs

Input arguments to a PTB are broadly categorized as either objects or pure values. The direct implementation of these arguments is often obscured by transaction builders or SDKs. This section describes information or data the Sui network needs when specifying the list of inputs, `[Input]`. Each `Input` is either an object, `Input::Object(ObjectArg)`, which contains the necessary metadata to specify the object being used, or a pure value, `Input::Pure(PureArg)`, which contains the bytes of the value.

For object inputs, the metadata needed differs depending on the type of [ownership of the object](../object-ownership.mdx). The data for the `ObjectArg` enum follows:

If the object is owned by an address (or it is immutable), then use `ObjectArg::ImmOrOwnedObject(ObjectID, SequenceNumber, ObjectDigest)`. The triple respectively specifies the object's ID, its sequence number (also known as its version), and the digest of the object's data.

If an object is shared, then use `ObjectArg::SharedObject { id: ObjectID, initial_shared_version: SequenceNumber, mutable: bool }`. Unlike `ImmOrOwnedObject`, a shared objects version and digest are determined by the network's consensus protocol. The `initial_shared_version` is the version of the object when it was first shared, which is used by consensus when it has not yet seen a transaction with that object. While all shared objects _can_ be mutated, the `mutable` flag indicates whether the object is to be used mutably in this transaction. In the case where the `mutable` flag is set to `false`, the object is read-only, and the system can schedule other read-only transactions in parallel.

If the object is owned by another object, as in it was sent to an object's ID via the `TransferObjects` command or the `sui::transfer::transfer` function, then use `ObjectArg::Receiving(ObjectID, SequenceNumber, ObjectDigest)`. The object data is the same as for the `ImmOrOwnedObject` case.

For pure inputs, the only data provided is the [BCS](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/std/bcs.md) bytes, which are deserialized to construct Move values. Not all Move values can be constructed from BCS bytes. This means that even if the bytes match the expected layout for a given Move type, they cannot be deserialized into a value of that type unless the type is one of the types permitted for `Pure` values. The following types are allowed to be used with pure values:

- All primitive types:
  - `u8`
  - `u16`
  - `u32`
  - `u64`
  - `u128`
  - `u256`
  - `bool`
  - `address`
- A string, either an ASCII string (`std::ascii::String`) or UTF8 string (`std::string::String`). In either case, the bytes are validated to be a valid string with the respective encoding.
- An object ID `sui::object::ID`.
- A vector, `vector<T>`, where `T` is a valid type for a pure input, checked recursively.
- An option, `std::option::Option<T>`, where `T` is a valid type for a pure input, checked recursively.

Interestingly, the bytes are not validated until the type is specified in a command, for example in `MoveCall` or `MakeMoveVec`. This means that a given pure input could be used to instantiate Move values of several types. See the [Arguments section](#arguments) for more details.

### Results

Each transaction command produces a (possibly empty) array of values. The type of the value can be any arbitrary Move type, so unlike inputs, the values are not limited to objects or pure values. The number of results generated and their types are specific to each transaction command. The specifics for each command can be found in the section for that command, but in summary:

- `MoveCall`: the number of results and their types are determined by the Move function being called. Move functions that return references are not supported at this time.
- `SplitCoins`: produces (one or more) coins from a single coin. The type of each coin is `sui::coin::Coin<T>` where the specific coin type `T` matches the coin being split.
- `Publish`: returns the upgrade capability, `sui::package::UpgradeCap`, for the newly published package.
- `Upgrade`: returns the upgrade receipt, `sui::package::UpgradeReceipt`, for the upgraded package.
- `TransferObjects` and `MergeCoins` do not produce any results (an empty result vector).

### Argument structure and usage

Each command takes `Argument`s that specify the input or result being used. The usage (by-reference or by-value) is inferred based on the type of the argument and the expected argument of the command. First, examine the structure of the `Argument` enum.

- `Input(u16)` is an input argument, where the `u16` is the index of the input in the input vector. For example, given an input vector of `[Object1, Object2, Pure1, Object3]`, `Object1` is accessed with `Input(0)` and `Pure1` is accessed with `Input(2)`.
- `GasCoin` is a special input argument representing the object for the `SUI` coin used to pay for gas. It is kept separate from the other inputs because the gas coin is always present in each transaction and has special restrictions (see below) not present for other inputs. Additionally, the gas coin being separate makes its usage explicit, which is helpful for sponsored transactions where the sponsor might not want the sender to use the gas coin for anything other than gas.

  The gas coin cannot be taken by-value except with the `TransferObjects` command. If you need an owned version of the gas coin, you can first use `SplitCoins` to split off a single coin.

  This limitation exists to make it easy for the remaining gas to be returned to the coin at the end of execution. In other words, if the gas coin was wrapped or deleted, then there would not be an obvious spot for the excess gas to be returned. See the [Execution section](#execution) for more details.

- `NestedResult(u16, u16)` uses the value from a previous command. The first `u16` is the index of the command in the command vector, and the second `u16` is the index of the result in the result vector of that command. For example, given a command vector of `[MoveCall1, MoveCall2, TransferObjects]` where `MoveCall2` has a result vector of `[Value1, Value2]`, `Value1` would be accessed with `NestedResult(1, 0)` and `Value2` would be accessed with `NestedResult(1, 1)`.
- `Result(u16)` is a special form of `NestedResult` where `Result(i)` is roughly equivalent to `NestedResult(i, 0)`. Unlike `NestedResult(i, 0)`, `Result(i)`, however, this errors if the result array at index `i` is empty or has more than one value. The ultimate intention of `Result` is to allow accessing the entire result array, but that is not yet supported. So in its current state, `NestedResult` can be used instead of `Result` in all circumstances.

## Execution {#execution}

For the execution of PTBs, the input vector is populated by the input objects or pure value bytes. The transaction commands are then executed in order, and the results are stored in the result vector. Finally, the effects of the transaction are applied atomically. The following sections describe each aspect of execution in greater detail.

### Start of execution

At the beginning of execution, the PTB runtime takes the already loaded input objects and loads them into the input array. The objects are already verified by the network, checking rules like existence and valid ownership. The pure value bytes are also loaded into the array but not validated until usage.

The most important thing to note at this stage is the effects on the gas coin. At the beginning of execution, the maximum gas budget (in terms of `SUI`) is withdrawn from the gas coin. Any unused gas is returned to the gas coin at the end of execution, even if the coin has changed owners.

### Executing a transaction command

Each transaction command is then executed in order. First, examine the rules around arguments, which are shared by all commands.

#### Arguments {#arguments}

You can use each argument by-reference or by-value. The usage is based on the type of the argument and the type signature of the command.

- If the signature expects an `&mut T`, the runtime checks the argument has type `T` and it is then mutably borrowed.
- If the signature expects an `&T`, the runtime checks the argument has type `T` and it is then immutably borrowed.
- If the signature expects a `T`, the runtime checks the argument has type `T` and it is copied if `T: copy` and moved otherwise. No object in Sui has `copy` because the unique ID field `sui::object::UID` present in all objects does not have the `copy` ability.

The transaction fails if an argument is used in any form after being moved. There is no way to restore an argument to its position (its input or result index) after it is moved.

If an argument is copied but does not have the `drop` ability, then the last usage is inferred to be a move. As a result, if an argument has `copy` and does not have `drop`, the last usage _must_ be by value. Otherwise, the transaction will fail because a value without `drop` has not been used.

The borrowing of arguments has other rules to ensure unique safe usage of an argument by reference. If an argument is:

- Mutably borrowed, there must be no outstanding borrows. Duplicate borrows with an outstanding mutable borrow could lead to dangling references (references that point to invalid memory).
- Immutably borrowed, there must be no outstanding mutable borrows. Duplicate immutable borrows are allowed.
- Moved, there must be no outstanding borrows. Moving a borrowed value would dangle those outstanding borrows, making them unsafe.
- Copied, there can be outstanding borrows, mutable or immutable. While it might lead to some unexpected results in some cases, there is no safety concern.

Object inputs have the type of their object `T` as you might expect. However, for `ObjectArg::Receiving` inputs, the object type `T` is instead wrapped as `sui::transfer::Receiving<T>`. This is because the object is not owned by the sender, but instead by another object. And to prove ownership with that parent object, you call the `sui::transfer::receive` function to remove the wrapper.

The `GasCoin` has special restrictions on being used by-value (moved). You can only use it by-value with the `TransferObjects` command.

Shared objects also have restrictions on being used by-value. These restrictions exist to ensure that at the end of the transaction the shared object is either still shared or deleted. A shared object cannot be unshared (having the owner changed) and it cannot be wrapped. A shared object:

- Marked as not `mutable` (being used read-only) cannot be used by value.
- Cannot be transferred or frozen. These checks are not done dynamically, however, but rather at the end of the transaction only. For example, `TransferObjects` succeeds if passed a shared object, but at the end of execution the transaction fails.
- Can be wrapped and can become a dynamic field transiently, but by the end of the transaction it must be re-shared or deleted.

Pure values are not type checked until their usage. When checking if a pure value has type `T`, it is checked whether `T` is a valid type for a pure value (see the previous list). If it is, the bytes are then validated. You can use a pure value with multiple types as long as the bytes are valid for each type. For example, you can use a string as an ASCII string `std::ascii::String` and as a UTF8 string `std::string::String`. However, after you mutably borrow the pure value, the type becomes fixed, and all future usages must be with that type.

#### `TransferObjects`

The command has the form `TransferObjects(ObjectArgs, AddressArg)` where `ObjectArgs` is a vector of objects and `AddressArg` is the address the objects are sent to.

- Each argument `ObjectArgs: [Argument]` must be an object, however, the objects do not need to have the same type.
- The address argument `AddressArg: Argument` must be an address, which could come from a `Pure` input or a result.
- All arguments, objects and address, are taken by value.
- The command does not produce any results (an empty result vector).
- While the signature of this command cannot be expressed in Move, you can think of it roughly as having the signature `(vector<forall T: key + store. T>, address): ()` where `forall T: key + store. T` is indicating that the `vector` is a heterogeneous vector of objects.

#### `SplitCoins`

The command has the form `SplitCoins(CoinArg, AmountArgs)` where `CoinArg` is the coin being split and `AmountArgs` is a vector of amounts to split off.

- When the transaction is signed, the network verifies that the `AmountArgs` is non-empty.
- The coin argument `CoinArg: Argument` must be a coin of type `sui::coin::Coin<T>` where `T` is the type of the coin being split. It can be any coin type and is not limited to `SUI` coins.
- The amount arguments `AmountArgs: [Argument]` must be `u64` values, which could come from a `Pure` input or a result.
- The coin argument `CoinArg` is taken by mutable reference.
- The amount arguments `AmountArgs` are taken by value (copied).
- The result of the command is a vector of coins, `sui::coin::Coin<T>`. The coin type `T` is the same as the coin being split, and the number of results matches the number of arguments
- For a rough signature expressed in Move, it is similar to a function `<T: key + store>(coin: &mut sui::coin::Coin<T>, amounts: vector<u64>): vector<sui::coin::Coin<T>>` where the result `vector` is guaranteed to have the same length as the `amounts` vector.

#### `MergeCoins`

The command has the form `MergeCoins(CoinArg, ToMergeArgs)` where the `CoinArg` is the target coin in which the `ToMergeArgs` coins are merged into. In other words, you merge multiple coins (`ToMergeArgs`) into a single coin (`CoinArg`).

- When the transaction is signed, the network verifies that the `ToMergeArgs` is non-empty.
- The coin argument `CoinArg: Argument` must be a coin of type `sui::coin::Coin<T>` where `T` is the type of the coin being merged. It can be any coin type and is not limited to `SUI` coins.
- The coin arguments `ToMergeArgs: [Argument]` must be `sui::coin::Coin<T>` values where the `T` is the same type as the `CoinArg`.
- The coin argument `CoinArg` is taken by mutable reference.
- The merge arguments `ToMergeArgs` are taken by value (moved).
- The command does not produce any results (an empty result vector).
- For a rough signature expressed in Move, it is similar to a function `<T: key + store>(coin: &mut sui::coin::Coin<T>, to_merge: vector<sui::coin::Coin<T>>): ()`

#### `MakeMoveVec`

The command has the form `MakeMoveVec(VecTypeOption, Args)` where `VecTypeOption` is an optional argument specifying the type of the elements in the vector being constructed and `Args` is a vector of arguments to be used as elements in the vector.

- When the transaction is signed, the network verifies that if that the type must be specified for an empty vector of `Args`.
- The type `VecTypeOption: Option<TypeTag>` is an optional argument specifying the type of the elements in the vector being constructed. The `TypeTag` is a Move type for the elements in the vector, i.e. the `T` in the produced `vector<T>`.
  - The type does not have to be specified for an object vector--when `T: key`.
  - The type _must_ be specified if the type is not an object type or when the vector is empty.
- The arguments `Args: [Argument]` are the elements of the vector. The arguments can be any type, including objects, pure values, or results from previous commands.
- The arguments `Args` are taken by value. Copied if `T: copy` and moved otherwise.
- The command produces a _single_ result of type `vector<T>`. The elements of the vector cannot then be accessed individually using `NestedResult`. Instead, the entire vector must be used as an argument to another command. If you wish to access the elements individually, you can use the `MoveCall` command and do so inside of Move code.
- While the signature of this command cannot be expressed in Move, you can think of it roughly as having the signature `(T...): vector<T>` where `T...` indicates a variadic number of arguments of type `T`.

#### `MoveCall`

This command has the form `MoveCall(Package, Module, Function, TypeArgs, Args)` where `Package::Module::Function` combine to specify the Move function being called, `TypeArgs` is a vector of type arguments to that function, and `Args` is a vector of arguments for the Move function.

- The package `Package: ObjectID` is the Object ID of the package containing the module being called.
- The module `Module: String` is the name of the module containing the function being called.
- The function `Function: String` is the name of the function being called.
- The type arguments `TypeArgs: [TypeTag]` are the type arguments to the function being called. They must satisfy the constraints of the type parameters for the function.
- The arguments `Args: [Argument]` are the arguments to the function being called. The arguments must be valid for the parameters as specified in the function's signature.
- Unlike the other commands, the usage of the arguments and the number of results are dynamic in that they both depend on the signature of the Move function being called.

#### `Publish` {#publish}

The command has the form `Publish(ModuleBytes, TransitiveDependencies)` where `ModuleBytes` are the bytes of the module being published and `TransitiveDependencies` is a vector of package Object ID dependencies to link against.

When the transaction is signed, the network verifies that the `ModuleBytes` are not empty. The module bytes `ModuleBytes: [[u8]]` contain the bytes of the modules being published with each `[u8]` element is a module.

The transitive dependencies `TransitiveDependencies: [ObjectID]` are the Object IDs of the packages that the new package depends on. While each module indicates the packages used as dependencies, the transitive object IDs must be provided to select the version of those packages. In other words, these object IDs are used to select the version of the packages marked as dependencies in the modules.

After the modules in the package are verified, the `init` function of each module is called in same order as the module byte vector `ModuleBytes`.

The command produces a single result of type `sui::package::UpgradeCap`, which is the upgrade capability for the newly published package.

#### `Upgrade`

The command has the form `Upgrade(ModuleBytes, TransitiveDependencies, Package, UpgradeTicket)`, where the `Package` indicates the object ID of the package being upgraded. The `ModuleBytes` and `TransitiveDependencies` work similarly as the `Publish` command.

For details on the `ModuleBytes` and `TransitiveDependencies`, see the [`Publish` command](#publish). Note though, that no `init` functions are called for the upgraded modules.

The `Package: ObjectID` is the Object ID of the package being upgraded. The package must exist and be the latest version.

The `UpgradeTicket: sui::package::UpgradeTicket` is the upgrade ticket for the package being upgraded and is generated from the `sui::package::UpgradeCap`. The ticket is taken by value (moved).

The command produces a single result type `sui::package::UpgradeReceipt` which provides proof for that upgrade. For more details on upgrades, see [Upgrading Packages](../sui-move-concepts/packages/upgrade.mdx).

### End of execution

At the end of execution, the remaining values are checked and effects for the transaction are calculated.

For inputs, the following checks are performed:

- Any remaining immutable or readonly input objects are skipped since no modifications have been made to them.
- Any remaining mutable input objects are returned to their original owners--if they were shared they remain shared, if they were owned they remain owned.
- Any remaining pure input values are dropped. Note that pure input values must have `copy` and `drop` since all permissible types for those values have `copy` and `drop`.
- For any shared object you must also check that it has only been deleted or re-shared. Any other operation (wrap, transfer, freezing, and so on) results in an error.

For results, the following checks are performed:

- Any remaining result with the `drop` ability is dropped.
- If the value has `copy` but not `drop`, it's last usage must have been by-value. In that way, it's last usage is treated as a move.
- Otherwise, an error is given because there is an unused value without `drop`.

Any remaining SUI deducted from the gas coin at the beginning of execution is returned to the coin, even if the owner has changed. In other words, the maximum possible gas is deducted at the beginning of execution, and then the unused gas is returned at the end of execution (all in SUI). Because you can take the gas coin only by-value with `TransferObjects`, it will not have been wrapped or deleted.

The total effects (which contain the created, mutated, and deleted objects) are then passed out of the execution layer and are applied by the Sui network.

## Example

Let's walk through an example of a PTB's execution. While this example is not exhaustive in demonstrating all the rules, it does show the general flow of execution.

Suppose you want to buy two items from a marketplace costing `100 MIST`. You keep one for yourself, and then send the object and the remaining coin to a friend at address `0x808`. You can do that all in one PTB:

```rust
{
  inputs: [
    Pure(/* @0x808 BCS bytes */ ...),
    Object(SharedObject { /* Marketplace shared object */ id: market_id, ... }),
    Pure(/* 100u64 BCS bytes */ ...),
  ]
  commands: [
    SplitCoins(GasCoin, [Input(2)]),
    MoveCall("some_package", "some_marketplace", "buy_two", [], [Input(1), NestedResult(0, 0)]),
    TransferObjects([GasCoin, NestedResult(1, 0)], Input(0)),
    MoveCall("sui", "tx_context", "sender", [], []),
    TransferObjects([NestedResult(1, 1)], NestedResult(3, 0)),
  ]
}
```

The inputs include the friend's address, the marketplace object, and the value for the coin split. For the commands, split off the coin, call the market place function, send the gas coin and one object, grab your address (via `sui::tx_context::sender`), and then send the remaining object to yourself. For simplicity, the documentation refers to the package names by name, but note that in practice they are referenced by the package's Object ID.

To walk through this, first look at the memory locations, for the gas object, inputs, and results

```rust
Gas Coin: sui::coin::Coin<SUI> { id: gas_coin, balance: sui::balance::Balance<SUI> { value: 1_000_000u64 } }
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  some_package::some_marketplace::Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: []
```

Here you have two objects loaded so far, the gas coin with a value of `1_000_000u64` and the marketplace object of type `some_package::some_marketplace::Marketplace` (these names and representations are shortened for simplicity going forward). The pure arguments are not loaded, and are present as BCS bytes.

Note that while gas is deducted at each command, that aspect of execution is not demonstrated in detail.

### Before commands: start of execution

Before execution, remove the gas budget from the gas coin. Assume a gas budget of `500_000` so the gas coin now has a value of `500_000u64`.

```rust
Gas Coin: Coin<SUI> { id: gas_coin, ... value: 500_000u64 ... } // The maximum gas is deducted
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: []
```

Now you can execute the commands.

### Command 0: `SplitCoins`

The first command `SplitCoins(GasCoin, [Input(2)])` accesses the gas coin by mutable reference and loads the pure argument at `Input(2)` as a `u64` value of `100u64`. Because `u64` has the `copy` ability, you do not move the `Pure` input at `Input(2)`. Instead, the bytes are copied out.

For the result, a new coin object is made.

This gives us updated memory locations of

```rust
Gas Coin: Coin<SUI> { id: gas_coin, ... value: 499_900u64 ... }
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [Coin<SUI> { id: new_coin, value: 100u64 ... }], // The result of SplitCoins
],
```

### Command 1: `MoveCall`

Now the command, `MoveCall("some_package", "some_marketplace", "buy_two", [], [Input(1), NestedResult(0, 0)])`. Call the function `some_package::some_marketplace::buy_two` with the arguments `Input(1)` and `NestedResult(0, 0)`. To determine how they are used, you need to look at the function's signature. For this example, assume the signature is

```move
entry fun buy_two(
    marketplace: &mut Marketplace,
    coin: Coin<Sui>,
    ctx: &mut TxContext,
): (Item, Item)
```

where `Item` is the type of the two objects being sold.

Since the `marketplace` parameter has type `&mut Marketplace`, use `Input(1)` by mutable reference. Assume some modifications are being made into the value of the `Marketplace` object. However, the `coin` parameter has type `Coin<Sui>`, so use `NestedResult(0, 0)` by value. The `TxContext` input is automatically provided by the runtime.

This gives updated memory locations, where `_` indicates the object has been moved.

```rust
Gas Coin: Coin<SUI> { id: gas_coin, ... value: 499_900u64 ... }
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ...  }, // Any mutations are applied
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [ _ ], // The coin was moved
  [Item { id: id1 }, Item { id: id2 }], // The results from the Move call
],
```

Assume that `buy_two` deletes its `Coin<SUI>` object argument and transfers the `Balance<SUI>` into the `Marketplace` object.

### Command 2: `TransferObjects`

`TransferObjects([GasCoin, NestedResult(1, 0)], Input(0))` transfers the gas coin and first item to the address at `Input(0)`. All inputs are by value, and the objects do not have `copy` so they are moved. While no results are given, the ownership of the objects is changed. This cannot be seen in the memory locations, but rather in the transaction effects.

You now have updated memory locations of

```rust
Gas Coin: _ // The gas coin is moved
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [ _ ],
  [ _ , Item { id: id2 }], // One item was moved
  [], // No results from TransferObjects
],
```

### Command 3: `MoveCall`

Make another Move call, this one to `sui::tx_context::sender` with the signature

```move
public fun sender(ctx: &TxContext): address
```

While you could have just passed in the sender's address as a `Pure` input, this example demonstrates calling some of the additional utility of PTBs; while this function is not an `entry` function, you can call the `public` function, too, because you can provide all of the arguments. In this case, the only argument, the `TxContext`, is provided by the runtime. The result of the function is the sender's address. Note that this value is not treated like the `Pure` inputs--the type is fixed to `address` and it cannot be deserialized into a different type, even if it has a compatible BCS representation.

You now have updated memory locations of

```rust
Gas Coin: _
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [ _ ],
  [ _ , Item { id: id2 }],
  [],
  [/* senders address */ ...], // The result of the Move call
],
```

### Command 4: `TransferObjects`

Finally, transfer the remaining item to yourself. This is similar to the previous `TransferObjects` command. You are using the last `Item` by-value and the sender's address by-value. The item is moved because `Item` does not have `copy`, and the address is copied because `address` does have `copy`.

The final memory locations are

```rust
Gas Coin: _
Inputs: [
  Pure(/* @0x808 BCS bytes */ ...),
  Marketplace { id: market_id, ... },
  Pure(/* 100u64 BCS bytes */ ...),
]
Results: [
  [ _ ],
  [ _ , _ ],
  [],
  [/* senders address */ ...],
  [], // No results from TransferObjects
],
```

### After commands: end of execution

At the end of execution, the runtime checks the remaining values, which are the three inputs and
the sender's address. The following summarizes the checks performed before effects are given:

- Any remaining input objects are marked as being returned to their original owners.
  - The gas coin has been Moved. And the `Marketplace` keeps the same owner, which is shared.
- All remaining values must have `drop`.
  - The Pure inputs have `drop` because any type they can instantiate has `drop`.
  - The sender's address has `drop` because the primitive type `address` has `drop`.
  - All other results have been moved.
- Any remaining shared objects must have been deleted or re-shared.
  - The `Marketplace` object was not moved, so the owner remains as shared.

After these checks are performed, generate the effects.

- The coin split off from the gas coin, `new_coin`, does not appear in the effects because it was created and deleted in the same transaction.
- The gas coin and the item with `id1` are transferred to `0x808`.
  - The gas coin is mutated to update its balance. The remaining gas of the maximum budget of `500_000` is returned to the gas coin even though the owner has changed.
  - The `Item` with `id1` is a newly created object.
- The item with `id2` is transferred to the sender's address.
  - The `Item` with `id2` is a newly created object.
- The `Marketplace` object is returned, remains shared, and it's mutated.
  - The object remains shared but its contents are mutated.

>>>> sui/docs/content/concepts/transactions/sponsored-transactions.mdx
---
title: Sponsored Transactions
description: A sponsored transaction is when one Sui address pays the gas fee for a transaction submitted by another address. Sponsored transactions can help facilitate user onboarding and simplified asset management.
keywords: [ sponsored transaction, how to sponsor a transaction, sponsor a transaction, pay gas for another address, can you pay gas for another address, sponsoring a transaction, paying fee for another user, paying gas for another user, paying for someone else, paying gas for someone else, sponsoring someone's transaction ]
---

A Sui sponsored transaction is one where a Sui address (the sponsor's) pays the gas fees for a transaction that another address (the user's) initializes. You can use sponsored transactions to cover the fees for users on your site or app so that they don't get charged for them. This removes a significant obstacle that Web2 users encounter when entering Web3, as they often have to purchase tokens to perform a transaction on-chain. For example, you could sponsor gamers' early transactions to increase conversion rates.

Sponsored transactions also facilitate asset management as you don't need to maintain multiple accounts with SUI tokens to transfer funds.

You can use Sui sponsored transactions to:
- Sponsor (pay gas fees for) a transaction a user initiates.
- Sponsor transactions you initiate as the sponsor.
- Provide a wildcard `GasData` object to users. The object covers the gas fees for a user transaction. The `GasData` object covers any fee amount determined for the transaction as long as the budget is sufficient.

## Potential risks using sponsored transactions

The most significant potential risk when using sponsored transactions is [equivocation](/references/sui-glossary.mdx#equivocation). In some cases under certain conditions, a sponsored transaction can result in all associated owned objects, including gas in a locked state when examined by Sui validators. To avoid double spending, validators lock objects as they validate transactions. An equivocation occurs when an owned object's pair (`ObjectID`, `SequenceNumber`) is concurrently used in multiple non-finalized transactions.

To equivocate, either the user or the sponsor signs and submits another transaction that attempts to manipulate an owned object in the original transaction. Because only the object owner can use an owned object, only the user and sponsor can cause this condition.

## Create a user-initiated sponsored transaction

A user-initiated sponsored transaction involves the following steps:

 1. A user initializes a `GasLessTransactionData` transaction.
 1. The user sends `GasLessTransactionData` to the sponsor.
 1. The sponsor validates the transaction, constructs `TransactionData` with gas fees, and then signs `TransactionData`.
 1. The sponsor sends the signed `TransactionData` and the sponsor `Signature` back to the user.
 1. The user verifies and then signs `TransactionData` and sends the dual-signed transaction to Sui network through a full node or the sponsor.

### GasLessTransactionData

`GasLessTransactionData` is basically `TransactionData` without `GasData`. It is not a `sui-core` data structure, but it is only an interface between user and sponsor.

The following example constructs a `GasLessTransactionData`  object.

```rust
pub struct GasLessTransactionData {
    pub kind: TransactionKind,
    sender: SuiAddress,
    â€¦
}
```

## Create a sponsor-initiated sponsored transaction  

A sponsor-initiated sponsored transaction involves the following steps:
 1. A sponsor constructs a `TransactionData` object that contains the transaction details and associated gas fee data. The sponsor signs it to generate a `Signature` before sending it to a user. You can send the unsigned `TransactionData` via email, SMS, or an application interface.
 1. The user checks the transaction and signs it to generate the second `Signature` for the transaction.
 1. The user submits the dual-signed transaction to a Sui full node or sponsor to execute it.

You can use a sponsor-initiated sponsored transaction as an advertiser, or to incentivize specific user actions without requiring the user to pay for gas fees.

## Create sponsored transactions using a GasData object

To use a `GasData` object to sponsor the gas fees for a transaction, create a `GasData` object that covers the fees determined for the transaction. This is similar to providing a blank check to a user that can be used only to cover gas fees. The user doesn't need to know how much the fee is or approve it.

 A sponsor transaction using a `GasData` object involves the following steps:
 1. The sponsor provides a `GasData` object to a user.
 1. The user constructs `TransactionData` and signs it to generate a `Signature`.
 1. The user sends the `TransactionData` and the `Signature` to the sponsor.
 1. The sponsor confirms the `TransactionData` and then signs it.
 1. The sponsor submits the dual-signed `TransactionData` to a full node to execute the transaction.

## Create a Sui gas station

On Sui, a gas station is a concept to describe where you set up processes to sponsor user transactions. You can customize a Sui gas station to support the specific user-facing functionality you need. Some example use cases for a Sui gas station include:

- Monitor real-time gas prices on the network to determine the gas price that the station provides.
- Track usage of gas provided to users on the network.
- Gas pool management, such as using specific gas objects to minimize costs or reduce the risk of a large amount of locked objects that remain illiquid while locked.

### Authorization and rate limiting

Depending on the nature of your gas station, you can apply different authorization rules to avoid being spammed by bad actors. Possible policies include:

- Rate limit gas requests per account or per IP address
- Only accept requests with a valid authorization header, which has separate rate limits

### Abuse detection

For all gas objects that you provide as a sponsor, you should track if users ever try to equivocate and lock objects. If you detect such behavior, block the user or requester accordingly.

## Code examples to create a Sui gas station

The following Rust SDK code examples demonstrate how to implement a Sui gas station that supports each of the sponsored transaction types described previously.

### User-initiated sponsored transactions

Use the API endpoint to receive `GaslessTransaction` transactions and return a sole-signed `SenderSignedData` object.

```rust
pub fn request_gas_and_signature(gasless_tx: GaslessTransaction) -> Result<SenderSignedData, Error>;
```

### Sponsored transactions with GasData objects

Use the API endpoint to receive sole-signed `SenderSignedData` and return the result of the transaction.

```rust
pub fn submit_sole_signed_transaction(sole_signed_data: SenderSignedData) -> Result<(Transaction, CertifiedTransactionEffects), Error>;
```

Alternatively, use the API endpoint to return a GasData object.

```rust
pub fn request_gas(/*requirement data*/) -> Result<GasData, Error>;
```

### User and sponsor-initiated transaction

Use the API endpoint to receive dual-signed `SenderSignedData` and return the result of the transaction.

```rust
pub fn submit_dual_signed_transaction(dual_signed_data: SenderSignedData) -> Result<(Transaction, CertifiedTransactionEffects), Error>;
```

For user and sponsor-initiated transactions, users can submit the dual-signed transaction via either a sponsor or a full node.

## Sponsored transaction data structure

The following code block describes the `TransactionData` structure for sponsored transactions and `GasObject`. You can view the [source code](https://github.com/MystenLabs/sui/blob/224a28ed9dece21a952547896bd5d794bdf8b562/crates/sui-types/src/transaction.rs) in the Sui GitHub repository.

**`TransactionData` Structure**
```rust
#[derive(Debug, PartialEq, Eq, Hash, Clone, Serialize, Deserialize)]
pub struct TransactionDataV1 {
    pub kind: TransactionKind,
    pub sender: SuiAddress,
    pub gas_data: GasData,
    pub expiration: TransactionExpiration,
}
```

**`GasData` Structure**
```rust
#[derive(Debug, PartialEq, Eq, Hash, Clone, Serialize, Deserialize)]
pub struct GasData {
    pub payment: Vec<ObjectRef>,
    pub owner: SuiAddress,
    pub price: u64,
    pub budget: u64,
}
```

To learn more about transactions in Sui, see [Transactions](../transactions.mdx).

>>>> sui/docs/content/concepts/transfers.mdx
---
title: Transfers
description: Everything on Sui is an object. To use objects, they must be transferred between owners, which can be an address or another object. 
keywords: [ object transfers, transferring objects, custom transfer rules, transfer to an object, transfer objects ]
---

Everything on Sui is an object and your smart contracts are inevitably going to need to move those objects around the network, transferring them from one owner to another. The topics in this section explore the options you have on Sui around transferring objects on the network.

<Cards>
<Card title="Custom Transfer Rules" href="/concepts/transfers/custom-rules">
</Card>
<Card title="Transfer to Object" href="/concepts/transfers/transfer-to-object">
</Card>
</Cards>
>>>> sui/docs/content/concepts/transfers/custom-rules.mdx
---
title: Custom Transfer Rules
description: Custom transfer rules enable you to define a set of rules that must be met before Sui considers a transfer operation valid.
---

Every Sui object must have the `key` ability. The `store` ability, on the other hand, is an optional ability you can add to Sui objects. Objects with the `store` ability:

- are transferable by anyone using the `transfer::public_transfer` function; and
- are able to be wrapped in other objects.

Importantly for custom transfer rules, if the Sui object `Object` does not have the `store` ability, you cannot call the `sui::transfer::public_transfer` function to transfer it. The Move module that defines `Object` is the only entity that can transfer objects of that type using the `sui::transfer::transfer` function. Consequently, the module that defines the object `Object` can define a custom transfer function for `Object` that can take any number of arguments, and enforce any restrictions desired for performing a transfer operation (for example, a fee must be paid in order to transfer the object).

## The store ability and transfer rules

Custom transfer rules for objects enable you to define the transfer conditions that must be met for a valid transfer operation. You should be intentional about adding the `store` ability to an object because you are providing unrestricted access to that object without having to go through the module that defines it. After you enable public transfers on an object, there is no way of re-enabling custom transfer rules or any type of restrictions regarding the transfer of the object.

## Example

This example creates an object type `Object` that is transferrable only if the `unlocked` flag inside of it is set to `true`:

```move
public struct Object has key {
    id: UID,
    // An `Object` object can only be transferred if this field is `true`
    unlocked: bool,
}
```

Within the same module that defines the object `Object`, you can then define a custom transfer rule `transfer_unlocked` for `Object` that takes the object to transfer and the address to transfer it to, and verifies that the object is unlocked before transferring it to the specified address.

```move
module examples::custom_transfer;

// Error code for trying to transfer a locked object
const EObjectLocked: u64 = 0;

public struct Object has key {
    id: UID,
    // An `Object` object can only be transferred if this field is `true`
    unlocked: bool,
}

// Check that `Object` is unlocked before transferring it
public fun transfer_unlocked(object: Object, to: address) {
    assert!(object.unlocked, EObjectLocked);
    transfer::transfer(object, to)
}
```

With custom transfer rules, you can define multiple different transfer rules for the same object. Each of these rules might have different restrictions that execution of the transaction can dynamically enforce. So, if you wanted to allow only locked objects to be transferred to a specific address you could add the following function to the previous module:

```move
const EObjectNotLocked: u64 = 1;
const HOME_ADDRESS = @0xCAFE;

public fun transfer_locked(object: Object) {
    assert!(!object.unlocked, EObjectNotLocked);
    transfer::transfer(object, HOME_ADDRESS)
}
```

With these rules in place, there are two different custom transfer rules for any object `Object`: either it's unlocked and anyone can transfer it, or it's locked, and it can only be transferred to `0xCAFE`. Importantly, these two ways of transferring `Object` are the only ways of transferring any object of type `Object`. In particular, because `Object` does not have the `store` ability, you cannot transfer it using the `sui::transfer::public_transfer` function. In fact, the only ways of transferring `Object` are using `examples::custom_transfer::transfer_unlocked` and `examples::custom_transfer::transfer_locked`.

>>>> sui/docs/content/concepts/transfers/transfer-policies.mdx
---
title: Transfer Policies
description: Learn about transfer policies on Sui.
keywords: [ transfer, policy, transferpolicy, transfer receipt, transfer request, transferrequest ]
---

A [`TransferPolicy`](/references/framework/sui_sui/transfer_policy) on Sui is a customizable primitive that enables the owner of a type to create custom rules that define how the type can be transferred. You can use a `TransferPolicy` within a Sui Kiosk marketplace or any other system that integrates the `TransferPolicy` primitive. You can set any number of rules, such as paying a royalty or commission, and all must be satisfied in a single transaction for the transfer to succeed.

In a kiosk, creating and sharing a `TransferPolicy<T>` makes the type `T` tradable in that kiosk. On every kiosk purchase, the `TransferPolicy` must confirm the `TransferRequest`, or the transaction fails.

## Transfer policies for kiosks 

When a kiosk purchase occurs, the system creates a `TransferRequest` _hot potato_, and only the matching `TransferPolicy` can confirm it to unblock the transaction.

A kiosk can trade an item of type `T` only if the `TransferPolicy` for `T` exists and the buyer can access it. A purchase issues a `TransferRequest` that must be resolved in a matching `TransferPolicy`. If no policy exists or the buyer can't access it, the transaction fails.

This system gives you maximum freedom and flexibility. By removing transfer policy logic from the trading primitive, only you can set policies, and you control all enforcement as long as the primitive is used.

## `TransferPolicy` rules 

By default, a single `TransferPolicy` enforces nothing and requires no user action. It confirms `TransferRequests` and therefore unblocks a transaction. However, the system allows setting _rules_. A rule is a way to request an additional action from the user before the request can be confirmed.

The rule logic is straightforward: someone can publish a new rule module, such as a "fixed fee," and add it to the `TransferPolicy`. After the rule is added, `TransferRequest` needs to collect a `TransferReceipt` marking that the requirement specified in the rule was completed.

### Example rule 

To implement VAT fees on every merchant transaction, you must introduce a rule.

A rule needs to provide 4 main components:

1. A `RuleWitness` struct, which uniquely identifies the rule.
1. A `config` type which is stored in the `TransferPolicy` and is used to configure the rule.
1. A set function which adds the rule to the `TransferPolicy`. The `TransferPolicyCap` holder must perform this action.
1. An actionable function which adds the receipt into the `TransferRequest` and potentially adds to the `TransferPolicy` balance if the functionality involves some monetary transaction.

```
module examples::dummy_rule {
    use sui::coin::Coin;
    use sui::sui::SUI;
    use sui::transfer_policy::{
        Self as policy,
        TransferPolicy,
        TransferPolicyCap,
        TransferRequest
    };

    /// The rule Witness; has no fields and is used as a
    /// static authorization method for the rule.
    struct Rule has drop {}

    /// Configuration struct with any fields (as long as it
    /// has `drop`). Managed by the rule module.
    struct Config has store, drop {}

    /// Function that adds a rule to the `TransferPolicy`.
    /// Requires `TransferPolicyCap` to make sure the rules are
    /// added only by the publisher of T.
    public fun add<T>(
        policy: &mut TransferPolicy<T>,
        cap: &TransferPolicyCap<T>
    ) {
        policy::add_rule(Rule {}, policy, cap, Config {})
    }

    /// Action function - perform a certain action (any, really)
    /// and pass in the `TransferRequest` so it gets the receipt.
    /// Receipt is a rule witness, so there's no way to create
    /// it anywhere else but in this module.
    ///
    /// This example also illustrates that rules can add Coin<SUI>
    /// to the balance of the TransferPolicy allowing creators to
    /// collect fees.
    public fun pay<T>(
        policy: &mut TransferPolicy<T>,
        request: &mut TransferRequest<T>,
        payment: Coin<SUI>
    ) {
        policy::add_to_balance(Rule {}, policy, payment);
        policy::add_receipt(Rule {}, request);
    }
}
```

The `TransferPolicy` module allows removing any rule at any time, as guaranteed by the constraints on the rule's configuration. This example module has no configuration and accepts a `Coin<SUI>` of any value.

### Royalty rules

To implement a percentage-based fee, such as royalties, a rule module must know the item's purchase price. The `TransferRequest` provides information that supports this and similar scenarios:

- Item ID
- Amount paid (SUI)
- From ID: The object that was used for selling, such as the kiosk

The `sui::transfer_policy` module provides public functions to access these fields: `paid()`, `item()`, and `from()`.

```
module examples::royalty_rule {
    // skipping dependencies
    const MAX_BP: u16 = 10_000;

    struct Rule has drop {}

    /// In this implementation rule has a configuration - `amount_bp`
    /// which is the percentage of the `paid` in basis points.
    struct Config has store, drop { amount_bp: u16 }

    /// When a rule is added, configuration details are specified
    public fun add<T>(
        policy: &mut TransferPolicy<T>,
        cap: &TransferPolicyCap<T>,
        amount_bp: u16
    ) {
        assert!(amount_bp <= MAX_BP, 0);
        policy::add_rule(Rule {}, policy, cap, Config { amount_bp })
    }

    /// To get the receipt, the buyer must call this function and pay
    /// the required amount; the amount is calculated dynamically and
    /// it is more convenient to use a mutable reference
    public fun pay<T>(
        policy: &mut TransferPolicy<T>,
        request: &mut TransferRequest<T>,
        payment: &mut Coin<SUI>,
        ctx: &mut TxContext
    ) {
        // using the getter to read the paid amount
        let paid = policy::paid(request);
        let config: &Config = policy::get_rule(Rule {}, policy);
        let amount = (((paid as u128) * (config.amount_bp as u128) / MAX_BP) as u64);
        assert!(coin::value(payment) >= amount, EInsufficientAmount);

        let fee = coin::split(payment, amount, ctx);
        policy::add_to_balance(Rule {}, policy, fee);
        policy::add_receipt(Rule {}, request)
    }
}
```

#### Time-based rules

Rules apply to more than just payments and fees. Some rules might permit trading only before or after a specific time. Because rules are not standardized, you can encode logic with any object.

```
module examples::time_rule {
    // skipping some dependencies
    use sui::clock::{Self, Clock};

    struct Rule has drop {}
    struct Config has store, drop { start_time: u64 }

    /// Start time is yet to come
    const ETooSoon: u64 = 0;

    /// Add a rule that enables purchases after a certain time
    public fun add<T>(/* skip default fields */, start_time: u64) {
        policy::add_rule(Rule {}, policy, cap, Config { start_time })
    }

    /// Pass in the clock and prove that current time value is higher
    /// than the `start_time`
    public fun confirm_time<T>(
        policy: &TransferPolicy<T>,
        request: &mut TransferRequest<T>,
        clock: &Clock
    ) {
        let config: &Config = policy::get_rule(Rule {}, policy)
        assert!(clock::timestamp_ms(clock) >= config.start_time, ETooSoon);
        policy::add_receipt(Rule {}, request)
    }
}
```

### `TransferRequest` receipts

The `TransferRequest` includes a field called `receipts`, which is a `VecSet` of `TypeName`. When the `confirm_request` call runs, the system compares the receipts against `TransferPolicy.rules`. If receipts do not match rules, the system rejects the request and the transaction fails.

In the following example, both the rules and receipts are empty, so they match trivially and the request is confirmed:

```
module sui::transfer_policy {
    // ... skipped ...

    struct TransferRequest<phantom T> {
        // ... other fields omitted ...

        /// Collected receipts. Used to verify that all of the rules
        /// were followed and `TransferRequest` can be confirmed.
        receipts: VecSet<TypeName>
    }

    // ... skipped ...

    struct TransferPolicy<phantom T> has key, store {
        // ... other fields omitted ...

        /// Set of types of attached rules - used to verify `receipts` when
        /// a `TransferRequest` is received in `confirm_request` function.
        ///
        /// Additionally provides a way to look up currently attached rules.
        rules: VecSet<TypeName>
    }

    // ...
}
```

## Witness policy

There are two ways to authorize an action: 

1. Static, by using a witness pattern.
1. Dynamic, via a capability pattern. 


Adding type parameters lets you create a generic rule that varies not just by configuration, but also by its type.

```
module examples::witness_rule {
    // skipping dependencies

    /// Rule is either not set or the witness does not match the expectation
    const ERuleNotSet: u64 = 0;

    /// This rule requires a witness of type W, see the implementation
    struct Rule<phantom W> has drop {}
    struct Config has store, drop {}

    /// No special arguments are required to set this rule, but the
    /// publisher now needs to specify a witness type
    public fun add<T, W>(/* .... */) {
        policy::add_rule(Rule<W> {}, policy, cap, Config {})
    }

    /// To confirm the action, buyer needs to pass in a witness
    /// which should be acquired either by calling some function or
    /// integrated into a more specific hook of a marketplace /
    /// trading module
    public fun confirm<T, W>(
        _: W,
        policy: &TransferPolicy<T>,
        request: &mut TransferRequest<T>
    ) {
        assert!(policy::has_rule<T, Rule<W>>(policy), ERuleNotSet);
        policy::add_receipt(Rule<W> {}, request)
    }
}
```

The `witness_rule` is generic and you can use it to require a custom witness depending on the settings. It is a way to link custom marketplace or trading logic to the `TransferPolicy`. With a slight modification, the rule can be turned into a generic capability requirement for any object, even a `TransferPolicy` for a different type or a `TransferRequest`. 

```
module examples::capability_rule {
    // skipping dependencies

    /// Changing the type parameter name for better readability
    struct Rule<phantom Cap> has drop {}
    struct Config {}

    /// Absolutely identical to the witness setting
    public fun add<T, Cap>(/* ... */) {
        policy::add_rule(Rule<Cap> {}, policy, cap, Config {})
    }

    /// Almost the same with the witness requirement, only now we
    /// require a reference to the type.
    public fun confirm<T, Cap>(
        cap: &Cap,
        /* ... */
    ) {
        assert!(policy::has_rule<T, Rule<Cap>>(policy), ERuleNotSet);
        policy::add_receipt(Rule<Cap> {}, request)
    }
}
```

## Using multiple transfer policies

You can create multiple policies for different purposes. For example, a default VAT policy requires everyone to use it. However, travelers leaving the country can claim a VAT refund without altering the default policy.

To achieve this, you can issue a second `TransferPolicy` for the same type and wrap it in a custom object to implement the logic. For instance, a `TaxFreePolicy` object can bypass VAT. This object stores another `TransferPolicy`, accessible only if the buyer presents a valid `Passport` object. The inner policy might contain no rules, so the buyer pays no fees.
>>>> sui/docs/content/concepts/transfers/transfer-to-object.mdx
---
title: Transfer to Object
description: On Sui, you can transfer objects to objects in the same way you can transfer objects to addresses.
---

You can transfer objects to an object ID in the same way you transfer objects to an address, using the same functions. This is because Sui does not distinguish between the 32-byte ID of an address and the 32-byte ID of an object (which are guaranteed not to overlap). The transfer to object operation takes advantage of this feature, allowing you to provide an object ID as the address input of a transfer operation.

:::note

The Transfer to Object mechanism is not supported for [Party Objects](../object-ownership/party.mdx) whose owning address corresponds to an object ID.

:::

Because of the identical ID structure, you can use an object ID for the address field when transferring an object. In fact, all functionality around address-owned objects works the same for objects owned by other objects, you just replace the address with the object ID.

When you transfer an object to another object, you're basically establishing a form of parent-child authentication relationship. Objects that you have transferred to another object can be received by the (possibly transitive) owner of the parent object. The module that defines the type of the parent (receiving) object also defines the access control for receiving a child object.

These restrictions for accessing sent child objects are enforced dynamically by providing mutable access to the parent object's `UID` during the execution of the transaction. Because of this, you can transfer objects to and receive them from owned objects, dynamic field objects, wrapped objects, and shared objects.

One of the benefits of the transfer to object operation is the ability to have a stable ID for an on-chain wallet or account, for example. The transfer of the object doesn't affect its ID, regardless of the state of the object that you send it to. When you transfer an object, all of that object's child objects move with it, and the object's address remains the same whether you transfer it, wrap it, or hold it as a dynamic field.

## Transferring to object

Just like with normal object transfers, you must make sure that the object ID exists that you are transferring the object to. Additionally, make sure that the object that you are transferring to is not immutable. You can't access an object transferred to an immutable object.

Be aware of both the type of the object you are transferring to and the object that is being transferred. The object that is transferred to (parent) can _always_:

- Define predicates that can be dynamically checked to access the sent object.
- Lack support for accessing objects that have been sent to it. Future versions of that package might support this functionality, but it's up to the package author to include it.

If the object being transferred has the `key` ability only, then:

- The module that defines the object that is being transferred must implement a custom receive function for it, similar to custom transfer functions. Just as with custom transfer functions, a custom receivership function might have arbitrary restrictions they can enforce and that you should be aware of, or they may not exist.
- After sending, you can't access or use the object unless the parent object's (object being sent to) module has defined a function to receive objects _and_ the child object's (object you're sending) module has defined a function to receive the object, and the restrictions that _both_ functions define are met.

```move
// 0xADD is an address
// 0x0B is an object ID
// b and c are objects

// Transfers the object `b` to the address 0xADD
transfer::public_transfer(b, @0xADD);

// Transfers the object `c` to the object with object ID 0x0B
transfer::public_transfer(c, @0x0B);
```

Transferring an object to an object ID results in the same result as if you transferred the object to an address - the object's owner is the 32-byte address or object ID provided. Additionally, because there is no difference in the result of the object transfer, you can use existing RPC methods such as `getOwnedObjects` on the 32-byte ID. If the ID represents an address, then the method returns the objects owned by that address. If the ID is an object ID, then the method returns the objects the object ID owns (transferred objects).

```json
// Get the objects owned by the address 0xADD. Returns `b`.
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_getOwnedObjects",
  "params": [
    "0xADD"
  ]
}

// Get the objects owned by the object with object ID 0x0B. Returns `c`
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_getOwnedObjects",
  "params": [
    "0x0B"
  ]
}
```

## Receiving objects

After an object `c` has been sent to another object `p`, `p` must then receive `c` to do anything with it. To receive the object `c`, a `Receiving(o: ObjectRef)` argument type for programmable transaction blocks (PTBs) is used that takes an object reference containing the to-be-received object's `ObjectID`, `Version`, and `Digest` (just as owned object arguments for PTBs do). However, `Receiving` PTB arguments are not passed as an owned value or mutable reference within the transaction.

To explain further, look at the core of the receiving interface in Move, which is defined in the `transfer` module in the Sui framework:

```move
module sui::transfer;

/// Represents the ability to receive an object of type `T`. Cannot be stored.
public struct Receiving<phantom T: key> has drop { ... }

/// Given mutable (i.e., locked) access to the `parent` and a `Receiving`
/// object referencing an object owned by `parent` use the `Receiving` ticket
/// and return the corresponding object.
///
/// This function has custom rules that the Sui Move bytecode verifier enforces to ensure
/// that `T` is an object defined in the module where `receive` is invoked. Use
/// `public_receive` to receive an object with `store` outside of its defining module.
///
/// NB: &mut UID here allows the defining module of the parent type to
/// define custom access/permission policies around receiving objects sent
/// to objects of a type that it defines. You can see this more in the examples.
public native fun receive<T: key>(parent: &mut UID, object: Receiving<T>): T;

/// Given mutable (locked) access to the `parent` and a `Receiving` argument
/// referencing an object of type `T` owned by `parent` use the `object`
/// argument to receive and return the referenced owned object of type `T`.
/// The object `T` must have `store` to be received by this function, and
/// this can be called outside of the module that defines `T`.
public native fun public_receive<T: key + store>(parent: &mut UID, object: Receiving<T>): T;

...
```

Each Receiving argument referring to a sent object of type `T` in a PTB results in exactly one argument with a Move type of `sui::transfer::Receiving<T>`. You can then use this argument to receive the sent object of type `T` with the `transfer::receive` function.

When you call the `transfer::receive` function, you must pass a mutable reference to the parent object's `UID`. You can't get a mutable reference to the `UID` of an object, though, unless the defining module of the object exposes it. Consequently, the module that defines the type of the parent object that is receiving the child object defines access control policies and other restrictions on receiving objects that are sent to it. See the [authorization example](#receive-shared-example) for a demonstration of this pattern. The fact that the passed-in `UID` actually owns the object referenced by the `Receiving` parameter is dynamically checked and enforced. This allows access to objects that have been sent to, for example, dynamic fields where the ownership chain can only be established dynamically.

Because `sui::transfer::Receiving` has only the `drop` ability, the existence of a `Receiving<T>` argument represents the ability, but not the obligation to receive the object of type `T` specified by the object reference in the PTB `Receiving` argument during that transaction. You can use some, none, or all `Receiving` arguments in a PTB without issue. Any object that corresponds to a `Receiving` argument remains untouched (in particular, its object reference remain the same) unless it is received.

## Custom receiving rules

Just like with [custom transfer policies](./custom-rules.mdx), Sui allows for the definition of custom receivership rules for `key`-only objects. In particular, you can use the `transfer::receive` function only on objects defined in the same module as the call to `transfer::receive`--just like you can use the `transfer::transfer` function only on objects defined in the module where it's being used.

Similarly for objects that also have the `store` ability, anyone can use the `transfer::public_receive` function to receive them--just like `transfer::public_transfer` can transfer any objects that have the `store` ability on them.

This coupled with the fact that the parent object can always define custom rules around receivership means that you must consider the following matrix of permissions around receiving objects and the abilities of the object being sent based on the child object's abilities:

| Child abilities | Parent can restrict access | Child can restrict access |
| --------------- | -------------------------- | ------------------------- |
| `key`           | Yes                        | Yes                       |
| `key` + `store` | Yes                        | No                        |

Just like with custom transfer policies, you can use and couple these restrictions to create powerful expressions. For example, you can implement [soul-bound objects](#soul-bound-example) using both custom transfer and receivership rules.

## Using SDKs

When creating transactions, you interact with `Receiving` transaction inputs almost exactly as you would with other object arguments in the Sui TypeScript SDK. For example, if in the [Simple Account](#simple-account) example that follows you want to send a transaction that receives a coin object with ID `0xc0ffee` that was sent to your account at `0xcafe`, you can do the following using either the Sui TypeScript SDK or Sui Rust SDK:

<Tabs groupId="code-language">

<TabItem label="TypeScript" value="typescript">

```ts
... // Setup TypeScript SDK as normal.
const tx = new Transaction();
tx.moveCall({
  target: `${examplePackageId}::account::accept_payment`,
  arguments: [tx.object("0xcafe"), tx.object("0xc0ffee")]
});
const result = await client.signAndExecuteTransaction({
      transaction: tx,
  });
...
```

</TabItem>

<TabItem label="Rust" value="rust">

```rust
... // setup Rust SDK client as normal
client
  .transaction_builder()
  .move_call(
     sending_account,
     example_package_id,
     "account",
     "accept_payment",
     vec!["0x2::sui::SUI"],
     vec![
       SuiJsonValue::from_object_id("0xcafe"),
       SuiJsonValue::from_object_id("0xc0ffee") // 0xcoffee is turned into the `Receiving<...>` argument of `accept_payment` by the SDK
     ])
  ...
```

</TabItem>

</Tabs>

Additionally, just as with object arguments that also have an `ObjectRef` constructor where you can provide an explicit object ID, version, and digest, there is also a `ReceivingRef` constructor that takes the same arguments corresponding to a receiving argument.

## Examples

The following examples demonstrate receiving previously sent objects.

### Receiving objects from shared objects {#receive-shared-example}

Generally, if you want to allow receiving sent objects from shared objects that are defined in the module, add dynamic authorization checks; otherwise, anyone could receive sent objects. In this example, a shared object (`SharedObject`) holds a counter that anyone can increment, but only the address `0xB0B` can receive objects from the shared object.

Because the `receive_object` function is generic over the object being received, it can only receive objects that are both `key` and `store`. `receive_object` must also use the `transfer::public_receive` function to receive the object and not `transfer::receive` because you can only use `receive` on objects defined in the current module.

```move
module examples::shared_object_auth;

use transfer::Receiving;

const EAccessDenied: u64 = 0;
const AuthorizedReceiverAddr: address = @0xB0B;

public struct SharedObject has key {
    id: UID,
    counter: u64,
}

public fun create(ctx: &mut TxContext) {
    let s = SharedObject {
        id: object::new(ctx),
        counter: 0,
    };
    transfer::share_object(s);
}

/// Anyone can increment the counter in the shared object.
public fun increment(obj: &mut SharedObject) {
    obj.counter = obj.counter + 1;
}

/// Objects can only be received from the `SharedObject` by the
/// `AuthorizedReceiverAddr` otherwise the transaction aborts.
public fun receive_object<T: key + store>(
    obj: &mut SharedObject,
    sent: Receiving<T>,
    ctx: &TxContext
): T {
    assert!(ctx.sender() == AuthorizedReceiverAddr, EAccessDenied);
    transfer::public_receive(&mut obj.id, sent)
}
```

### Receiving objects and adding them as dynamic fields {#simple-account}

This example defines a basic account-type model where an `Account` object holds its coin balances in different dynamic fields. This `Account` is also transferable to a different address or object.

Importantly, the address that coins are to be sent with this `Account` object remains the same regardless of whether the `Account` object is transferred, wrapped (for example, in an escrow account), or moved into a dynamic field. In particular, there is a stable ID for a given `Account` object across the object's lifecycle, regardless of any ownership changes.

```move
module examples::account;

use sui::dynamic_field as df;
use sui::coin::{Self, Coin};
use transfer::Receiving;

const EBalanceDONE: u64 = 1;

/// Account object that `Coin`s can be sent to. Balances of different types
/// are held as dynamic fields indexed by the `Coin` type's `type_name`.
public struct Account has key {
    id: UID,
}

/// Dynamic field key representing a balance of a particular coin type.
public struct AccountBalance<phantom T> has copy, drop, store { }

/// This function will receive a coin sent to the `Account` object and then
/// join it to the balance for each coin type.
/// Dynamic fields are used to index the balances by their coin type.
public fun accept_payment<T>(account: &mut Account, sent: Receiving<Coin<T>>) {
    // Receive the coin that was sent to the `account` object
    // Since `Coin` is not defined in this module, and since it has the `store`
    // ability we receive the coin object using the `transfer::public_receive` function.
    let coin = transfer::public_receive(&mut account.id, sent);
    let account_balance_type = AccountBalance<T>{};
    let account_uid = &mut account.id;

    // Check if a balance of that coin type already exists.
    // If it does then merge the coin we just received into it,
    // otherwise create new balance.
    if (df::exists_(account_uid, account_balance_type)) {
        let balance: &mut Coin<T> = df::borrow_mut(account_uid, account_balance_type);
        balance.join(coin);
    } else {
        df::add(account_uid, account_balance_type, coin);
    }
}

/// Withdraw `amount` of coins of type `T` from `account`.
public fun withdraw<T>(account: &mut Account, amount: u64, ctx: &mut TxContext): Coin<T> {
    let account_balance_type = AccountBalance<T>{};
    let account_uid = &mut account.id;
    // Make sure what we are withdrawing exists
    assert!(df::exists_(account_uid, account_balance_type), EBalanceDONE);
    let balance: &mut Coin<T> = df::borrow_mut(account_uid, account_balance_type);
    balance.split(amount, ctx)
}

/// Can transfer this account to a different address
/// (e.g., to an object or address).
public fun transfer_account(account: Account, to: address, _ctx: &mut TxContext) {
    // Perform some authorization checks here and if they pass then transfer the account
    // ...
    transfer::transfer(account, to);
}
```

### Soul-bound objects {#soul-bound-example}

The ability to control the rules about how and when an object can be received, and how and when it can be transferred allows us to define a type of _soul-bound_ object that can be used by value in a transaction, but it must always stay in the same place, or be returned to the same object.

You can implement a simple version of this with the following module where the `get_object` function receives the soul-bound object and creates a receipt that must be destroyed in the transaction in order for it to execute successfully. However, in order to destroy the receipt, the object that was received must be transferred back to the object it was received from in the transaction using the `return_object` function.

```move
module examples::soul_bound;

use transfer::{Self, Receiving};

/// Tried to return the wrong object.
const EWrongObject: u64 = 0;

/// This object has `key` only  -- if this had `store` we would not be
/// able to ensure it is bound to whatever address we sent it to
public struct SoulBound has key {
    id: UID,
}

/// A non-store, non-drop, non-copy struct. When you receive a `SoulBound`
/// object, we'll also give you one of these. In order to successfully
/// execute the transaction you need to destroy this `ReturnReceipt` and
/// the only way to do that is to transfer it back to the same object you
/// received it from in the transaction using the `return_object` function.
public struct ReturnReceipt {
    /// The object ID of the object that needs to be returned.
    /// This field is required to prevent swapping of soul bound objects if
    /// multiple are present in the same transaction.
    object_id: ID,
    /// The address (object ID) it needs to be returned to.
    return_to: address,
}

/// Takes the object UID that owns the `SoulBound` object and a `SoulBound`
/// receiving ticket. It then receives the `SoulBound` object and returns a
/// `ReturnReceipt` that must be destroyed in the transaction by calling `return_object`.
public fun get_object(parent: &mut UID, soul_bound_ticket: Receiving<SoulBound>): (SoulBound, ReturnReceipt) {
    let soul_bound = transfer::receive(parent, soul_bound_ticket);
    let return_receipt = ReturnReceipt {
        return_to: parent.to_address(),
        object_id: object::id(&soul_bound),
    };
    (soul_bound, return_receipt)
}

/// Given a `SoulBound` object and a return receipt returns it to the
/// object it was received from. Verifies that the `receipt`
/// is for the given `soul_bound` object before returning it.
public fun return_object(soul_bound: SoulBound, receipt: ReturnReceipt) {
    let ReturnReceipt { return_to, object_id }  = receipt;
    assert!(object::id(&soul_bound) == object_id, EWrongObject);
    transfer::transfer(soul_bound, return_to);
}
```

>>>> sui/docs/content/concepts/versioning.mdx
---
title: Object and Package Versioning
description: Versioning provides the ability to upgrade packages and objects on the Sui network.
keywords: [ object versioning, object versions, versioning objects, package versioning, package versions, versioning packages ]
---

You reference every object stored on chain by an ID and version. When a transaction modifies an object, it writes the new contents to an on-chain reference with the same ID but a later version. This means that a single object (with ID `I`) might appear in multiple entries in the distributed store:

```
(I, v0) => ...
(I, v1) => ...  # v0 < v1
(I, v2) => ...  # v1 < v2
```

Despite appearing multiple times in the store, only one version of the object is available to transactions - the latest version (v2 in the previous example). Moreover, only one transaction can modify the object at that version to create a new version, guaranteeing a linear history (`v1` was created in a state where `I` was at `v0`, and `v2` was created in a state where `I` was at `v1`).

Versions are strictly increasing and (ID, version) pairs are never re-used. This structure allows node operators to prune their stores of old object versions that are now inaccessible, if they choose. This is not a requirement, though, as node operators might keep prior object versions around to serve requests for an object's history, either from other nodes that are catching up, or from RPC requests.

## Move objects

Sui uses [Lamport timestamps](https://en.wikipedia.org/wiki/Lamport_timestamp) in its versioning algorithm for objects. The use of Lamport timestamps guarantees that versions never get re-used as the new version for objects touched by a transaction is one greater than the latest version among all input objects to the transaction. For example, a transaction transferring an object `O` at version 5 using a gas object `G` at version 3 updates both `O` and `G` versions to `1 + max(5, 3) = 6` (version 6).

The following sections detail the relevance of Lamport versions for maintaining the "no (ID, version) re-use" invariant or for accessing an object as a transaction input changes depending on that object's ownership.

### Address-owned objects

You must reference address-owned transaction inputs at a specific ID and version. When a validator signs a transaction with an owned object input at a specific version, that version of the object is locked to that transaction. Validators reject requests to sign other transactions that require the same input (same ID and version).

If `F + 1` validators sign one transaction that takes an object as input, and a different `F + 1` validators sign a different transaction that takes the same object as input, that object (and all the other inputs to both transactions) is equivocated, meaning they cannot be used for any further transactions in that epoch. This is because neither transaction can form a quorum without relying on a signature from a validator that has already committed the object to a different transaction, which it cannot get. All locks are reset at the end of the epoch, which frees the objects again.

:::info

Only an object's owner can equivocate it, but this is not a desirable thing to do. You can avoid equivocation by carefully managing the versions of address-owned input objects: never attempt to execute two different transactions that use the same object. If you don't get a definite success or failure response from the network for a transaction, assume that the transaction might have gone through, and do not re-use any of its objects for different transactions.

:::

### Immutable objects

Like address-owned objects, you reference immutable objects at an ID and version, but they do not need to be locked as their contents and versions do not change. Their version is relevant because they could have started life as an address-owned object before being frozen. The given version identifies the point at which they became immutable.

### Shared objects

Specifying a shared transaction input is slightly more complex. You reference it by its ID, the version it was shared at, and a flag indicating whether it is accessed mutably. You don't specify the precise version the transaction accesses because consensus decides that during transaction scheduling. When scheduling multiple transactions that touch the same shared object, validators agree the order of those transactions, and pick each transaction's input versions for the shared object accordingly (one transaction's output version becomes the next transaction's input version, and so on).

Shared transaction inputs that you reference immutably participate in scheduling, but don't modify the object or increment its version.

### Wrapped objects

You can't access wrapped objects by their ID in the object store, you must access them by the object that wraps them. Consider the following example that creates a `make_wrapped` function with an `Inner` object, wrapped in an `Outer` object, which is returned to the transaction sender.

```move
module example::wrapped {
    use sui::object::{Self, UID};
    use sui::transfer;
    use sui::tx_context::{Self, TxContext};

    struct Inner has key, store {
        id: UID,
        x: u64,
    }

    struct Outer has key {
        id: UID,
        inner: Inner,
    }

    entry fun make_wrapped(ctx: &mut TxContext) {
        let inner = Inner {
            id: object::new(ctx),
            x: 42,
        };

        let outer = Outer {
            id: object::new(ctx),
            inner,
        };

        transfer::transfer(outer, tx_context::sender(ctx));
    }
}
```

The owner of `Outer` in this example must specify it as the transaction input and then access its `inner` field to read the instance of `Inner`. Validators refuse to sign transactions that directly specify wrapped objects (like the `inner` of an `Outer`) as inputs. As a result, you don't need to specify a wrapped object's version in a transaction that reads that object.

Wrapped objects can eventually become unwrapped, meaning that they are once again accessible at their ID:

```move
module example::wrapped {
    // ...

    entry fun unwrap(outer: Outer, ctx: &TxContext) {
        let Outer { id, inner } = outer;
        object::delete(id);
        transfer::transfer(inner, tx_context::sender(ctx));
    }
}
```

The `unwrap` function in the previous code takes an instance of `Outer`, destroys it, and sends the `Inner` back to the sender. After calling this function, the previous owner of `Outer` can access `Inner` directly by its ID because it is now unwrapped. Wrapping and unwrapping of an object can happen multiple times across its lifespan, and the object retains its ID across all those events.

The Lamport timestamp-based versioning scheme ensures that the version that an object is unwrapped at is always greater than the version it was wrapped at, to prevent version re-use.

- After a transaction, `W`, where object `I` is wrapped by object `O`, the `O` version is greater than or equal to the `I` version. This means one of the following conditions is true:
    - `I` is an input so has a strictly lower version.
    - `I` is new and has an equal version.
- After a later transaction unwrapping `I` out of `O`, the following must be true:
    - The `O` input version is greater than or equal to its version after `W` because it is a later transaction, so the version can only have increased.
    - The `I` version in the output must be strictly greater than the `O` input version.

This leads to the following chain of inequalities for I's version before wrapping:

- less than or equal to O's version after wrapping
- less than or equal to O's version before unwrapping
- less than I's version after unwrapping

So the `I` version before wrapping is less than the `I` version after unwrapping.

### Dynamic fields

From a versioning perspective, values held in dynamic fields behave like wrapped objects:

- They are only accessible via the field's parent object, not as direct transaction inputs.
- Based on the previous point, you do not need to supply their IDs or versions with the transaction inputs.
- Lamport timestamp-based versioning makes sure that when a field contains an object and a transaction removes that field, its value becomes accessible by its ID and the value's version has been incremented to a previously unused version.

:::info

One distinction dynamic fields have to wrapped objects is that if a transaction modifies a dynamic object field, its version is incremented in that transaction, where a wrapped object's version would not be.

:::

Adding a new dynamic field to a parent object also creates a `Field` object, responsible for associating the field name and value with that parent. Unlike other newly created objects, the ID for the resulting instance of `Field` is not created using `sui::object::new`. Instead, it is computed as a hash of the parent object ID and the type and value of the field name, so that you can use it to look-up the `Field` via its parent and name.

When you remove a field, Sui deletes its associated `Field`, and if you add a new field with the same name, Sui creates a new instance with the same ID. Versioning using Lamport timestamps, coupled with dynamic fields being only accessible through their parent object, ensures that (ID, version) pairs are not reused in the process:

- The transaction that deletes the original field increments the parent's version to be greater than the deleted field's version.
- The transaction that creates the new version of the same field creates the field with a version that is greater than the parent's version.

So the version of the new `Field` instance is greater than the version of the deleted `Field`.

## Packages

Move packages are also versioned and stored on chain, but follow a different versioning scheme to objects because they are immutable from their inception. This means that you refer to package transaction inputs (for example, the package that a function is from for a Move call transaction) by just their ID, and are always loaded at their latest version.

### User packages

Every time you publish or upgrade a package, Sui generates a new ID. A newly published package has its version set to 1, whereas an upgraded package's version is one greater than the package it is upgrading. Unlike objects, older versions of a package remain accessible even after being upgraded. For example, imagine a package `P` that is published and upgraded twice. It might be represented in the store as:

```
(0x17fb7f87e48622257725f584949beac81539a3f4ff864317ad90357c37d82605, 1) => P v1
(0x260f6eeb866c61ab5659f4a89bc0704dd4c51a573c4f4627e40c5bb93d4d500e, 2) => P v2
(0xd24cc3ec3e2877f085bc756337bf73ae6976c38c3d93a0dbaf8004505de980ef, 3) => P v3
```

In this example, all three versions of the same package are at different IDs. The packages have increasing versions but it is possible to call into `v1`, even though `v2` and `v3` exist on chain.

### Framework packages

Framework packages (such as the Move standard library at `0x1`,the Sui Framework at `0x2`, Sui System at `0x3` and Deepbook at `0xdee9`) are a special-case because their IDs must remain stable across upgrades. The network can upgrade framework packages while preserving their IDs via a system transaction, but can only perform this operation on epoch boundaries because they are considered immutable like other packages. New versions of framework packages retain the same ID as their predecessor, but increment their version by one:

```
(0x1, 1) => MoveStdlib v1
(0x1, 2) => MoveStdlib v2
(0x1, 3) => MoveStdlib v3
```

The prior example shows the on-chain representation of the first three versions of the Move standard library.

### Package versions

Sui smart contracts are organized into upgradeable packages and, as a result, multiple versions of any given package can exist on chain. Before someone can use an on-chain package, you must publish its first, original version. When you upgrade a package, you create a new version of that package. Each upgrade of a package is based on the immediately preceding version of that package in the versions history. In other words, you can upgrade the `nth` version of a package from only the `nth - 1` version. For example, you can upgrade a package from version 1 to 2, but afterwards you can upgrade that package only from version 2 to 3; you're not allowed to upgrade from version 1 to 3.

There is a notion of versioning in package manifest files, existing in both the package section and in the dependencies section. For example, consider the manifest code that follows:

```toml
[package]
name = "some_pkg"
version = "1.0.0"

[dependencies]
another_pkg = { git = "https://github.com/another_pkg/another_pkg.git" , version = "2.0.0"}
```

At this point, the version references in the manifest are used only for user-level documentation as the `publish` and `upgrade` commands do not leverage this information. If you publish a package with a certain package version in the manifest file and then modify and re-publish the same package with a different version (using `publish` command rather than `upgrade` command), the two are considered different packages, rather than on-chain versions of the same package. You cannot use any of these packages as a dependency override to stand in for the other one. While you can specify this type of override when building a package, it results in an error when publishing or upgrading on chain.

>>>> sui/docs/content/guides.mdx
---
title: Guides and Tutorials
sidebar_label: Overview
description: Start developing on Sui through example projects and developer guides.
keywords: [ developer guides, get started, operator guides, suiplayx01 guides, sui 101, coins, tokens, nfts ]
---

This section provides practical, implementation-focused examples designed to accelerate your journey developing on Sui. 

Whether you are new to blockchain development or an experienced Sui developer, these resources offer structured guidance for building applications, creating assets, and leveraging Sui's unique technical features effectively.

## Get started developing on Sui

Install tooling, setup your environment, and deploy a "Hello, World!" Move package to start your Sui developer experience. 

<Cards>
<Card className="plausible-event-name=guides+install+button" title="1. Install Sui" href="/guides/developer/getting-started/sui-install" />
<Card className="plausible-event-name=guides+client+button" title="2. Configure a Sui Client" href="/guides/developer/getting-started/configure-sui-client" />
<Card className="plausible-event-name=guides+address+button" title="3. Create a Sui Address" href="/guides/developer/getting-started/get-address" />
<Card className="plausible-event-name=guides+faucet+button" title="4. Get SUI from Faucet" href="/guides/developer/getting-started/get-coins" />
<Card className="plausible-event-name=guides+hello+button" title="5. Hello, World!" href="/guides/developer/getting-started/hello-world" />
<Card className="plausible-event-name=guides+next+button" title="6. Next Steps" href="/guides/developer/getting-started/next-steps" />
</Cards>

## Sui essentials

Follow these guides to learn about essential Sui concepts.

<Cards>
<Card title="Object Ownership" href="/guides/developer/sui-101/object-ownership" />
<Card title="Using Events" href="/guides/developer/sui-101/using-events" />
<Card title="Access Sui Data" href="/guides/developer/sui-101/data-serving" />
<Card title="Access On-Chain Time" href="/guides/developer/sui-101/access-time" />
</Cards>

## Signing and sending transactions 

Learn about signing and sending transactions.

<Cards>
<Card title="Sponsored Transactions" href="/guides/developer/sui-101/sponsor-txn" />
<Card title="Avoid Equivocation" href="/guides/developer/sui-101/avoid-equivocation" />
<Card title="Building PTBs" href="/guides/developer/sui-101/building-ptb" />
<Card title="Coin Management" href="/guides/developer/sui-101/coin-mgt" />
<Card title="Simulating References" href="/guides/developer/sui-101/simulating-refs" />
</Cards>

## Coins, tokens, and NFTs

Learn how to mint coins and tokens on Sui.

<Cards>
<Card title="Create Currencies and Tokens" href="/guides/developer/currency" />
<Card title="Regulated Currency and Deny List" href="/guides/developer/coin/regulated" />
<Card title="In-Game Currency" href="/guides/developer/coin/in-game-token" />
<Card title="Loyalty Token" href="/guides/developer/coin/loyalty" />
<Card title="Create an NFT" href="/guides/developer/nft" />
<Card title="Soulbound NFT" href="/guides/developer/nft/nft-soulbound" />
<Card title="NFT Rental Example" href="/guides/developer/nft/nft-rental" />
<Card title="Asset Tokenization" href="/guides/developer/nft/asset-tokenization" />
</Cards>

## Cryptography 

Learn about on-chain signatures, multisig authentication, and zkLogin.

<Cards>
<Card title="Sui On-Chain Signatures Verification in Move" href="/guides/developer/cryptography/signing" />
<Card title="Groth16" href="/guides/developer/cryptography/groth16" />
<Card title="Hashing" href="/guides/developer/cryptography/hashing" />
<Card title="ECVRF" href="/guides/developer/cryptography/ecvrf" />
<Card title="Multisig Authentication" href="/guides/developer/cryptography/multisig" />
<Card title="Configure OpenID Providers" href="/guides/developer/cryptography/zklogin-integration/developer-account" />
<Card title="zkLogin Example" href="/guides/developer/cryptography/zklogin-integration/zklogin-example" />
</Cards>

## Indexers 

Build your own custom indexer, integrate it with your application, and benchmark its performance.

<Cards>
<Card title="Build Your First Custom Indexer" href="/guides/developer/advanced/custom-indexer/build" />
<Card title="Custom Indexer and Walrus" href="/guides/developer/advanced/custom-indexer/indexer-walrus" />
<Card title="Indexer Data and Integration" href="/guides/developer/advanced/custom-indexer/indexer-data-integration" />
<Card title="Indexer Runtime and Performance" href="/guides/developer/advanced/custom-indexer/indexer-runtime-perf" />
</Cards>

## Example applications 

Try out these example applications to learn more about Sui.

<Cards>
<Card title="End-to-End Counter" href="/guides/developer/app-examples/e2e-counter" />
<Card title="Trustless Swap" href="/guides/developer/app-examples/trustless-swap" />
<Card title="Coin Flip" href="/guides/developer/app-examples/coin-flip" />
<Card title="Review Rating" href="/guides/developer/app-examples/reviews-rating" />
<Card title="Blackjack" href="/guides/developer/app-examples/blackjack" />
<Card title="Plinko" href="/guides/developer/app-examples/plinko" />
<Card title="Tic-Tac-Toe" href="/guides/developer/app-examples/tic-tac-toe" />
<Card title="Weather oracle" href="/guides/developer/app-examples/weather-oracle" />
</Cards>

## Validating and operating nodes on Sui

Processes and guides for validators and node operators on the Sui network.

<Cards>
<Card title="Validator Configuration" href="/guides/operator/validator/validator-config" />
<Card title="Run a Sui Full Node" href="/guides/operator/sui-full-node" />
<Card title="Full Node Data Management" href="/guides/operator/data-management"/>
<Card title="Sui Bridge Node Configuration" href="/guides/operator/bridge-node-configuration" />
</Cards>

>>>> sui/docs/content/guides/developer/advanced.mdx
---
title: Advanced Topics
description: Advanced topics include coding practices, useful features, and other developer-focused considerations that might arise as you continue your development journey on Sui.
keywords: [ advanced, advanced topics, custom indexer, custom indexing, graphql, using graphql, migrating to graphql ]
pagination_prev: null
---

Information in the Advanced Topics section covers coding practices, useful features, and other developer-focused considerations that might arise as you continue your development journey on Sui. The topics in this section aren't necessarily more difficult than other topics, but they include subjects you might not encounter or need to consider until you're developing more advanced solutions on the Sui network.

<Cards>
<Card title="Migrating to Move 2024" href="/guides/developer/advanced/move-2024-migration"/>
<Card title="Custom Indexer" href="/guides/developer/advanced/custom-indexer"/>
<Card title="On-Chain Randomness" href="/guides/developer/advanced/randomness-onchain"/>
<Card title="Querying Sui RPC with GraphQL" href="/guides/developer/advanced/graphql-rpc"/>
<Card title="Object-Based Local Fee Markets" href="/guides/developer/advanced/local-fee-markets"/>
</Cards>

>>>> sui/docs/content/guides/developer/advanced/custom-indexer.mdx
---
title: Custom Indexer
description: Establishing a custom indexer helps improve latency, allows pruning the data of your Sui full node, and provides efficient assemblage of checkpoint data.
keywords: [ indexer, custom indexer, indexer framework, indexer pipeline ]
---

Establishing a custom indexer helps improve latency, allows pruning the data of your Sui full node, and provides efficient assemblage of checkpoint data.

<Cards>
<Card title="Build Your First Custom Indexer" href="/guides/developer/advanced/custom-indexer/build"/>
<Card title="Custom Indexer and Walrus" href="/guides/developer/advanced/custom-indexer/indexer-walrus"/>
<Card title="Indexer Data and Integration" href="/guides/developer/advanced/custom-indexer/indexer-data-integration"/>
<Card title="Indexer Runtime and Performance" href="/guides/developer/advanced/custom-indexer/indexer-runtime-perf"/>
</Cards>

>>>> sui/docs/content/guides/developer/advanced/custom-indexer/build.mdx
---
title: Build Your First Custom Indexer
description: Build a custom indexer using the `sui-indexer-alt-framework` module. The example indexer demonstrates a sequential pipeline that extracts transaction digests from Sui checkpoints and stores them in a local PostgreSQL.
keywords: [ indexer, custom indexer, indexer framework, indexer pipeline ]
---

:::info

Refer to [Custom Indexing Framework](/concepts/custom-indexing-framework.mdx) and [Indexer Pipeline Architecture](/concepts/custom-indexer/pipeline-architecture.mdx) for a conceptual overview of the indexer framework.

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::

To build a complete custom indexer, you use the `sui-indexer-alt-framework`. The steps that follow demonstrate how to create a sequential pipeline that extracts transaction digests from Sui checkpoints and stores them in a local PostgreSQL. You can find the [source code for the framework](https://github.com/MystenLabs/sui/tree/main/crates/sui-indexer-alt-framework) in the Sui repo on GitHub.

:::tip

While this example uses PostgreSQL with [Diesel](https://diesel.rs/guides/getting-started) (a popular Rust ORM and query builder) for minimalism and out-of-the-box support, the `sui-indexer-alt-framework` is designed for flexible storage. You can use different databases (such as [MongoDB](https://www.mongodb.com/), [CouchDB](https://couchdb.apache.org/), or similar) or utilize other database clients if you prefer not to use Diesel. To achieve this, implement the framework's `Store` and `Connection` traits and define your database write logic directly within your `Handler::commit()` method.

:::

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Rust and Cargo](https://rustup.rs/)
- [x] [PostgreSQL](https://www.postgresql.org/download/)
- [x] [Diesel CLI](https://diesel.rs/guides/getting-started#installing-diesel-cli)

<details className="nudge-details">

<summary>

Check installation

</summary>

If you're unsure whether your system has the necessary software properly installed, you can verify installation with the following commands.

```sh
$ psql --version
$ diesel --version
```

</details>

- [x] Read the [Custom Indexing Framework](/concepts/custom-indexing-framework.mdx) and [Indexer Pipeline Architecture](/concepts/custom-indexer/pipeline-architecture.mdx) topics first to understand the overall architecture and concurrent pipeline concepts.

</TabItem>
</Tabs>

## What you build

The following steps show how to create an indexer that:

- Connects to Sui Testnet: Uses the remote checkpoint store at https://checkpoints.testnet.sui.io.
- Processes checkpoints: Streams checkpoint data continuously.
- Extracts transaction data: Pulls transaction digests from each checkpoint.
- Stores in local PostgreSQL: Commits data to a local PostgreSQL database.
- Implements sequential pipeline: Uses in-order processing with batching for optimal consistency and performance.

In the end, you have a working indexer that demonstrates all core framework concepts and can serve as a foundation for more complex custom indexers.

:::info

Sui provides checkpoint stores for both Mainnet and Testnet.

- Testnet: `https://checkpoints.testnet.sui.io`
- Mainnet: `https://checkpoints.mainnet.sui.io`

:::

##step Project setup

First, open your console to the directory you want to store your indexer project. Use the `cargo new` command to create a new Rust project and then navigate to its directory.

```sh
$ cargo new simple-sui-indexer
$ cd simple-sui-indexer
```

##step Configure dependencies

Replace your `Cargo.toml` code with the following configuration and save.

<ImportContent source="examples/rust/basic-sui-indexer/Cargo.toml" mode="code" />

The manifest now includes the following dependencies:

- `sui-indexer-alt-framework`: Core framework providing pipeline infrastructure.
- `diesel/diesel-async`: Type-safe database ORM with asynchronous support.
- `tokio`: Async runtime required by the framework.
- `clap`: Command-line argument parsing for configuration.
- `anyhow`: Error handling and async-trait for trait implementations.
- `dotenvy`: Ingest `.env` file that stores your PostgreSQL URL.

##step Create database

Before configuring migrations, create and verify your local PostgreSQL database:

```sh
$ createdb sui_indexer
```

Get your connection details:

```sh
$ psql sui_indexer -c "\conninfo"
```

If successful, your console should display a message similar to the following:

```sh
You are connected to database "sui_indexer" as user "username" via socket in "/tmp" at port "5432".
```

If you receive a `createdb` error similar to

```sh
createdb: error: connection to server on socket "/tmp/.s.PGSQL.5432" failed: FATAL:  role "username" does not exist
```

This means you need to create the user (replace `username` with the name provided in your error message).

```sh
$ sudo -u postgres createuser --superuser username
```

Enter the password for your pgAdmin account when prompted, then try the `createdb` command again.

You can now set a variable to your database URL as it's used in following commands. Make sure to change `username` to your actual username.

```sh
$ PSQL_URL=postgres://username@localhost:5432/sui_indexer
```

You can now test your connection with the following command:

```sh
$ psql $PSQL_URL -c "SELECT 'Connected';"
```

If successful, your console or terminal should respond with a message similar to the following:

```sh
?column?
-----------
 Connected
(1 row)
```

##step Database setup

Before you start coding, make sure you set up a local PostgreSQL database from the previous step. This is required for the indexer to store the extracted transaction data.

The following database setup steps have you:

1. Create a database table to store the data.
1. Use Diesel to manage the process.
1. Generate Rust code that maps to the database table.

###substep Configure Diesel

First, create a `diesel.toml` file (within the same folder as `cargo.toml`) to configure database migrations.

```sh
$ touch diesel.toml
```

Update and save the file with the following code:

<ImportContent source="examples/rust/basic-sui-indexer/diesel.toml" mode="code" />

###substep Create database table using Diesel migrations

Diesel migrations are a way of creating and managing database tables using SQL files. Each migration has two files:

- `up.sql`: Creates and changes the table.
- `down.sql`: Removes and undoes the changes.

Use the `diesel setup` command to create the necessary directory structure, passing your database URL with the `--database-url` argument.

```sh
$ diesel setup --database-url $PSQL_URL
```

Use the `diesel migration` command at the root of your project to then generate the migration files.

```sh
$ diesel migration generate transaction_digests
```

You should now have a `migrations` folder in your project. There should be a subdirectory in this folder with the name format `YYYY-MM-DD-HHMMSS_transaction_digests`. This folder should contain the `up.sql` and `down.sql` files.

Open `up.sql` and replace its contents with the following code (using the actual folder name):

<ImportContent source="examples/rust/basic-sui-indexer/migrations/YYYY-MM-DD-HHMMSS_transaction_digests/up.sql" mode="code" />

:::tip

This example uses the `TEXT` data type for `tx_digest`, but best practice for a production indexer is to use the `BYTEA` data type.

The `TEXT` type is used to make the transaction digest easily readable and directly usable with external tools. Digests are `Base58` encoded, and because PostgreSQL cannot natively display `BYTEA` data in this format, storing it as `TEXT` allows you to copy the digest from a query and paste it into an explorer like [SuiScan](https://suiscan.xyz/testnet/home).

For a production environment, however, `BYTEA` is strongly recommended. It offers superior storage and query efficiency by storing the raw byte representation, which is more compact and significantly faster for comparisons than a string. Refer to [Binary data performance in PostgreSQL](https://www.cybertec-postgresql.com/en/binary-data-performance-in-postgresql/) on the CYBERTEC website for more information.

:::

Save `up.sql`, then open `down.sql` to edit. Replace the contents of the file with the following code and save it:

<ImportContent source="examples/rust/basic-sui-indexer/migrations/YYYY-MM-DD-HHMMSS_transaction_digests/down.sql" mode="code" />

###substep Apply migration and generate Rust schema

From the root of your project, use the `diesel migration` command to create tables.

```sh
$ diesel migration run --database-url $PSQL_URL
```

Then use the `diesel print-schema` command to generate the `schema.rs` file from the actual database.

```sh
$ diesel print-schema --database-url $PSQL_URL > src/schema.rs
```

Your `src/schema.rs` file should now look like the following:

<ImportContent source="examples/rust/basic-sui-indexer/src/schema.rs" mode="code" />

After running the previous commands, your project is set up for the next steps:

- PostgreSQL now has a `transaction_digests` table with the defined columns.
- `src/schema.rs` contains automatically generated Rust code that represents this table structure.
- You can now write type-safe Rust code that talks to this specific table.

The Diesel's migration system evolves the database schema over time in a structured and version-controlled way. For a complete walkthrough, see the official Diesel [Getting Started guide](https://diesel.rs/guides/getting-started).

##step Create data structure

To simplify writes to Diesel, you can define a struct that represents a record on the `transaction_digests` table.

<ImportContent source="examples/rust/basic-sui-indexer/src/models.rs" mode="code" />

Key annotations:

- `FieldCount`: Required by `sui-indexer-alt-framework` for memory optimization and batch processing efficiency. It is used to limit the max size of a batch so that we don't exceed the postgres limit on the number of bind parameters a single SQL statement can have.
- `diesel(table_name = transaction_digests)`: Maps this Rust struct to the `transaction_digests` table, whose schema is generated in a previous step.
- `Insertable`: Allows this struct to be inserted into the database using Diesel.

##step Define the `Handler` struct in `handler.rs`

Create a `handlers.rs` file in your `src` directory.

```sh
$ touch ./src/handlers.rs
```

Open the file and define a concrete struct to implement the `Processor` and `Handler` traits:

<ImportContent source="examples/rust/basic-sui-indexer/src/handlers.rs" mode="code" struct="TransactionDigestHandler" />

Save the file but keep it open as the next steps add to its code.

##step Implement the `Processor`

The `Processor` trait defines how to extract and transform data from checkpoints. The resulting data is then passed to `Handler::commit`.

Add the necessary dependencies at the top of the file.

<ImportContent source="examples/rust/basic-sui-indexer/src/handlers.rs" mode="code" tag="processordeps" />

After the `TransactionDigestHandler` struct, add the `Processor` code:

<ImportContent source="examples/rust/basic-sui-indexer/src/handlers.rs" mode="code" tag="processor" />

Key concepts:

- `NAME`: Unique identifier for this processor used in monitoring and logging.
- `type Value`: Defines what data flows through the pipeline, which ensures type safety.
- `process()`: Core logic that transforms checkpoint data into your custom data structure.

Save the `handlers.rs` file.

<details>
  
<summary>
  
Processor trait definition
  
</summary>
  
<ImportContent source="crates/sui-indexer-alt-framework/src/pipeline/processor.rs" mode="code" trait="Processor" />
  
</details>

##step Implement the `Handler`

The `Handler` trait defines how to commit data to the database. Append the `Handler` dependencies to bottom of the dependency list you created in the previous step.

<ImportContent source="examples/rust/basic-sui-indexer/src/handlers.rs" mode="code" tag="handlerdeps" />

Add the logic for `Handler` after the `Processor` code. The complete code is available at the end of this step.

<ImportContent source="examples/rust/basic-sui-indexer/src/handlers.rs" mode="code" tag="handler" />

How sequential batching works:

1. `process()` returns values for each checkpoint.
1. `batch()` accumulates values from multiple checkpoints.
1. `commit()` writes the batch when framework reaches limits (`H::MAX_BATCH_CHECKPOINTS`).

<ImportContent source="crates/sui-indexer-alt-framework/src/pipeline/sequential/committer.rs" mode="code" tag="batch" />

:::tip

You can override the default batch limits by implementing constants in your `Handler`.

:::

The `handlers.rs` file is now complete. Save the file.

<details>
  
<summary>
  
Complete `handler.rs` file
  
</summary>
  
<ImportContent source="examples/rust/basic-sui-indexer/src/handlers.rs" mode="code" />
  
</details>

<details>
  
<summary>
  
Handler trait definition
  
</summary>
  
<ImportContent source="crates/sui-indexer-alt-framework/src/pipeline/sequential/committer.rs" mode="code" trait="Handler" />
  
</details>

##step Create `.env` file

The main function you create in the next step needs the value you stored to the shell variable `$PSQL_URL`. To make it available, create a `.env` file with that data.

<Tabs>
<TabItem label="Bash/zsh" value="bash">
  
```sh
echo "DATABASE_URL=$PSQL_URL" > .env
```
  
</TabItem>
<TabItem label="fish" value="fish">
  
```sh
echo "DATABASE_URL=$PSQL_URL" > .env
```
  
</TabItem>
<TabItem label="PowerShell" value="powershell">
  
```sh
"DATABASE_URL=$env:PSQL_URL" | Out-File -Encoding UTF8 .env
```
  
</TabItem>
</Tabs>

After running the command for your environment, make sure the `.env` file exists at your project root with the correct data.

##step Create main function

Now, to tie everything together in the main function, open your `main.rs` file. Replace the default code with the following and save the file:

<ImportContent source="examples/rust/basic-sui-indexer/src/main.rs" mode="code" />

Key components explained:

- `embed_migrations!`: Includes your migration files in the binary so the indexer automatically updates the database schema on startup.
- `Args::parse()`: Provides command-line configuration like `--first-checkpoint`, `--remote-store-url`, and so on.
- `IndexerCluster::builder()`: Sets up the framework infrastructure (database connections, checkpoint streaming, monitoring).
- `sequential_pipeline()`: Registers a sequential pipeline that processes checkpoints in order with smart batching.
- `SequentialConfig::default()`: Uses framework defaults for batch sizes and checkpoint lag (how many checkpoints to batch together).
- `cluster.run()`: Starts processing checkpoints and blocks until completion.

Your indexer is now complete. The next steps walk you through running the indexer and checking its functionality.

##step Run your indexer

Use the `cargo run` command to run your indexer against Testnet with remote checkpoint storage.

```sh
$ cargo run -- --remote-store-url https://checkpoints.testnet.sui.io
```

:::info

Allow incoming network requests if your operating system requests it for the `basic-sui-indexer` application.

:::

If successful, your console informs you that the indexer is running.

##step Verify results

Open a new terminal or console and connect to your database to check the results:

```bash
$ psql sui_indexer
```

After connecting, run a few queries to verify your indexer is working:

Check how many transaction digests are indexed:

```sql
$ SELECT COUNT(*) FROM transaction_digests;
```

View sample records:

```sql
$ SELECT * FROM transaction_digests LIMIT 5;
```

To confirm your data is accurate, copy any transaction digest from your database and verify it on SuiScan: [https://suiscan.xyz/testnet/home](https://suiscan.xyz/testnet/home)

You've built a working custom indexer. ðŸŽ‰ 

The key concepts covered here apply to any custom indexer: define your data structure, implement the `Processor` and `Handler` traits, and let the framework handle the infrastructure.

## Related links

<RelatedLink href="https://github.com/MystenLabs/sui/tree/main/crates/sui-indexer-alt" label="Sui Indexer Alt" desc="The `sui-indexer-alt` crate in the Sui repo." />
<RelatedLink href="https://github.com/MystenLabs/mvr/tree/main/crates/mvr-indexer" label="Move Registry" desc="The indexer that the Move Registry (MVR) implements." />
<RelatedLink href="https://github.com/MystenLabs/deepbookv3/tree/main/crates/indexer" label="DeepBook Indexer" desc="The indexer that DeepBook implements." />
<RelatedLink to="/concepts/custom-indexing-framework.mdx" />
<RelatedLink to="/concepts/custom-indexer/pipeline-architecture.mdx" />

>>>> sui/docs/content/guides/developer/advanced/custom-indexer/indexer-data-integration.mdx
---
title: Indexer Data and Integration
description: Learn how to integrate custom data sources and storage systems with Sui indexers. Covers checkpoint data sources, custom store implementations, and Move event deserialization for building flexible indexing solutions.
keywords: [sui custom indexer, checkpoint data sources, custom storage backend, move event deserialization, BCS serialization, indexer integration, bring your own store, postgresql indexer, blockchain data ingestion, sui indexing framework]
---

Building a custom indexer on Sui lets you take full control of data ingestion, storage, and processing. You can choose from multiple [checkpoint data sources](#checkpoint-data-sources) such as remote store, local files, or direct RPC API access, depending on whether you're indexing Mainnet data, testing against known checkpoints, or working on a local network. 

For storage, you can either use the built-in `IndexerCluster` with PostgreSQL or implement your own [`Store` and `Connection` traits](#byos) to integrate a different database or storage backend. After connected, you can wire up a manual indexer, add your custom pipelines, and handle watermark coordination to keep data in sync. 

Finally, you need to [deserialize Move events](#deserialize) from raw BCS bytes into Rust structs, using `bcs` and `serde`, so that your pipelines can work with strongly-typed data. This gives you a reproducible, end-to-end setup that you can tune for performance, reliability, and custom analytics.

## Checkpoint data sources {#checkpoint-data-sources}

The `sui-indexer-alt-framework` supports three data sources for accessing Sui blockchain data. For all data sources, the [indexing framework](/concepts/custom-indexing-framework.mdx) is using a polling technique to check for new checkpoints. Data sources are configured through command-line arguments.

### Remote store

The most direct stream source is a subscription to a remote checkpoint store. Sui provides the following endpoints:

- **Testnet**: `https://checkpoints.testnet.sui.io`
- **Mainnet**: `https://checkpoints.mainnet.sui.io`

```sh
$ cargo run -- --remote-store-url https://checkpoints.testnet.sui.io
```

### Local path

Local checkpoint files are useful for development and testing scenarios:

```sh
$ cargo run -- --local-ingestion-path /path/to/checkpoints
```

**Common use cases:**

- Unit and integration testing with known checkpoint data
- Development workflows with reproducible datasets

### RPC API

RPC API access queries full nodes directly using gRPC:

```sh 
$ cargo run -- --rpc-api-url https://fullnode.testnet.sui.io:443
```

**Endpoint format:** `https://fullnode.NETWORK.sui.io:443` where `NETWORK` is one of the available networks:

- `testnet`
- `devnet`
- `mainnet`

**When to use RPC API:**

- Networks without official remote store (devnet, localnet, custom networks)
- Development against local Sui networks

## Bring your own store (BYOS) {#byos}

The `IndexerCluster` provides a convenient way to get started with PostgreSQL, but you might want to use a different database or storage system. This requires using the manual `Indexer` class and implementing custom `Store` and `Connection` traits from `sui-indexer-alt-framework-store-traits`.

<details>
<summary>
`lib.rs` in `sui-indexer-alt-framework-store-traits`
</summary>

<ImportContent source="crates/sui-indexer-alt-framework-store-traits/src/lib.rs" mode="code" trait="Connection,Store" />

</details>

**When to use BYOS:**

- **Different database:** MongoDB, CouchDB, or other non-PostgreSQL databases. This also applies if you prefer to use PostgreSQL but without the default Diesel ORM.
- **Custom requirements:** Specialized storage logic, partitioning, or performance optimizations.

### Core implementation requirements

To implement BYOS, you need to:

1. Define your `Store` and `Connection` struct that manages connections.
1. Implement the `Store` trait for connection management.
1. Implement the `Connection` trait for watermark operations.
1. Use manual `Indexer` instead of `IndexerCluster`.

###step Define your store structure

```rust
use sui_indexer_alt_framework::store::{Store, Connection};
use async_trait::async_trait;

#[derive(Clone)]
pub struct MyCustomStore {
    // Your database connection details
    connection_pool: MyDatabasePool,
    config: MyConfig,
}

pub struct MyCustomConnection<'a> {
    // A connection instance
    conn: MyDatabaseConnection<'a>,
}
```

###step Implement the `Store` trait

The `Store` trait manages connection lifecycle:

```rust
#[async_trait]
impl Store for MyCustomStore {
    type Connection<'c> = MyCustomConnection<'c>;

    async fn connect<'c>(&'c self) -> anyhow::Result<Self::Connection<'c>> {
        // Your implementation
    }
}
```

###step Implement the `Connection` trait

The `Connection` trait handles watermark operations for pipeline coordination:

```rust
#[async_trait]
impl Connection for MyCustomConnection<'_> {
    // Get the highest checkpoint processed by a pipeline
    async fn committer_watermark(
        &mut self,
        pipeline: &'static str,
    ) -> anyhow::Result<Option<CommitterWatermark>> {
        // Query your database for watermark data
        todo!("Implement based on your storage system")
    }

    // Get the lowest available checkpoint for readers
    async fn reader_watermark(
        &mut self,
        pipeline: &'static str,
    ) -> anyhow::Result<Option<ReaderWatermark>> {
        // Implementation depends on your database schema
        todo!("Implement based on your storage system")
    }
    
	  // Implement other required methods...
}
```

For a complete reference, study the `sui-pg-db` implementation on `Connection`:

<ImportContent source="crates/sui-pg-db/src/store.rs" mode="code" impl="Connection" />

###step Use manual indexer

Replace `IndexerCluster` with manual `Indexer`:

```rust
use sui_indexer_alt_framework::{Indexer, IndexerArgs};
use sui_indexer_alt_framework::ingestion::{ClientArgs, IngestionConfig};

async fn main() -> anyhow::Result<()> {
    // Initialize your custom store
    let store = MyCustomStore::new(config).await?;
    
    // Configure indexer manually
    let indexer = Indexer::new(
        store,
        IndexerArgs::default(),
        ClientArgs {
            remote_store_url: Some("https://checkpoints.testnet.sui.io".to_string()),
            local_ingestion_path: None,
            rpc_api_url: None,
            rpc_username: None, 
            rpc_password: None,
        },
        IngestionConfig::default(),
        &prometheus::Registry::new(),
        tokio_util::sync::CancellationToken::new(),
    ).await?;

    // Add your pipelines
    indexer.concurrent_pipeline(
        YourHandler::default(),
        ConcurrentConfig::default(),
    ).await?;

    // Start the indexer
    indexer.run().await?;
    Ok(())
}
```

### Example: ClickHouse implementation

For a complete working example of BYOS with [ClickHouse](https://clickhouse.com/) (a high-performance columnar database for analytics), see the [example project in the Sui repo](https://github.com/MystenLabs/sui/tree/main/examples/rust/clickhouse-sui-indexer).

<details>
<summary>
ClickHouse example README
</summary>
<ImportContent source="examples/rust/clickhouse-sui-indexer/README.md" mode="code" style="md" />
</details>

This example demonstrates:

- **Custom store** implementation using the [ClickHouse Rust client](https://clickhouse.com/docs/integrations/rust).
- **Watermark persistence** with ClickHouse-specific SQL syntax.
- **Transaction digest indexing** similar to the built-in PostgreSQL handler.

The example includes three main components:

1. `store.rs` - ClickHouseStore implementing `Store` and `Connection` traits.

    <details>
    <summary>
    `store.rs`
    </summary>
    <ImportContent source="examples/rust/clickhouse-sui-indexer/src/store.rs" mode="code" />
    </details>

1. `handlers.rs` - `TxDigest` handler processing checkpoint data.

    <details>
    <summary>
    `handlers.rs`
    </summary>
    <ImportContent source="examples/rust/clickhouse-sui-indexer/src/handlers.rs" mode="code" />
    </details>

1. `main.rs` - Manual indexer setup with ClickHouse backend.

    <details>
    <summary>
    `main.rs`
    </summary>
    <ImportContent source="examples/rust/clickhouse-sui-indexer/src/main.rs" mode="code" />
    </details>

## Deserializing Move events {#deserialize}

When Move smart contracts execute on Sui, they can emit events using the `sui::event` module. These events are stored in checkpoints as **BCS-serialized bytes** that your indexer needs to deserialize to extract meaningful data.

### Why deserialization is needed

Move contracts emit events like this:

```rust
// Move smart contract
use sui::event;

public fun transfer_balance(...) {
    event::emit(BalanceEvent {
        balance_manager_id: id,
        asset: asset_id, 
        amount: 100,
        deposit: true
    });
}
```

But in checkpoint data, these events arrive as **raw BCS bytes** that need to be converted back to Rust structs for processing.

### Step-by-step deserialization

1. Add BCS dependency

    ```rust
    [dependencies]
    bcs = "0.1.6"
    serde = { version = "1.0", features = ["derive"] }
    ```

1. Define the `Event` struct in Rust

    Define the same structure in Rust as declared in Move. You can do this manually or use [`move-binding`](https://github.com/MystenLabs/move-binding) to auto-generate it from on-chain packages.

    ```rust
    use serde::Deserialize;
    use sui_indexer_alt_framework::types::::base_types::ObjectID;

    #[derive(Deserialize, Debug)]
    struct BalanceEvent {
        balance_manager_id: ObjectID,
        asset: ObjectID,
        amount: u64,
        deposit: bool,
    }
    ```

    :::important

    Field order and types must match the Move event exactly.

    :::

1. Extract event bytes in your processor

    ```rust
    impl Processor for YourHandler {
        fn process(&self, checkpoint: &Arc<CheckpointData>) -> anyhow::Result<Vec<Self::Value>> {
            let mut results = Vec::new();
            
            for transaction in &checkpoint.transactions {
                for event in &transaction.events {
                    // Get the raw BCS bytes
                    let event_bytes = &event.contents;
                    
                    // Deserialize to your Rust struct
                    if let Ok(balance_event) = bcs::from_bytes::<BalanceEvent>(event_bytes) {
                        // Do something
                    }
                }
            }
            
            Ok(results)
        }
    }
    ```

## Related links

<RelatedLink to="/concepts/custom-indexing-framework.mdx" />
<RelatedLink to="/guides/developer/advanced/custom-indexer.mdx" />

>>>> sui/docs/content/guides/developer/advanced/custom-indexer/indexer-runtime-perf.mdx
---
title: Indexer Runtime and Performance
description: Learn how to optimize Sui custom indexer performance through runtime configuration, resource monitoring, and debugging tools. Covers ingestion settings, database tuning, Tokio console debugging, Prometheus metrics, and data pruning strategies.
keywords: [ sui indexer performance, indexer optimization, tokio console debugging, prometheus metrics, database tuning, checkpoint ingestion, data pruning, indexer configuration, performance monitoring, sui blockchain indexing ]
---

Proper configuration and resource monitoring delivers the most performant custom indexer possible. For example:

- Runtime configuration options for ingestion, database connections, and pipeline selection, as well as purposeful use of debugging tools like `tokio_console` help dial in your indexer performance. 

- A sensible strategy targeting efficient data pruning for your tables keeps them performant over time. 

- Following best practices for exposing and extending Prometheus metrics helps you keep track of indexer performance. 

Together, these techniques help you run indexers that are fast, resource-efficient, and easier to monitor in both development and production.

## Fine-tuning configurations

The indexing framework provides multiple levels of configuration to optimize performance for different use cases. This section covers basic configuration options, while complex pipeline-specific tuning is covered in [Indexer Pipeline Architecture](/concepts/custom-indexer/pipeline-architecture.mdx).

### Ingestion layer configuration

Control how checkpoint data is fetched and distributed:

```rust
let ingestion_config = IngestionConfig {
    // Buffer size across all downstream workers (default: 5000)
    checkpoint_buffer_size: 10000,
    
    // Concurrent checkpoint fetches (default: 200)
    ingest_concurrency: 500,
    
    // Retry interval for missing checkpoints in ms (default: 200)
    retry_interval_ms: 100,
};
```

**Tuning guidelines:**

- `checkpoint_buffer_size`: Increase for high-throughput scenarios, decrease to reduce memory usage.
- `ingest_concurrency`: Higher values improve ingestion speed but increase network/storage load.
- `retry_interval_ms`: Lower values reduce latency for live data, higher values reduce unnecessary retries.

### Database connection configuration

```rust
let db_args = DbArgs {
    // Connection pool size (default: 100)
    db_connection_pool_size: 200,
    
    // Connection timeout in ms (default: 60,000)
    db_connection_timeout_ms: 30000,
    
    // Statement timeout in ms (default: None)
    db_statement_timeout_ms: Some(120000),
};
```

**Tuning guidelines:**

- `db_connection_pool_size`: Size based on `write_concurrency` across all pipelines.
- `db_connection_timeout_ms`: Reduce for faster failure detection in high-load scenarios.
- `db_statement_timeout_ms`: Set based on expected query complexity and database performance.

### Command-line arguments

Include the following command-line arguments to help focus processing. These values are for demonstration. Use values that make sense to your environment and goals. 

```sh
# Checkpoint range control
--first-checkpoint 1000000     # Start from specific checkpoint
--last-checkpoint 2000000      # Stop at specific checkpoint

# Pipeline selection
--pipeline "tx_counts"          # Run specific pipeline only
--pipeline "events"             # Can specify multiple pipelines

# Watermark behavior
--skip-watermark  
```

**Use cases:**

- **Checkpoint range:** Essential for backfills and historical data processing.
- **Pipeline selection:** Useful for selective reprocessing or testing.
- **Skip watermark:** Enables faster backfills when watermark consistency isn't required.

### Pipeline-specific advanced tuning

For complex configuration scenarios requiring deep understanding of pipeline internals:

- [Sequential pipeline architecture](/concepts/custom-indexer/pipeline-architecture.mdx#sequential-pipeline-architecture)
- [Concurrent pipeline architecture](/concepts/custom-indexer/pipeline-architecture.mdx#concurrent-pipeline-architecture)

## Tokio runtime debugging

For performance-sensitive pipelines or when troubleshooting async runtime issues, the `sui-indexer-alt-framework` integrates with `tokio-console`, a powerful debugger for async Rust applications. This tool provides real-time insights into task execution, helping identify performance bottlenecks, stuck tasks, and memory issues.

[GitHub repo for `tokio-console`](https://github.com/tokio-rs/console)

### When to use Tokio console

The Tokio console is particularly useful for:

- **Performance debugging:** Identifying slow or blocking tasks.
- **Memory analysis:** Finding tasks consuming excessive memory.
- **Concurrency issues:** Detecting tasks that never yield or wake themselves excessively.
- **Runtime behavior:** Understanding task scheduling and execution patterns.

### Setup instructions

Consult the [README](https://github.com/tokio-rs/console/blob/main/README.md) in the Tokio GitHub repo for additional information.

1. Add dependencies

    Add the `telemetry_subscribers` dependency to your `Cargo.toml`:

    ```rust
    [dependencies]
    telemetry_subscribers = { git = "https://github.com/MystenLabs/sui.git", branch = "main" }
    ```

1. Initialize telemetry

    Add telemetry initialization at the beginning of your `main` function:

    ```rust
    #[tokio::main]
    async fn main() -> Result<()> {
        // Enable tracing, configured by environment variables
        let _guard = telemetry_subscribers::TelemetryConfig::new()
            .with_env()
            .init();

        // Your indexer code here...
    }
    ```

1. Run with console enabled

    Start your indexer with the required flags:

    ```bash
    RUSTFLAGS="--cfg tokio_unstable" TOKIO_CONSOLE=1 cargo run
    ```

    **Flag explanations:**

    - `TOKIO_CONSOLE=1`: Enables `tokio-console` integration in `telemetry_subscribers`.
    - `RUSTFLAGS="--cfg tokio_unstable"`: Required by `tokio-console` to collect task instrumentation data.

1. Launch the console dashboard

    ```sh
    # Install tokio-console if not already installed
    cargo install tokio-console

    # Connect to your running indexer (default: localhost:6669)
    tokio-console
    ```

    If successful, the dashboard appears with information about every running Tokio task:

    ![Tokio console](./images/tokio.png)

### Console features

For detailed information about the console dashboard, available views, warnings, and diagnostic capabilities, refer to the official [`tokio-console` documentation](https://github.com/tokio-rs/console)

### Production considerations

`tokio-console` introduces runtime overhead and should be used carefully in production. While it's safe to use regularly during development and staging, production usage requires careful evaluation. Before enabling in production, you should run performance benchmarks with and without Tokio console enabled to measure the impact on your specific workload. Consider enabling only during maintenance windows or targeted troubleshooting sessions while monitoring system resources.

## Metrics

The `sui-indexer-alt-framework` provides built-in Prometheus metrics for monitoring indexer performance and health. All metrics are automatically exposed via HTTP and can be extended with custom metrics.

### Built-in metrics

The framework tracks extensive metrics across ingestion, pipeline processing, database operations, and watermark management. For a complete list of available metrics with descriptions, refer to the `IndexerMetrics` struct in `sui-indexer-alt-framework/src/metrics.rs`.

<ImportContent source="crates/sui-indexer-alt-framework/src/metrics.rs" mode="code" struct="IndexerMetrics" />

Key metric categories include:

- **Ingestion metrics:** Global checkpoint and transaction processing stats.
- **Pipeline metrics:** Per-pipeline processing performance (labeled by pipeline name).
- **Database metrics:** Batch processing, commit latency, and failure rates.
- **Watermark metrics:** Progress tracking and lag measurements.

### Accessing metrics

By default, metrics are served on `0.0.0.0:9184/metrics` in [Prometheus format](https://prometheus.io/docs/concepts/data_model/). You can override this address:

- Via the command line:

    ```sh
    $ cargo run --metrics-address "0.0.0.0:8080"
    ```

- Or, via the builder configuration:

    ```rust
    let cluster = IndexerCluster::builder()
        .with_metrics_args(MetricsArgs {
            metrics_address: "0.0.0.0:8080".parse().unwrap(),
        })
    ```

### Adding metric labels

It's highly recommended to add a metric label prefix to differentiate between different indexer instances:

```rust
let cluster = IndexerCluster::builder()
    .with_metric_label("my_custom_indexer")
```

This prefixes all default metrics (for example, `my_custom_indexer_indexer_total_ingested_checkpoints`).

### Adding custom metrics

You can register custom metrics using the shared `Registry`:

```rust
use prometheus::{IntCounter, register_int_counter_with_registry}

// Get the metrics registry before running the cluster
let cluster = IndexerCluster::builder()
    .with_database_url(database_url)
    .with_args(args)
    .build()
    .await?;

// Register custom metrics
let custom_counter = register_int_counter_with_registry!(
    "my_custom_metric_total",
    "Description of my custom metric",
    cluster.metrics().registry(),
)?;
```

### Metrics collection and visualization

The framework only exposes metrics via HTTP, and you're responsible for collection and storage. For example, some indexers use the Alloy agent to scrape the `/metrics` endpoint and write to a metrics database for visualization and alerting.

See [Collect Prometheus metrics](https://grafana.com/docs/alloy/latest/collect/prometheus-metrics/) on the Grafana Labs website.

## Pruning best practices

If your table prunes data in checkpoint order, you can improve efficiency by partitioning the table, so that you can prune by just dropping whole partitions. This usually requires only a single pruner task, avoiding the need for concurrent batched `DELETE` queries.

Partition size is the key tradeoff: you need `N` full partitions plus one trailing _active_ partition that cannot be dropped until it falls outside the read window. Larger partitions mean fewer total partitions to scan, reducing read amplification. Smaller partitions reduce retention overhead but increase the number of partitions queried. For example, keeping 10M checkpoints could use a 10M partition plus 1 active partition (querying at most 2 partitions) or 10 1M partitions plus 1 active partition (querying 11 partitions). In practice, per-epoch partitioning tends to produce too many small partitions, and not partitioning at all leads to performance degradation from repeated `DELETE`s creating dead tuples and fragmentation.

Pipelines with more complex pruning rules can still benefit. For example, in consistent pipelines, a record can only be pruned if there is a newer record for the same key or if it is a sentinel row. A separate, leaner table can track deletable records and be partitioned by checkpoint to make pruning efficient.

### Implementation

You can use `pg_partman` to simplify partition management. Configure a partitioned table with `create_parent`, followed by a cron job to periodically `run_maintenance`. You might need to iterate to determine the correct frequency of `run_maintenance`. 

:::info

Tables with primary key or unique constraints must additionally include all columns used in the partitioning scheme.

:::

```sql
CREATE EXTENSION pg_partman;

SELECT create_parent(
    p_parent_table := 'public.tx_calls',
    p_control := 'cp_sequence_number',
    p_type := 'range',
    p_interval := '10000000',
    p_start_partition := '70000000',
    p_premake := 5,
);

-- Create a maintenance job to run every hour
SELECT cron.schedule('0 * * * *', $$SELECT run_maintenance(p_analyze := false)$$);
```

This can be included as a migration:

```sql
CREATE EXTENSION IF NOT EXISTS pg_partman;
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- Function to safely set up partitioning for a table
CREATE OR REPLACE FUNCTION safe_create_parent(
    p_schema text,
    p_table text,
    p_control text,
    p_type text,
    p_interval text,
    p_start_partition text,
    p_premake int
) RETURNS text AS $$
DECLARE
    full_table_name text := p_schema || '.' || p_table;
    result_message text;
BEGIN
    -- Check if the table is already managed by pg_partman
    IF NOT EXISTS (
        SELECT 1 FROM part_config
        WHERE parent_table = full_table_name
    ) THEN
        -- If not managed, set up partitioning
        PERFORM create_parent(
            p_parent_table := full_table_name,
            p_control := p_control,
            p_type := p_type,
            p_interval := p_interval,
            p_start_partition := p_start_partition,
            p_premake := p_premake
        );
        result_message := 'CREATED: Partitioning set up for ' || full_table_name;
    ELSE
        -- Table is already managed
        result_message := 'EXISTS: Table ' || full_table_name || ' is already managed by pg_partman';
    END IF;
    
    RETURN result_message;
END;
$$ LANGUAGE plpgsql;

SELECT safe_create_parent('public', 'tx_affected_objects', 'cp_sequence_number', 'range', '10000000', '70000000', 1);

SELECT cron.schedule('0 * * * *', 'SELECT run_maintenance()');
```

The accompanying `down.sql` looks like the following:

```sql
-- Remove the scheduled job
DELETE FROM cron.job WHERE command = 'SELECT run_maintenance()';

-- Undo partitioning for all tables
SELECT undo_partition('public.tx_affected_objects', p_keep_table := true);
```

You can confirm that the partitioned table and cron job are set up correctly with the following SQL queries:

```sql
SELECT parent_table, partition_type, control, interval_val
FROM part_config
ORDER BY parent_table;

-- Check maintenance job is scheduled
SELECT jobid, schedule, command, nodename, database, username 
FROM cron.job
WHERE command = 'SELECT run_maintenance()';
```

## Related links

<RelatedLink to="/concepts/custom-indexing-framework.mdx" />
<RelatedLink to="/guides/developer/advanced/custom-indexer.mdx" />

>>>> sui/docs/content/guides/developer/advanced/custom-indexer/indexer-walrus.mdx
---
title: Custom Indexer and Walrus
description: Walrus is a content-addressable storage protocol, where data is retrieved using a unique identifier derived from the content itself, rather than from a file path or location. Integrating a custom Sui Indexer with Walrus can provide novel user experiences.
keywords: [ walrus, indexer, custom indexer, custom indexer framework, blob, sequential pipeline, blog ]
---

:::tip

This topic examines how to use a custom indexer with [Walrus](https://www.walrus.xyz/). For a more in-depth look at creating a custom indexer, see [Build Your First Custom Indexer](../custom-indexer.mdx). 

:::

Walrus is a decentralized storage and data availability protocol designed specifically for large binary files, or blobs.  It is a content-addressable storage protocol, meaning data is identified and retrieved using a unique identifier called a  _blob_. Blobs are derived from the content itself rather than from a file path or location. Consequently, if different users upload the same content, Walrus reuses the existing blob rather than creating a new one. 

For uniqueness, each blob uploaded to Walrus also creates a corresponding [`Blob` NFT object on Sui](https://docs.wal.app/dev-guide/sui-struct.html#blob-and-storage-objects) with a unique ID. Furthermore, the associated `Blob` object can optionally have a `Metadata` [dynamic field](../../../../concepts/dynamic-fields.mdx). 

`Metadata` dynamic fields are a key-value extension that allows an on-chain objectâ€™s data to be augmented at runtime. If set, this dynamic field acts as [a mapping of key-value attribute pairs](https://docs.wal.app/usage/client-cli.html?highlight=attribute#blob-attributes). 

You can use the [custom indexer framework](/concepts/custom-indexing-framework) to extend the existing functionality of Walrus.

:::info 

The Walrus Foundation operates and controls Walrus. For the most accurate and up-to-date information on the Walrus protocol, consult the official [Walrus Docs](https://docs.wal.app/).

:::

## Blog platform using Walrus

The system derives the ID of a dynamic field from its type and parent object's ID. Each `Metadata` dynamic field ID is also unique. You can leverage these unique characteristics and the `Metadata` attribute pairs to build a blog platform that enables users to:

- Upload blog posts with titles.
- View their own posts and metrics.
- Delete posts they created.
- Edit post titles.
- Browse posts by other publishers.

Assume a blog platform service already exists to handle uploads to Walrus. When the service creates a blob and its associated NFT object on Walrus, it also attaches a `Metadata` dynamic field containing key-value pairs for `publisher` (the Sui Address that uploaded the blob), `view_count`, and `title`. The service prevents users from modifying the `publisher` and `view_count` pairs, but allows the `publisher` to update the `title `value.

When a user views a post, the service retrieves the relevant blog post `Metadata` from the indexed database. It then uses the `Owner` field to fetch the blob from the full node. The liveness of the `Blob` object on Sui is used to represent whether a blog post is available. If the `Blob` object is wrapped or deleted, the blog post is not accessible through the service, even if the underlying content on Walrus still exists.

## Data modeling

One option for data modeling is to use a single table that maps publisher addresses to `Metadata` dynamic fields. With this approach, the table is keyed on `dynamic_field_id` because it both identifies your dApp data and uniquely represents the content of each uploaded blob. 

For example, the `up.sql` file to create this table might looks like the following:

<ImportContent source="examples/rust/walrus-attributes-indexer/migrations/YYYY-MM-DD-HHMMSS_blog-post/up.sql" mode="code" />

### Reads

To load blog posts from a particular publisher, pass the `publisher` and `LIMIT` values to the following query pattern:

```sql
SELECT *
FROM blog_post
WHERE publisher = $1
ORDER BY title
LIMIT $2;
```

## Custom indexer implementation

This example uses a [sequential pipeline](../../../../concepts/custom-indexer/pipeline-architecture.mdx#sequential-pipeline-architecture), ensuring each checkpoint is committed once in strict order and as a single atomic operation. The sequential pipeline architecture is not required for this project, but it is a more straightforward option than implementing the concurrent architecture. You can always [scale up to the concurrent pipeline](../../../../concepts/custom-indexer/pipeline-architecture.mdx#decision-framework) if and when your project requires it.

This implementation tracks the latest object state at checkpoint boundary. When the `Metadata` dynamic field is created, mutated, wrapped or deleted, or unwrapped, it appears among the transaction output under the object changes. You can see an [example transaction](https://suivision.xyz/txblock/3Qcuo2FaTZL5wfdi7JzPELcmkuZm7hVfdNrkLrdkKioN?tab=Changes) on Testnet that creates the field. These dynamic fields have type `0x2::dynamic_field::Field<vector<u8>, 0xabc...123::metadata::Metadata>`.

| Object change to `Metadata` dynamic field | Included in input objects | Included in live output objects | How to index |
| --- | --- | --- | --- |
| Creation (or unwrap) | âŒ | âœ… | Insert row |
| Mutation | âœ… | âœ… | Update row |
| Deletion (or wrap) | âœ… | âŒ | Delete row |

### `Processor`

All pipelines implement the same [`Processor` trait](../../../../concepts/custom-indexer/pipeline-architecture.mdx#seq-processor), which defines the logic to transform a checkpoint from the ingestion task into an intermediate or final form to commit to the store. Data flows into and out of the processor, potentially out of order.

#### `process` function

The `process` function computes the `checkpoint_input_objects` and `latest_live_output_objects` sets to capture the state of objects entering and exiting a checkpoint. A `Metadata` dynamic field that appears in `checkpoint_input_objects` but not in `latest_live_output_objects` means it has been either wrapped or deleted. In those cases, you need to record only the dynamic field ID for the commit function to handle later deletion. For creation, mutation, and unwrap operations, the objects always appear in at least the `latest_live_output_objects` set.

<ImportContent source="examples/rust/walrus-attributes-indexer/src/handlers/blog_post.rs" mode="code" fun="process" />

### `Committer`

The second and final part of the sequential pipeline is the `Committer`. Because data flows from the processor into the committer out of order, it is the committer's responsibility to batch and write the transformed data to the store in order on checkpoint boundaries.

#### `batch`

The `batch` function defines how to batch transformed data from other processed checkpoints. This function maintains a mapping of `dynamic_field_id` to the processed Walrus `Metadata`. The `batch` function guarantees that the next checkpoint to batch is the next contiguous checkpoint, which means it's safe for you to overwrite the existing entry.

<ImportContent source="examples/rust/walrus-attributes-indexer/src/handlers/blog_post.rs" mode="code" fun="batch" />

#### `commit`

The `commit` function conducts final transformations to the processed data before writing to the store. In this case, the logic partitions the processed data into `to_delete` and `to_upsert`.

<ImportContent source="examples/rust/walrus-attributes-indexer/src/handlers/blog_post.rs" mode="code" fun="commit" />

## Putting it all together

The `main` function for the service 

<ImportContent source="examples/rust/walrus-attributes-indexer/src/main.rs" mode="code" fun="main" />

To provide users with a list of posts written by a publisher, your service first queries the
database on `publisher`, yielding a result like the following. The service then uses the `blob_obj_id` to fetch the
`Blob` NFT contents. From there, you can retrieve the actual Walrus content.

```
                          dynamic_field_id                          | df_version |                             publisher                              |                            blob_obj_id                             | view_count |      title
--------------------------------------------------------------------+------------+--------------------------------------------------------------------+--------------------------------------------------------------------+------------+------------------
 \x40b5ae12e780ae815d7b0956281291253c02f227657fe2b7a8ccf003a5f597f7 |  608253371 | \xfe9c7a465f63388e5b95c8fd2db857fad4356fc873f96900f4d8b6e7fc1e760e | \xcfb3d474c9a510fde93262d4b7de66cad62a2005a54f31a63e96f3033f465ed3 |         10 | Blog Post Module
```

## Additional considerations

All Walrus blobs carry an associated lifetime, so you must track expiration changes. Whenever the `Metadata` dynamic field changes, the parent Sui `Blob` object should also appear in the output changes. You can read the blobâ€™s lifetime directly from the `Blob` object contents. However, lifetime changes usually occur on the `Blob` object itself. Because updates to the parent object donâ€™t affect the child dynamic field, unless you directly modify the child, these lifetime changes remain hidden in the current indexing setup. You can address this in several ways:

- Watch all `Blob` object changes.
- Watch all `BlobCertified` events.
- Construct PTBs that make calls to manage blob lifetime and ping the `Metadata` dynamic field in the same transaction.

If you don't want to perform additional work on the write side, then you are limited to the first two options. This requires two pipelines, one to do the work in the previous section of indexing metadata, and another to index `BlobCertified` events (or `Blob` object changes.)

## Related links

<RelatedLink href="https://docs.wal.app/" label="Walrus Docs" desc="Walrus is a decentralized storage and data availability protocol designed specifically for large binary files, or blobs." />
<RelatedLink to="/guides/developer/advanced/custom-indexer.mdx" />
<RelatedLink to="/concepts/dynamic-fields.mdx" />
<RelatedLink href="https://github.com/MystenLabs/sui/tree/main/examples/rust/walrus-attributes-indexer" label="Indexer with Walrus example files" desc="Directory in the Sui repo containing the files for this example." />

>>>> sui/docs/content/guides/developer/advanced/efficient-smart-contracts.mdx
---
title: Efficient Smart Contracts
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/developer/advanced/graphql-rpc.mdx
---
title: Querying Sui RPC with GraphQL
description: Introductory guide to making queries of the Sui RPC using the GraphQL service.
keywords: [ rpc, sui rpc, graphql, how to use graphql, schema, graphql schema, query transactions, query blocks, query block info, query dynamic field, execute transaction ]
---

:::info

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

<ImportContent source="data-serving-gql-alpha.mdx" mode="snippet" />

:::

The quickest way to access the GraphQL service for Sui RPC is through the online IDE that provides a complete toolbox for fetching data and executing transactions on the network. The online IDE provides features such as auto-completion (use <kbd>Ctrl</kbd>+<kbd>Space</kbd> or just start typing), built-in documentation (Book icon, top-left), multi-tabs, and more.

The online IDE is available for Mainnet, Testnet, and Devnet. You can try the various queries on this page directly in the IDE.

:::info

Both Mainnet and Testnet services are rate-limited to keep network throughput optimized.

:::

- Mainnet: https://graphql.mainnet.sui.io/graphql
- Testnet: https://graphql.testnet.sui.io/graphql
- Devnet: https://graphql.devnet.sui.io/graphql

:::caution

Switch any apps that still use the GraphQL Alpha endpoints (`https://sui-mainnet.mystenlabs.com/graphql`, `https://sui-testnet.mystenlabs.com/graphql`, and `https://sui-devnet.mystenlabs.com/graphql`) as soon as possible. Migrate your apps to the GraphQL Beta endpoints to avoid disruption of service.

:::

For more details about some concepts used in the following examples, see the [GraphQL concepts](../../../concepts/graphql-rpc.mdx) page. Consult the [GraphQL reference](../../../references/sui-graphql.mdx) for full documentation on the supported schema.

## Discovering the schema

GraphQL introspection exposes the schema supported by the RPC service. The IDE's **Docs** pane (Book icon, top-left) and **Search** dialog (<kbd>Cmd</kbd> + <kbd>K</kbd> on macOS or <kbd>Ctrl</kbd> + <kbd>K</kbd> on Windows and Linux) offer a way to browse introspection output interactively.

The [official GraphQL introspection documentation](https://graphql.org/learn/introspection/) provides an overview on introspection and how to interact with it programmatically.

## Beta schema changes

Some of the schema updates for the beta version include:

### Renames and deprecations

- `TransactionBlock` is being replaced with `Transaction`
- `Owner` has been merged with `Address`
- `dryRunTransactionBlock` is being replaced with `simulateTransaction`
- `bcs` fields are qualified with the type of BCS data they hold to avoid confusion.
- `changedObject` and `inputObject` filters in `transactions` query are being replaced with `affectedObject`.
- `address.coins` and `address.stakedSuis` are being deprecated in favor of `address.objects` with the corresponding `type` filter.
- `MoveValue.data` has been deprecated because it does not add value over `MoveValue.json`, which provides a more clear representation of the data.

### Consistency

GraphQL Beta offers the ability to run a query at a fixed checkpoint (retention permitting). This allows clients to query the chain state at a particular snapshot in time over multiple arbitrary requests (GraphQL Alpha offered consistency across multiple requests as long as they were for pages of a paginated query).

### Versioning

APIs for traversing different versions of packages and objects have been added. You can now list a package or object's versions, or go from one version of a package or object to another version by number, or the latest version.

### Splitting up query APIs

Paginated query APIs were previously responsible for 3 kinds of query pattern, which are broken up into 2 separate APIs:

- A dedicated multi-get API that accepts a list of keys and returns a list of results.
- A query API that offers the original core functionality: Efficient paginated results without having to supply a checkpoint range, but for limited combinations of filters.

### Relaxed consistency cursors

Cursors in GraphQL Alpha indicated the checkpoint that pagination started at. Future pages would be fetched as if from this checkpoint. This is helpful for paginating owned objects of an address but cannot express queries that update over time (like tracking a stream of events in real time). Cursors in GraphQL Beta have relaxed this constraint â€” only cursors for pages whose results do not flow in the same direction as time (such as owned object queries) remember their checkpoint.

The old behavior is reproducible by explicitly setting the checkpoint to query from (see the [Consistency](#consistency) section).

### Preserving Entity IDs

The service retains the ability to identify entities that have been pruned when they are referred to by other entities. For example, even if an object's previous transaction has been pruned, the service is still able to return the transaction digest.

### Unpruned point lookups

Point look-ups (accessing an object by its ID and version, a transaction by its digest, a checkpoint by its sequence number, and so on) are generally unpruned if GraphQL has access to an Archival Service.

### More detailed retention API

The service provides more details about the retention of its underlying data through the `ServiceConfig.availableRange` field.

### Governance

APIs related to governance and staking are removed in favor of using view functions to access the data at its source of truth on-chain.

### Owned Coin Pagination

As there is no longer a dedicated API for fetching the coins owned by an address, whenever coins are returned by an owned object API (such as `Query.objects` with an `owner` filter or `IAddressable.objects`), they are grouped by coin type and sorted in descending balance order.

### Dry-run, gas estimation, and coin selection

Dry-run now supports the same input schema as `gRPC`'s [`SimulateTransaction`](/references/fullnode-protocol#sui-rpc-v2-Transaction) in JSON form. This means that it can also accept transactions where the inputs have not been fully resolved or serialized, perform gas estimation, and coin selection. The feature is now called `simulateTransaction`.

## Example queries

The following queries show some common tasks you can perform with GraphQL.

### Find the reference gas price for latest epoch

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query {
  epoch {
    referenceGasPrice
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query {
  epoch {
    referenceGasPrice
  }
}
```
</TabItem>
</Tabs>

### Find a specific historical epoch

Find the total stake rewards, the reference gas price, the number of checkpoints and the total gas fees for epoch 100. In the query, the `epochId` argument is optional and defaults to the latest epoch.

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query {
  epoch(epochId: 100)
  {
    epochId
    totalStakeRewards
    referenceGasPrice
    totalCheckpoints
    totalGasFees
    totalStakeSubsidies
    storageFund {
      totalObjectStorageRebates
      nonRefundableBalance
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query {
  epoch(id: 100)
  {
    epochId
    totalStakeRewards
    referenceGasPrice
    totalCheckpoints
    totalGasFees
    totalStakeSubsidies
    storageFund {
      totalObjectStorageRebates
      nonRefundableBalance
    }
  }
}
```
</TabItem>
</Tabs>

### Find a transaction by its digest

Get a transaction by its digest and show information such as the gas sponsor address, the gas price, the gas budget, and effects from executing that transaction.

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query {
  transaction(digest: "FdK...qK2") {
    gasInput {
      gasSponsor {
        address
      }
      gasPrice
      gasBudget
    }
    effects {
      status
      timestamp
      checkpoint {
        sequenceNumber
      }
      epoch {
        epochId
        referenceGasPrice
      }
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query {
  transactionBlock(digest: "FdK...qK2") {
    gasInput {
      gasSponsor {
        address
      }
      gasPrice
      gasBudget
    }
    effects {
      status
      timestamp
      checkpoint {
        sequenceNumber
      }
      epoch {
        epochId
        referenceGasPrice
      }
    }
  }
}
```
</TabItem>
</Tabs>

### Find the last 10 transactions that are not a system transaction

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
:::caution

This example demonstrates future functionality.

:::

```graphql
query {
  transactions(last: 10, filter: {kind: PROGRAMMABLE_TX}) {
    nodes {
      digest
      kind {
        __typename
      }
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query {
  transactionBlocks(last: 10, filter: {kind: PROGRAMMABLE_TX}) {
    nodes {
      digest
      kind {
        __typename
      }
    }
  }
}
```
</TabItem>
</Tabs>



### Find all transactions that touched a given object

Find all the transactions that touched (modified/transferred/deleted) a given object. Useful when you want to trace the flow of a `Coin`, `StakeSui`, `NFT`, or similar object.

:::info

This example uses GraphQL [variables](/concepts/graphql-rpc.mdx#variables) and [pagination](/concepts/graphql-rpc.mdx#pagination).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query ($objectID: SuiAddress!) {
  transactions(filter: {affectedObject: $objectID}) {
    nodes {
      sender {
        address
      }
      digest
      effects {
        objectChanges {
          nodes {
            address
          }
        }
      }
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
:::caution

This example demonstrates future functionality.

:::
```graphql
query ($objectID: SuiAddress!) {
  transactionBlocks(filter: {changedObject: $objectID}) {
    nodes {
      sender {
        address
      }
      digest
      effects {
        objectChanges {
          nodes {
            address
          }
        }
      }
    }
  }
}
```
</TabItem>
</Tabs>

#### Variables

When using the online IDE, copy the following JSON to the **Variables** window, below the main editor.

```json
{
  "objectID": "0x11c6ae8432156527fc2e12e05ac7db79f2e972510a823a4ef2e670f27ad7b52f"
}
```

### Filter transactions by a function

Find the last ten transactions that called the `public_transfer` function as a Move call transaction command.

:::info

This example makes use of the `last` filter. In this case, returns only the last `10` transactions known to the service.

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
:::caution

This example demonstrates future functionality.

:::
```graphql
{
  transactions(
    last: 10,
      filter: {
        function: "0x2::transfer::public_transfer"
      }
  ) {
    nodes { digest }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
{
  transactionBlocks(
    last: 10,
      filter: {
        function: "0x2::transfer::public_transfer"
      }
  ) {
    nodes { digest }
  }
}
```
</TabItem>
</Tabs>

### Find transaction balance changes

Find the balance changes of all the transactions where a given address called a staking-related function. Useful when you want to get your staking or unstaking history.

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
:::caution

This example demonstrates future functionality.

:::
```graphql
query ($address: SuiAddress!) {
  transactions(filter: {
    function: "0x3::sui_system::request_add_stake"
    sentAddress: $address
  }) {
    nodes {
      digest
      effects {
        balanceChanges {
          nodes {
            owner {
              address
            }
            amount
          }
        }
      }
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query ($address: SuiAddress!) {
  transactionBlocks(filter: {
    function: "0x3::sui_system::request_add_stake"
    sentAddress: $address
  }) {
    nodes {
      digest
      effects {
        balanceChanges {
          nodes {
            owner {
              address
            }
            amount
          }
        }
      }
    }
  }
}
```
</TabItem>
</Tabs>

#### Variables

When using the online IDE, copy the following JSON to the **Variables** window, below the main editor.

```json
{
  "address": "0xa9ad44383140a07cc9ea62d185c12c4d9ef9c6a8fd2f47e16316229815862d23"
}
```

### Fetch a dynamic field on an object

:::info

This example uses aliases and [fragments](/concepts/graphql-rpc.mdx#fragments).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query DynamicField {
  object(
    address: "0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac"
  ) {
    dynamicField(
      name: {
        type: "0x2::kiosk::Lock",
        bcs: "NLArx1UJguOUYmXgNG8Pv8KbKXLjWtCi6i0Yeq1Vhfw=",
      }
    ) {
      ...DynamicFieldSelect
    }
  }
}

fragment DynamicFieldSelect on DynamicField {
  name {
    ...MoveValueFields
  }
  value {
    ...DynamicFieldValueSelection
  }
}

fragment DynamicFieldValueSelection on DynamicFieldValue {
  __typename
  ... on MoveValue {
    ...MoveValueFields
  }
  ... on MoveObject {
    hasPublicTransfer
    contents {
      ...MoveValueFields
    }
  }
}

fragment MoveValueFields on MoveValue {
  type {
    repr
  }
  json
  bcs
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query DynamicField {
  object(
    address: "0xb57fba584a700a5bcb40991e1b2e6bf68b0f3896d767a0da92e69de73de226ac"
  ) {
    dynamicField(
      name: {
        type: "0x2::kiosk::Lock",
        bcs: "NLArx1UJguOUYmXgNG8Pv8KbKXLjWtCi6i0Yeq1Vhfw=",
      }
    ) {
      ...DynamicFieldSelect
    }
  }
}

fragment DynamicFieldSelect on DynamicField {
  name {
    ...MoveValueFields
  }
  value {
    ...DynamicFieldValueSelection
  }
}

fragment DynamicFieldValueSelection on DynamicFieldValue {
  __typename
  ... on MoveValue {
    ...MoveValueFields
  }
  ... on MoveObject {
    hasPublicTransfer
    contents {
      ...MoveValueFields
    }
  }
}

fragment MoveValueFields on MoveValue {
  type {
    repr
  }
  data
  bcs
}
```
</TabItem>
</Tabs>



### Fetch all dynamic fields on an object

Paginate over the dynamic fields of an object. This works even when the object in question is [wrapped](/concepts/object-ownership/wrapped.mdx) by using the <a href="/references/sui-api/sui-graphql/alpha/reference/operations/queries/owner.mdx" data-noBrokenLinkCheck='true'>owner query</a>. It can be used for iterating over the elements of on-chain data structures, like tables and bags. See [The Move Book](https://move-book.com/programmability/dynamic-collections.html) to learn more about dynamic collections available in Move.

:::info

This example uses [fragments](/concepts/graphql-rpc.mdx#fragments) and [variables](/concepts/graphql-rpc.mdx#variables).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query ($id: SuiAddress!) {
  address(address: $id) {
    dynamicFields {
      nodes {
        name { ...Value }
        value {
          __typename
          ... on MoveValue {
            ...Value
          }
          ... on MoveObject {
            contents {
              ...Value
            }
          }
        }
      }
    }
  }
}

fragment Value on MoveValue {
  type {
    repr
  }
  json
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query ($id: SuiAddress!) {
  owner(address: $id) {
    dynamicFields {
      nodes {
        name { ...Value }
        value {
          __typename
          ... on MoveValue {
            ...Value
          }
          ... on MoveObject {
            contents {
              ...Value
            }
          }
        }
      }
    }
  }
}

fragment Value on MoveValue {
  type {
    repr
  }
  json
}
```
</TabItem>
</Tabs>

### Paginate checkpoints forward five at a time {#page-forward}

Set up a paginated query starting at the genesis checkpoint, reading five checkpoints at a time in increasing order of sequence number. The value of `pageInfo.hasNextPage` determines whether there is another page to read. The value of `pageInfo.endCursor` is used as the cursor to read `$after`.

:::info

This example uses GraphQL [variables](/concepts/graphql-rpc.mdx#variables) and [pagination](/concepts/graphql-rpc.mdx#pagination).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query ($after: String) {
  checkpoints(first: 5, after: $after) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query ($after: String) {
  checkpoints(first: 5, after: $after) {
    pageInfo {
      hasNextPage
      endCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```
</TabItem>
</Tabs>

### Paginate checkpoints backwards five at a time {#page-back}

Set up a paginated query starting at the latest indexed checkpoint, reading five checkpoints at a time in decreasing order of sequence number. The value of `pageInfo.hasPreviousPage` determines whether there is another page to read. The value of `pageInfo.startCursor` is used as the cursor to read `$before`.

:::info

This example uses GraphQL [variables](/concepts/graphql-rpc.mdx#variables) and [pagination](/concepts/graphql-rpc.mdx#pagination).

:::

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
query ($before: String) {
  checkpoints(last: 5, before: $before) {
    pageInfo {
      hasPreviousPage
      startCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
query ($before: String) {
  checkpoints(last: 5, before: $before) {
    pageInfo {
      hasPreviousPage
      startCursor
    }
    nodes {
      digest
      timestamp
    }
  }
}
```
</TabItem>
</Tabs>

### Execute a transaction

Transaction execution takes 2 arguments, `transactionDataBcs` and `signatures`. `transactionDataBcs` is the serialized unsigned transaction data, which the [Sui Client CLI](/references/cli/client.mdx) `client call` command can generate. Pass the `--serialize-unsigned-transaction` flag to the command to call a Move function. The [Sui Keytool CLI](/references/cli/keytool.mdx) command `sui keytool sign` can generate the `signatures`.

<Tabs groupId="graphql">
<TabItem label="Beta" value="beta">
```graphql
mutation ($tx: String!, $sigs: [String!]!) {
  executeTransaction(transactionDataBcs: $tx, signatures: $sigs) {
    errors
    effects {
      status
      epoch {
        startTimestamp
      }
      gasEffects {
        gasSummary {
          computationCost
        }
      }
    }
  }
}
```
</TabItem>
<TabItem label="Alpha (deprecated)" value="alpha">
```graphql
mutation ($tx: String!, $sigs: [String!]!) {
  executeTransactionBlock(txBytes: $tx, signatures: $sigs) {
    errors
    effects {
      status
      epoch {
        startTimestamp
      }
      gasEffects {
        gasSummary {
          computationCost
        }
      }
    }
  }
}
```
</TabItem>
</Tabs>

#### Variables

When using the online IDE, copy the following JSON to the **Variables** window, below the main editor.

```json
{
  "tx": "AAACACAZXApmrHgzTs3FGDyXWka+wmMCy2IwOdKLmTWHb5PnFQEASlCnLAw4qfzLF3unH9or5/L7YpOlReaSEWfoEwhTqpavSxAAAAAAACCUFUCOn8ljIxcG9O+CA1bzqjunqr4DLDSzSoNCkUvu2AEBAQEBAAEAALNQHmLi4jgC5MuwwmiMvZEeV5kuyh+waCS60voE7fpzAa3v/tOFuqDvQ+bjBpKTfjyL+6yIg+5eC3dKReVwghH/rksQAAAAAAAgxtZtKhXTr1zeFAo1JzEqVKn9J1H74ddbCJNVZGo2I1izUB5i4uI4AuTLsMJojL2RHleZLsofsGgkutL6BO36c+gDAAAAAAAAQEIPAAAAAAAA",
  "sigs": [
    "AB4ZihXxUMSs9Ju5Cstuuf/hvbTvvycuRk2TMuagLYNJgQuAeXmKyJF9DAXUtL8spIsHrDQgemn4NmojcNl8HQ3JFqhnaTC8gMX4fy/rGgqgL6CDcbikawUUjC4zlkflwg=="
  ]
}
```

## Migrating to GraphQL from JSON-RPC {#migrate}

The examples in the following sections demonstrate the typical API calls. The calls are tabbed to show both the JSON-RPC call and the equivalent GraphQL structure. For a comprehensive list of all available GraphQL features, consult the [reference](/references/sui-graphql).

### Example 1: Get total transactions

Get the total number of transactions in the network.

<Tabs groupId="migrating-json-rpc">

<TabItem value="json-rpc1" label="JSON-RPC">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sui_getTotalTransactionBlocks",
  "params": []
}
```

</TabItem>
<TabItem value="graphql1" label="GraphQL">

```graphql
query {
  checkpoint {
    networkTotalTransactions
  }
}
```

</TabItem>
</Tabs>

### Example 2: Get a specific transaction

Get the transaction by its digest.

<Tabs groupId="migrating-json-rpc">

<TabItem value="json-rpc2" label="JSON-RPC">

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sui_getTransactionBlock",
  "params": [
    "Hay2tj3GcDYcE3AMHrej5WDsHGPVAYsegcubixLUvXUF",
    {
      "showInput": true,
      "showRawInput": false,
      "showEffects": true,
      "showEvents": true,
      "showObjectChanges": false,
      "showBalanceChanges": false
    }
  ]
}
```

</TabItem>
<TabItem value="graphql2" label="GraphQL">

```graphql
query {
  transaction(digest: "Hay2tj3GcDYcE3AMHrej5WDsHGPVAYsegcubixLUvXUF") {
    gasInput {
      gasSponsor {
        address
      }
      gasPrice
      gasBudget
    }
    effects {
      status
      timestamp
      checkpoint {
        sequenceNumber
      }
      epoch {
        epochId
        referenceGasPrice
      }
    }
  }
}
```
</TabItem>
</Tabs>

### Example 3: Get coin objects owned by an address

Return all `Coin<0x2::sui::SUI>` objects that an address owns.

<Tabs groupId="migrating-json-rpc">

<TabItem value="json-rpc3" label="JSON-RPC">

```json
query {
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_getCoins",
  "params": [
    "0x5094652429957619e6efa79a404a6714d1126e63f551f4b6c7fb76440f8118c9", //owner
    "0x2::sui::SUI",                                                      //coin type
    "0xe5c651321915b06c81838c2e370109b554a448a78d3a56220f798398dde66eab", //cursor
    3 //limit
  ]
}
```

</TabItem>
<TabItem value="graphql3" label="GraphQL">

```graphql
query {
  address(address: "0x5094652429957619e6efa79a404a6714d1126e63f551f4b6c7fb76440f8118c9") {
    objects(
      first: 3,
      after: "vBIzCwAAAADMAQBQlGUkKZV2Gebvp5pASmcU0RJuY/VR9LbH+3ZED4EYyQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAARjb2luAAAAAAAAAARDb2luAAAAAAAAAAEAAAAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAA3N1aQAAAAAAAAADU1VJAAAAAAAAAAAB/////XBZUf9feyhb9cW+AOBraL10O9t0D9JAr+tIq2wXDJdl5/zP5w==",
      filter: { type: "0x2::coin::Coin<0x2::sui::SUI>" }
    ) {
      nodes {
        address
      }
    }
  }
}
```

:::info

The cursor is now passed in the `after` (or `before`) fields on the connection, and the limit in the `first` or `last` fields.

:::

</TabItem>
</Tabs>

## New features

The previous examples show GraphQL calls that perform the same function as their JSON-RPC equivalent. There is functionality available to GraphQL that can't be replicated with JSON-RPC, such as: 

- Time travel queries with checkpoint `{ query { ... } }`.
- Nested dynamic field look-ups (and paginating dynamic fields with their contents in 1 request).
- Fetching live objects by owner kind and type (such as all shared objects of a certain type).
- Fetching deserialized input and output object contents from a transaction that has just executed.

The following examples demonstrate some of the functions not available with JSON-RPC.

### Example 4: Getting objects by type

Fetch the latest versions of objects of type `0x2::package::Publisher` that are currently live on-chain.

```graphql
query {
  objects(filter: { type: "0x2::package::Publisher" }) {
    nodes {
      address
      digest
      asMoveObject {
        contents { json }
      }
    }
  }
}
```

### Example 5: Paging through package versions

Find all versions of the Sui framework and list their modules:

```graphql
query {
  packageVersions(address: "0x2") {
    nodes {
      version
      modules {
        nodes {
          name
        }
      }
    }
  } 
}
```

## Related links

<RelatedLink to="/concepts/graphql-rpc.mdx" />
<RelatedLink to="/references/sui-graphql.mdx" />
<RelatedLink to="/concepts/graphql-indexer" />
<RelatedLink href="https://graphql.testnet.sui.io/graphql" label="Sui Testnet GraphiQL" desc="Sui GraphiQL IDE for Testnet." />
<RelatedLink href="https://graphql.mainnet.sui.io/graphql" label="Sui Mainnet GraphiQL" desc="Sui GraphiQL IDE for Mainnet." />
>>>> sui/docs/content/guides/developer/advanced/local-fee-markets.mdx
---
title: Object-Based Local Fee Markets
description: Object-based local fee markets limit the rate of transactions writing to a single shared object, preventing the network from becoming overloaded with checkpoints that take too long to execute.
---

Object-based local fee markets limit the rate of transactions writing to a single shared object, preventing the network from becoming overloaded with checkpoints that take too long to execute.

The Sui network's object-based architecture allows processing many different user transactions massively in parallel, in a way that's not possible on most other networks. However, if multiple transactions are all writing to the same shared object, they must execute in sequential order. There is a limit to how many transactions the network can process that touch 1 specific object.

If you see transactions fail with the error `ExecutionCancelledDueToSharedObjectCongestion`, you are observing object-based local fee markets at work. Continue reading to learn:

- How transaction space is allocated on a congested shared object.
- How to bid for priority access to limited space.
- How to structure your applications and transactions for maximum throughput.

## How object-based local fee markets work

Sui's local fee market algorithm runs every time a new batch of sequenced transactions is received from consensus.

1. Sorts all transactions in order of gas price, from highest to lowest.

1. Estimates each transaction's execution cost using the [`ExecutionTimeEstimate`](https://github.com/MystenLabs/sui/blob/main/crates/sui-core/src/authority/execution_time_estimator.rs) heuristic.

1. The [`SharedObjectCongestionTracker`](https://github.com/MystenLabs/sui/blob/main/crates/sui-core/src/authority/shared_object_congestion_tracker.rs) keeps a running tally of how much per-object congestion budget is used. If all shared objects used by the transaction have enough budget left, the transaction is scheduled. In that case, it consumes budget for the mutable shared objects that it uses. Keep in mind that immutable shared objects don't consume any budget because multiple immutable uses of a shared object can execute in parallel. If the transaction cannot be scheduled, it is deferred until the next commit.

### Priority ordering of transactions

Transaction priority is determined solely by gas price. If you want your transaction to be assigned access to shared objects ahead of others in the same consensus commit, you must pay a higher gas price than the others. This is the only way to get priority access.

Using a gas price that is at least 5 times the reference gas price also increases the likelihood that the transaction is included in the earliest consensus commit possible. See [SIP-45](https://github.com/sui-foundation/sips/blob/main/sips/sip-45.md) for details.

### Cost estimation of transactions

Sui limits the per-commit execution capacity of each shared object. If transactions touching a shared object have a low estimated execution time, more of them can fit. If they have a high estimated execution time, not as many can fit.  

Transaction execution time is estimated separately for each top-level Move function called from a PTB. Measurements of actual execution time are shared between the validators, and the cost estimate used for scheduling is the stake-weighted median of these measurements of past invocations. (For most functions, which are never called with congested inputs, a low default estimate is used.)

### Transaction deferral

If the network is unable to schedule a transaction because it's trying to use a congested shared object with no space left, the transaction is deferred. This means that validators hold onto the transaction and attempt to schedule it with the next commit, each time prioritizing all waiting transactions by gas price.

If a transaction is deferred for several commits without successfully being scheduled, it's cancelled and returns an `ExecutionCancelledDueToSharedObjectCongestion` error. You need to try it again with a higher gas price or at a time when the shared objects it depends on are not as congested.

### Determining total per-object capacity

At the protocol level, Sui is configured with a per-commit target utilization and burst capacity for each shared object. On average, a shared object's activity cannot exceed the per-commit limit. However, short bursts of traffic might exceed the limit temporarily.

There is no way to increase the total execution capacity of a particular shared object. The network sets that limit to ensure that validators, full nodes, and indexers can all execute checkpoints in a reasonable amount of time.

## Practical takeaways

- For priority access to a congested shared object, set a higher gas price.

- When designing Move packages, avoid using a single shared object if possible. For example, a DEX application with a single, main shared object and dynamic fields for each currency pair suffers much more congestion than 1 with a separate object per currency pair.

- If your object `O` is congested, optimize the execution time of the functions that are commonly used to access the object. For example, if all the accesses to your object happen through Move function `f`, halving the execution time of `f` effectively doubles the number of transactions that can touch `O` in a single commit.
>>>> sui/docs/content/guides/developer/advanced/maximize-reach.mdx
---
title: Maximize your Reach
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/developer/advanced/min-gas-fees.mdx
---
title: Minimize Gas Fees
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/developer/advanced/move-2024-migration.mdx
---
title: Migrating to Move 2024
description: New features are becoming available to Move in 2024. These features are opt-in, so existing code will continue to function as expected. If you want to use these features in code you've already written, however, there are some steps you must take and breaking changes to be aware of to migrate to Move 2024.
---

New features for Move are becoming available in 2024, a part of the aptly titled "Move 2024" edition. Many of these changes are enhancements to the source language, affecting the compiler without requiring any changes to the binary representation published on chain.

The primary goal of these changes is to make Move easier to write and hopefully easier to read. The relatively few breaking changes introduced to the source language are to better position Move to handle future advancements.

Existing code continues to compile, even with the addition of these new features. And because these features are opt-in, you can write your packages with the new features, even if your dependencies do not. Opting to take advantage of the new features in your current modules, however, does introduce some breaking changes.

This document highlights some new features to try out and shows how to migrate your existing modules to use Move 2024.

:::info

Provide any feedback or report any issues you encounter through [GitHub](https://github.com/MystenLabs/sui/issues/new/choose), [Discord](https://discord.gg/Sui), or [Telegram](https://t.me/SuiTokenNetwork).

:::

## How to migrate

To migrate a project to Move 2024 Beta:

1. Delete your existing `Move.lock` file (if it exists) to make sure you're using the newest `sui-framework` version.
1. Perform 1 of the following:
   - Run `sui move migrate` in the root of your Move project. See [Automatic migration](#automatic-migration).
   - Alternatively, update your `Move.toml` file's `[package]` entry to include `edition = "2024.beta"`. If you do this, you might receive a number of new errors related to the [breaking changes](#breaking-changes).

### Automatic migration {#automatic-migration}

Move 2024 includes an automatic migration script that you can use by calling `sui move migrate` in the root of your Move project. Upon running, your console prompts you for which Move edition to use. If you select `2024.beta`, the script invokes the compiler and attempts to automatically update your code to avoid the [breaking changes](#breaking-changes) the update introduces (including marking structs as `public`, mutable variables with the `mut` keyword, avoiding restricted keywords, swapping `friend`s for `public(package)`, and even updating paths to global paths in many cases).

After this is done, your console displays a diff of the changes the script intends to make. If you accept the changes, the script updates your code and your `Move.toml` file automatically. You are now using Move 2024 Beta.

### Update IDE support

Use the new [VSCode Move extension](https://marketplace.visualstudio.com/items?itemName=mysten.move) to get support for Move 2024 features. The new extension has a number of improvements over the original [move-analyzer extension](https://marketplace.visualstudio.com/items?itemName=move.move-analyzer), but if you would like to keep using the original, be sure to rebuild and reinstall the `move-analyzer` binary to get 2024 support:

```sh
$ cargo install --git https://github.com/MystenLabs/sui.git move-analyzer
```

See the getting started guide on [Move IDEs and plugins](/references/contribute/sui-environment.mdx#move-ides-and-plugins) for more information.

## New features

Here is a brief overview of some of the new features in Move 2024.

### Method syntax

You can call certain functions now as methods using the `.` syntax. For example, the following call

```move
vector::push_back(&mut v, coin::value(&c));
```

can now be written as

```move
v.push_back(c.value());
```

Where the receiver of the method (`v` and `c` in this example) is automatically borrowed if necessary (as `&mut v` and `&c` respectively).

You can call any function defined in the same module as the receiver's type as a method if it takes the receiver as its first argument.

For functions defined outside the module, you can declare methods using `public use fun` and `use fun`.

### Index syntax

With method syntax, you can annotate certain functions as being `#[syntax(index)]` methods. You then call these methods using `v[i]`-style calls.

For example,

```move
*&mut v[i] = v[j];
```

resolves to

```move
*vector::borrow_mut(&mut v, i) = *vector::borrow(&v, j);
```

### `public(package)` {#public-package}

`friend` declarations and the associated `public(friend)` visibility modifiers are deprecated. In their place is the `public(package)` visibility modifier, which allows calling functions only within the same package where they are defined.

### Positional fields

You can now define `struct`s with positional fields, which are accessed by zero-based index. For example,

```move
public struct Pair(u64, u64) has copy, drop, store;
```

then to access each field,

```move
public fun sum(p: &Pair): u64 {
  p.0 + p.1
}
```

And as this example shows, you can now declare abilities after the struct field list.

### Nested `use` and standard library defaults

You can now nest `use` aliases for more conciseness.

```move
use sui::{balance, coin::{Self, Coin}};
```

Additionally, the following `use` declarations are now automatically included in every module:

```move
use std::vector;
use std::option::{Self, Option};
use sui::object::{Self, ID, UID};
use sui::transfer;
use sui::tx_context::{Self, TxContext};
```

### Automatic referencing in equality

Equality operations, `==` and `!=`, now automatically borrow if 1 side is a reference and the other is not. For example,

```move
fun check(x: u64, r: &u64): bool {
  x == r
}
```

is equivalent to

```move
fun check(x: u64, r: &u64): bool {
  &x == r
}
```

This automatic borrowing can occur on either side of `==` and `!=`.

### Loop labels

When nesting loops, it can be convenient to break to the outer loop. For example,

```move
let mut i = 0;
let mut j = 0;
let mut terminate_loop = false;
while (i < 10) {
    while (j < 10) {
        if (haystack(i, j) == needle) {
            terminate_loop = true;
            break;
        };
        j = j + 1;
    };
    if (terminate_loop) break;
    i = i + 1;
}
```

Now, you can directly name the outer loop (`outer` in this case) and break it all at once:

```move
let mut i = 0;
let mut j = 0;
'outer: while (i < 10) {
    while (j < 10) {
        if (haystack(i, j) == needle) break'outer;
        j = j + 1;
    };
    i = i + 1;
}
```

### `break` with value

It's now possible to `break` with a value from a `loop`. For example,

```move
let mut i = 0;
let x: u64 = loop {
    if (v[i] > 10) break i;
    i = i + 1;
};
```

You can achieve this with labels, as well. For example,

```move
let mut i = 0;
let mut j = 0;
let item = 'outer: loop {
    while (j < 10) {
        let item = haystack(i, j);
        if (item == needle) break'outer option::some(item);
        j = j + 1;
    };
    i = i + 1;
    if (i == 10) break option::none();
};
```

## Breaking changes {#breaking-changes}

Breaking changes are, unfortunately, a growing pain in Move 2024. We anticipate these changes to be minimally invasive and have provided a migration script to automate them in most cases. In addition, these changes pave the way for new features still to come in Move 2024.

### Datatype visibility requirements

Currently, all structs in Move are, by convention, public: any other module or package can import them and refer to them by type. To make this clearer, Move 2024 requires that all structs be declared with the `public` keyword. For example,

```move
// legacy code
struct S { x: u64 }

// Move 2024 code
public struct S { x: u64 }
```

Any non-public struct produces an error at this time, though the Move team is working on new visibility options for future releases.

### Mutability requirements

Previously, all variables in Move were implicitly mutable. For example,

```move
fun f(s: S, y: u64): u64 {
    let a = 0;
    let S { x } = s;
    a = 1;
    x = 10;
    y = 5;
    x + y
}
```

Now, you must declare mutable variables explicitly:

```move
fun f(s: S, mut y: u64): u64 {
    let mut a = 0;
    let S { mut x } = 5;
    a = 1;
    x = 10;
    y = 5;
    x + y
}
```

The compiler now produces an error if you attempt to reassign or borrow a variable mutably without this explicit declaration.

### Removing friends and `public(friend)`

Friends and the `public(friend)` visibilities were introduced early in Move's development, predating even the package system. As indicated in the [public(package)](#public-package) section, `public(package)` deprecates `public(friend)` in Move 2024.

The following declaration now produces an error:

```move
module pkg::m {
    friend pkg::a;
    public(friend) fun f() { ... }
}

module pkg::a {
    fun calls_f() { ... pkg::m::f() ... }
}
```

Instead, if you want your function to be visible only in the package, write:

```move
module pkg::m {
    public(package) fun f() { ... }
}

module pkg::a {
    // this now works directly
    fun calls_f() { ... pkg::m::f() ... }
}
```

### New keywords

Looking toward the future, Move 2024 Beta adds the following keywords to the language: `enum`, `for`, `match`, `mut`, and `type`. The compiler, unfortunately, now produces parsing errors when it finds these in other positions. This is a necessary change as the language matures. If you perform automatic migration, the migration tool renames these as `enum` and so on, rewriting the code to use these escaped forms.

### Revised paths and namespaces

Move 2024 revises how paths and namespaces work compared to legacy Move, toward easing `enum` aliasing in the future. Consider the following snippet from a test annotation in the `sui_system` library:

```move
use sui_system::sui_system;
...
#[expected_failure(abort_code = sui_system::validator_set::EInvalidCap)]
```

Legacy Move always treats a 3-part name as an address(`sui_system`), module(`validator_set`), and module member (`EInvalidCap`). Move 2024 respects scope for `use`, so `sui_system` in the attribute resolves to the module, producing a name resolution error overall.

To avoid cases where this is the intended behavior, Move 2024 introduces a prefix operation for global qualification. To use, you can rewrite this annotation as:

```move
use sui_system::sui_system;
...
#[expected_failure(abort_code = ::sui_system::validator_set::EInvalidCap)]
                             // ^ note `::` here
```

The migration script attempts to remediate naming errors using global qualification when possible.

## Follow along

The beta release of Move 2024 comes with some powerful new features in addition to the breaking changes described here. There are also more on the horizon. Join the [Sui developer newsletter](https://sui.io/developers#newsletter) to learn about new, exciting features coming to Move this year, including syntactic macros, enums with pattern matching, and other user-defined syntax extensions.

### `alpha` and `beta` guidance

- `beta` (specified through `edition = "2024.beta"`) is the recommended edition. It includes all the new features mentioned above and all breaking changes. While there is the risk of breaking changes or bugs in `beta`, you should feel comfortable using it in your projects. As new features are added and tested, they are included in the `beta` edition. The `beta` edition ends after all features for the year have been added and finalized.
- `alpha` (specified through `edition = "2024.alpha"`) gets new features and changes as they are developed. Breaking changes to features in `alpha` should be expected. As such, take caution when using `alpha` in your projects.
>>>> sui/docs/content/guides/developer/advanced/randomness-onchain.mdx
---
title: On-Chain Randomness
description: Randomness is a valuable tool to simulate chance on chain, but can also expose flaws in your logic. Understanding the vulnerabilities and accounting for them can mitigate the threat exposure for your smart contracts.
keywords: [ raffle, randomness, random, RandomGenerator, ProtocolConfig, PTB, dice ]
---

Generating pseudo-random values in Move is similar to solutions in other languages. A Move function can create a new instance of `RandomGenerator` and use it for generating random values of different types, for example, `generate_u128(&mut generator), generate_u8_in_range(&mut generator, 1, 6)`, or,

```move
entry fun roll_dice(r: &Random, ctx: &mut TxContext): Dice {
  let mut generator = new_generator(r, ctx); // generator is a PRG
  Dice { value: random::generate_u8_in_range(&mut generator, 1, 6) }
}
```

`Random` has a reserved address `0x8`. See <UnsafeLink href="/references/framework/sui-framework/sui_sui/random">random.move</UnsafeLink> for the Move APIs for accessing randomness on Sui.

:::info

Although `Random` is a shared object, it is inaccessible for mutable operations, and any transaction attempting to modify it fails.

:::

Having access to random numbers is only one part of designing secure applications, you should also pay careful attention to how you use that randomness.
To securely access randomness:

- Define your function as (private) `entry`.
- Prefer generating randomness using function-local `RandomGenerator`.
- Make sure that the "unhappy path" of your function does not consume more resources than the "happy path".

## Limited resources and `Random` dependent flows

Be aware that some resources that are available to transactions are limited.
If you are not careful, an attacker can break or exploit your application by deliberately controlling the point where your function runs out of resources.

Concretely, gas is such a resource.
Consider the following vulnerable code:

```move
// Insecure implementation, do not use!
entry fun insecure_play(r: &Random, payment: Coin<SUI>, ...) {
  ...
  let mut generator = new_generator(r, ctx);
  let win = generator.generate_bool();
  if (win) { // happy flow
    ... cheap computation ...
  } else {
    ... very expensive computation ...
  }
}
```

Observe that the gas costs of a transaction that calls `insecure_play` depends on the value of `win`.
An attacker could call this function with a gas budget that is sufficient for the "happy flow" but not the "unhappy one", resulting in it either winning or reverting the transaction (but never losing the payment).

:::warning

The `Random` API does not automatically prevent this kind of attack, and you must be aware of this subtlety when designing your contracts.

:::


Other limited resources per transaction that you should consider are:

- The number of new objects.
- The number of objects that can be used (including dynamic fields).
- Number of events emitted.
- Number of UIDs generated, deleted, or transferred.

<details>

<summary>

Complete list of `ProtocolConfig` limits.

</summary>

<ImportContent source="crates/sui-protocol-config/src/lib.rs" mode="code" struct="ProtocolConfig" />

</details>

For many use cases, like when selecting a raffle winner or lottery numbers, this attack is not an issue as the code running is independent of the randomness. However, in other use cases where this attack can be problematic, consider using one of the following approaches:

### Option 1: Divide logic

Split the logic into 2 functions that different transactions must call.

1. The first transaction, `tx1`, calls the first function, which fetches a random value and stores it in an object that is unreadable by other commands in `tx1`. For example, the function might transfer the object to the caller or store the transaction digest and check that it's different on read.

2. The second transaction, `tx2`, calls a second function, which reads the stored value and completes the operation. `tx2` might fail, but now the random value is fixed and cannot be modified using repeated calls.
It's important that the inputs to the second function are fixed and cannot be modified after `tx1`, otherwise an attacker can modify them after seeing the randomness committed by `tx1`.

Gracefully handle the case in which the second step is never completed. You could accomplish this, for example, by charging a fee in the first step.

<details>

<summary>

Example implementation.

</summary>

<ImportContent source="examples/move/random/random_nft/sources/example.move" mode="code" fun="reveal_alternative2_step1,reveal_alternative2_step2" />

</details>

### Option 2: Resource usage

Write the function so the main processing path does the heavy work, while early-exit paths return quickly. Keep the following in mind:

  - Both external or native functions can change in the future, potentially resulting in different costs compared to when you conducted your tests.
  - [Profile the transaction](../../../references/cli/trace-analysis.mdx#profile-a-transaction) to benchmark the costs of a transaction.
  - UIDs generated and deleted on the same transaction do not count towards the limit on generated or deleted UIDs. 

## Use (non-public) `entry` functions

While composition is very powerful for smart contracts, it opens the door to attacks on functions that use randomness.

Consider for example a betting game that uses randomness for rolling dice:

```move
module games::dice {
  ...
  public enum Ticket has drop {
    Lost,
    Won,
  }

  public fun is_winner(t: &Ticket): bool {
    match (t) {
      Ticket::Won => true,
      Ticket::Lost => false,
    }
  }

  /// If you guess correctly the output, then you get a GuessedCorrectly object.
  /// Otherwise you get nothing.
  public fun play_dice(guess: u8, fee: Coin<SUI>, r: &Random, ctx: &mut TxContext): Ticket {
    // Pay for the turn
    assert!(coin::value(&fee) == 1000000, EInvalidAmount);
    transfer::public_transfer(fee, CREATOR_ADDRESS);

    // Roll the dice
    let mut generator = new_generator(r, ctx);
    if (guess == generator.generate_u8_in_range(1, 6)) {
      Ticket::Won
    } else {
      Ticket::Lost
    }
  }
  ...
}
```

An attacker can deploy the next function:

```move
public fun attack(guess: u8, r: &Random, ctx: &mut TxContext): Ticket {
  let t = dice::play_dice(guess, r, ctx);
  // revert the transaction if play_dice lost
  assert!(!dice::is_winner(&t), 0);
  t
}
```

The attacker can now call `attack` with a guess and always revert the fee transfer if the guess is incorrect.

To protect against composition attacks, define your function as a private `entry` function so functions from other modules cannot call it.

:::tip

The Move compiler enforces this behavior by rejecting `public` functions with `Random` as an argument.

:::

## Programmable transaction block (PTB) restrictions

A similar attack to the one previously described involves PTBs even when `play_dice` is defined as a private `entry` function.
For example, consider the `entry play_dice(guess: u8, fee: Coin<SUI>, r: &Random, ctx: &mut TxContext): Ticket { â€¦ }` function defined earlier, the attacker can publish the function

```move
public fun attack(t: Ticket): Ticket {
  assert!(!dice::is_winner(&t), 0);
  t
}
```

and send a PTB with commands `play_dice(...), attack(Result(0))` where `Result(0)` is the output of the first command.

As before, the attack takes advantage of the atomic nature of PTBs and always reverts the entire transaction if the guess was incorrect, without paying the fee. Sending multiple transactions can repeat the attack, each one executed with different randomness and reverted if the guess is incorrect.

:::tip

To protect against PTB-based composition attacks, Sui rejects PTBs that have commands that are not `TransferObjects` or `MergeCoins` following a `MoveCall` command that uses `Random` as an input.

:::

## Instantiating `RandomGenerator`

`RandomGenerator` is secure as long as it's created by the consuming module. If passed as an argument, the caller might be able to predict the outputs of that `RandomGenerator` instance (for example, by calling `bcs::to_bytes(&generator)` and parsing its internal state).

:::tip

The Move compiler enforces this behavior by rejecting `public` functions with `RandomGenerator` as an argument.

:::

## Accessing `Random` from TypeScript

If you want to call `roll_dice(r: &Random, ctx: &mut TxContext)` in module `example`, use the following code snippet:

```typescript
const tx = new Transaction();
tx.moveCall({
  target: "${PACKAGE_ID}::example::roll_dice",
  arguments: [tx.object.random()]
});
...
```

## Related Links

<RelatedLink to="/references/framework" />
<RelatedLink href="https://docs.sui.io/references/framework/sui_sui/random" label="random.move" desc="Documentation for the `random` module." />
<RelatedLink href="https://github.com/MystenLabs/sui/blob/main/examples/move/random/raffles" label="Raffle example" desc="GitHub repo containing a raffle smart contract demonstrating randomness." />
<RelatedLink to="/references/cli/client" />
>>>> sui/docs/content/guides/developer/advanced/security-best-practices.mdx
---
title: Security Best Practices
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/developer/advanced/wallet-integrations.mdx
---
title: Wallet Integrations
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/developer/app-examples.mdx
---
title: App Examples
description: Ever-growing list of example packages that demonstrate solutions built on the Sui blockchain, written by Sui and Move experts. Use these examples to learn Sui and Move, and to extract techniques you can apply to your own Sui projects.
keywords: [ example apps, example application, counter, trustless swap, coin flip, review, food review app, blackjack game, plinko game, tic-tac-toe, weather oracle, dApp examples, dapps, sample applications, sample apps ]
pagination_prev: null
---

The ever-growing number of examples in this section showcase packages for the Sui blockchain. Extract techniques used in these examples to apply to your own Sui projects as they are written by Sui and Move experts. 

<ImportContent source="warn-ml-rpcs.mdx" mode="snippet" />

## Examples

Sui is dedicated to providing a wide range of examples to guide you in proper programming techniques for the Sui blockchain. This list will continue to grow, so check back often. 

:::tip

The projects are grouped by stack type and are sorted by complexity.

:::

### Full-stack apps
- [Distributed Counter](./app-examples/e2e-counter.mdx): An end-to-end example that creates a basic decentralized counter that anyone can increment, but only the object owner can reset it. The example includes Move code to create the package and leverages the Sui TypeScript SDK to provide a basic frontend.
- [Trustless Swap](./app-examples/trustless-swap.mdx): This example demonstrates trustless swaps on the Sui blockchain using a shared object as an escrow account.
- [Coin Flip](./app-examples/coin-flip.mdx): The Coin Flip app demonstrates on-chain randomness.
- [Reviews Rating](./app-examples/reviews-rating.mdx): This example demonstrates implementing a reviews-rating platform for the food service industry on Sui.
- [Blackjack](./app-examples/blackjack.mdx): This example demonstrates the logic behind an on-chain version of the popular casino card game, Blackjack.
- [Plinko](./app-examples/plinko.mdx): This example puts the classic Plinko game on chain, demonstrating use of cryptography-based strategies to create a fair and transparent game of chance. 

### Smart contracts
- [Tic-tac-toe](./app-examples/tic-tac-toe.mdx): Three implementations of the classic tic-tac-toe game on the Sui network to demonstrate different approaches to user interaction.

### Smart contracts & Backend
- [Weather Oracle](./app-examples/weather-oracle.mdx): The Sui Weather Oracle demonstrates how to create a basic weather oracle that provides real-time weather data.


>>>> sui/docs/content/guides/developer/app-examples/auction.mdx
---
title: Auction
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/developer/app-examples/blackjack.mdx
---
title: Blackjack
description: Learn Sui using an example implementation of the popular casino game Blackjack.
keywords: [ public bls key, http requests, serverless functions, randomness, generate randomness, create game, game app, game dApp, example game ]
---

The following documentation goes through an example implementation of the popular casino game Blackjack on Sui. This guide walks through its components, providing a detailed look at the module's functions, structures, constants, and their significance in the overall gameplay mechanism.

A deployed version of the Blackjack game is online at [Mysten Blackjack](https://blackjack-sui.vercel.app/).

Building an on-chain blackjack game shares a lot of similarities with a Coin Flip game. This example covers the smart contracts (Move modules), backend logic (using serverless functions), and frontend logic.

<ImportContent source="prerequisites.mdx" mode="snippet" />

:::info

For more details on building a backend and deploying to Sui, check out the [Coin Flip app example](./coin-flip.mdx).

You can also find the [full repository for this example here](https://github.com/MystenLabs/blackjack-sui).

:::


## Gameplay

In this single-player version of blackjack, the player competes against a dealer, which is automated by the system. The dealer is equipped with a public BLS key that plays a central role in the game's mechanics. The dealer's actions are triggered by HTTP requests to serverless functions. Players place their bet to start the game. Upon initiating the game, a request is made to the backend (dealer), which processes it by signing and subsequently dealing two cards to the player and one to themselves.

The player has the option to 'Hit' or 'Stand.' Selecting 'Stand' triggers the dealer to draw cards until the total reaches 17 or higher. After the dealer stops, the smart contract steps in to compare the totals and declare the winner. On the other hand, choosing 'Hit' prompts the dealer to draw an additional card for the player.

Note that more complex Blackjack rules, such as splitting, are considered out of scope for this example, and are therefore not implemented.

## Smart contracts

### `single_player_blackjack` module

The [`single_player_blackjack.move`](https://github.com/MystenLabs/blackjack-sui/blob/main/move/blackjack/sources/single_player_blackjack.move) module includes several constants that define game statuses and help track the game's progress:

- `IN_PROGRESS`
- `PLAYER_WON_STATUS`
- `HOUSE_WON_STATUS`
- `TIE_STATUS`

There are also constants for error handling, such as `EInvalidBlsSig`, `EInsufficientBalance`, and others, ensuring robust game mechanics.

Structs like `GameCreatedEvent`, `GameOutcomeEvent`, and `HitDoneEvent` capture the various events and actions within a game. The `HitRequest` and `StandRequest` structs ensure that a move (hit/stand) can be performed by the house only if the player has already requested it. `HouseAdminCap` and `HouseData` are crucial for maintaining the house's data, including balance and public key, while the `Game` struct contains all the necessary information about each game, such as player data, cards, and the current status.

The module's functions can be broadly categorized into initialization, game management, and utility functions. The `init` function sets up the house admin capability, while `initialize_house_data` prepares the house for the game by setting up the balance and public key. `place_bet_and_create_game` is the entry point for players to start a new game, involving a bet and random input. The functions `first_deal`, `hit`, and `stand` govern the core gameplay, handling the dealing of cards and player choices.

Utility functions like `get_next_random_card` and `get_card_sum` are essential for the game's mechanics, generating random cards and calculating hand values. The module also includes accessors for retrieving various pieces of game and house data.

For testing purposes, the module provides special functions like `get_house_admin_cap_for_testing`, `player_won_post_handling_for_test` and `house_won_post_handling_for_test`, ensuring that developers can thoroughly test the game mechanics and house data handling.

## Backend

The backend is used for all the transactions that are executed by the dealer. The backend can be completely stateless, and for that reason serverless functions are utilized. As a result, the corresponding code lies under the [`app/src/app/api/` directory](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api).

### Directories structure

The backend code is split in the following sub directories:

- [`games/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/games):
  The main code of the backend endpoints. Each file that is named `route.ts` is served as an endpoint, in the path defined by the project structure (see [Route Segments on NextJS App Router](https://nextjs.org/docs/app/building-your-application/routing#route-segments) for details).
- [`health/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/health): A simple health check endpoint to check the API availability.
- [`helpers/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/helpers): Multiple helper functions used in various endpoints.
- [`services/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/services): The core logic of the backend, that signs and executes the transactions on the Sui blockchain.
- [`utils/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/api/utils): Reusable methods for signing the transactions as the dealer, and sponsoring them with Shinami, to avoid gas coins equivocation.

### High-Level endpoints specification

| HTTP Method | Path                    | Description                                                   | Request Body                                      |
| ----------- | ----------------------- | ------------------------------------------------------------- | ------------------------------------------------- |
| GET         | `/api/health`           | A simple health check endpoint to check the API availability.   | `txDigest`                                          |
| POST        | `/api/games/{id}/deal`  | Executes the initial deal transaction after the game creation. | `txDigest`                                          |
| POST        | `/api/games/{id}/hit`   | Executes a hit move.                                           | `txDigest`, ID of corresponding `HitRequest` object   |
| POST        | `/api/games/{id}/stand` | Executes a stand move.                                         | `txDigest`, ID of corresponding `StandRequest` object |

### Need of usage of `waitForTransaction`

An interesting aspect of developing a dApp on Sui, that is coupled to using a full node with/without a load balancer, and requires attention by the developer, is the occurrence of read-after-write and write-after-write cases.

#### Initial deal transaction

As an example, in the Blackjack game, just after the create game transaction that the user executes, the dealer executes the initial deal transaction. This one accepts an argument and modifies the game object, meaning that you are using an object that was just created.

To ensure that the game object is available in the full node that the dealer is using, you need to call `waitForTransaction` after the create game transaction.

#### Hit and stand transactions

In the same way, every time you re-fetch the game object in the frontend, make sure that the previous transaction that modified the game object is already available in the full node.

This leads to the need of exchanging the `txDigest` between the frontend and the backend, and use `waitForTransaction` on each write-after-write or read-after-write case.

## Frontend

The [`page` component](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/page.tsx), a central element of the Blackjack game's frontend module, is structured to create an interactive and responsive gaming experience. Written in React, it integrates several features and functions to handle the game's logic and user interactions effectively.

### Directories structure

The frontend is a NextJS project, that follows the NextJS App Router [project structure](https://nextjs.org/docs/app/building-your-application/routing).
The main code of the frontend lies under the [`app/src/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/) directory.
The main sub-directories are:

- [`app/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/app/): The main code of the pages and the API endpoints.
- [`components/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components): The reusable components of the app, organized in sub-directories.
- [`hooks/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks): The custom hooks used in the app.
- [`helpers/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/helpers), [`utils/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/utils), [`lib/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/lib): Multiple helper functions and utilities.
- [`types/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/types): The types/interfaces used in the app.
- [`styles/`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/styles): The global CSS files to style the app.

### Components and custom hooks for state management

- **Custom hooks:** To keep the code as structured as possible, multiple custom hooks are utilized to manage the complex state of the game board at each step. The [`useBlackjackGame`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useBlackjackGame.ts) custom hook encapsulates the game state and logic, exposing all the required information (with fields such as `game`, `isInitialDealLoading`), and the required functionality (with methods such as `handleCreateGame` and `handleHit`) to display and play the game. Multiple additional custom hooks, such as [`useCreateBlackjackGame`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useCreateBlackjackGame.ts), and [`useMakeMoveInBlackjackGame`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useMakeMoveInBlackjackGame.ts) are encapsulating their own piece of state and logic to make the code readable and maintainable.

- **Component for game initialization:** The [`StartGame`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/StartGame.tsx) component is implemented to facilitate the creation of a new game. It uses the `handleCreateGame` function of the [`useBlackjackGame`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useBlackjackGame.ts) hook to execute the create-game transaction.

- **Card displaying and management:** The [`DealerCards`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/DealerCards.tsx) and the [`PlayerCards`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/PlayerCards.tsx) components are used to display the total points and the cards owned by the dealer and the player respectively.

- **Game actions:** The [`GameActions`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/GameActions.tsx) component is used to display the **Hit** and **Stand** buttons, and trigger the corresponding actions, as they are exported by the [`useBlackjackGame`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/hooks/useBlackjackGame.ts) hook to execute the corresponding transactions.

- **`BlackjackBanner`**: The [`BlackjackBanner`](https://github.com/MystenLabs/blackjack-sui/blob/main/app/src/components/home/BlackjackBanner.tsx) component is used as a custom view to display when the player wins with a blackjack.

## Comparison: Blackjack and Coin Flip

### Similarities

- **Blockchain-based logic:** Both games are built on Sui, leveraging its capabilities for decentralized applications. The core game logic for each resides in Move modules, ensuring secure and verifiable gameplay.

- **State management:** In both games, state management is crucial. For Blackjack, this involves managing the player and dealer's hands and scores using React state hooks. In Coin Flip, the state is managed through Move structs like `HouseData`, which track the house's balance and other game-related details.

- **Randomness and fair play:** Both games emphasize randomness for fairness. Both games use Sui's [on-chain randomness module](/guides/developer/advanced/randomness-onchain.mdx), ensuring verifiable and truly random outcomes for every game.

- **Smart contract interactions:** Each game involves smart contract interactions for game actions like placing bets, dealing cards (Blackjack), or making guesses (Coin Flip). These interactions are crucial for executing the game's logic on the blockchain.

### Differences

- **Game mechanics and complexity:** Blackjack is a more complex game with multiple actions (hit, stand, deal) and state updates, requiring a more dynamic frontend. In contrast, Coin Flip has a simpler mechanic centered around a single bet and guess outcome.

- **User interface (UI) complexity:** The Blackjack game involves a more intricate UI to display cards, manage game states, and player interactions. Coin Flip, being simpler in gameplay, requires a less complex UI.

- **Backend processing:** In Blackjack, the dealer is automated (the machine), and the player's actions directly influence game outcomes. In the Coin Flip game, the house (smart contract) plays a more passive role, primarily in initializing and finalizing the game based on the player's guess.

- **Module structure and focus:** The Blackjack game focuses more on frontend interactions and real-time updates. The Coin Flip game delves into backend logic with structures like `HouseCap` and `house_data` for initializing and managing game data securely on the blockchain.

- **Multi-version implementation:** The Coin Flip game mentions two versions: one susceptible to MEV attacks and another that is resistant, indicating a focus on security and user experience variations. Such variations aren't implemented in Blackjack.

:::info

The complete app example can be found in [the `blackjack-sui` repo](https://github.com/MystenLabs/blackjack-sui).

:::

>>>> sui/docs/content/guides/developer/app-examples/coin-flip.mdx
---
title: Coin Flip
description: Learn Sui through a coin flip dApp that covers the full end-to-end flow of building a Sui Move module and connecting it to a React Sui dApp.
keywords: [ react app, react dApp, react example, verifiable random functions, vrfs, randomness, shared objects, one-time witness, assets, address-owned objects, events, storage rebates, mev attack protection, mev attacks, example app, example dApp ] 
---

This example walks you through building a Coin Flip dApp, covering the full end-to-end flow of building your Sui Move module and connecting it to your React Sui dApp. This Coin Flip dApp utilizes verifiable random functions (VRFs) to create a fair coin game on the Sui blockchain. The user (human) plays against the house (module) and places a bet on either heads or tails. The user then either receives double their bet, or gets nothing, depending on the outcome of the game.

The guide is split into two parts:

1. [Smart Contracts](#smart-contracts): The Move code that sets up the coin flip logic.
1. [Frontend](#frontend): A UI that enables the players to place bets and take profits, and the admin to manage the house. 

<ImportContent source="prerequisites.mdx" mode="snippet" />

:::tip Additional resources

Source code locations for the smart contracts and frontend: 
- [Move package repository](https://github.com/MystenLabs/satoshi-coin-flip)
- [Frontend repository](https://github.com/sui-foundation/satoshi-coin-flip-frontend-example)

:::

## What the guide teaches

- **Shared objects:** The guide teaches you how to use [shared objects](concepts/object-ownership/shared.mdx), in this case to create a globally accessible `HouseData` object.
- **One-time witnesses:** The guide teaches you how to use [one-time witnesses](concepts/sui-move-concepts.mdx#one-time-witness) to ensure only a single instance of the `HouseData` object ever exists.
- **Asserts:** The guide teaches you how to use [asserts](https://move-book.com/move-basics/assert-and-abort.html?highlight=asserts#assert) to abort functions due to certain conditions not being met.
- **Address-owned objects:** The guide teaches you how to use [address-owned objects](concepts/object-ownership/address-owned.mdx) when necessary.
- **Events:** The guide teaches you how to emit events in your contracts, which can be used to track on-chain activity. For more information on events, see [Using Events](../sui-101/using-events.mdx) for practical usage of events on Sui or [Events in The Move Book](https://move-book.com/programmability/events.html) to learn about event structure and how to emit them in Move.
- **Storage rebates:** The guide shows you best practices regarding [storage fee rebates](concepts/tokenomics.mdx#storage-fund-rewards).
- **MEV attack protection:** The guide introduces you to [MEV attacks](https://github.com/MystenLabs/satoshi-coin-flip?tab=readme-ov-file#mev-attack-resistant-single-player-satoshi-smart-contract-flow), how to make your contracts MEV-resistant, and the trade-offs between protection and user experience.


## Smart contracts {#smart-contracts}

In this part of the guide, you write the Move contracts that manage the house and set up the coin-flip logic. The first step is to [set up a Move package](/guides/developer/getting-started/hello-world.mdx) for storing your Move modules.

:::info

To follow along with this guide, set your new Move package to `satoshi_flip`.

:::

### `house_data` module

This example uses several modules to create a package for the Satoshi Coin Flip game. The first module is `house_data.move`. You need to store the game's data somewhere, and in this module you create a [shared object](concepts/object-ownership/shared.mdx) for all house data.

Create a new file in the `sources` directory with the name `house_data.move` and populate the file with the following code:

```move title='house_data.move'
module satoshi_flip::house_data {

  use sui::balance::{Self, Balance};
  use sui::sui::SUI;
  use sui::coin::{Self, Coin};
  use sui::package::{Self};

  // Error codes
  const ECallerNotHouse: u64 = 0;
  const EInsufficientBalance: u64 = 1;

```

There are few details to take note of in this code:

1. The first line declares the module name as `house_data` within the package `satoshi_flip`.
1. Seven lines begin with the `use` keyword, which enables this module to use types and functions declared in other modules (in this case, they are all coming from the Sui standard library).
1. Two error codes. These codes are used in assertions and unit tests to ensure that the program is running as intended.

Next, add some more code to this module:

```move title='house_data.move'
  /// Configuration and Treasury object, managed by the house.
  public struct HouseData has key {
    id: UID,
    balance: Balance<SUI>,
    house: address,
    public_key: vector<u8>,
    max_stake: u64,
    min_stake: u64,
    fees: Balance<SUI>,
    base_fee_in_bp: u16
  }

  /// A one-time use capability to initialize the house data; created and sent
  /// to sender in the initializer.
  public struct HouseCap has key {
    id: UID
  }

  /// Used as a one time witness to generate the publisher.
  public struct HOUSE_DATA has drop {}

  fun init(otw: HOUSE_DATA, ctx: &mut TxContext) {
    // Creating and sending the Publisher object to the sender.
    package::claim_and_keep(otw, ctx);

    // Creating and sending the HouseCap object to the sender.
    let house_cap = HouseCap {
      id: object::new(ctx)
    };

    transfer::transfer(house_cap, ctx.sender());
  }
```

- The first struct, `HouseData`, stores the most essential information pertaining to the game.
- The second struct, `HouseCap`, is a capability that initializes the house data.
- The third struct, `HOUSE_DATA`, is a one-time witness that ensures only a single instance of this `HouseData` ever exists.
- The `init` function creates and sends the `Publisher` and `HouseCap` objects to the sender. See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in The Move Book for more information.

So far, you've set up the data structures within the module. Now, create a function that initializes the house data and shares the `HouseData` object:

```move title='house_data.move'
  public fun initialize_house_data(house_cap: HouseCap, coin: Coin<SUI>, public_key: vector<u8>, ctx: &mut TxContext) {
    assert!(coin.value() > 0, EInsufficientBalance);

    let house_data = HouseData {
      id: object::new(ctx),
      balance: coin.into_balance(),
      house: ctx.sender(),
      public_key,
      max_stake: 50_000_000_000, // 50 SUI, 1 SUI = 10^9.
      min_stake: 1_000_000_000, // 1 SUI.
      fees: balance::zero(),
      base_fee_in_bp: 100 // 1% in basis points.
    };

    let HouseCap { id } = house_cap;
    object::delete(id);

    transfer::share_object(house_data);
  }
```

With the house data initialized, you also need to add some functions that enable some important administrative tasks for the house to perform:

```move title='house_data.move'
  public fun top_up(house_data: &mut HouseData, coin: Coin<SUI>, _: &mut TxContext) {
    coin::put(&mut house_data.balance, coin)
  }

  public fun withdraw(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_balance = balance(house_data);
    let coin = coin::take(&mut house_data.balance, total_balance, ctx);
    transfer::public_transfer(coin, house_data.house());
  }

  public fun claim_fees(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw fee funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_fees = fees(house_data);
    let coin = coin::take(&mut house_data.fees, total_fees, ctx);
    transfer::public_transfer(coin, house_data.house());
  }

  public fun update_max_stake(house_data: &mut HouseData, max_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the base fee.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.max_stake = max_stake;
  }

  public fun update_min_stake(house_data: &mut HouseData, min_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the min stake.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.min_stake = min_stake;
  }
```

All of these functions contain an `assert!` call that ensures only the house can call them:

- `top_up`: Add to the balance of the house to ensure that there is enough SUI for future games.
- `withdraw`: Withdraw the entire balance of the house object.
- `claim_fees`: Withdraw the accumulated fees of the house object.
- `update_max_stake`, `update_min_stake`: Update the maximum and minimum stake allowed in the game, respectively.

You have established the data structure of this module, but without the appropriate functions this data is not accessible. Now add helper functions that return mutable references, read-only references, and test-only functions:

```move title='house_data.move'
  // --------------- Mutable References ---------------

  public(package) fun borrow_balance_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.balance
  }

  public(package) fun borrow_fees_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.fees
  }

  public(package) fun borrow_mut(house_data: &mut HouseData): &mut UID {
    &mut house_data.id
  }

  // --------------- Read-only References ---------------

  /// Returns a reference to the house id.
  public(package) fun borrow(house_data: &HouseData): &UID {
    &house_data.id
  }

  /// Returns the balance of the house.
  public fun balance(house_data: &HouseData): u64 {
    house_data.balance.value()
  }

  /// Returns the address of the house.
  public fun house(house_data: &HouseData): address {
    house_data.house
  }

  /// Returns the public key of the house.
  public fun public_key(house_data: &HouseData): vector<u8> {
    house_data.public_key
  }

  /// Returns the max stake of the house.
  public fun max_stake(house_data: &HouseData): u64 {
    house_data.max_stake
  }

  /// Returns the min stake of the house.
  public fun min_stake(house_data: &HouseData): u64 {
    house_data.min_stake
  }

  /// Returns the fees of the house.
  public fun fees(house_data: &HouseData): u64 {
    house_data.fees.value()
  }

  /// Returns the base fee.
  public fun base_fee_in_bp(house_data: &HouseData): u16 {
    house_data.base_fee_in_bp
  }

  // --------------- Test-only Functions ---------------

  #[test_only]
  public fun init_for_testing(ctx: &mut TxContext) {
    init(HOUSE_DATA {}, ctx);
  }
}
```

And with that, your `house_data.move` code is complete.

### `counter_nft` module

In the same `sources` directory, now create a file named `counter_nft.move`. A `Counter` object is used as the VRF input for every game that a player plays. First, populate the file with the following:

```move title='counter_nft.move'
module satoshi_flip::counter_nft {

  use sui::bcs::{Self};

  public struct Counter has key {
    id: UID,
    count: u64,
  }

  entry fun burn(self: Counter) {
    let Counter { id, count: _ } = self;
    object::delete(id);
  }

  public fun mint(ctx: &mut TxContext): Counter {
    Counter {
      id: object::new(ctx),
      count: 0
    }
  }

  public fun transfer_to_sender(counter: Counter, ctx: &mut TxContext) {
    transfer::transfer(counter, tx_context::sender(ctx));
  }
```

This might look familiar from the house module. You set the module name, import functions from the standard library, and initialize the `Counter` object. The `Counter` object has the `key` ability, but does not have `store` - this prevents the object from being transferable.

In addition, you create `mint` and `transfer_to_sender` functions used when the game is set up to create the `Counter` object (with an initial count of `0`) and transfer the object to the sender of the transaction. And finally a `burn` function to allow deletion of the `Counter`.

You have a `Counter` object, as well as functions that initialize and burn the object, but you need a way to increment the counter. Add the following code to the module:

```move title='counter_nft.move'
  public fun get_vrf_input_and_increment(self: &mut Counter): vector<u8> {
    let mut vrf_input = object::id_bytes(self);
    let count_to_bytes = bcs::to_bytes(&count(self));
    vrf_input.append(count_to_bytes);
    self.increment();
    vrf_input
  }

  public fun count(self: &Counter): u64 {
    self.count
  }

  fun increment(self: &mut Counter) {
    self.count = self.count + 1;
  }

  #[test_only]
  public fun burn_for_testing(self: Counter) {
    self.burn();
  }
}
```

The `get_vrf_input_and_increment` function is the core of this module. The function takes a mutable reference to the `Counter` object that the `mint` function creates, then appends the `Counter` object's current count to its ID and returns the result as a `vector<u8>`. The function then calls the internal `increment` function to increment the count by one.

This code also adds a `count` function that returns the current count, and a test-only function that calls the `burn` function.

### `single_player_satoshi` module

Lastly, you need a game module and object that can create a new game, distribute funds after the game, and potentially cancel games. Because this is a one-player game, create an [address-owned object](concepts/object-ownership/address-owned.mdx) rather than a [shared object](/concepts/object-ownership/shared.mdx).

Create the game module. In the `sources` directory, create a new file called `single_player_satoshi.move` and populate with the following:

```move title='single_player_satoshi.move'
module satoshi_flip::single_player_satoshi {
  use std::string::String;

  use sui::coin::{Self, Coin};
  use sui::balance::Balance;
  use sui::sui::SUI;
  use sui::bls12381::bls12381_min_pk_verify;
  use sui::event::emit;
  use sui::hash::{blake2b256};
  use sui::dynamic_object_field::{Self as dof};

  use satoshi_flip::counter_nft::Counter;
  use satoshi_flip::house_data::HouseData;

  const EPOCHS_CANCEL_AFTER: u64 = 7;
  const GAME_RETURN: u8 = 2;
  const PLAYER_WON_STATE: u8 = 1;
  const HOUSE_WON_STATE: u8 = 2;
  const CHALLENGED_STATE: u8 = 3;
  const HEADS: vector<u8> = b"H";
  const TAILS: vector<u8> = b"T";

  const EStakeTooLow: u64 = 0;
  const EStakeTooHigh: u64 = 1;
  const EInvalidBlsSig: u64 = 2;
  const ECanNotChallengeYet: u64 = 3;
  const EInvalidGuess: u64 = 4;
  const EInsufficientHouseBalance: u64 = 5;
  const EGameDoesNotExist: u64 = 6;

  public struct NewGame has copy, drop {
    game_id: ID,
    player: address,
    vrf_input: vector<u8>,
    guess: String,
    user_stake: u64,
    fee_bp: u16
  }

  public struct Outcome has copy, drop {
    game_id: ID,
    status: u8
  }
```

This code follows the same pattern as the others. First, you include the respective imports, although this time the imports are not only from the standard library but also include modules created previously in this example. You also create several constants (in upper case), as well as constants used for errors (Pascal case prefixed with `E`).

Lastly in this section, you also create structs for two events to emit. Indexers consume emitted events, which enables you to track these events through API services, or your own indexer. In this case, the events are for when a new game begins (`NewGame`) and for the outcome of a game when it has finished (`Outcome`).

Add a struct to the module:

```move title='single_player_satoshi.move'
  public struct Game has key, store {
    id: UID,
    guess_placed_epoch: u64,
    total_stake: Balance<SUI>,
    guess: String,
    player: address,
    vrf_input: vector<u8>,
    fee_bp: u16
  }
```

The `Game` struct represents a single game and all its information, including the epoch the player placed the bet (`guess_placed_epoch`), bet (`total_stake`), `guess`, address of the `player`, `vrf_input`, and the fee the house collects (`fee_bp`).

Now take a look at the main function in this game, `finish_game`:

```move title='single_player_satoshi.move'
  public fun finish_game(game_id: ID, bls_sig: vector<u8>, house_data: &mut HouseData, ctx: &mut TxContext) {
    // Ensure that the game exists.
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);

    let Game {
      id,
      guess_placed_epoch: _,
      mut total_stake,
      guess,
      player,
      vrf_input,
      fee_bp
    } = dof::remove<ID, Game>(house_data.borrow_mut(), game_id);

    object::delete(id);

    // Step 1: Check the BLS signature, if its invalid abort.
    let is_sig_valid = bls12381_min_pk_verify(&bls_sig, &house_data.public_key(), &vrf_input);
    assert!(is_sig_valid, EInvalidBlsSig);

    // Hash the beacon before taking the 1st byte.
    let hashed_beacon = blake2b256(&bls_sig);
    // Step 2: Determine winner.
    let first_byte = hashed_beacon[0];
    let player_won = map_guess(guess) == (first_byte % 2);

    // Step 3: Distribute funds based on result.
    let status = if (player_won) {
      // Step 3.a: If player wins transfer the game balance as a coin to the player.
      // Calculate the fee and transfer it to the house.
      let stake_amount = total_stake.value();
      let fee_amount = fee_amount(stake_amount, fee_bp);
      let fees = total_stake.split(fee_amount);
      house_data.borrow_fees_mut().join(fees);

      // Calculate the rewards and take it from the game stake.
      transfer::public_transfer(total_stake.into_coin(ctx), player);
      PLAYER_WON_STATE
    } else {
      // Step 3.b: If house wins, then add the game stake to the house_data.house_balance (no fees are taken).
      house_data.borrow_balance_mut().join(total_stake);
      HOUSE_WON_STATE
    };

    emit(Outcome {
      game_id,
      status
    });
  }
```

- First, the function makes sure the `Game` object exists, then deletes it, as after the game concludes the metadata is no longer needed. Freeing up unnecessary storage is not only recommended, but [incentivized through rebates on storage fees](concepts/tokenomics.mdx#storage-fund-rewards).
- In step 1, the function checks to see if the BLS signature is valid. This is to ensure the game is truly random.
- In step 2, the function checks to see if the player's guess, heads (`0`) or tails (`1`), is the same as that of the house. This is done by taking the first byte of the randomized vector and checking to see if it's divisible by two. If it is, it is heads, if it is not, it is tails.
- In step 3, if the player won, meaning the player's guess matched the results of the house, the logic transfers fees from the stake to the house, then distributes the rest of the principle plus an equal amount from the house's balance back to the player. If the player loses, the logic transfers the entire stake to the house, and takes no fees.
- Lastly, the game emits its outcome as an event.

Now add a function that handles game disputes:

```move title='single_player_satoshi.move'
  public fun dispute_and_win(house_data: &mut HouseData, game_id: ID, ctx: &mut TxContext) {
    // Ensure that the game exists.
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);

    let Game {
      id,
      guess_placed_epoch,
      total_stake,
      guess: _,
      player,
      vrf_input: _,
      fee_bp: _
    } = dof::remove(house_data.borrow_mut(), game_id);

    object::delete(id);

    let caller_epoch = ctx.epoch();
    let cancel_epoch = guess_placed_epoch + EPOCHS_CANCEL_AFTER;
    // Ensure that minimum epochs have passed before user can cancel.
    assert!(cancel_epoch <= caller_epoch, ECanNotChallengeYet);

    transfer::public_transfer(total_stake.into_coin(ctx), player);

    emit(Outcome {
      game_id,
      status: CHALLENGED_STATE
    });
  }
```

This function, `dispute_and_win`, ensures that no bet can live in â€œpurgatoryâ€. After a certain amount of time passes, the player can call this function and get all of their funds back.

The rest of the functions are accessors and helper functions used to retrieve values, check if values exist, initialize the game, and so on:

```move title='single_player_satoshi.move'
  // --------------- Read-only References ---------------

  public fun guess_placed_epoch(game: &Game): u64 {
    game.guess_placed_epoch
  }

  public fun stake(game: &Game): u64 {
    game.total_stake.value()
  }

  public fun guess(game: &Game): u8 {
    map_guess(game.guess)
  }

  public fun player(game: &Game): address {
    game.player
  }

  public fun vrf_input(game: &Game): vector<u8> {
    game.vrf_input
  }

  public fun fee_in_bp(game: &Game): u16 {
    game.fee_bp
  }

  // --------------- Helper functions ---------------

  /// Public helper function to calculate the amount of fees to be paid.
  public fun fee_amount(game_stake: u64, fee_in_bp: u16): u64 {
    ((((game_stake / (GAME_RETURN as u64)) as u128) * (fee_in_bp as u128) / 10_000) as u64)
  }

  /// Helper function to check if a game exists.
  public fun game_exists(house_data: &HouseData, game_id: ID): bool {
    dof::exists_(house_data.borrow(), game_id)
  }

  /// Helper function to check that a game exists and return a reference to the game Object.
  /// Can be used in combination with any accessor to retrieve the desired game field.
  public fun borrow_game(game_id: ID, house_data: &HouseData): &Game {
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);
    dof::borrow(house_data.borrow(), game_id)
  }

  /// Internal helper function used to create a new game.
  fun internal_start_game(guess: String, counter: &mut Counter, coin: Coin<SUI>, house_data: &mut HouseData, fee_bp: u16, ctx: &mut TxContext): (ID, Game) {
    // Ensure guess is valid.
    map_guess(guess);
    let user_stake = coin.value();
    // Ensure that the stake is not higher than the max stake.
    assert!(user_stake <= house_data.max_stake(), EStakeTooHigh);
    // Ensure that the stake is not lower than the min stake.
    assert!(user_stake >= house_data.min_stake(), EStakeTooLow);
    // Ensure that the house has enough balance to play for this game.
    assert!(house_data.balance() >= user_stake, EInsufficientHouseBalance);

    // Get the house's stake.
    let mut total_stake = house_data.borrow_balance_mut().split(user_stake);
    coin::put(&mut total_stake, coin);

    let vrf_input = counter.get_vrf_input_and_increment();

    let id = object::new(ctx);
    let game_id = object::uid_to_inner(&id);

    let new_game = Game {
      id,
      guess_placed_epoch: ctx.epoch(),
      total_stake,
      guess,
      player: ctx.sender(),
      vrf_input,
      fee_bp
    };

    emit(NewGame {
      game_id,
      player: ctx.sender(),
      vrf_input,
      guess,
      user_stake,
      fee_bp
    });

    (game_id, new_game)
  }

  /// Helper function to map (H)EADS and (T)AILS to 0 and 1 respectively.
  /// H = 0
  /// T = 1
  fun map_guess(guess: String): u8 {
    let heads = HEADS;
    let tails = TAILS;
    assert!(guess.bytes() == heads || guess.bytes() == tails, EInvalidGuess);

    if (guess.bytes() == heads) {
      0
    } else {
      1
    }
  }
}
```

## Finished package

This represents a basic example of a coin flip backend in Move. The game module, `single_player_satoshi`, is prone to MEV attacks, but the user experience for the player is streamlined. Another example game module, `mev_attack_resistant_single_player_satoshi`, exists that is MEV-resistant, but has a slightly downgraded user experience (two player-transactions per game).

You can read more about both versions of the game, and view the full source code for all the modules in the [Satoshi Coin Flip repository](https://github.com/MystenLabs/satoshi-coin-flip).

Now that you have written our contracts, it's time to deploy them.

### Deployment {#deployment}

<ImportContent source="initialize-sui-client-cli.mdx" mode="snippet" />

Next, configure the Sui CLI to use `testnet` as the active environment, as well. If you haven't already set up a `testnet` environment, do so by running the following command in a terminal or console:

```sh
$ sui client new-env --alias testnet --rpc https://fullnode.testnet.sui.io:443
```

Run the following command to activate the `testnet` environment:

```sh
$ sui client switch --env testnet
```

<ImportContent source="publish-to-devnet-with-coins.mdx" mode="snippet" />

The output of this command contains a `packageID` value that you need to save to use the package.

Partial snippet of CLI deployment output.

```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object Changes                                                                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Created Objects:                                                                                         â”‚
â”‚  â”Œâ”€â”€                                                                                                     â”‚
â”‚  â”‚ ObjectID: 0x17e9468127384cfff5523940586f5617a75fac8fd93f143601983523ae9c9f31                          â”‚
â”‚  â”‚ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            â”‚
â”‚  â”‚ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         â”‚
â”‚  â”‚ ObjectType: 0x2::package::UpgradeCap                                                                  â”‚
â”‚  â”‚ Version: 75261540                                                                                     â”‚
â”‚  â”‚ Digest: 9ahkhuGYTNYi5GucCqmUHyBuWoV2R3rRqBu553KBPVv8                                                  â”‚
â”‚  â””â”€â”€                                                                                                     â”‚
â”‚  â”Œâ”€â”€                                                                                                     â”‚
â”‚  â”‚ ObjectID: 0xa01d8d5ba121e7771547e749a787b4dd9ff8cc32e341c898bab5d12c46412a23                          â”‚
â”‚  â”‚ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            â”‚
â”‚  â”‚ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         â”‚
â”‚  â”‚ ObjectType: 0x2::package::Publisher                                                                   â”‚
â”‚  â”‚ Version: 75261540                                                                                     â”‚
â”‚  â”‚ Digest: Ba9VU2dUqg3NHkwQ4t5AKDLJQuiFZnnxvty2xREQKWm9                                                  â”‚
â”‚  â””â”€â”€                                                                                                     â”‚
â”‚  â”Œâ”€â”€                                                                                                     â”‚
â”‚  â”‚ ObjectID: 0xfa1f6edad697afca055749fedbdee420b6cdba3edc2f7fd4927ed42f98a7e63a                          â”‚
â”‚  â”‚ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            â”‚
â”‚  â”‚ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         â”‚
â”‚  â”‚ ObjectType: 0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8::house_data::HouseCap  â”‚
â”‚  â”‚ Version: 75261540                                                                                     â”‚
â”‚  â”‚ Digest: 5326hf6zWgdiNgr63wvwKkhUNtnTFkp82e9vfS5QHy3n                                                  â”‚
â”‚  â””â”€â”€                                                                                                     â”‚
â”‚ Mutated Objects:                                                                                         â”‚
â”‚  â”Œâ”€â”€                                                                                                     â”‚
â”‚  â”‚ ObjectID: 0x0e4eb516f8899e116a26f927c8aaddae8466c8cdc3822f05c15159e3a8ff8006                          â”‚
â”‚  â”‚ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                            â”‚
â”‚  â”‚ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 )         â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                            â”‚
â”‚  â”‚ Version: 75261540                                                                                     â”‚
â”‚  â”‚ Digest: Ezmi94kWCfjRzgGTwnXehv9ipPvYQ7T6Z4wefPLRQPPY                                                  â”‚
â”‚  â””â”€â”€                                                                                                     â”‚
â”‚ Published Objects:                                                                                       â”‚
â”‚  â”Œâ”€â”€                                                                                                     â”‚
â”‚  â”‚ PackageID: 0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8                         â”‚
â”‚  â”‚ Version: 1                                                                                            â”‚
â”‚  â”‚ Digest: 5XbJkgx8RSccxaHoP3xinY2fMMhwKJ7qoWfp349cmZBg                                                  â”‚
â”‚  â”‚ Modules: counter_nft, house_data, single_player_satoshi                                               â”‚
â”‚  â””â”€â”€                                                                                                     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

Save the `PackageID` and the `ObjectID` of the `HouseCap` object you receive in your own response to [connect to your frontend](#connecting-your-package).

In this case, the `PackageID` is `0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8` and the `HouseCap` ID is `0xfa1f6edad697afca055749fedbdee420b6cdba3edc2f7fd4927ed42f98a7e63a`.

### Next steps

Well done. You have written and deployed the Move package. ðŸŽ‰ 

To turn this into a complete dApp, you need to [create a frontend](#frontend).

## Frontend {#frontend}

In this final part of the dApp example, you build a frontend (UI) that allows end users to place bets and take profits, and lets the admin manage the house.

:::info

To skip building the frontend and test out your newly deployed package, use the provided [Satoshi Coin Flip Frontend Example repository](https://github.com/sui-foundation/satoshi-coin-flip-frontend-example) and follow the instructions in the example's `README.md` file

:::

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install).

- [x] [Deploy the complete `satoshi_flip` Move package](#smart-contracts) and understand its design.

- [x] Install [`pnpm`](https://pnpm.io/installation) or [`yarn`](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable) to use as the package manager.

</TabItem>
</Tabs>


:::tip Additional resources

- [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript) for basic usage on how to interact with Sui using TypeScript.
- [Sui dApp Kit](https://sdk.mystenlabs.com/dapp-kit) to learn basic building blocks for developing a dApp in the Sui ecosystem with React.js.
- [`@mysten/dapp`](https://sdk.mystenlabs.com/dapp-kit/create-dapp), used within this project to quickly scaffold a React-based Sui dApp.

:::

### Overview

The UI of this example demonstrates how to use the dApp Kit instead of serving as a production-grade product, so the Player and the House features are in the same UI to simplify the process. In a production solution, your frontend would only contain functionality dedicated to the Player, with a backend service carrying out the interactions with House functions in the smart contracts.

The UI has two columns:

- First column is dedicated to the Player, and all Player-related features live there
- Second column is dedicated to the House, and all House-related features live there

### Scaffold a new app

The first step is to set up the client app. Run the following command to scaffold a new app.

```sh
$ pnpm create @mysten/dapp --template react-client-dapp
```

or

```sh
$ yarn create @mysten/dapp --template react-client-dapp
```

### Project folder structure

Structure the project folder according to the UI layout, meaning that all Player-related React components reside in the `containers/Player` folder, while all House-related React components reside in the `containers/House` folder.

### Connecting your deployed package {#connecting-your-package}

Add the `packageId` value you saved from [deploying your package](#deployment) to a new `src/constants.ts` file in your project:

```ts
export const PACKAGE_ID =
  "0x4120b39e5d94845aa539d4b830743a7433fd8511bdcf3841f98080080f327ca8";
export const HOUSECAP_ID =
  "0xfa1f6edad697afca055749fedbdee420b6cdba3edc2f7fd4927ed42f98a7e63a";
```

### Exploring the code

The UI interacts with the [Single Player smart contract](guides/developer/app-examples/coin-flip.mdx#game-module) variant of the game. This section walks you through each step in the smart contract flow and the corresponding frontend code.

:::info

The following frontend code snippets include only the most relevant sections. Refer to the [Satoshi Coin Flip Frontend Example repository](https://github.com/sui-foundation/satoshi-coin-flip-frontend-example) for complete source code.

:::

As is common in other React projects, `App.tsx` is where you implement the outer layout:

```typescript title='App.tsx'
import { ConnectButton, useCurrentAccount } from '@mysten/dapp-kit';
import { InfoCircledIcon } from '@radix-ui/react-icons';
import { Box, Callout, Container, Flex, Grid, Heading } from '@radix-ui/themes';

import { HOUSECAP_ID, PACKAGE_ID } from './constants';
import { HouseSesh } from './containers/House/HouseSesh';
import { PlayerSesh } from './containers/Player/PlayerSesh';

function App() {
  const account = useCurrentAccount();
  return (
    <>
      <Flex
        position="sticky"
        px="4"
        py="2"
        justify="between"
        style={{
          borderBottom: '1px solid var(--gray-a2)',
        }}
      >
        <Box>
          <Heading>Satoshi Coin Flip Single Player</Heading>
        </Box>

        <Box>
          <ConnectButton />
        </Box>
      </Flex>
      <Container>
        <Heading size="4" m={'2'}>
          Package ID: {PACKAGE_ID}
        </Heading>
        <Heading size="4" m={'2'}>
          HouseCap ID: {HOUSECAP_ID}
        </Heading>

        <Callout.Root mb="2">
          <Callout.Icon>
            <InfoCircledIcon />
          </Callout.Icon>
          <Callout.Text>
            You need to connect to wallet that publish the smart contract package
          </Callout.Text>
        </Callout.Root>

        {!account ? (
          <Heading size="4" align="center">
            Please connect wallet to continue
          </Heading>
        ) : (
          <Grid columns="2" gap={'3'} width={'auto'}>
            <PlayerSesh />
            <HouseSesh />
          </Grid>
        )}
      </Container>
    </>
  );
}

export default App;
```

Like other dApps, you need a "connect wallet" button to enable connecting users' wallets. dApp Kit contains a pre-made `ConnectButton` React component that you can reuse to help users onboard.

`useCurrentAccount()` is a React hook the dApp Kit also provides to query the current connected wallet; returning `null` if there isn't a wallet connection. Leverage this behavior to prevent a user from proceeding further if they haven't connected their wallet yet.

After ensuring that the user has connected their wallet, you can display the two columns described in the previous section: `PlayerSesh` and `HouseSesh` components.

Okay, that's a good start to have an overview of the project. Time to move to initializing the `HouseData` object. All the frontend logic for calling this lives in the `HouseInitialize.tsx` component. The component includes UI code, but the logic that executes the transaction follows:

```typescript title='containers/House/HouseInitialize.tsx'
<form
  onSubmit={(e) => {
    e.preventDefault();

    // Create new transaction
    const txb = new Transaction();
    // Split gas coin into house stake coin
    // SDK will take care for us abstracting away of up-front coin selections
    const [houseStakeCoin] = txb.splitCoins(txb.gas, [
      MIST_PER_SUI * BigInt(houseStake),
    ]);
    // Calling smart contract function
    txb.moveCall({
      target: `${PACKAGE_ID}::house_data::initialize_house_data`,
      arguments: [
        txb.object(HOUSECAP_ID),
        houseStakeCoin,
        // This argument is not an on-chain object, hence, we must serialize it using `bcs`
        // https://sdk.mystenlabs.com/typescript/transaction-building/basics#pure-values
        txb.pure(
          bcs
            .vector(bcs.U8)
            .serialize(curveUtils.hexToBytes(getHousePubHex())),
        ),
      ],
    });

    execInitializeHouse(
      {
        transaction: txb,
        options: {
          showObjectChanges: true,
        },
      },
      {
        onError: (err) => {
          toast.error(err.message);
        },
        onSuccess: (result: SuiTransactionBlockResponse) => {
          let houseDataObjId;


          result.objectChanges?.some((objCh) => {
            if (
              objCh.type === "created" &&
              objCh.objectType === `${PACKAGE_ID}::house_data::HouseData`
            ) {
              houseDataObjId = objCh.objectId;
              return true;
            }
          });

          setHouseDataId(houseDataObjId!);

          toast.success(`Digest: ${result.digest}`);
        },
      },
    );
  }}
```

To use a [programmable transaction block](/concepts/transactions/prog-txn-blocks.mdx) (PTB) in Sui, create a `Transaction`. To initiate a Move call, you must know the global identifier of a public function in your smart contract. The global identifier usually takes the following form:

```
${PACKAGE_ID}::${MODULE_NAME}::${FUNCTION_NAME}
```

In this example, it is:

```
${PACKAGE_ID}::house_data::initialize_house_data
```

There are a few parameters that you need to pass into `initialize_house_data()` Move function: the `HouseCap` ID, the House stake, and the House BLS public key:

- Import the `HouseCap` ID from `constants.ts`, which you set up in the previous section.
- Use `Transaction::splitCoin` for the House stake to create a new coin with a defined amount split from the Gas Coin `txb.gas`. Think of the gas coin as one singular coin available for gas payment from your account (which might cover the entire remaining balance of your account). This is useful for Sui payments - instead of manually selecting the coins for gas payment or manually splitting/merging to have the coin with correct amount for your Move call, the gas coin is the single entry point for this, with all the heavy lifting delegated to the SDK behind the scenes.
- Pass the BLS public key as bytes `vector<u8>`. When providing inputs that are not on-chain objects, serialize them as BCS using a combination of `txb.pure` and `bcs` imported from `@mysten/sui/bcs`.

Now sign and execute the transaction block. dApp Kit provides a React hook `useSignAndExecuteTransaction()` to streamline this process. This hook, when executed, prompts the UI for you to approve, sign, and execute the transaction block. You can configure the hook with the `showObjectChanges` option to return the newly-created `HouseData` shared object as the result of the transaction block. This `HouseData` object is important as you use it as input for later Move calls, so save its ID somewhere.

Great, now you know how to initialize the `HouseData` shared object. Move to the next function call.

In this game, the users must create a `Counter` object to start the game. So there should be a place in the Player column UI to list the existing `Counter` object information for the player to choose. It seems likely that you will reuse the fetching logic for the `Counter` object in several places in your UI, so it's good practice to isolate this logic into a React hook, which you call `useFetchCounterNft()` in `useFetchCounterNft.ts`:

```typescript title='containers/Player/useFetchCounterNft.ts'
import { useCurrentAccount, useSuiClientQuery } from '@mysten/dapp-kit';

import 'react';

import { PACKAGE_ID } from '../../constants';

// React hook to fetch CounterNFT owned by connected wallet
// This hook is to demonstrate how to use `@mysten/dapp-kit` React hook to query data
// besides using SuiClient directly
export function useFetchCounterNft() {
  const account = useCurrentAccount();

  if (!account) {
    return { data: [] };
  }

  // Fetch CounterNFT owned by current connected wallet
  // Only fetch the 1st one
  const { data, isLoading, isError, error, refetch } = useSuiClientQuery(
    'getOwnedObjects',
    {
      owner: account.address,
      limit: 1,
      filter: {
        MatchAll: [
          {
            StructType: `${PACKAGE_ID}::counter_nft::Counter`,
          },
          {
            AddressOwner: account.address,
          },
        ],
      },
      options: {
        showOwner: true,
        showType: true,
      },
    },
    { queryKey: ['CounterNFT'] },
  );

  return {
    data: data && data.data.length > 0 ? data?.data : [],
    isLoading,
    isError,
    error,
    refetch,
  };
}
```

This hook logic is very basic: if there is no current connected wallet, return empty data; otherwise, fetch the `Counter` object and return it. dApp Kit provides a React hook, `useSuiClientQuery()`, that enables interaction with [Sui RPC](references/sui-api.mdx) methods. Different RPC methods require different parameters. To fetch the object owned by a known address, use the [`getOwnedObjects` query](/sui-api-ref#suix_getownedobjects).

Now, pass the address of the connected wallet, as well as the global identifier for the `Counter`. This is in similar format to the global identifier type for function calls:

`${PACKAGE_ID}::counter_nft::Counter`

That's it, now put the hook into the UI component `PlayerListCounterNft.tsx` and display the data:

```typescript title='containers/Player/PlayerListCounterNft.tsx'
export function PlayerListCounterNft() {
  const { data, isLoading, error, refetch } = useFetchCounterNft();
  const { mutate: execCreateCounterNFT } = useSignAndExecuteTransaction();

  return (
    <Container mb={'4'}>
      <Heading size="3" mb="2">
        Counter NFTs
      </Heading>

      {error && <Text>Error: {error.message}</Text>}

      <Box mb="3">
        {data.length > 0 ? (
          data.map((it) => {
            return (
              <Box key={it.data?.objectId}>
                <Text as="div" weight="bold">
                  Object ID:
                </Text>
                <Text as="div">{it.data?.objectId}</Text>
                <Text as="div" weight="bold">
                  Object Type:
                </Text>
                <Text as="div">{it.data?.type}</Text>
              </Box>
            );
          })
        ) : (
          <Text>No CounterNFT Owned</Text>
        )}
      </Box>
    </Container>
  );
}
```

For the case when there is no existing `Counter` object, mint a new `Counter` for the connected wallet. Also add the minting logic into `PlayerListCounterNft.tsx` when the user clicks the button. You already know how to build and execute a Move call with `TransactionBlock` and `initialize_house_data()`, you can implement a similar call here.

As you might recall with `Transaction`, outputs from the transaction can be inputs for the next transaction. Call `counter_nft::mint()`, which returns the newly created `Counter` object, and use it as input for `counter_nft::transfer_to_sender()` to transfer the `Counter` object to the caller wallet:

```typescript title='containers/Player/PlayerListCounterNft.tsx'
const txb = new Transaction();
const [counterNft] = txb.moveCall({
  target: `${PACKAGE_ID}::counter_nft::mint`,
});
txb.moveCall({
  target: `${PACKAGE_ID}::counter_nft::transfer_to_sender`,
  arguments: [counterNft],
});

execCreateCounterNFT(
  {
    transaction: txb,
  },
  {
    onError: (err) => {
      toast.error(err.message);
    },
    onSuccess: (result) => {
      toast.success(`Digest: ${result.digest}`);
      refetch?.();
    },
  },
);
```

Great, now you can create the game with the created `Counter` object. Isolate the game creation logic into `PlayerCreateGame.tsx`. There is one more thing to keep in mind - to flag an input as an on-chain object, you should use `txb.object()` with the corresponding object ID.

```typescript title='containers/Player/PlayerCreateGame.tsx'
// Create new transaction
const txb = new Transaction();

// Player stake
const [stakeCoin] = txb.splitCoins(txb.gas, [MIST_PER_SUI * BigInt(stake)]);

// Create the game with CounterNFT
txb.moveCall({
  target: `${PACKAGE_ID}::single_player_satoshi::start_game`,
  arguments: [
    txb.pure.string(guess),
    txb.object(counterNFTData[0].data?.objectId!),
    stakeCoin,
    txb.object(houseDataId),
  ],
});

execCreateGame(
  {
    transaction: txb,
  },
  {
    onError: (err) => {
      toast.error(err.message);
    },
    onSuccess: (result: SuiTransactionBlockResponse) => {
      toast.success(`Digest: ${result.digest}`);
    },
  },
);
```

One final step remains: settle the game. There are a couple of ways you can use the UI to settle the game:

1. Create a Settle Game button and pass all the necessary arguments to the `single_player_satoshi::finish_game()` Move call.
1. Settle the game automatically through an events subscription. This example uses this path to teach good practices on events and how to subscribe to them.

:::info

Event subscriptions are deprecated. To learn future-safe methods to work with events, see [Using Events](../sui-101/using-events.mdx).

:::

All of this logic is in `HouseFinishGame.tsx`:

```typescript title='containers/House/HouseFinishGame.tsx'
// This component will help the House to automatically finish the game whenever new game is started
export function HouseFinishGame() {
  const suiClient = useSuiClient();
  const { mutate: execFinishGame } = useSignAndExecuteTransactionBlock();

  const [housePrivHex] = useContext(HouseKeypairContext);
  const [houseDataId] = useContext(HouseDataContext);

  useEffect(() => {
    // Subscribe to NewGame event
    const unsub = suiClient.subscribeEvent({
      filter: {
        MoveEventType: `${PACKAGE_ID}::single_player_satoshi::NewGame`,
      },
      onMessage(event) {
        console.log(event);
        const { game_id, vrf_input } = event.parsedJson as {
          game_id: string;
          vrf_input: number[];
        };

        toast.info(`NewGame started ID: ${game_id}`);

        console.log(housePrivHex);

        try {
          const houseSignedInput = bls.sign(
            new Uint8Array(vrf_input),
            curveUtils.hexToBytes(housePrivHex),
          );

          // Finish the game immediately after new game started
          const txb = new Transaction();
          txb.moveCall({
            target: `${PACKAGE_ID}::single_player_satoshi::finish_game`,
            arguments: [
              txb.pure.id(game_id),
              txb.pure(bcs.vector(bcs.U8).serialize(houseSignedInput)),
              txb.object(houseDataId),
            ],
          });
          execFinishGame(
            {
              transaction: txb,
            },
            {
              onError: (err) => {
                toast.error(err.message);
              },
              onSuccess: (result: SuiTransactionBlockResponse) => {
                toast.success(`Digest: ${result.digest}`);
              },
            },
          );
        } catch (err) {
          console.error(err);
        }
      },
    });

    return () => {
      (async () => (await unsub)())();
    };
  }, [housePrivHex, houseDataId, suiClient]);

  return null;
}
```

To get the underlying `SuiClient` instance from the SDK, use `useSuiClient()`. You want to subscribe to events whenever the `HouseFinishGame` component loads. To do this, use the React hook `useEffect()` from the core React library.

`SuiClient` exposes a method called `subscribeEvent()` that enables you to subscribe to a variety of event types. `SuiClient::subscribeEvent()` is actually a thin wrapper around the RPC method [`suix_subscribeEvent`](/sui-api-ref#suix_subscribeevent).

The logic is that whenever a new game starts, you want to settle the game immediately. The necessary event to achieve this is the Move event type called `single_player_satoshi::NewGame`. If you inspect the parsed payload of the event through `event.parsedJson`, you can see the corresponding event fields declared in the smart contract. In this case, you just need to use two fields, the Game ID and the VRF input.

The next steps are similar to the previous Move calls, but you have to use the BLS private key to sign the VRF input and then pass the Game ID, signed VRF input and `HouseData` ID to the `single_player_satoshi::finish_game()` Move call.

Last but not least, remember to unsubscribe from the event whenever the `HouseFinishGame` component dismounts. This is important as you might not want to subscribe to the same event multiple times.

Congratulations, you completed the frontend. You can carry the lessons learned here forward when using the dApp Kit to build your next Sui project.

>>>> sui/docs/content/guides/developer/app-examples/e2e-counter.mdx
---
title: Distributed Counter
description: An app that allows users to create counters that anyone can increment, but only the owner can reset.
effort: small
keywords: [ distributed counter, example dApp, example app, react app, react dApp, increment counter, shared objects, programmable transaction blocks ptbs ]
---

This example walks you through building a basic distributed counter app, covering the full end-to-end flow of building your Sui Move module and connecting it to your React Sui dApp. The app allows users to create counters that anyone can increment, but only the owner can reset. 

The guide is split into two parts:

1. [Smart Contracts](#smart-contracts): The Move code that sets up the `Counter` structure and logic.
1. [Frontend](#frontend): A UI that enables users to create, increment, and reset `Counter` objects.

<ImportContent source="prerequisites.mdx" mode="snippet" />

:::tip Additional resources

[Example source code](https://github.com/MystenLabs/sui/blob/60bb8bdc274b9e5706fd916cd84c13f81e832529/sdk/create-dapp/templates/react-e2e-counter)

:::

## What the guide teaches

- **Shared objects:** The guide teaches you how to use [shared objects](../../../concepts/object-ownership/shared.mdx), in this case to create globally accessible `Counter` objects.
- **Programmable transaction blocks (PTBs):** You learn how to use PTBs to interact with your Move module from your frontend.

## Directory structure

To begin, create a new folder on your system titled `react-e2e-counter` to hold all your project files. You can name this directory differently, but the rest of the guide references this file structure. Inside that folder, create two more folders: `move` and `src`. Inside the `move` folder, create a `counter` directory. Finally, create a `sources` folder inside `counter`. Different projects have their own directory structure, but it's common to split code into functional groups to help with maintenance. See ["Hello, World!"](/guides/developer/getting-started/hello-world.mdx) to learn more about package structure and how to use the Sui CLI to scaffold a new project.

:::checkpoint

- You have the latest version of Sui installed. If you run `sui --version` in your terminal or console, it responds with the currently installed version.
- Your active environment is pointing to the expected network. Run `sui client active-env` to make sure. If you receive a warning about a client and server API version mismatch, update Sui using the version in the relevant branch (`mainnet`, `testnet`, `devent`) of the Sui repo.
- Your active address has SUI. Run `sui client balance` in your terminal or console. If there is no balance, [acquire SUI](../getting-started/get-coins.mdx) from the faucet (not available in Mainnet).
- You have a directory to place the files you create in. The top-level directory is named `react-e2e-counter` if you want to match the directory structure in this guide. 

:::

:::tip
    
<ImportContent source="faucet-online.mdx" mode="snippet" />

:::

## Smart contracts {#smart-contracts}

In this part of the guide, you write the Move contracts that create, increment, and reset counters.

### `Move.toml`

To begin writing your smart contracts, create a file inside `react-e2e-counter/move/counter` named `Move.toml` and copy the following code into it. This is the package manifest file. If you want to learn more about the structure of the file, see [Package Manifest](https://move-book.com/concepts/manifest.html) in The Move Book.

:::info

If you are targeting a network other than Testnet, be sure to update the `rev` value for the Sui dependency.

:::

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/move/counter/Move.toml" mode="code" org="MystenLabs" repo="ts-sdks" />

### `Counter` struct

To begin creating the smart contract that defines the on-chain counter, create a `counter.move` file inside your `react-e2e-counter/move/counter/sources` folder. Define the module that holds your smart contract logic.

```move
module counter::counter {
  // Code goes here
}
```

Add the `Counter` struct and elements described in the following sections to the module. 

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move" mode="code" struct="Counter" org="MystenLabs" repo="ts-sdks" noComments />

- The `Counter` type stores the address of its `owner`, its current `value`, and its own `id`.

### Creating `Counter`

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move" mode="code" fun="create" org="MystenLabs" repo="ts-sdks" noComments />

In the `create` function, a new `Counter` object is created and [shared](../../../concepts/object-ownership/shared.mdx). 

### Incrementing and resetting `Counter`

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move" mode="code" fun="increment" org="MystenLabs" repo="ts-sdks" noComments />

The `increment` function accepts a mutable reference to any shared `Counter` object and increments its `value` field.

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move" mode="code" fun="set_value" org="MystenLabs" repo="ts-sdks" noComments />

The `set_value` function accepts a mutable reference to any shared `Counter` object, the `value` to set its `value` field, and the `ctx` which contains the `sender` of the transaction. The `Counter` `owner` is the only one that can run this function.

:::tip Additional resources

Learn more about taking [object references as input](https://move-book.com/move-basics/references.html)

:::

## Finished package

The final module should look like this

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/move/counter/sources/counter.move" mode="code" org="MystenLabs" repo="ts-sdks" noComments />

:::checkpoint

Your smart contract is complete. You should be able to run the `sui move build` command from `react-e2e-counter/move/counter` and receive a response similar to the following:
```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING counter
```
You always run `sui move build` at the same level as your `Move.toml` file. After a successful build, you now have a `build` folder inside `react-e2e-counter/move/counter`.

:::

### Deployment {#deployment}

<ImportContent source="initialize-sui-client-cli.mdx" mode="snippet" />

Next, configure the Sui CLI to use `testnet` as the active environment, as well. If you haven't already set up a `testnet` environment, do so by running the following command in a terminal or console:

```sh
$ sui client new-env --alias testnet --rpc https://fullnode.testnet.sui.io:443
```

Run the following command to activate the `testnet` environment:

```sh
$ sui client switch --env testnet
```

<ImportContent source="publish-to-devnet-with-coins.mdx" mode="snippet" />

The output of this command contains a `packageID` value that you need to save to use the package.

Partial snippet of CLI deployment output.

```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Created Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0x7530c33e4cf3345236601d69303e3fab84efc294194a810dc1cfea13c009e77f                  â”‚
â”‚  â”‚ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 ) â”‚
â”‚  â”‚ ObjectType: 0x2::package::UpgradeCap                                                          â”‚
â”‚  â”‚ Version: 47482286                                                                             â”‚
â”‚  â”‚ Digest: 5aEez7HkJ82Xs5ZArPHJF6Ty38UtprsCvEiyy22hBVRE                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚ Mutated Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0x0fcc6d770d80aa409a9645e78ac4810be6400919ac7f507bddd2f9d279da509f                  â”‚
â”‚  â”‚ Sender: 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x8e8cae7791a93778800b88b6a274de5c32a86484593568d38619c7ea71999654 ) â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    â”‚
â”‚  â”‚ Version: 47482286                                                                             â”‚
â”‚  â”‚ Digest: A6TH6ja5TM4S6nZBwB14AB17ZgixCijYX1aNMGHF3syv                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚ Published Objects:                                                                               â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ PackageID: 0x7b6a8f5782e57cd948dc75ee098b73046a79282183d51eefb83d31ec95c312aa                 â”‚
â”‚  â”‚ Version: 1                                                                                    â”‚
â”‚  â”‚ Digest: FKAZc1cmQ9FUYudDQBjZPTb1uXDnekKRUbAALuVnwURC                                          â”‚
â”‚  â”‚ Modules: counter                                                                              â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

Store the `PackageID` value you receive in your own response to [connect to your frontend](#connecting-your-package).

### Next steps

Well done. You have written and deployed the Move package. ðŸŽ‰ 

To turn this into a complete dApp, you need to [create a frontend](#frontend).


## Frontend {#frontend}

In this final part of the app example, you build a frontend (UI) that allows end users to create, increment, and reset `Counter` objects.


:::info

To skip building the frontend and test out your newly deployed package, create this example using the following template and follow the instructions in the template's `README.md` file: 

<Tabs groupId="packagemanager">
<TabItem label="PNPM" value="pnpm">

```sh
$ pnpm create @mysten/dapp --template react-e2e-counter
```

</TabItem>

<TabItem label="Yarn" value="yarn">

```sh
$ yarn create @mysten/dapp --template react-e2e-counter
```

</TabItem>
</Tabs>

:::

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install).

- [x] [Deploy the complete `counter` Move module](#smart-contracts) and understand its design.

- [x] Install [`pnpm`](https://pnpm.io/installation) or [`yarn`](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable) to use as the package manager.

</TabItem>
</Tabs>

:::tip Additional resources

- [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript) for basic usage on how to interact with Sui using TypeScript.
- [Sui dApp Kit](https://sdk.mystenlabs.com/dapp-kit) to learn basic building blocks for developing a dApp in the Sui ecosystem with React.js.
- [`@mysten/dapp`](https://sdk.mystenlabs.com/dapp-kit/create-dapp), used within this project to quickly scaffold a React-based Sui dApp.

:::

### Overview

The UI design consists of two parts:

- A button for users to create new `Counter` objects
- A `Counter` UI for users to view the `value`, and to increment and reset the `Counter` object.


### Scaffold a new app

The first step is to set up the client app. Run the following command to scaffold a new app.

<Tabs groupId="packagemanager">
<TabItem label="PNPM" value="pnpm">

```sh
$ pnpm create @mysten/dapp --template react-client-dapp
```

</TabItem>
<TabItem label="Yarn" value="yarn">

```sh
$ yarn create @mysten/dapp --template react-client-dapp
```

</TabItem>
</Tabs>

### Install new dependencies

This app uses the `react-spinners` package for icons. Install it by running the following command:

<Tabs groupId="packagemanager">
<TabItem label="PNPM" value="pnpm">

```sh
$ pnpm add react-spinners
```

</TabItem>
<TabItem label="Yarn" value="yarn">

```sh
$ yarn add react-spinners
```

</TabItem>
</Tabs>

### Connecting your deployed package {#connecting-your-package}

<details>
<summary>

Add the `packageId` value you saved from [deploying your package](#deployment) to a new `src/constants.ts` file in your project:

</summary>

```ts
export const DEVNET_COUNTER_PACKAGE_ID = "0xTODO";
export const TESTNET_COUNTER_PACKAGE_ID = "0x7b6a8f5782e57cd948dc75ee098b73046a79282183d51eefb83d31ec95c312aa";
export const MAINNET_COUNTER_PACKAGE_ID = "0xTODO";
```

</details>

<details>
<summary>

Update the `src/networkConfig.ts` file to include the `packageID` constants.

</summary>

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/src/networkConfig.ts" mode="code" org="MystenLabs" repo="ts-sdks" noComments />

</details>

### Creating `Counter`

You need a way to create a new `Counter` object. 

<details>
<summary>

Create `src/CreateCounter.tsx` and add the following code:

</summary>

```tsx
  import { Button, Container } from "@radix-ui/themes";
  import { useState } from "react";
  import ClipLoader from "react-spinners/ClipLoader";

  export function CreateCounter({
    onCreated,
  }: {
    onCreated: (id: string) => void;
  }) {
    const [waitingForTxn, setWaitingForTxn] = useState(false);

    function create() {
      // TODO
    }

    return (
      <Container>
        <Button
          size="3"
          onClick={() => {
            create();
          }}
          disabled={waitingForTxn}
        >
          {waitingForTxn ? <ClipLoader size={20} /> : "Create Counter"}
        </Button>
      </Container>
    );
  }
```

</details>

This component renders a button that enables the user to create a counter. Now, update your `create` function so that it calls the `create` function from your Move module.

<details>
<summary>

Update the `create` function in the `src/CreateCounter.tsx` file:

</summary>

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/src/CreateCounter.tsx" mode="code" org="MystenLabs" fun="create" repo="ts-sdks" noComments />

</details>

The `create` function now creates a new Sui `Transaction` and calls the `create` function from your Move module. The PTB is then signed and executed via the `useSignAndExecuteTransaction` hook. The `onCreated` callback is called with the new counter's ID when the transaction is successful.

### Set up routing

Now that your users can create counters, you need a way to route to them. Routing in a React app can be complex, but this example keeps it basic. 

<details>
<summary>

Set up your `src/App.tsx` file so that you render the `CreateCounter` component by default, and if you want to display a specific counter you can put its ID into the hash portion of the URL.

</summary>

```tsx
  import { ConnectButton, useCurrentAccount } from "@mysten/dapp-kit";
  import { isValidSuiObjectId } from "@mysten/sui/utils";
  import { Box, Container, Flex, Heading } from "@radix-ui/themes";
  import { useState } from "react";
  import { CreateCounter } from "./CreateCounter";

  function App() {
    const currentAccount = useCurrentAccount();
    const [counterId, setCounter] = useState(() => {
      const hash = window.location.hash.slice(1);
      return isValidSuiObjectId(hash) ? hash : null;
    });

    return (
      <>
        <Flex
          position="sticky"
          px="4"
          py="2"
          justify="between"
          style={{
            borderBottom: "1px solid var(--gray-a2)",
          }}
        >
          <Box>
            <Heading>dApp Starter Template</Heading>
          </Box>

          <Box>
            <ConnectButton />
          </Box>
        </Flex>
        <Container>
          <Container
            mt="5"
            pt="2"
            px="4"
            style={{ background: "var(--gray-a2)", minHeight: 500 }}
          >
            {currentAccount ? (
              counterId ? (
                null
              ) : (
                <CreateCounter
                  onCreated={(id) => {
                    window.location.hash = id;
                    setCounter(id);
                  }}
                />
              )
            ) : (
              <Heading>Please connect your wallet</Heading>
            )}
          </Container>
        </Container>
      </>
    );
  }

  export default App;
```

</details>

This sets up your app to read the hash from the URL, and get the counter's ID if the hash is a valid object ID. Then, if you have a counter ID, it renders a `Counter` (which you define in the next step). If you don't have a counter ID, then it renders the `CreateCounter` button from the previous step. When a counter is created, you update the URL, and set the counter ID.

Currently, the `Counter` component doesn't exist, so the app displays an empty page if you navigate to a counter ID.

:::checkpoint

At this point, you have a basic routing setup. Run your app and ensure you can:

- Create a new counter.
- See the counter ID in the URL.

The `create counter` button should look like this: 

![Create Counter Button](./images/distributed-create-counter-button.png)

:::

### Building your counter user interface

Create a new file: `src/Counter.tsx`.

For your counter, you want to display three elements:

- The current count, which you fetch from the object using the `getObject` RPC method.
- An increment button, which calls the `increment` Move function.
- A reset button, which calls the `set_value` Move function with `0`. This is only shown if the current user owns the counter.

<details>
<summary>

Add the following code to your `src/Counter.tsx` file:

</summary>

  ```tsx
    import {
      useCurrentAccount,
      useSuiClientQuery,
    } from "@mysten/dapp-kit";
    import { SuiObjectData } from "@mysten/sui/client";
    import { Button, Flex, Heading, Text } from "@radix-ui/themes";
    import { useState } from "react";
    import ClipLoader from "react-spinners/ClipLoader";


    export function Counter({ id }: { id: string }) {
      const currentAccount = useCurrentAccount();
      const { data, isPending, error, refetch } = useSuiClientQuery("getObject", {
        id,
        options: {
          showContent: true,
          showOwner: true,
        },
      });

      const [waitingForTxn, setWaitingForTxn] = useState("");

      const executeMoveCall = (method: "increment" | "reset") => {
        // TODO
      };

      if (isPending) return <Text>Loading...</Text>;

      if (error) return <Text>Error: {error.message}</Text>;

      if (!data.data) return <Text>Not found</Text>;

      const ownedByCurrentAccount =
        getCounterFields(data.data)?.owner === currentAccount?.address;

      return (
        <>
          <Heading size="3">Counter {id}</Heading>

          <Flex direction="column" gap="2">
            <Text>Count: {getCounterFields(data.data)?.value}</Text>
            <Flex direction="row" gap="2">
              <Button
                onClick={() => executeMoveCall("increment")}
                disabled={waitingForTxn !== ""}
              >
                {waitingForTxn === "increment" ? (
                  <ClipLoader size={20} />
                ) : (
                  "Increment"
                )}
              </Button>
              {ownedByCurrentAccount ? (
                <Button
                  onClick={() => executeMoveCall("reset")}
                  disabled={waitingForTxn !== ""}
                >
                  {waitingForTxn === "reset" ? (
                    <ClipLoader size={20} />
                  ) : (
                    "Reset"
                  )}
                </Button>
              ) : null}
            </Flex>
          </Flex>
        </>
      );
    }
    function getCounterFields(data: SuiObjectData) {
      if (data.content?.dataType !== "moveObject") {
        return null;
      }

      return data.content.fields as { value: number; owner: string };
    }
  ```

</details>

This snippet has a few new concepts to examine. It uses the `useSuiClientQuery` hook to make the `getObject` RPC call. This returns a data object representing your counter. dApp Kit doesn't know which fields your counter object has, so define a `getCounterFields` helper that gets the counter fields, and adds a type-cast so that you can access the expected `value` and `owner` fields in your component.

The code also adds an `executeMoveCall` function that still needs implementing. This works just like the `create` function you used to create the counter. Instead of using a callback prop like you did for `CreateCounter`, you can use the refetch provided by `useSuiClientQuery` to reload your `Counter` object after you've executed your PTB.

<details>

<summary>

Update the `executeMoveCall` function in the `src/Counter.tsx` file:

</summary>

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/src/Counter.tsx" mode="code" org="MystenLabs" repo="ts-sdks" noComments />

</details>

### Updating the routing

Now that you have a `Counter` component, you need to update your `App` component to render it when you have a counter ID.

<details>

<summary>

Update the `src/App.tsx` file to render the `Counter` component when you have a counter ID:

</summary>

<ImportContent source="packages/create-dapp/templates/react-e2e-counter/src/App.tsx" mode="code" org="MystenLabs" repo="ts-sdks" noComments />

</details>

:::checkpoint

At this point, you have the complete app. ðŸŽ‰ Run it and ensure you can:

- Create counters
- Increment and reset counters

The `Counter` component should look like this:

![Counter Component](./images/distributed-counter-ui.png)

:::

>>>> sui/docs/content/guides/developer/app-examples/meta-pricing-oracle.mdx
---
title: Meta and Pricing Oracle
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/developer/app-examples/oracle.mdx
---
title: Oracles
description: Oracles connect smart contracts deployed on-chain with data that is stored off-chain.
keywords: [ oracles, oracle services, off-chain data, available oracles, pyth, stork, supra, switchboard ]
---
   
Oracles are services that connect on-chain smart contracts with off-chain data. Blockchains are inherently isolated from outside sources for the purpose of security and reliability. Sui is no different, which means your projects cannot directly fetch real-world information, like stock prices, weather data, or sports scores. Oracles provide a bridge between the blockchain and external data sources, pulling in this information and making it available to smart contracts in a secure and verifiable way.

## Oracles available for the Sui network

The guides in this section demonstrate how to create basic oracle services for your Sui projects. As your needs become more advanced, you might consider integrating third-party services to perform the heavy lifting. There are several oracle services available for the Sui network:

| Service | Description |
| --- | --- | 
| [**Pyth**](https://www.pyth.network/) | Pyth is a blockchain oracle for market data. Check the [Sui guide](https://docs.pyth.network/price-feeds/core/use-real-time-data/pull-integration/sui) on the Pyth website to learn how to integrate into your Sui projects. |
| [**Stork**](https://www.stork.network/) | Stork is an open data marketplace designed to address the limitations of traditional blockchain oracles. Check the [Stork documentation](https://docs.stork.network/) for implementation details. |
| [**Supra**](https://supra.com/data) | Supra is a decentralized oracle network designed to connect blockchain smart contracts with real-world data, enhancing the functionality of decentralized applications (dApps) across various blockchain ecosystems. Check the [Index Fund](https://docs.supra.com/oracles/indices/creating-a-new-on-chain-index).|
| [**Switchboard**](https://switchboard.xyz/) | Switchboard is a permissionless oracle network that seamlessly connects dApps to real-world data. Check the [On Sui](https://docs.switchboard.xyz/product-documentation/data-feeds/sui) guide for integration details. |

## Oracle guides

The following guides demonstrate how to build oracles on the Sui network. Currently, there is one guide but more are planned.

- [Sui Weather Oracle](./weather-oracle.mdx): Fetches weather data from OpenWeather API to provide real-time weather data for 1,000+ locations around the world.

>>>> sui/docs/content/guides/developer/app-examples/plinko.mdx
---
title: Plinko
description: Learn Sui through an example implementation of the popular casino game, Plinko.
keywords: [ example dApp, example app, on-chain randomness, enoki sponsorship, sponsored transactions, codegen, typescript codegen, example game, game dApp ]
---

Plinko is an example implementation of the popular casino game. The Plinko game on Sui leverages on-chain randomness to ensure fairness and transparency. Players drop Plinko balls onto a pegged board, where they randomly fall into slots representing different multipliers. This document details the game's mechanics, on-chain randomness implementation, sponsored transactions through Enoki, and TypeScript integration using codegen.

Building an on-chain Plinko game shares a lot of similarities with the [Coin Flip](./coin-flip.mdx) game and [Blackjack](./blackjack.mdx) game. For that reason, this example covers only the smart contracts (Move modules) and frontend logic.

<ImportContent source="prerequisites.mdx" mode="snippet" />

:::info

You can find the source files for this example in the [Plinko repo](https://github.com/MystenLabs/plinko-poc/tree/main) on GitHub.

A version of the game is also deployed at [Mysten Plinko](https://plinko-poc.vercel.app/).

:::

## Gameplay

The Plinko game, implemented through smart contracts on the Sui blockchain, leverages Sui's native on-chain randomness to ensure fairness and transparency. The game calculates the trace path for each ball using secure random values generated directly on-chain, determining the game's outcome based on the number of Plinko balls a player chooses to drop.

The game mechanics involve a player starting a game by specifying the number of balls and staking a certain amount. The on-chain randomness is provided through Sui's Move randomness framework, which ensures each game's randomness is cryptographically secure and cannot be predicted or manipulated. The number of Plinko balls, chosen by the player, directly influences the game's complexity and potential payout, as each ball's final position is determined by the on-chain random values that dictate the ball's path through the pegged board.

## Sequence diagram

```mermaid
sequenceDiagram
    participant Player as Player
    participant FE as Frontend
    participant BE as Backend
    participant Enoki as Enoki
    participant Blockchain as Sui Blockchain

    Note over Player, Blockchain: Plinko Game Interaction Flow

    Player->>+FE: Places bet, selects number of balls, presses play

    Note over FE: Start Game Transaction
    FE->>FE: Construct PTB with plinko::start_game
    FE->>FE: Build unsigned TransactionKind bytes
    FE->>+Enoki: POST /sponsor - Send unsigned tx bytes
    Note over Enoki: createSponsoredTransaction()
    Enoki-->>-FE: Returns sponsored unsigned bytes + digest
    FE->>Player: Request signature for sponsored transaction
    Player->>FE: Signs sponsored transaction bytes
    FE->>+Enoki: POST /execute - Send digest + signature
    Note over Enoki: executeSponsoredTransaction()
    Enoki->>+Blockchain: Submit sponsored + signed transaction
    Note over Blockchain: Executes plinko::start_game,<br/>creates Game object with player's stake
    Blockchain-->>-Enoki: Transaction result with game_id
    Enoki-->>-FE: Returns execution digest
    FE->>FE: Extract game_id from events

    Note over FE,BE: Finish Game Transaction
    FE->>+BE: POST /game/plinko/end - Send game_id, numberofBalls
    BE->>BE: Construct PTB with plinko::finish_game
    BE->>BE: Build unsigned TransactionKind bytes
    BE->>+Enoki: POST /sponsor - Send unsigned tx bytes
    Note over Enoki: createSponsoredTransaction()
    Enoki-->>-BE: Returns sponsored unsigned bytes + digest
    BE->>BE: Backend signer signs transaction
    BE->>+Enoki: POST /execute - Send digest + signature
    Note over Enoki: executeSponsoredTransaction()
    Enoki->>+Blockchain: Submit sponsored + signed transaction
    Note over Blockchain: Executes plinko::finish_game,<br/>uses on-chain randomness to calculate outcome<br/>(ball trace paths, payments), emits GameFinished event
    Blockchain-->>-Enoki: Transaction result with trace
    Enoki-->>-BE: Returns execution digest
    BE->>BE: Extract trace from events
    BE-->>-FE: Returns trace + transactionDigest
    FE->>FE: Process trace into ball paths
    FE-->>-Player: Display game result, ball animations, winnings
```

## Move modules

Follow the comments in each module's code to understand the logic each creates.

### `plinko::plinko`

The `plinko::plinko` module combines various Sui blockchain features, such as coin handling, event emissions, on-chain randomness, and game logic, to create fair and transparent on-chain Plinko games.

<details>
<summary>
`plinko.move`
</summary>

```move title="plinko.move"
module plinko::plinko;
use plinko::house_data::{Self as hd, HouseData};
use sui::balance::Balance;
use sui::coin::{Self, Coin};
use sui::dynamic_object_field as dof;
use sui::event::emit;
use sui::random::Random;
use sui::sui::SUI;

// === Errors ===
const EStakeTooLow: u64 = 0;
const EStakeTooHigh: u64 = 1;
const EInsufficientHouseBalance: u64 = 5;
const EGameDoesNotExist: u64 = 6;
const ENumberOfBallsNotAllowed: u64 = 7;

// === Structs ===

/// Represents a game and holds the accrued stake.
public struct Game has key, store {
    id: UID,
    game_start_epoch: u64,
    stake: Balance<SUI>,
    player: address,
    fee_bp: u16,
}

// === Events ===

/// Emitted when a new game has started.
public struct NewGameStarted has copy, drop {
    game_id: ID,
    player: address,
    user_stake: u64,
    fee_bp: u16,
}

/// Emitted when a game has finished.
public struct GameFinished has copy, drop {
    game_id: ID,
    result: u64,
    player: address,
    // The trace path representing each ball's journey
    trace: vector<u8>,
}

// === Public Functions ===

/// Function used to create a new game.
public fun start_game(coin: Coin<SUI>, house_data: &mut HouseData, ctx: &mut TxContext): ID {
    let fee_bp = house_data.base_fee_in_bp();
    let (id, new_game) = internal_start_game(coin, house_data, fee_bp, ctx);
    dof::add(house_data.borrow_mut(), id, new_game);
    id
}

/// finish_game Completes the game by calculating the outcome using on-chain randomness
/// and transferring the funds to the player.
/// It emits a GameFinished event with the game result and the trace path.
entry fun finish_game(
    game_id: ID,
    random: &Random,
    house_data: &mut HouseData,
    num_balls: u64,
    ctx: &mut TxContext,
): (u64, address, vector<u8>) {
    // Ensure that the game exists.
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);

    // Ensure that the player selected at least one ball and no more than 100 balls.
    assert!(num_balls > 0 && num_balls <= 100, ENumberOfBallsNotAllowed);

    // Retrieves and removes the game from HouseData, preparing for outcome calculation.
    let Game {
        id,
        game_start_epoch: _,
        stake,
        player,
        fee_bp: _,
    } = dof::remove<ID, Game>(house_data.borrow_mut(), game_id);

    id.delete();

    // Initialize random generator and variables
    let mut random_generator = random.new_generator(ctx);
    let mut trace = vector[];

    // Calculate the stake amount per ball
    let stake_per_ball = stake.value<SUI>() / num_balls;
    let mut total_funds_amount: u64 = 0;

    // Calculate outcome for each ball using native randomness
    let mut ball_index = 0;
    while (ball_index < num_balls) {
        let mut state: u64 = 0;

        // Generate 12 random bytes for this ball and process them directly
        let mut i = 0;
        while (i < 12) {
            let byte = random_generator.generate_u8_in_range(0, 255);
            // Add the byte to the trace vector
            trace.push_back<u8>(byte);
            // Count the number of even bytes
            // If even, add 1 to the state
            // Odd byte -> 0, Even byte -> 1
            // The state is used to calculate the multiplier index
            state = if (byte % 2 == 0) { state + 1 } else { state };
            i = i + 1;
        };

        // Calculate multiplier index based on state
        let multiplier_index = state % house_data.multiplier().length();
        // Retrieve the multiplier from the house data
        let result = house_data.multiplier()[multiplier_index];

        // Calculate funds amount for this particular ball
        // Divide by 100 to adjust for multiplier scale and SUI units
        let funds_amount_per_ball = (result * stake_per_ball) / 100;
        // Add the funds amount to the total funds amount
        total_funds_amount = total_funds_amount + funds_amount_per_ball;
        ball_index = ball_index + 1;
    };

    // Processes the payout to the player and returns the game outcome.
    // Read available balance and fail early if insufficient.
    let available: u64 = hd::balance(house_data);
    assert!(available >= total_funds_amount, EInsufficientHouseBalance);
    let payout_balance_mut = house_data.borrow_balance_mut();
    let payout_coin: Coin<SUI> = coin::take(payout_balance_mut, total_funds_amount, ctx);

    payout_balance_mut.join(stake);

    // transfer the payout coins to the player
    transfer::public_transfer(payout_coin, player);
    // Emit the GameFinished event
    emit(GameFinished {
        game_id,
        result: total_funds_amount,
        player,
        trace,
    });

    // return the total amount to be sent to the player, (and the player address)
    (total_funds_amount, player, trace)
}


// === Public-View Functions ===

/// Returns the epoch in which the game started.
public fun game_start_epoch(game: &Game): u64 {
    game.game_start_epoch
}

/// Returns the total stake.
public fun stake(game: &Game): u64 {
    game.stake.value()
}

/// Returns the player's address.
public fun player(game: &Game): address {
    game.player
}

/// Returns the fee of the game.
public fun fee_in_bp(game: &Game): u16 {
    game.fee_bp
}

// === Admin Functions ===

/// Helper function to check if a game exists.
public fun game_exists(house_data: &HouseData, game_id: ID): bool {
    dof::exists_(house_data.borrow(), game_id)
}

/// Helper function to check that a game exists and return a reference to the game Object.
/// Can be used in combination with any accessor to retrieve the desired game field.
public fun borrow_game(game_id: ID, house_data: &HouseData): &Game {
    assert!(game_exists(house_data, game_id), EGameDoesNotExist);
    dof::borrow(house_data.borrow(), game_id)
}

// === Private Functions ===

/// Internal helper function used to create a new game.
/// Stake is taken from the player's coin and added to the game's stake.
fun internal_start_game(
    coin: Coin<SUI>,
    house_data: &HouseData,
    fee_bp: u16,
    ctx: &mut TxContext,
): (ID, Game) {
    let user_stake = coin.value();
    // Ensure that the stake is not higher than the max stake.
    assert!(user_stake <= house_data.max_stake(), EStakeTooHigh);
    // Ensure that the stake is not lower than the min stake.
    assert!(user_stake >= house_data.min_stake(), EStakeTooLow);
    // Ensure that the house has enough balance to play for this game.
    assert!(
        house_data.balance() >= (user_stake * (house_data.multiplier()[0])) / 100,
        EInsufficientHouseBalance,
    );

    let id = object::new(ctx);
    let game_id = object::uid_to_inner(&id);

    // Create a new game object and emit a NewGameStarted event.
    let new_game = Game {
        id,
        game_start_epoch: ctx.epoch(),
        stake: coin.into_balance<SUI>(),
        player: ctx.sender(),
        fee_bp,
    };
    // Emit a NewGameStarted event
    emit(NewGameStarted {
        game_id,
        player: ctx.sender(),
        user_stake,
        fee_bp,
    });

    (game_id, new_game)
}
```

</details>

#### Error codes

Error handling is integral to the module, with specific codes indicating various failure states or invalid operations:

- `EStakeTooLow`: Indicates that the stake provided is below the minimum threshold.
- `EStakeTooHigh`: Indicates that the stake exceeds the maximum allowed limit.
- `EInsufficientHouseBalance`: Indicates the house does not have enough balance to cover the game's outcome.
- `EGameDoesNotExist`: Used when a referenced game cannot be found.
- `ENumberOfBallsNotAllowed`: Indicates the player selected an invalid number of balls (must be between 1 and 100).

#### Events

- `NewGameStarted`: Emitted when a new game starts, capturing essential details like game ID, player address, stake, and fee basis points.
- `GameFinished`: Emitted upon the conclusion of a game, detailing the outcome, including the game ID, result, player address, and a trace of each ball's path through the Plinko board.

#### Structures

- `Game`: Represents an individual game session, holding information such as the game ID, epoch of game start, stake amount, player address, and the fee basis points.

#### Key functions

- `start_game`: Initiates a new Plinko game session, accepting the player's stake coin, house data, and transaction context. Returns the game ID.
- `finish_game`: Completes the game using on-chain randomness to calculate outcomes, traces the path each ball travels, and distributes the total winnings to the player. This is an entry function that takes the Random object from Sui's randomness framework.

#### Accessors

Provide read-only access to the game's properties:

- `game_start_epoch`: Returns the epoch when the game started
- `stake`: Returns the total stake amount
- `player`: Returns the player's address
- `fee_in_bp`: Returns the fee in basis points

#### Public helper functions

- `game_exists`: Checks if a game exists within the house data.
- `borrow_game`: Retrieves a reference to a game object for further processing.

#### Internal helper functions

- `internal_start_game`: A core utility that facilitates the creation of a new game, ensuring compliance with stake limits, house balance sufficiency, and the generation of a unique game ID.

### `plinko::house_data`

The `plinko::house_data` module manages the game's treasury and configurations. It stores the house funds, sets game parameters (like maximum and minimum stakes), handles game fees, and manages the multiplier vector used to calculate winnings. The module provides functions to adjust game settings and manages the house funds.

<details>
<summary>
`house_data.move`
</summary>

```move title="house_data.move"
module plinko::house_data;
use sui::balance::{Self, Balance};
use sui::coin::{Self, Coin};
use sui::package;
use sui::sui::SUI;

// === Errors ===
const ECallerNotHouse: u64 = 0;
const EInsufficientBalance: u64 = 1;

// === Structs ===

/// Configuration and Treasury shared object, managed by the house.
public struct HouseData has key {
    id: UID,
    // House's balance which also contains the accrued winnings of the house.
    balance: Balance<SUI>,
    // Address of the house or the game operator.
    house: address,
    // Maximum stake amount a player can bet in a single game.
    max_stake: u64,
    // Minimum stake amount required to play the game.
    min_stake: u64,
    // The accrued fees from games played.
    fees: Balance<SUI>,
    // The default fee in basis points. 1 basis point = 0.01%.
    base_fee_in_bp: u16,
    // Multipliers used to calculate winnings based on the game outcome.
    multiplier: vector<u64>,
}

/// A one-time use capability to initialize the house data;
/// created and sent to sender in the initializer.
public struct HouseCap has key {
    id: UID,
}

/// Used as a one time witness to generate the publisher.
public struct HOUSE_DATA has drop {}

fun init(otw: HOUSE_DATA, ctx: &mut TxContext) {
    // Creating and sending the Publisher object to the sender.
    package::claim_and_keep(otw, ctx);

    // Creating and sending the HouseCap object to the sender.
    let house_cap = HouseCap {
        id: object::new(ctx),
    };

    transfer::transfer(house_cap, ctx.sender());
}

/// Initializer function that should only be called once and by the creator of the contract.
/// Initializes the house data object with an initial balance.
/// It also sets the max and min stake values, that can later on be updated.
/// Stores the house address and the base fee in basis points.
/// This object is involved in all games created by the same instance of this package.
public fun initialize_house_data(
    house_cap: HouseCap,
    coin: Coin<SUI>,
    multiplier: vector<u64>,
    ctx: &mut TxContext,
) {
    assert!(coin.value() > 0, EInsufficientBalance);

    let mut house_data = HouseData {
        id: object::new(ctx),
        balance: coin.into_balance(),
        house: ctx.sender(),
        max_stake: 10_000_000_000, // 10 SUI = 10^9.
        min_stake: 100_000_000, // 0.1 SUI.
        fees: balance::zero(),
        base_fee_in_bp: 100, // 1% in basis points.
        multiplier: vector[],
    };

    house_data.set_multiplier_vector(multiplier);

    let HouseCap { id } = house_cap;
    id.delete();

    transfer::share_object(house_data);
}

// === Public-Mutative Functions ===

public fun update_multiplier_vector(
    house_data: &mut HouseData,
    v: vector<u64>,
    ctx: &mut TxContext,
) {
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);
    house_data.multiplier = vector[];
    house_data.set_multiplier_vector(v);
}

/// Function used to top up the house balance. Can be called by anyone.
/// House can have multiple accounts so giving the treasury balance is not limited.
public fun top_up(house_data: &mut HouseData, coin: Coin<SUI>, _: &mut TxContext) {
    coin::put(&mut house_data.balance, coin)
}

/// A function to withdraw the entire balance of the house object.
/// It can be called only by the house
public fun withdraw(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_balance = house_data.balance();
    let coin = coin::take(&mut house_data.balance, total_balance, ctx);
    transfer::public_transfer(coin, house_data.house());
}

/// House can withdraw the accumulated fees of the house object.
public fun claim_fees(house_data: &mut HouseData, ctx: &mut TxContext) {
    // Only the house address can withdraw fee funds.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    let total_fees = house_data.fees();
    let coin = coin::take(&mut house_data.fees, total_fees, ctx);
    transfer::public_transfer(coin, house_data.house());
}

/// House can update the max stake. This allows larger stake to be placed.
public fun update_max_stake(house_data: &mut HouseData, max_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the base fee.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.max_stake = max_stake;
}

/// House can update the min stake. This allows smaller stake to be placed.
public fun update_min_stake(house_data: &mut HouseData, min_stake: u64, ctx: &mut TxContext) {
    // Only the house address can update the min stake.
    assert!(ctx.sender() == house_data.house(), ECallerNotHouse);

    house_data.min_stake = min_stake;
}

// === Public-View Functions ===

/// Returns the balance of the house.
public fun balance(house_data: &HouseData): u64 {
    house_data.balance.value()
}

/// Returns the address of the house.
public fun house(house_data: &HouseData): address {
    house_data.house
}

/// Returns the max stake of the house.
public fun max_stake(house_data: &HouseData): u64 {
    house_data.max_stake
}

/// Returns the min stake of the house.
public fun min_stake(house_data: &HouseData): u64 {
    house_data.min_stake
}

/// Returns the fees of the house.
public fun fees(house_data: &HouseData): u64 {
    house_data.fees.value()
}

/// Returns the base fee.
public fun base_fee_in_bp(house_data: &HouseData): u16 {
    house_data.base_fee_in_bp
}

/// Returns the multiplier vector
public fun multiplier(house_data: &HouseData): vector<u64> {
    house_data.multiplier
}

// === Public-Friend Functions ===

/// Returns a reference to the house ID.
public(package) fun borrow(house_data: &HouseData): &UID {
    &house_data.id
}

/// Returns a mutable reference to the balance of the house.
public(package) fun borrow_balance_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.balance
}

/// Returns a mutable reference to the fees of the house.
public(package) fun borrow_fees_mut(house_data: &mut HouseData): &mut Balance<SUI> {
    &mut house_data.fees
}

/// Returns a mutable reference to the house ID.
public(package) fun borrow_mut(house_data: &mut HouseData): &mut UID {
    &mut house_data.id
}

// === Private Functions ===

fun set_multiplier_vector(house_data: &mut HouseData, v: vector<u64>) {
    house_data.multiplier.append(v);
}

// === Test Functions ===

#[test_only]
public fun init_for_testing(ctx: &mut TxContext) {
    init(HOUSE_DATA {}, ctx);
}
```
</details>

#### Error codes

The module defines specific error codes to handle exceptional scenarios:

- `ECallerNotHouse`: Ensures that only the house (game operator) can perform certain operations.
- `EInsufficientBalance`: Indicates an insufficient balance for operations requiring a minimum fund level.

#### Structures

- `HouseData`: A key configuration object storing the house's operational parameters, including its balance, stake limits, accumulated fees, base fee rate, and multiplier settings for game outcomes.
- `HouseCap`: A unique capability indicating the authority to initialize the house data.
- `HOUSE_DATA`: A one time witness for initializing house data, used once during the setup phase.

#### Initialization function

- `init`: Prepares the environment for the house, generating essential capabilities and objects for house data management.

#### Public functions

- `initialize_house_data`: Sets up the initial configuration for the house, including balance, stake limits, and multipliers.
- `top_up`: Allows adding funds to the house's balance to support game operations.
- `withdraw`: Enables the house to withdraw its balance, a critical function with implications for the house's operational capacity.
- `claim_fees`: Permits the house to collect accumulated fees from game activities.
- `update_max_stake`: Adjusts the maximum stake limit for games.
- `update_min_stake`: Modifies the minimum stake requirement.
- `update_multiplier_vector`: Updates the multiplier vector used to calculate game outcomes.

#### Internal helper functions

- `set_multiplier_vector`: Internally used to set the initial multiplier vector.

#### Accessors

Provide read-only and mutable access to house data properties, enabling operations like querying balance, stake limits, fees, and modifying configurations within authorized contexts:

- `balance`: Returns the house's current balance.
- `house`: Retrieves the house's address.
- `max_stake`, `min_stake`: Access the current stake limits.
- `fees`: Shows the accumulated fees from game operations.
- `base_fee_in_bp`: Provides the base fee rate in basis points.
- `multiplier`: Returns the multiplier vector used in game outcome calculations.

#### Test utilities

- `init_for_testing`: A utility function facilitating module testing by initializing house data within a test environment.

## Enoki sponsorship

The Plinko game demonstrates a frictionless user experience by leveraging [Enoki](https://docs.enoki.mystenlabs.com/) for transaction sponsorship. This allows players to interact with the game without needing to hold SUI tokens for gas fees, significantly reducing barriers to entry.

### How sponsorship works

The sponsorship flow is split into two backend API endpoints that work with the Enoki client:

1. **`/sponsor` endpoint**: Receives unsigned transaction bytes from the frontend and calls `enokiClient.createSponsoredTransaction()` to sponsor them. Returns the sponsored (but still unsigned) transaction bytes and digest.

2. **`/execute` endpoint**: Receives the transaction digest and user signature, then calls `enokiClient.executeSponsoredTransaction()` to submit the sponsored and signed transaction to the blockchain.

The complete flow works as follows:

1. **Frontend constructs transaction**: The UI builds a programmable transaction block (PTB) with the necessary Move calls (such as, `plinko::start_game`) and serializes it to `TransactionKind` bytes.

2. **Request sponsorship**: The unsigned transaction bytes are sent to `/sponsor`, which returns sponsored unsigned bytes.

3. **User signs**: The player signs the sponsored transaction bytes through their wallet.

4. **Execute transaction**: The signed transaction is sent to `/execute`, which submits it to the blockchain.

This two-step process ensures that:
- Players only need to sign transactions (proving ownership)
- The game operator covers all gas fees through Enoki
- The user experience is seamless and Web2-like
- **Important:** Set `useGasCoin: false` when creating coins for sponsored transactions

### Implementation Example

#### Backend: `/sponsor` endpoint

```typescript
import { enokiClient } from "../EnokiClient";

export const POST = async (req: NextRequest) => {
  try {
    const { transactionKindBytes, sender } = await req.json();
    const sponsored = await enokiClient.createSponsoredTransaction({
      network: process.env.NEXT_PUBLIC_SUI_NETWORK_NAME as
        | "mainnet"
        | "testnet"
        | "devnet",
      transactionKindBytes,
      sender,
      allowedAddresses: [sender],
    });

    return NextResponse.json(
      { bytes: sponsored.bytes, digest: sponsored.digest },
      { status: 200 }
    );
  } catch (error) {
    console.error("Sponsorship failed:", error);
    return NextResponse.json({ error: "Sponsorship failed" }, { status: 500 });
  }
};
```

#### Backend: `/execute` endpoint

```typescript
import { enokiClient } from "../EnokiClient";

export const POST = async (req: NextRequest) => {
  try {
    const { digest, signature } = await req.json();
    const executionResult = await enokiClient.executeSponsoredTransaction({
      digest,
      signature,
    });
    return NextResponse.json(
      { digest: executionResult.digest },
      { status: 200 }
    );
  } catch (error) {
    console.error("Execution failed:", error);
    return NextResponse.json({ error: "Execution failed" }, { status: 500 });
  }
};
```

#### Frontend: Complete sponsorship flow

```typescript
// 1) Create the tx and get TransactionKind bytes
const tx = new Transaction();
tx.setSender(sender);
const betCoin = coinWithBalance({
  type: "0x2::sui::SUI",
  balance: betInMist,
  useGasCoin: false, // important for sponsorship
})(tx);
tx.add(
  plinko.startGame({
    package: process.env.NEXT_PUBLIC_PACKAGE_ADDRESS,
    arguments: [betCoin, `${process.env.NEXT_PUBLIC_HOUSE_DATA_ID}`],
  })
);

const txBytes = await tx.build({
  client,
  onlyTransactionKind: true,
});

// 2) Sponsor the unsigned TxBytes
const sponsorResp = await fetch("/api/sponsor", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    transactionKindBytes: toBase64(txBytes),
    sender,
  }),
});

if (!sponsorResp.ok) {
  console.error("Failed to sponsor transaction:", sponsorResp.status);
  showError("Failed to sponsor transaction. Please try again.");
  return;
}

const { bytes: sponsoredBytes, digest: sponsoredDigest } =
  (await sponsorResp.json()) as { bytes: string; digest: string };

// 3) Sign the sponsored TxBytes
const { signature } = await signTransaction({
  transaction: sponsoredBytes,
});

// 4) Execute the sponsored + signed TxBytes
const execResp = await fetch("/api/execute", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({ digest: sponsoredDigest, signature }),
});
```

## TypeScript Integration with Codegen

The Plinko frontend uses [Mysten's codegen tool](https://www.npmjs.com/package/@mysten/codegen?activeTab=readme) to automatically generate TypeScript bindings from the Move smart contracts. This provides several advantages:

### Usage example

Instead of manually building transaction blocks, you can use generated functions:

```typescript
import { plinko } from './generated/plinko';

// Type-safe function call with autocomplete
const tx = plinko.startGame({
  coin: coinObject,
  houseData: houseDataId,
});
```

## Deployment

Navigate to the [setup folder](https://github.com/MystenLabs/plinko-poc/tree/main/setup) of the Plinko repository and execute the `publish.sh` script. Refer to the [README instructions](https://github.com/MystenLabs/plinko-poc/blob/main/README.md) for deploying the smart contracts and testing them locally.


## Frontend

The Plinko frontend is built with React and integrates with the Sui blockchain using sponsored transactions through Enoki. The application provides an interactive and responsive gaming experience while abstracting away blockchain complexity from end users.

### State management and setup

- **State hooks:** The application uses React's `useState` to manage game states, including `finalPaths`, `isPlaying`, `totalWon`, and more. These states track the current game status and update the UI in real-time.

- **Sponsored transactions:** The frontend leverages Enoki's `/sponsor` and `/execute` APIs to create a gasless experience. Players can interact with the game without needing SUI tokens, as the backend sponsors all transaction fees.

- **TypeScript integration:** Generated TypeScript bindings from codegen provide type-safe contract interactions, reducing errors, and improving developer experience.

## UI components and styling

The `MatterSim` and `PlinkoSettings` components are the foundation for the Plinko frontend. To see code for all components and source files, see the [Plinko repo](https://github.com/MystenLabs/plinko-poc/tree/main/app/src).  

### Simulation component

The [`MatterSim` component](https://github.com/MystenLabs/plinko-poc/blob/main/app/src/components/MatterSim.tsx) renders the game board with realistic physics for the dropping Plinko balls. It uses [Matter.js](https://brm.io/matter-js/), a 2D physics engine, to simulate the game dynamics.

```ts
import Matter, {
  Engine,
  Render,
  Runner,
  Bodies,
  Composite,
  Vector,
  Events,
  Body,
  Common,
} from "matter-js";
```

The component receives ball paths (trace data) generated from on-chain randomness, emitted in the `GameFinished` event. Each path consists of 12 bytes per ball, where each byte determines whether the ball moves left (odd) or right (even) at each peg. `MatterSim` applies physics principles like gravity for natural ball descent while using custom forces to guide balls along their predetermined paths. The physics simulation provides smooth, realistic movement that matches the on-chain outcomes, creating an engaging visual experience where fairness is guaranteed by blockchain randomness.

## Plinko settings component

The [`PlinkoSettings` component](https://github.com/MystenLabs/plinko-poc/blob/main/app/src/components/PlinkoSettings.tsx) is an integral part of the user interface in the Plinko game, enabling players to customize their gameplay experience according to their preferences. This React component allows users to select the number of Plinko balls they want to drop, set the bet size for each ball, and initiate the game round by pressing the **Play** button.

### Customization options

- `betSize` (per ball): Players can specify the amount they want to bet on each ball. This is a crucial feature that allows users to manage their risk and potential rewards.
- `numberOfBalls`: This setting lets players choose how many balls they want to play in a single round, adding a strategic layer to the game as the total bet size is a multiplication of the bet size per ball and the number of balls.

## User interaction and feedback

Game Initiation: After selecting the desired number of balls and setting the bet size for each, players can initiate a new game by pressing the **Play** button. This action starts the game, with the button becoming disabled during gameplay to prevent new games from being initiated until the current game concludes and the last ball has reached the end. Links are also provided for players to view game details on a Sui network explorer for transparency and engagement.

## Related links

<RelatedLink href="https://github.com/MystenLabs/plinko-poc/tree/main" label="Plinko repository" desc="The Plinko GitHub repository contains all the source files for this example." />
<RelatedLink href="https://plinko-poc.vercel.app/" label="Mysten Plinko" desc="A hosted version of the Plinko game." />

>>>> sui/docs/content/guides/developer/app-examples/recaptcha.mdx
---
title: Prevent Bots
description: Write and deploy a smart contract in Move that uses reCAPTCHA to verify users are human (and not bots) before they interact with the contract.
draft: true
---

This guide shows you how to write and deploy a smart contract in Move that uses reCAPTCHA to verify users are human (and not bots) before they interact with the contract. CAPTCHA is a method of bot mitigation that requires you to pass a challenge test to prove that you are human. CAPTCHA tests are effective in preventing bots from performing tasks, but the tests can become annoying or frustrating for legitimate users if they are too difficult or frequent. reCAPTCHA is a form of CAPTCHA testing.

<ImportContent source="prerequisites.mdx" mode="snippet" />

## Move smart contract

As with all Sui dApps, a Move package on chain powers the logic of the reCAPTCHA module. The following instruction walks you through creating and publishing the module.

### reCAPTCHA module

Before you get started, you must initialize a Move package. Open a terminal or console in the directory you want to store the example and run the following command to create an empty package with the name `recaptcha`:

```sh
$ sui move new recaptcha
```

With that done, it's time to jump into some code. Create a new file in the `sources` directory with the name `recaptcha.move` and populate the file with the following code:

```rust title='recaptcha.move'
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module recaptcha::recaptcha {
    // Import the vector module for manipulating vectors.
    use std::vector;

    // Import the clock module for getting the current time.
    use sui::clock::Clock;
    // Import the dynamic_field module for adding custom fields to objects.
    use sui::dynamic_field as df;
    // Import the ed25519 module for verifying signatures.
    use sui::ed25519::ed25519_verify;
    // Import the event module for emitting events.
    use sui::event::emit;
    // Import the math module for performing mathematical operations.
    use sui::math;
    // Import the object module for creating and manipulating objects.
    use sui::object::{Self, UID};
    // Import the transfer module for sharing and transferring objects.
    use sui::transfer;
    // Import the tx_context module for accessing transaction information.
    use sui::tx_context::{sender, TxContext};

    /// Error code for transactions that violate the cooldown period.
    const EVerificationExpired: u64 = 0;
    /// Error code for invalid signatures.
    const EInvalidSignature: u64 = 1;
    /// Error code for senders that are not yet verified.
    const ENotYetVerified: u64 = 2;

    // Define a constant for the duration of the time window in milliseconds
    const TIME_WINDOW: u64 = 60_000;
}
```

There are few details to take note of in this code:

1. The fourth line declares the module name as `recaptcha` within the package `recaptcha`.
1. The next eight lines use the use keyword to import types and functions from other modules, such as `sui::clock::Clock`, `sui::dynamic_field as df`, `sui::ed25519::ed25519_verify`, `sui::event::emit,sui::math`, `sui::object::{Self, UID}`, `sui::transfer`, and `sui::tx_context::{sender, TxContext}`. These modules are needed for the implementation of the reCAPTCHA verification and the interaction logic.
1. The following three lines declare the error codes, namely: `EVerificationExpired`, `EInvalidSignature`, and `ENotYetVerified`, that are used to check the validity of the reCAPTCHA test result and the eligibility of the user. The error codes are also used in the unit tests to verify the correctness of the program.
1. The last line declares the constant `TIME_WINDOW`, which specifies the duration of the time window in milliseconds. The time window is the period of time that the user is eligible to interact with the smart contract after passing the reCAPTCHA test.

Next, add some more code to this module:

```rust title='recaptcha.move'
struct Interaction has copy, drop {
    sender: address, // The address of the sender
    timestamp_ms: u64, // The timestamp in milliseconds
}

// Define a struct for the registry object that has a key field
struct Registry has key {
    id: UID, // The unique identifier of the registry object
    window: u64, // The length of the time window in milliseconds
}

// Define a function for initializing the registry
fun init(ctx: &mut TxContext) {
    // Share the registry object with other participants
    transfer::share_object(
        Registry {
            id: object::new(ctx), // Create a new object with a unique id
            window: TIME_WINDOW, // Set the time window to the constant value
        }
    );
}
```

- The `Interaction` struct is used to define the data that is emitted as an event when a user successfully interacts with the smart contract. The `Interaction` event has two fields: the sender's address and the timestamp in milliseconds. The sender's address is the account that initiated the interaction, and the timestamp is the current time when the event is triggered.
- The `Registry` struct stores the mapping of the userâ€™s address to the expiration time of the eligibility to interact with the smart contract. It also has a `window` field that specifies the length of the time window in milliseconds. The time window is the period of time that the user is eligible to interact with the smart contract after passing the reCAPTCHA test.
- The [`init` function](../../../concepts/sui-move-concepts.mdx) creates a [shared object](concepts/object-ownership/shared.mdx) for the `Registry`. The function is called when the smart contract is deployed to the blockchain. The function creates a new registry object with a unique ID and sets the time window to the constant value.

So far, you've set up the data structures within the module.
Now, create a function that verifies the message

```rust title='recaptcha.move'
/// @param registry: The registry object.
/// @param signature: 32-byte signature that is a point on the Ed25519 elliptic curve.
/// @param public_key: 32-byte signature that is a point on the Ed25519 elliptic curve.
/// @param msg: The message that we test the signature against.
public fun verify(
    registry: &mut Registry,
    signature: vector<u8>,
    public_key: vector<u8>,
    msg: vector<u8>,
    ctx: &mut TxContext
) {
    let verified = ed25519_verify(&signature, &public_key, &msg);
    assert!(verified, EInvalidSignature);

    if (!df::exists_with_type<address, u64>(&registry.id, sender(ctx))) {
        df::add<address, u64>(
            &mut registry.id,
            sender(ctx),
            msg_to_ts(&msg)
        );
    } else {
        let timestamp_ms = df::borrow_mut<address, u64>(&mut registry.id, sender(ctx));
        *timestamp_ms = msg_to_ts(&msg);
    }
}

/// Function to get the timestamp_ms from the message, which is a vector of bytes, and transform it to a u64.
public fun msg_to_ts(
    message: &vector<u8>
): u64 {
    let vec_length = vector::length(message);

    let (value, i) = (0u64, 0u8);
    while (i < 13) {
        let element = (*vector::borrow(message, vec_length - (i as u64) - 1) - 48 as u64); // '0' = 48
        value = value + element * math::pow(10, i); // 10^i
        i = i + 1;
    };
    value
}
```

The `verify` function is a public function that allows anyone to register themselves as non-bot using the function call. The function takes five parameters:

- `registry`: The registry object that stores the mapping of the user's address to the expiration time of the eligibility.
- `signature`: The 32-byte signature that is a point on the Ed25519 elliptic curve. The signature is generated by the oracle using its private key and the message that contains the user's address and the current timestamp.
- `public_key`: The 32-byte public key that is a point on the Ed25519 elliptic curve. The public key is the oracle's public key that is used to verify the signature.
- `msg`: The message that contains the user's address and the current timestamp. The message is encoded as a vector of bytes.
- `ctx`: The transaction context that provides information about the sender, the gas limit, and the gas price.

The function performs the following steps:

- It calls the `ed25519_verify` function from the `sui::ed25519` module to check if the signature is valid for the given public key and message. The `ed25519_verify` function returns a boolean value that indicates the validity of the signature.
- It asserts that the signature is valid, otherwise it aborts the execution with the error code `EInvalidSignature`.
- It checks if the user's address exists as a key in the dynamic field of the registry object. The dynamic field is a way of storing key-value pairs in an object without declaring them in advance and it can be accessed, modified, or deleted using the `sui::dynamic_field` module.
- If the user's address does not exist as a key in the dynamic field, it adds a new key-value pair to the dynamic field. The key is the user's address and the value is the expiration time of the eligibility. The expiration time is calculated by calling the `msg_to_ts` function that converts the message to a timestamp in milliseconds.
- If the user's address already exists as a key in the dynamic field, it updates the value of the key to the new expiration time of the eligibility.

Now that you have implemented `verify`, you can move on to the next step, which is to demonstrate how someone can interact with the contract. Write an `interact` function that checks whether the user is verified or not.

```rust title='recaptcha.move'
// Define a public function for interacting with the registry object
public fun interact(
    registry: &mut Registry,  // A mutable reference to the registry object
    clock: &Clock,  // A reference to the clock object
    ctx: &mut TxContext  // A mutable reference to the transaction context
) {
    // Check if there is an existing interaction history for the sender address with the registry object
    if (df::exists_with_type<address, u64>(&registry.id, sender(ctx))) {
        // Borrow a mutable reference to the interaction history object
        let timestamp_ms = df::borrow_mut<address, u64>(&mut registry.id, sender(ctx));
        // Get the current timestamp in milliseconds from the clock object
        let current_timestamp = sui::clock::timestamp_ms(clock);

        if (current_timestamp - *timestamp_ms <= registry.window) {
            emit(
                Interaction{
                    sender: sender(ctx),
                    timestamp_ms: sui::clock::timestamp_ms(clock)
                }
            );
        } else {
            abort EVerificationExpired
        }
    } else {
        abort ENotYetVerified
    }
}
```

The `interact` function is a public function that allows the user to interact with the smart contract after passing the reCAPTCHA test. The function is linked to the `verify` function, which verifies the reCAPTCHA test result and registers the user's eligibility to interact with the smart contract.
The function takes three parameters:

- `registry`: A mutable reference to the registry object that stores the mapping of the user's address to the expiration time of the eligibility.
- `clock`: A reference to the clock object that provides the current timestamp in milliseconds.
- `ctx`: A mutable reference to the transaction context that provides information about the sender, the gas limit, and the gas price.

The function performs the following steps:

- It checks if there is an existing interaction history for the sender address with the registry object. The interaction history is stored as a dynamic field in the registry object. The dynamic field is a way of storing key-value pairs in an object without declaring them in advance. The dynamic field can be accessed, modified, or deleted using the `sui::dynamic_field` module.
- If there is an existing interaction history, it borrows a mutable reference to the interaction history object. The interaction history object contains the expiration time of the eligibility in milliseconds.
- It gets the current timestamp in milliseconds from the clock object and compares it with the expiration time of the eligibility. If the current timestamp is within the time window of the eligibility, it emits an interaction event. The interaction event is a struct that contains the sender address and the timestamp in milliseconds. The interaction event can be used to implement the logic of the decentralized application, such as voting, bidding, or playing.
- If the current timestamp is outside the time window of the eligibility, it aborts the execution with the error code `EVerificationExpired`. This means that the user has to pass the reCAPTCHA test again to interact with the smart contract.
- If there is no existing interaction history, it aborts the execution with the error code `ENotYetVerified`. This means that the user has not passed the reCAPTCHA test yet and cannot interact with the smart contract.

And with that, your `recaptcha.move` code is complete.

## Deployment

<ImportContent source="initialize-sui-client-cli.mdx" mode="snippet" />

<ImportContent source="publish-to-devnet-with-coins.mdx" mode="snippet" />

The package should successfully deploy. Next, set up a backend server that verifies whether the user has successfully completed the reCAPTCHA challenge and then signs a message that should be passed to the `verify` function.

## Backend

To implement the backend for the reCAPTCHA, you need to create an `express` app that can handle HTTP requests and responses. You also need to install some dependencies, such as `@noble/ed25519`, `axios`, `cors`, `helmet`, `morgan`, and `dotenv`. These packages help you with cryptography, HTTP requests, cross-origin resource sharing, security, logging, and environment variables.

Here are the steps to create the backend:

1. Initialize a new project with `npm init -y`.
2. Install the dependencies with `npm install --save @noble/ed25519 axios cors helmet morgan dotenv` or `yarn add @noble/ed25519 axios cors helmet morgan dotenv`.
3. Create a file named `app.ts` and paste the following code.

```typescript title='app.ts'
import * as ed from '@noble/ed25519';
import axios from 'axios';
import cors from 'cors';
import express from 'express';
import helmet from 'helmet';
import morgan from 'morgan';

import api from './api';
import MessageResponse from './interfaces/MessageResponse';
import * as middlewares from './middlewares';

require('dotenv').config();

const app = express();

app.use(morgan('dev'));
app.use(helmet());
app.use(cors());
app.use(express.json());

app.get<{}, MessageResponse>('/', (req, res) => {
	res.json({
		message: 'Express + TypeScript Server',
	});
});

interface RecaptchaApiResponse {
	success: boolean;
	challenge_ts: string; // timestamp of the challenge load (ISO format yyyy-MM-dd'T'HH:mm:ssZZ)
	hostname: string; // the hostname of the site where the reCAPTCHA was solved
	signature?: Uint8Array;
	pubKey?: Uint8Array;
	message?: Uint8Array;
	'error-codes'?: any[]; // optional
}

app.post('/verify-token', async (req, res) => {
	const now: number = Date.now();
	const privKey = process.env.SK!;

	const pubKey = await ed.getPublicKey(privKey);
	const { response, secret, userAddress } = req.body;

	console.log('userAddress: ' + userAddress);
	console.log('secret: ' + secret);
	console.log('response: ' + response);
	console.log('now: ' + now);
	console.log('privKey: ' + privKey);

	const message: string = stringToHex(userAddress.replace('0x', '').concat(now.toString()));

	console.log('message: ' + message);

	const signature = await ed.sign(message, privKey);
	const isValid = await ed.verify(signature, message, pubKey);

	console.log({ message, pubKey, signature, isValid });

	try {
		let axiosResponse = await axios.post<RecaptchaApiResponse>(
			`https://www.google.com/recaptcha/api/siteverify?secret=${secret}&response=${response}`,
		);
		console.log(axiosResponse.data);
		return res.status(200).json({
			success: axiosResponse.data.success,
			verificationInfo: axiosResponse.data,
			signature: Array.from(signature),
			pubKey: Array.from(pubKey),
			message: Array.from(Uint8Array.from(Buffer.from(message, 'hex'))),
		});
	} catch (error) {
		console.log(error);
		return res.status(500).json({
			success: false,
		});
	}
});

function stringToHex(str: string): string {
	let hex = '';
	for (let i = 0; i < str.length; i++) {
		const charCode = str.charCodeAt(i);
		const hexValue = charCode.toString(16);

		// Pad with zeros to ensure two-digit representation
		hex += hexValue.padStart(2, '0');
	}
	return hex;
}

app.use('/api/v1', api);

app.use(middlewares.notFound);
app.use(middlewares.errorHandler);

export default app;
```

4. Examine the code to see what it does.

- First, you import the modules that you need for your app.
- Next, you create an express app and use some middlewares to enhance its functionality. You use `morgan` for logging, `helmet` for security, `cors` for cross-origin resource sharing, and `express.json` for parsing JSON data.
- Then, you define a `GET` route for the root path (`/`) that returns a simple JSON message.
- After that, you define an interface for the reCAPTCHA API response. This is the data that you receive from Google when you verify the user's response token. It contains some fields such as `success`, `challenge_ts`, `hostname`, and `error-codes`. It also has some optional fields that you will add later, such as `signature`, `pubKey`, and `message`.
- Next, you define a `POST` route for the `/verify-token` path that handles the verification of the user's response token. This is the main logic of your backend. Here are the steps that you follow in this route:
  - Get the current time in milliseconds and store it in a variable named `now`.
  - Get the secret key from the environment variable `SK` and store it in a variable named `privKey`. This is the key that you use to sign your message and verify your identity to the smart contract.
  - Use the `@noble/ed25519` module to get the public key from the private key and store it in a variable named `pubKey`. This is the key that you share with the smart contract and the user.
  - Get the response token, the secret key, and the user's address from the request body and store them in variables named `response`, `secret`, and `userAddress`.
  - Log the values of these variables for debugging purposes.
  - Create a message that consists of the user's address (without the `0x` prefix) and the current time, and convert it to a hexadecimal string. Store it in a variable named `message`.
  - Use the `@noble/ed25519` module to sign the message with the private key and store the signature in a variable named `signature`.
  - Use the `@noble/ed25519` module to verify the signature with the message and the public key and store the result in a variable named `isValid`.
  - Log the values of these variables for debugging purposes.
  - Use the axios module to send a POST request to the reCAPTCHA API with the secret key and the response token as parameters. Store the response in a variable named `axiosResponse`.
  - Check if the response data has a success field and if it is true. If so, return a JSON object with the following fields:
    - `success`: true
    - `verificationInfo`: the response data from the reCAPTCHA API
    - `signature`: the signature converted to an array of numbers
    - `pubKey`: the public key converted to an array of numbers
    - `message`: the message converted to an array of numbers
  - If not, catch the error and return a JSON object with the following field:
    - `success`: false
- Next, define a helper function named `stringToHex` that takes a string as an input and returns a hexadecimal string as an output. This function is used to convert the message to a hexadecimal format.
- Finally, use some custom middlewares to handle not found and error cases, and export the app as a default module.

That's it. ðŸŽ‰ You have implemented the backend for the reCAPTCHA. To run the app, you can use `node app.ts` or `ts-node app.ts` if you have TypeScript installed. You can also use a tool like `nodemon` to automatically restart the app when you make changes. To test the app, you can use a tool like Postman or curl to send requests to the app and see the responses.

## Frontend

To implement the frontend for the reCAPTCHA, you need to create a react app that can render a user interface and interact with the backend and the smart contract. You also need to install some dependencies, such as `@mysten/dapp-kit`, `@mysten/sui`, `axios`, and `react-google-recaptcha`. These packages help you with wallet integration, transaction execution, HTTP requests, and reCAPTCHA rendering.

Here are the steps to create the frontend:

1. Initialize a new project with `pnpm create vite recaptcha-app --template react-ts`.
2. Install the dependencies with `pnpm install --save @mysten/dapp-kit @mysten/sui axios react-google-recaptcha`.
3. Create a file named `.env` and add the following environment variables:
   - `VITE_reCAPTCHA_SITE_KEY`: the site key that you get from Google when you register your site for reCAPTCHA
   - `VITE_reCAPTCHA_SECRET_KEY`: the secret key that you get from Google when you register your site for reCAPTCHA
   - `VITE_PACKAGE_ID`: the package ID of the smart contract that you want to interact with
   - `VITE_REGISTRY_ID`: the registry ID of the smart contract that you want to interact with
4. Create a file named `App.tsx` and paste the code you have provided.

```typescript title='App.tsx'
import './App.css';

import {
	ConnectButton,
	useCurrentAccount,
	useCurrentWallet,
	useSignAndExecuteTransaction,
} from '@mysten/dapp-kit';
import { Transaction } from '@mysten/sui/transactions';
import { SUI_CLOCK_OBJECT_ID } from '@mysten/sui/utils';
import Axios from 'axios';
import { useEffect, useState } from 'react';
import ReCAPTCHA from 'react-google-recaptcha';

interface RecaptchaApiResponse {
	success: boolean;
	challenge_ts: string; // timestamp of the challenge load (ISO format yyyy-MM-dd'T'HH:mm:ssZZ)
	hostname: string; // the hostname of the site where the reCAPTCHA was solved
	signature?: Uint8Array;
	pubKey?: Uint8Array;
	message?: Uint8Array;
	'error-codes'?: any[]; // optional
}

function App() {
	const { currentWallet } = useCurrentWallet();
	const { mutateAsync: signAndExecuteTransaction } = useSignAndExecuteTransaction();
	const currentAccount = useCurrentAccount();

	const SITE_KEY = import.meta.env.VITE_reCAPTCHA_SITE_KEY!;
	const SECRET_KEY = import.meta.env.VITE_reCAPTCHA_SECRET_KEY!;
	const packageId = import.meta.env.VITE_PACKAGE_ID!;
	const registryId = import.meta.env.VITE_REGISTRY_ID!;
	const moduleId: string = 'recaptcha';

	const [isRecaptchaValid, setRecaptchaValidation] = useState(false);

	const [verificationPassedOneTime, setVerificationPassedOneTime] = useState(false);

	const [message, setMessage] = useState(new Uint8Array());
	const [pubKey, setPubKey] = useState(new Uint8Array());
	const [signature, setSignature] = useState(new Uint8Array());

	const onChange = async (token: string | null) => {
		if (token === null) {
			setRecaptchaValidation(false);
		} else {
			const recaptchaApiResponse: RecaptchaApiResponse = await verifyToken(token);

			setRecaptchaValidation(true);

			if (!verificationPassedOneTime) setVerificationPassedOneTime(true);

			if (recaptchaApiResponse.message !== undefined) setMessage(recaptchaApiResponse.message);
			if (recaptchaApiResponse.pubKey !== undefined) setPubKey(recaptchaApiResponse.pubKey);
			if (recaptchaApiResponse.signature !== undefined)
				setSignature(recaptchaApiResponse.signature);
		}
	};

	async function verifyToken(token: string): Promise<RecaptchaApiResponse> {
		try {
			const response = await Axios.post(`https://bot-prevention-api.vercel.app/verify-token`, {
				response: token,
				secret: SECRET_KEY,
				userAddress: currentAccount?.address,
			});
			return response['data'];
		} catch (error) {
			console.log(error);
		}
		return {} as RecaptchaApiResponse;
	}

	useEffect(() => {
		// You can do something with `currentWallet` here.
	}, [currentWallet]);

	return (
		<div className="App">
			<ConnectButton />
			<div>
				<button
					disabled={!verificationPassedOneTime}
					onClick={async () => {
						const transaction = new Transaction();

						transaction.moveCall({
							target: `${packageId}::${moduleId}::interact`,
							arguments: [transaction.object(registryId), transaction.object(SUI_CLOCK_OBJECT_ID)],
						});

						console.log(
							await signAndExecuteTransaction({
								transaction: transaction,
							}),
						);
					}}
				>
					Interact
				</button>
			</div>

			<div>
				<button
					disabled={!isRecaptchaValid}
					onClick={async () => {
						const transaction = new Transaction();

						transaction.moveCall({
							target: `${packageId}::${moduleId}::verify`,
							arguments: [
								transaction.object(registryId),
								transaction.pure(signature),
								transaction.pure(pubKey),
								transaction.pure(message),
							],
						});

						console.log(
							await signAndExecuteTransaction({
								transaction,
							}),
						);
					}}
				>
					Verify
				</button>
			</div>

			<hr />
			<ReCAPTCHA sitekey={SITE_KEY} onChange={onChange} />
		</div>
	);
}

export default App;
```

5. Examine the code to see what it does.

- First, import the modules that you need for your app.
- Next, use hooks from `@mysten/dapp-kit` to get access to the current wallet, the current account, and the `signAndExecuteTransaction` function. These help you connect to the wallet and execute transactions on the blockchain.
- Then, define some constants for the site key, the secret key, the package ID, the registry ID, and the module ID. These are the values that you use to interact with the reCAPTCHA API and the smart contract.
- After that, define some state variables to store the status of the reCAPTCHA validation, the verification result, and the message, the public key, and the signature that you get from the backend. Use the `useState` hook from React to manage these state variables.
- Next, define a function named `onChange` that takes a token as an input and handles the change of the reCAPTCHA component. This function is triggered when the user completes the reCAPTCHA challenge. Here are the steps that you follow in this function:
  - Check if the token is null. If so, set the reCAPTCHA validation state to false.
  - If not, call the `verifyToken` function with the token as an argument and store the result in a variable named `recaptchaApiResponse`. This function sends a POST request to the backend and gets the verification result and the data that you need to interact with the smart contract.
  - Set the reCAPTCHA validation state to true.
  - Check if the `verificationPassedOneTime` state is false. If so, set it to true. This state is used to enable the interact button only once after the user passes the verification.
  - Check if the `recaptchaApiResponse` has the message, the `pubKey`, and the `signature` fields. If so, set the corresponding state variables with the values from the response.
- Next, define a function named `verifyToken` that takes a token as an input and returns a promise of the reCAPTCHA API response. This function is used to communicate with the backend. Here are the steps that you follow in this function:
  - Try to send a POST request to the backend URL with the token, the secret key, and the user's address as the body parameters. Use the `axios` module to send the request and store the response in a variable named `response`.
  - Return the data field of the response as the reCAPTCHA API response.
  - Catch any error and log it to the console.
  - Return an empty object as the default reCAPTCHA API response.
- Next, use the `useEffect` hook from React to run some code when the `currentWallet` state changes. In this case, you don't do anything, but you could add some logic here if you want to.
- Finally, return a JSX element that renders the app. The app consists of the following components:
  - A `ConnectButton` component from `@mysten/dapp-kit` that allows the user to connect to their wallet.
  - A button that allows the user to interact with the smart contract. This button is disabled unless the user passes the verification at least once. When the user clicks this button, create a new `Transaction` object from `@mysten/sui` and add a `moveCall` action that calls the `interact` function of the smart contract with the registry ID and the clock object ID as arguments. Then, use the `signAndExecuteTransaction` function from `@mysten/dapp-kit` to sign and execute the transaction block on the blockchain. You also log the result to the console.
  - A button that allows the user to verify their identity to the smart contract. This button is disabled unless the user passes the reCAPTCHA challenge. When the user clicks this button, create a new `Transaction` object from `@mysten/sui` and add a `moveCall` action that calls the verify function of the smart contract with the registry ID, the signature, the public key, and the message as arguments. Then, use the `signAndExecuteTransaction` function from `@mysten/dapp-kit` to sign and execute the transaction block on the blockchain. You also log the result to the console.
  - A `ReCAPTCHA` component from `react-google-recaptcha` that renders the reCAPTCHA widget. You pass the site key and the `onChange` function as props to this component.

That's it. ðŸŽ‰ You have implemented the frontend for the reCAPTCHA. To run the app, you can use `pnpm run dev`. To test the app, you can open the browser and go to the `localhost:5173` URL. You should see the app and can interact with the reCAPTCHA and the smart contract.

>>>> sui/docs/content/guides/developer/app-examples/reviews-rating.mdx
---
title: Review Rating
description: This example app creates a food rating service that stores all review data and algorithms on-chain.
keywords: [ execute transaction hook, rating app, review app, ConnectButton, custom hooks for state management, transaction hooks ]
---

The following documentation goes through an example implementation of a review rating platform for the food service industry on Sui.
Unlike traditional review rating platforms that often do not disclose the algorithm used to rate reviews, this example uses an algorithm that is published on-chain for everyone to see and verify. The low gas cost of computation on Sui make it financially feasible to submit, score, and order all reviews on-chain.

<ImportContent source="prerequisites.mdx" mode="snippet" />

## Personas

There are four actors in the typical workflow of the Reviews Rating example.

- Service: Review requester.
- Dashboard: Review hub.
- Reviewer: Review creator.
- Moderator: Review list editor.

```mermaid
sequenceDiagram
  Service ->> Dashboard: Add service to dashboard
  Service ->> Reviewer: Send proof of experience
  Reviewer ->> Service: Send review
  Service ->> Reviewer: Send reward
  Review reader ->> Service: Vote on review
  Moderator ->> Service: Remove abused review
```

### Service owners

Service owners are entities like restaurants that list their services on the platform. They want to attract more customers by receiving high-rated reviews for their services.

Service owners allocate a specific amount of SUI as a reward pool. Assets from the pool are used to provide rewards for high-rated reviews. A proof of experience (PoE) NFT confirms a reviewer used the service, which the reviewer can burn later to provide a verified review. Service owners provide their customers with unique identifiers (perhaps using QR codes) to identify individual reviewers.

### Reviewers

Reviewers are consumers of services that use the review system. Reviewers provide feedback in the form of comments that detail specific aspects of the service as well as a star rating to inform others. The reviews are rated, with the most effective reviews getting the highest rating. Service owners award the 10 highest rated reviews for their service. How often the rewards are distributed is up to the service owner's discretion; for example, the rewards can be distributed once a week or once a month.

### Review readers

Review readers access reviews to make informed decisions on selecting services. Readers rate reviews by casting votes. The review readers' ratings are factored into the algorithm that rates the reviews, with the authors of the highest-rated reviews getting rewarded. Although it is not implemented as part of this guide, this example could be extended to award review readers a portion of the rewards for casting votes for reviews.

### Moderators

Moderators monitor content of the reviews and can delete any reviews that contain inappropriate content.

The incentive mechanism for moderators is not implemented for this guide, but service owners can all pay into a pool that goes to moderators on a rolling basis. People can stake moderators to influence what portion of the reward each moderator gets, up to a limit (similar to how validators are staked on chain), and moderator decisions are decided by quorum of stake weight. This process installs incentives for moderators to perform their job well.

## How reviews are scored

The reviews are scored on chain using the following criteria:

- Intrinsic score (IS): Length of review content.
- Extrinsic score (ES): Number of votes a review receives.
- Verification multiplier (VM): Reviews with PoE receive a multiplier to improve rating.

```
Total Score = (IS + ES) * VM
```

## Smart contracts

There are several modules that create the backend logic for the example.

### `dashboard.move`

The `dashboard.move` module defines the `Dashboard` struct that groups services.

```move
/// Dashboard is a collection of services
public struct Dashboard has key, store {
    id: UID,
    service_type: String
}
```

The services are grouped by attributes, which can be cuisine type, geographical location, operating hours, Google Maps ID, and so on. To keep it basic, the example stores only `service_type` (for example, fast food, Chinese, Italian).

```move
/// Creates a new dashboard
public fun create_dashboard(
    service_type: String,
    ctx: &mut TxContext,
) {
    let db = Dashboard {
        id: object::new(ctx),
        service_type
    };
    transfer::share_object(db);
}

/// Registers a service to a dashboard
public fun register_service(db: &mut Dashboard, service_id: ID) {
    df::add(&mut db.id, service_id, service_id);
}
```

A `Dashboard` is a [shared object](../../../concepts/object-ownership/shared.mdx), so any service owner can register their service to a dashboard.
A service owner should look for dashboards that best match their service attribute and register.
A dynamic field stores the list of services that are registered to a dashboard. Learn more about dynamic fields in [The Move Book](https://move-book.com/programmability/dynamic-fields.html).
A service may be registered to multiple dashboards at the same time. For example, a Chinese-Italian fusion restaurant may be registered to both the Chinese and Italian dashboards.

:::info

See [Object Ownership Basics](../sui-101/object-ownership.mdx) for more information on the differences between object types.

:::

### `review.move`

This module defines the `Review` struct.

```move
/// Represents a review of a service
public struct Review has key, store {
    id: UID,
    owner: address,
    service_id: ID,
    content: String,
    // intrinsic score
    len: u64,
    // extrinsic score
    votes: u64,
    time_issued: u64,
    // proof of experience
    has_poe: bool,
    total_score: u64,
    overall_rate: u8,
}

/// Updates the total score of a review
fun update_total_score(rev: &mut Review) {
    rev.total_score = rev.calculate_total_score();
}

/// Calculates the total score of a review
fun calculate_total_score(rev: &Review): u64 {
    let mut intrinsic_score: u64 = rev.len;
    intrinsic_score = math::min(intrinsic_score, 150);
    let extrinsic_score: u64 = 10 * rev.votes;
    // VM = either 1.0 or 2.0 (if user has proof of experience)
    let vm: u64 = if (rev.has_poe) { 2 } else { 1 };
    (intrinsic_score + extrinsic_score) * vm
}
```

In addition to the content of a review, all the elements that are required to compute total score are stored in a `Review` object.

A `Review` is a [shared object](../../../concepts/object-ownership/shared.mdx), so anyone can cast a vote on a review and update its `total_score` field.
After `total_score` is updated, the [`update_top_reviews`](#casting-votes) function can be called to update the `top_reviews` field of the `Service` object.

### `service.move`

This module defines the `Service` struct that service owners manage.

```move
const MAX_REVIEWERS_TO_REWARD: u64 = 10;

/// Represents a service
public struct Service has key, store {
    id: UID,
    reward_pool: Balance<SUI>,
    reward: u64,
    top_reviews: vector<ID>,
    reviews: ObjectTable<ID, Review>,
    overall_rate: u64,
    name: String
}
```

#### Reward distribution

The same amount is rewarded to top reviewers, and the reward is distributed to 10 participants at most.
The pool of `SUI` tokens to be distributed to reviewers is stored in the `reward_pool` field, and the amount of `SUI` tokens awarded to each participant is configured in `reward` field.

#### Storage for reviews

Because anyone can submit a review for a service, `Service` is defined as a shared object. All the reviews are stored in the `reviews` field, which has `ObjectTable<ID, Review>` type. The `reviews` are stored as children of the shared object, but they are still accessible by their `ID`. See [Dynamic Collections](https://move-book.com/programmability/dynamic-collections.html#objecttable) in The Move Book for more information on `ObjectTables`.

In other words, anyone can go to a transaction explorer and find a review object by its object ID, but they won't be able to use a review as an input to a transaction by its object ID.

:::info

See [Dynamic Collections](https://move-book.com/programmability/dynamic-collections.html) in The Move Book for more information on the differences between `Table` and `ObjectTable`.

:::

The top rated reviews are stored in `top_reviews` field, which has `vector<ID>` type. A simple vector can store the top rated reviews because the maximum number of reviews that can be rewarded is 10.
The elements of `top_reviews` are sorted by the `total_score` of the reviews, with the highest rated reviews coming first. The vector contains the `ID` of the reviews, which can be used to retrieve content and vote count from the relevant `reviews`.

#### Casting votes

A reader can cast a vote on a review to rate it as follows:

```move
/// Upvotes a review and reorders top_reviews
public fun upvote(service: &mut Service, review_id: ID) {
    let review = &mut service.reviews[review_id];
    review.upvote();
    service.reorder(review_id, review.get_total_score());
}

/// Reorders top_reviews after a review is updated
/// If the review is not in top_reviews, it will be added if it is in the top 10
/// Otherwise, it will be reordered
fun reorder(
    service: &mut Service,
    review_id: ID,
    total_score: u64
) {
    let (contains, idx) = service.top_reviews.index_of(&review_id);
    if (!contains) {
        service.update_top_reviews(review_id, total_score);
    } else {
        service.top_reviews.remove(idx);
        let idx = service.find_idx(total_score);
        service.top_reviews.insert(review_id, idx);
    }
}

/// Updates top_reviews if necessary
fun update_top_reviews(
    service: &mut Service,
    review_id: ID,
    total_score: u64
) {
    if (service.should_update_top_reviews(total_score)) {
        let idx = service.find_idx(total_score);
        service.top_reviews.insert(review_id, idx);
        service.prune_top_reviews();
    };
}

/// Finds the index of a review in top_reviews
fun find_idx(service: &Service, total_score: u64): u64 {
    let mut i = service.top_reviews.length();
    while (0 < i) {
        let review_id = service.top_reviews[i - 1];
        if (service.get_total_score(review_id) > total_score) {
            break
        };
        i = i - 1;
    };
    i
}

/// Prunes top_reviews if it exceeds MAX_REVIEWERS_TO_REWARD
fun prune_top_reviews(
    service: &mut Service
) {
    let len = service.top_reviews.length();
    if (len > MAX_REVIEWERS_TO_REWARD) {
        service.top_reviews.pop_back();
    };
}
```

Whenever someone casts a vote on a review, the `total_score` of the review is updated and the `update_top_reviews` function updates the `top_reviews` field, as needed.
Casting a vote also triggers a reordering of the `top_reviews` field to ensure that the top rated reviews are always at the top.

#### Authorization

```move
/// A capability that can be used to perform admin operations on a service
struct AdminCap has key, store {
    id: UID,
    service_id: ID
}

/// Represents a moderator that can be used to delete reviews
struct Moderator has key {
    id: UID,
}
```

This example follows a capabilities pattern to manage authorizations.
For example, `SERVICE OWNERS` are given `AdminCap` and `MODERATORS` are given `Moderator` such that only they are allowed to perform privileged operations.

To learn more about the capabilities pattern, see [The Move Book](https://move-book.com/programmability/capability.html).

## Deployment

Navigate to the [setup folder](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/setup) of the repository and execute the `publish.sh` script. Refer to the [README instructions](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/README.md) for deploying the smart contracts.

## Frontend

The frontend module is written in React, and is structured to provide a responsive user experience for interacting with a review rating platform. The [`page` component](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/page.tsx) supports user log in as a `SERVICE OWNER`, a `MODERATOR`, or a `REVIEWER`. A `REVIEW READER` role is not implemented for this example, but a `REVIEWER` can also read reviews and cast votes.

### Directories structure

The frontend is a NextJS project, that follows the NextJS App Router [project structure](https://nextjs.org/docs/app/building-your-application/routing).
The main code of the frontend is located in the [app/src/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/) directory.

The main sub-directories are:

- [app/](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/): The main code of the pages and the global styles.
- [components/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/components): The reusable components of the app, organized in sub-directories.
- [hooks/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/hooks): The custom hooks used in the app.
- [moderator/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/moderator): The pages for `MODERATOR`.
- [serviceOwner/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/serviceOwner): The pages for `SERVICE OWNER`.
- [types/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/types): The types/interfaces used in the app.
- [user/](https://github.com/MystenLabs/reviews-ratings-poc/tree/main/app/src/app/user): The pages for `REVIEWER`.

### Connect button

The Wallet Kit comes with a pre-built React.js component called `ConnectButton` that displays a button to connect and disconnect a wallet. The component handles connecting and disconnecting wallet logic.

Place the `ConnectButton` in the navigation bar for users to connect their wallets:

```ts title='src/app/components/navbar/Navbar.tsx'
import { ConnectButton } from '@mysten/wallet-kit';
import { usePathname } from 'next/navigation';

import { useAuthentication } from '@/app/hooks/useAuthentication';

export const Navbar = () => {
	const pathname = usePathname();
	console.log(pathname);
	const { user, handleLogout } = useAuthentication();

	return (
		<div
			className="grid grid-cols-12 w-full items-center p-[8px] h-[80px] border-b-gray-400 border-b-[1px] sticky top-0"
			style={{
				background: 'white',
			}}
		>
			<div className="col-span-3 flex space-x-3 items-center">
				<div className="text-red-600 text-2xl font-bold cursor-pointer" onClick={handleLogout}>
					Restaurant Reviews
				</div>
			</div>

			<div className="col-span-6 flex space-x-3 justify-center">
				{pathname !== '/' && (
					<h6 className="mb-4 text-2xl leading-none tracking-tight text-gray-400">
						logged in as{' '}
						<span className="underline underline-offset-3 decoration-8 decoration-blue-400 dark:decoration-blue-600">
							{user.role === 'user' && 'USER'}
							{user.role === 'serviceOwner' && 'SERVICE OWNER'}
							{user.role === 'moderator' && 'MODERATOR'}
						</span>
					</h6>
				)}
			</div>

			<div className="col-span-3 flex justify-end gap-[14px]">
				<ConnectButton />
			</div>
		</div>
	);
};
```

### Type definitions

All the type definitions are in `src/app/types/`.

`Review` and `Service` represent the review and service objects.

```ts title='src/app/types/Review.ts'
export interface Review {
	id: string;
	owner: string;
	service_id: string;
	content: string;
	len: number;
	votes: number;
	time_issued: number;
	has_poe: boolean;
	total_score: number;
}
```

```ts title='src/app/types/Service.ts'
export interface Service {
	id: string;
	name: string;
	stars: number;
	reward?: number;
	pool?: number;
}
```

### Execute transaction hook

In the frontend, you might need to execute a transaction block in multiple places, hence it's better to extract the transaction execution logic and reuse it everywhere. Let's examine the execute transaction hook.

```ts title='src/app/hooks/useSignAndExecuteTransaction.ts'
import { Transaction } from '@mysten/sui/transactions';
import { useWalletKit } from '@mysten/wallet-kit';
import { toast } from 'react-hot-toast';

import { useSui } from './useSui';

export const useSignAndExecuteTransaction = () => {
	const { executeSignedTransaction } = useSui();
	const { signTransaction } = useWalletKit();
	const handleSignAndExecuteTransaction = async (
		tx: Transaction,
		operation: String,
		setIsLoading: any,
	) => {
		return signTransaction({
			transaction: tx,
		})
			.then((signedTx: any) => {
				return executeSignedTransaction({
					signedTx,
					requestType: 'WaitForLocalExecution',
					options: {
						showEffects: true,
						showEvents: true,
					},
				})
					.then((resp) => {
						setIsLoading(false);
						console.log(resp);
						if (resp.effects?.status.status === 'success') {
							console.log(`${operation} operation successful`);
							toast.success(`${operation} operation successful`);
							return;
						} else {
							console.log(`${operation} operation failed`);
							toast.error(`${operation} operation failed.`);
							return;
						}
					})
					.catch((err) => {
						setIsLoading(false);
						console.log(`${operation} operation failed`);
						console.log(`${operation} error : `, err);
						toast.error(`Something went wrong, ${operation} operation failed.`);
					});
			})
			.catch((err) => {
				setIsLoading(false);
				console.log(`signing goes wrong ${operation} error : `, err);
				toast.error(`signing goes wrong, ${operation} operation failed.`);
			});
	};
	return { handleSignAndExecuteTransaction };
};
```

A `Transaction` is the input, sign it with the current connected wallet account, execute the transaction block, return the execution result, and finally display a basic toast message to indicate whether the transaction is successful or not.

Use the `useWalletKit()` hook from the Wallet Kit to retrieve the Sui client instance configured in `WalletKitProvider`. The `signTransaction()` function is another hook that helps to sign the transaction block using the currently connected wallet. It displays the UI for users to review and sign their transactions with their selected wallet. To execute a transaction block, the `executeSignedTransaction()` on the Sui client instance of the Sui TypeScript SDK. Use `react-hot-toast` as another dependency to toast transaction status to users.

### Components and custom hooks for state management

- Custom hooks: To keep the code as structured as possible, multiple custom hooks are utilized to manage the list of reviews associated with a service. The [useGetReviews](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useGetReviews.ts)
  custom hook encapsulates the service, exposing all the required information (with fields such as `nameOfService`, `listOfReviews`, `listOfStars`) to display the reviews in a table.
  Multiple additional custom hooks, such as [useDashboardCreation](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useDashboardCreation.ts), and [useServiceReview](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useServiceReview.ts) are encapsulating their own piece of state and logic to make the code readable and maintainable.

- Component for adding a new review: The [AddReview](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/components/review/AddReview.tsx) component is implemented to facilitate the creation of a new review. It is rendered by the [servicePage](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/service/[id]/page.tsx) to collect a review entry from a `USER` and uses the `signAndExecuteTransaction` function of the [useWalletKit] hook to execute the transaction.

- Proof of experience generation: PoE is an NFT that is minted by `SERVICE OWNER` for customers after they dine at the restaurant; customers can then burn the PoE to write a high-rated review later. Minting an NFT is facilitated by the [ownedServicePage](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/serviceOwner/ownedServices/page.tsx) component. This component is using the [useServicePoEGeneration](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/hooks/useServicePoeGeneration.ts) custom hook.

- Delete a review: The moderator can delete a review that contains inappropriate content. [moderatorRemovePage](https://github.com/MystenLabs/reviews-ratings-poc/blob/main/app/src/app/moderator/remove/[id]/[nft]/page.tsx) component is used to delete a review.

## Related links

<RelatedLink href="https://github.com/MystenLabs/sui/tree/main/examples/move/reviews_rating" label="Reviews Rating repository" desc="Repo with the Revies Rating codebase." />

>>>> sui/docs/content/guides/developer/app-examples/tic-tac-toe.mdx
---
title: Tic-Tac-Toe
effort: small
description: This example demonstrates how to create three variations of a tic-tac-toe app on Sui.
keywords: [ multisig public key, multisig example, game example, game app, owned objects, shared objects, dynamic object fields, multisig accounts ]
---

This guide covers three different implementations of the game tic-tac-toe on Sui. The first example utilizes a centralized admin that owns the board object and marks it on the usersâ€™ behalf. The second example utilizes a shared object that both users can mutate. And the third example utilizes a [multisig](https://docs.sui.io/guides/developer/cryptography/multisig), where instead of sharing the game board, it's in a 1-of-2 multisig of both usersâ€™ accounts.

The guide is divided into three parts that each cover a different implementation of the tic-tac-toe game board:

1. [Centralized game board](#owned.move): An admin service that tracks player moves and updates the game board.
1. [Shared game board](#shared.move): A shared object that allows players to directly update the game board.
1. [Multisig operated game board](#multisig): A multisig account that acts as the game admin, allowing either player to update the game board directly.

<ImportContent source="prerequisites.mdx" mode="snippet" />

:::info

You can view the [complete source code for this app example](https://github.com/MystenLabs/sui/tree/main/examples/tic-tac-toe) in the Sui repository.

:::

## What the guide teaches

- **Owned objects:** The guide teaches you how to use [owned objects](../../../concepts/object-ownership/address-owned.mdx), in this case to act as the game board in the centralized and multisig version of tic-tac-toe. Owned objects are objects that are owned by a single account and can only be modified by that account. In this case, the game board is owned by a game admin, who is responsible for updating the board with each player's move.
- **Shared objects:** The guide teaches you how to use [shared objects](../../../concepts/object-ownership/shared.mdx), in this case to act as the game board in the more decentralized version of tic-tac-toe. Shared objects are objects that can be modified by multiple accounts. In this case, the game board is shared between the two players, allowing them to update the board directly.
- **Multisig accounts:** The guide teaches you how to use [multisig accounts](https://sdk.mystenlabs.com/typescript/cryptography/multisig) to share ownership of the game board between two players. Multisig accounts are accounts that require a certain threshold of signatures to authorize a transaction. In this case, the game board is owned by a 1-of-2 multisig account.
- **Dynamic object fields:** The guide teaches you how to use dynamic object fields, in this case to transfer the actions of the players to the game board, which will be retrieved by the game admin. See [The Move Book](https://move-book.com/programmability/dynamic-object-fields.html to learn more about dynamic object fields.


## Directory structure

To begin, create a new folder on your system titled `tic-tac-toe` that holds all your files.

In this folder, create the following subfolders: 
- `move` to hold the Move code for the game board.
  - `sources` to hold the Move source files.

<details>

<summary>

Add `Move.toml` to `tic-tac-toe/move/`

</summary>

<ImportContent source="examples/tic-tac-toe/move/Move.toml" mode="code" />

</details>

:::checkpoint

- You have the latest version of Sui installed. If you run `sui --version` in your terminal or console, it responds with the currently installed version.
- You have a directory to place the files you create in. 
- You have created a `Move.toml` file in the `tic-tac-toe/move/` directory.

:::

## `owned.move` {#owned.move}

Create a new file in `tic-tac-toe/move/sources` titled `owned.move`. Later, you will update this file to contain the Move code for the game board in the centralized (and multisig) version of tic-tac-toe.

In this first example of tic-tac-toe, the `Game` object, including the game board, is controlled by a game admin.

<ImportContent source="examples/tic-tac-toe/move/sources/owned.move" mode="code" struct="Game" noComments />

Ignore the `admin` field for now, as it is only relevant for the multisig approach.

Games are created with the `new` function:

<ImportContent source="examples/tic-tac-toe/move/sources/owned.move" mode="code" fun="new" noComments />

Some things to note: 
- `MARK__` is a constant that represents an empty cell on the game board. `MARK_X` and `MARK_O` represent the two players' markers.
- The first player is sent a `TurnCap`, which gives them permission to take the next turn.
- This function creates and returns the `Game` object, it is up to its creator to send it to the game admin to own.

Because the players donâ€™t own the game board object, they cannot directly mutate it. Instead, they indicate their move by creating a `Mark` object with their intended placement and send it to the game object using transfer to object:

<ImportContent source="examples/tic-tac-toe/move/sources/owned.move" mode="code" struct="Mark" noComments />

When playing the game, the admin operates a service that keeps track of marks using events. When a request is received (`send_mark`), the admin tries to place the marker on the board (`place_mark`). Each move requires two steps (thus two transactions): one from the player and one from the admin. This setup relies on the admin's service to keep the game moving.

<ImportContent source="examples/tic-tac-toe/move/sources/owned.move" mode="code" fun="send_mark" noComments />

<ImportContent source="examples/tic-tac-toe/move/sources/owned.move" mode="code" fun="place_mark" noComments />

When a player sends a mark, a `Mark` object is created and is sent to the `Game` object. The admin then receives the mark and places it on the board. This is a use of dynamic object fields, where an object, `Game`, can hold other objects, `Mark`.

To view the entire source code, see the [owned.move source file](https://github.com/MystenLabs/sui/blob/main/examples/tic-tac-toe/move/sources/owned.move). You can find the rest of the logic, including how to check for a winner, as well as deleting the game board after the game concludes there.

<details>

<summary>

`owned.move`

</summary>

<ImportContent source="examples/tic-tac-toe/move/sources/owned.move" mode="code" />

</details>

An alternative version of this game, shared tic-tac-toe, uses shared objects for a more straightforward implementation that doesn't use a centralized service. This comes at a slightly increased cost, as using shared objects is more expensive than transactions involving wholly owned objects.

## `shared.move` {#shared.move}

In the previous version, the admin owned the game object, preventing players from directly changing the gameboard, as well as requiring two transactions for each marker placement. In this version, the game object is a shared object, allowing both players to access and modify it directly, enabling them to place markers in just one transaction. However, using a shared object generally incurs extra costs because Sui needs to sequence the operations from different transactions. In the context of this game, where players are expected to take turns, this shouldn't significantly impact performance. Overall, this shared object approach simplifies the implementation compared to the previous method.

As the following code demonstrates, the `Game` object in this example is almost identical to the one before it. The only differences are that it does not include an `admin` field, which is only relevant for the multisig version of the game, and it does not have `store`, because it only ever exists as a shared object (so it cannot be transferred or wrapped).

<ImportContent source="examples/tic-tac-toe/move/sources/shared.move" mode="code" struct="Game" noComments />

Take a look at the `new` function:

<ImportContent source="examples/tic-tac-toe/move/sources/shared.move" mode="code" fun="new" noComments />

Instead of the game being sent to the game admin, it is instantiated as a shared object. The other notable difference is that there is no need to mint a `TurnCap` because the only two addresses that can play this game are `x` and `o`, and this is checked in the next function, `place_mark`:

<ImportContent source="examples/tic-tac-toe/move/sources/shared.move" mode="code" fun="place_mark" noComments />

<details>

<summary>

`shared.move`

</summary>

<ImportContent source="examples/tic-tac-toe/move/sources/shared.move" mode="code" />

</details>

## Multisig  {#multisig}

Multisig tic-tac-toe uses the same Move code as the owned version of the game, but interacts with it differently. Instead of transferring the game to a third party admin account, the players create a 1-of-2 multisig account to act as the game admin, so that either player can sign on behalf of the admin. This pattern offers a way to share a resource between up to ten accounts without relying on consensus.

In this implementation of the game, the game is in a 1-of-2 multisig account that acts as the game admin. In this particular case, because there are only two players, the previous example is a more convenient use case. However, this example illustrates that in some cases, a multisig can replace shared objects, thus allowing transactions to bypass consensus when using such an implementation.

### Creating a multisig account

A multisig account is defined by the public keys of its constituent key pairs, their relative weights, and the threshold -- a signature is valid if the sum of weights of constituent keys having signed the signature exceeds the threshold. In our case, there are at most two constituent keypairs, they each have a weight of 1 and the threshold is also 1. A multisig cannot mention the same public key twice, so keys are deduplicated before the multisig is formed to deal with the case where a player is playing themselves:

```typescript title="examples/tic-tac-toe/ui/src/MultiSig.ts"
export function multiSigPublicKey(keys: PublicKey[]): MultiSigPublicKey {
  const deduplicated: { [key: string]: PublicKey } = {};
  for (const key of keys) {
    deduplicated[key.toSuiAddress()] = key;
  }

  return MultiSigPublicKey.fromPublicKeys({
    threshold: 1,
    publicKeys: Object.values(deduplicated).map((publicKey) => {
      return { publicKey, weight: 1 };
    }),
  });
}
```

<details>

<summary>

`MultiSig.ts`

</summary>

<ImportContent source="examples/tic-tac-toe/ui/src/MultiSig.ts" mode="code" />

</details>

Note that an address on Sui can be derived from a public key (this fact is used in the previous example to deduplicate public keys based on their accompanying address), but the opposite is not true. This means that to start a game of multisig tic-tac-toe, players must exchange public keys, instead of addresses.

### Building a multisig transaction

When creating a multisig game, we make use of `owned::Game`'s `admin` field to store the multisig public key for the admin account. Later, it will be used to form the signature for the second transaction in the move. This does not need to be stored on-chain, but we are doing so for convenience so that when we fetch the `Game`'s contents, we get the public key as well:

```typescript title="examples/tic-tac-toe/ui/src/hooks/useTransactions.ts"
newMultiSigGame(player: PublicKey, opponent: PublicKey): Transaction {
  const admin = multiSigPublicKey([player, opponent]);
  const tx = new Transaction();

  const game = tx.moveCall({
    target: `${this.packageId}::owned::new`,
    arguments: [
      tx.pure.address(player.toSuiAddress()),
      tx.pure.address(opponent.toSuiAddress()),
      tx.pure(bcs.vector(bcs.u8()).serialize(admin.toRawBytes()).toBytes()),
    ],
  });

  tx.transferObjects([game], admin.toSuiAddress());

  return tx;
}
```

`useTransactions.ts` also contains functions to place, send, and receive marks, end the game, and burn completed games. These functions all return a `Transaction` object, which is used in the React frontend to execute the transaction with the appropriate signer.

<details>

<summary>

`useTransactions.ts`

</summary>

<ImportContent source="examples/tic-tac-toe/ui/src/hooks/useTransactions.ts" mode="code" />

</details>

### Placing a mark

Placing a mark requires two transactions, just like the owned example, but they are both driven by one of the players. The first transaction is executed by the player as themselves, to send the mark to the game, and the second is executed by the player acting as the admin to place the mark they just sent. In the React frontend, this is performed as follows:

```typescript title="examples/tic-tac-toe/ui/src/pages/Game.tsx"
function OwnedGame({
  game,
  trophy,
  invalidateGame,
  invalidateTrophy,
}: {
  game: GameData;
  trophy: Trophy;
  invalidateGame: InvalidateGameQuery;
  invalidateTrophy: InvalidateTrophyQuery;
}): ReactElement {
  const adminKey = game.admin ? new MultiSigPublicKey(new Uint8Array(game.admin)) : null;

  const client = useSuiClient();
  const signAndExecute = useExecutor();
  const multiSignAndExecute = useExecutor({
    execute: ({ bytes, signature }) => {
      const multiSig = adminKey!!.combinePartialSignatures([signature]);
      return client.executeTransactionBlock({
        transactionBlock: bytes,
        signature: [multiSig, signature],
        options: {
          showRawEffects: true,
        },
      });
    },
  });

  const [turnCap, invalidateTurnCap] = useTurnCapQuery(game.id);
  const account = useCurrentAccount();
  const tx = useTransactions()!!;

  // ...

  const onMove = (row: number, col: number) => {
    signAndExecute(
      {
        tx: tx.sendMark(turnCap?.data!!, row, col),
        options: { showObjectChanges: true },
      },
      ({ objectChanges }) => {
        const mark = objectChanges?.find(
          (c) => c.type === 'created' && c.objectType.endsWith('::Mark'),
        );

        if (mark && mark.type === 'created') {
          const recv = tx.receiveMark(game, mark);
          recv.setSender(adminKey!!.toSuiAddress());
          recv.setGasOwner(account?.address!!);

          multiSignAndExecute({ tx: recv }, () => {
            invalidateGame();
            invalidateTrophy();
            invalidateTurnCap();
          });
        }
      },
    );
  };

  // ...
}
```

<details>

<summary>

`Game.tsx`

</summary>

<ImportContent source="examples/tic-tac-toe/ui/src/pages/Game.tsx" mode="code" />

</details>

The first step is to get the multisig public key, which was written to `Game.admin` earlier. Then two executor hooks are created: The first is to sign and execute as the current player, and the second is to sign and execute as the multisig/admin account. After the wallet has serialized and signed the transaction the second executor creates a multisig from the wallet signature and executes the transaction with two signatures: Authorizing on behalf of the multisig and the wallet.

The reason for the two signatures is clearer when looking at the construction of the `recv` transaction: The multisig authorizes access to the `Game`, and the wallet authorizes access to the gas object. This is because the multisig account does not hold any coins of its own, so it relies on the player account to sponsor the transaction.

You can find an example React front-end supporting both the multi-sig and shared variants of the game in the [`ui` directory](https://github.com/MystenLabs/sui/blob/main/examples/tic-tac-toe/ui), and a CLI written in Rust in the [`cli` directory](https://github.com/MystenLabs/sui/blob/main/examples/tic-tac-toe/cli).

>>>> sui/docs/content/guides/developer/app-examples/trustless-swap.mdx
---
title: Trustless Swap
description: An app that performs atomic swaps on Sui. Atomic swaps are similar to escrows but without requiring a trusted third party.
effort: large
keywords: [ trustless, swap, atomic swaps, shared objects, composability, example app, example dApp, example swap, swap example, how to swap tokens  ]
---

This guide demonstrates how to make an app that performs atomic swaps on Sui. Atomic swaps are similar to escrows but without requiring a trusted third party.

There are three main sections to this guide:

1. [Smart Contracts](#smart-contracts): The Move code that holds the state and performs the swaps.
1. [Backend](#backend): A service that indexes chain state to discover trades, and an API service to read this data.
1. [Frontend](#frontend): A UI that enables users to list objects for sale and to accept trades.

<ImportContent source="prerequisites.mdx" mode="snippet" />

<ImportContent source="app-examples-swap-source.mdx" mode="snippet" />

## What the guide teaches

- **Shared objects:** The guide teaches you how to use [shared objects](../../../concepts/object-ownership/shared.mdx), in this case to act as the escrow between two Sui users wanting to trade. Shared objects are a unique concept to Sui. Any transaction and any signer can modify it, given the changes meet the requirements set forth by the package that defined the type.
- **Composability:** The guide teaches you how to design your Move code in a way that enables full composability. In this app, the Move code that handles trading is completely unaware of the code that defines the objects it is trading and vice versa.

The guide also shows how to build an app that:

- **Is trustless:** Users do not have to trust (or pay) any third parties; the chain manages the swap.
- **Avoids rug-pulls:** Guarantees that the object a user wants to trade for is not tampered with after initiating the trade.
- **Preserves liveness:** Users are able to pull out of the trade and reclaim their object at any time, in case the other party stops responding.

## Directory structure

To begin, create a new folder on your system titled `trading` that holds all your files. Inside that folder, create three more folders: `api`, `contracts`, and `frontend`. Keep this directory structure as some helper scripts in this example target these directories by name. Different projects have their own directory structure, but it's common to split code into functional groups to help with maintenance.

:::checkpoint

- You have the latest version of Sui installed. If you run `sui --version` in your terminal or console, it responds with the currently installed version.
- Your active environment is pointing to the expected network. Run `sui client active-env` to make sure. If you receive a warning about a client and server API version mismatch, update Sui using the version in the relevant branch (`mainnet`, `testnet`, `devent`) of the Sui repo.
- Your active address has SUI. Run `sui client balance` in your terminal or console. If there is no balance, [acquire SUI](/guides/developer/getting-started/get-coins.mdx) from the faucet (not available in Mainnet).
- You have a directory to place the files you create in. The suggested names of the directories are important if you use the available helper functions later in the guide.

:::

## Smart contracts {#smart-contracts}

In this part of the guide, you write the Move contracts that perform the trustless swaps. The guide describes how to create the package from scratch, but you can use a fork or copy of the example code in the Sui repo to follow along instead. See [Hello, World!](/guides/developer/getting-started/hello-world.mdx) to learn more about package structure and how to use the Sui CLI to scaffold a new project.

### `Move.toml`

To begin writing your smart contracts, create an `escrow` folder in your `contracts` folder (if using recommended directory names). Create a file inside the folder named `Move.toml` and copy the following code into it. This is the package manifest file. If you want to learn more about the structure of the file, see [Package Manifest](https://move-book.com/concepts/manifest.html) in The Move Book.

:::info

If you are targeting a network other than Testnet, be sure to update the `rev` value for the Sui dependency.

:::

<ImportContent source="examples/trading/contracts/escrow/Move.toml" mode="code"  />

### `Locked` and `Key`

With your manifest file in place, start creating the Move assets for this project. In your `escrow` folder, at the same level as your `Move.toml` file, create a `sources` folder. This is the common file structure of a package in Move. Create a new file inside `sources` titled `lock.move`. This file contains the logic that locks the object involved in a trade. The complete source code for this file follows and the sections that come after detail its components.

:::tip

Click the titles at the top of codeblocks to open the relevant source file in GitHub.

:::

<details>

<summary>

`lock.move`

</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/lock.move" mode="code"  />

</details>

After a trade is initiated, you do not want the trading party to modify the object they agreed to trade. Imagine you are trading in-game items and you agree to trade a weapon with all its attachments, and its owner strips all its attachments just before the trade.

In a traditional trade, a third party typically holds the items in escrow to make sure they are not tampered with before the trade completes. This requires either trusting that the third party does not tamper with it themselves, paying the third party to ensure that does not happen, or both.

In a trustless swap, however, you can use the safety properties of Move to force an item's owner to prove that they have not tampered with the version of the object that you agreed to trade, without involving anyone else.

You do this by requiring that an object that is available for trading is **locked** with a **single-use key**, and asking the owner to supply the key when finalizing the trade.

To tamper with the object would require unlocking it, which consumes the key. Consequently, there would no longer be a key to finish the trade.

<ImportContent source="examples/trading/contracts/escrow/sources/lock.move" mode="code" struct="Locked,Key" noComments />

- The `Locked<T>` type stores the `ID` of the key that unlocks it, and its own `id`. The object being locked is added as a [dynamic object field](/concepts/dynamic-fields.mdx), so that it is still readable at its own ID off-chain.
- The corresponding `Key` type only stores its own `id`.

The lock and key are made single-use by the signatures of the `lock` and `unlock` functions. `lock` accepts any object of type `T: store` (the `store` ability is necessary for storing it inside a `Locked<T>`), and creates both the `Locked<T>` and its corresponding `Key`:

<details>

<summary>

`lock` function in `lock.move`

</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/lock.move" mode="code" fun="lock" noComments />

</details>


The `unlock` function accepts the `Locked<T>` and `Key` by value (which consumes them), and returns the underlying `T` as long as the correct key has been supplied for the lock:

<details>

<summary>

`unlock` function in `lock.move`

</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/lock.move" mode="code" variable="ELockKeyMismatch" noComments />

<ImportContent source="examples/trading/contracts/escrow/sources/lock.move" mode="code" fun="unlock" noTitle noComments />

</details>


Together, they ensure that a lock and key cannot have existed before the lock operation, and do not exist after a successful unlock. It is single use.

:::tip Additional resources

- [Move Package](https://move-book.com/concepts/packages.html) defined in The Move Book.
- Concepts: [Wrapped Objects](../../../concepts/versioning.mdx#wrapped-objects)

:::

### Testing `Locked` and `Key`

Move's type system guarantees that a given `Key` cannot be re-used (because `unlock` accepts it by value), but there are some properties that need to be confirmed with tests:

- A locked object can be unlocked with its key.
- Trying to unlock an object with the wrong key fails.

The test starts with a helper function for creating an object. The object type does not matter, as long as it has the `store` ability. The test uses `Coin<SUI>`, because it comes with a `#[test_only]` function for minting:

<ImportContent source="examples/trading/contracts/escrow/sources/lock.move" mode="code" fun="test_coin" noComments />

- All test-related functions and imports are annotated with `#[test_only]` to make sure they do not show up in the published package. You can also do this by separating tests into their own module (for example, `lock_tests.move`) and marking that module as `#[test_only]`.
- The `test_scenario` module is used to provide access to a `&mut TxContext` in the test (necessary for creating new objects). Tests that do not need to simulate multiple transactions but still need access to a `TxContext` can use `sui::tx_context::dummy` to create a test context instead.

The first test works by creating an object to test, locking it and unlocking it â€“ this should finish executing without aborting.
The last two lines exist to keep the Move compiler happy by cleaning up the test coin and test scenario objects, because values in Move are not implicitly cleaned up unless they have the `drop` ability.

<ImportContent source="examples/trading/contracts/escrow/sources/lock.move" mode="code" fun="test_lock_unlock" noComments />

The other test is testing a failure scenario â€“ that an abort happens. It creates two locked objects (this time the values are just `u64`s), and use the key from one to try and unlock the other, which should fail (specified using the `expected_failure` attribute).

Unlike the previous test, the same clean up is not needed, because the code is expected to terminate. Instead, add another abort after the code that you expect to abort (making sure to use a different code for this second abort).

<ImportContent source="examples/trading/contracts/escrow/sources/lock.move" mode="code" fun="test_lock_key_mismatch" noComments />

:::tip Additional resources

- Concepts: [Test Scenario](/guides/developer/getting-started/hello-world.mdx#testing-a-package)
- [Drop ability](https://move-book.com/move-basics/drop-ability.html) defined in The Move Book.
- [Testing] Move code discussion in The Move Book.

:::

:::checkpoint

At this point, you have 
- A Move package consisting of a manifest file (`Move.toml`)
- A `lock.move` file in your `sources` folder. 

From your `escrow` folder, run `sui move test` in your terminal or console. If successful, you get a response similar to the following that confirms the package builds and your tests pass:

```
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING escrow
Running Move unit tests
[ PASS    ] escrow::lock::test_lock_key_mismatch
[ PASS    ] escrow::lock::test_lock_unlock
Test result: OK. Total tests: 2; passed: 2; failed: 0
```

You might notice that the Move compiler creates a `build` subfolder inside `escrow` upon a successful build. This folder contains your package's compiled bytecode, code from your package's dependencies, and various other files necessary for the build. At this point, be aware of these files. You do not need to fully understand the contents in `build`.

:::

### The `Escrow` protocol {#escrow}

Create a new file in your `escrow` folder titled `shared.move`. The code in this file creates the shared `Escrow` object and completes the trading logic. The complete source code for this file follows and the sections that come after detail its components.

<details>

<summary>

`shared.move`

</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" noComments />

</details>

Trading proceeds in three steps:

1. The first party locks the object they want to trade â€“ this is already handled by the `lock` module you wrote earlier.
1. The second party puts their object up for escrow and registers their interest in the first party's object. This is handled by a new module called `escrow`.
1. The first party completes the trade by providing their locked object and the key to unlock it. Assuming all checks pass, this transfers their object to the second party and makes the second party's object available to them.

You can start by implementing steps two and three, by defining a new type to hold the escrowed object. It holds the `escrowed` object and an `id: UID` (because it is an object in its own right), but it also records the `sender` and intended `recipient` (to confirm they match when the trade happens), and it registers interest in the first party's object by recording the `ID` of the key that unlocks the `Locked<U>` that contains the object.

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" struct="Escrow" noComments singleSpace />

You also need to create a function for creating the `Escrow` object. The object is shared because it needs to be accessed by the address that created it (in case the object needs to be returned) and by the intended recipient (to complete the swap).

<details>

<summary>

`create` function in `shared.move`

</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" tag="noemit"  noComments />

</details>

If the second party stops responding, the first party can unlock their object. You need to create a function so the second party can recover their object in the symmetric case as well.

- It needs to check that the caller matches `sender`, because `Escrow` objects are shared and anybody can access them.
- It accepts the `Escrow` by value so that it can clean it up after extracting the escrowed object, reclaiming the storage rebate for the sender and cleaning up an unused object on chain.

<details>

<summary>

`return_to_sender` function in `shared.move`

</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" fun="return_to_sender" noComments />

</details>

Finally, you need to add a function to allow the first party to complete the trade.

- This function also accepts the `Escrow` by value because it consumes it after the swap is complete.
- It checks that the sender of the transaction is the intended recipient (the first party), and that the ID of the key that they provided matches the key specified when the object was escrowed. This ensures no tampering occurs, because this key can be provided only if it had not been used to unlock the object, which proves the object has not left its `Locked<U>` between the call to `create` and to `swap`. You can inspect the `lock` module to see that it cannot be modified while in there.
- The call to `unlock` further checks that the key matches the locked object that was provided.
- Instead of transferring the escrowed object to the recipient address, it is returned by the `swap` function. You can do this because you checked that the transaction sender is the recipient, and it makes this API more composable. Programmable transaction blocks (PTBs) provide the flexibility to decide whether to transfer the object as it is received or do something else with it.

<details>

<summary>

`swap` function in `shared.move`

</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" variable="EMismatchedSenderRecipient,EMismatchedExchangeObject" singleSpace noComments />

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" fun="swap" noComments noTitle />

</details>


:::tip Additional resources

- [Full source code](https://github.com/MystenLabs/sui/blob/705ee1ed3ce8cfadc4597c6facb6769d7dfb5896/examples/trading/contracts/escrow/sources/shared.move)
- Concepts: [Shared Objects](../../../concepts/object-ownership/shared)
- Concepts: [Shared Object Deletion](https://blog.sui.io/ephemeral-shared-objects/)
- Concepts: [PTBs](../../../concepts/transactions/prog-txn-blocks)

:::

### Testing

Tests for the `escrow` module are more involved than for `lock` â€“ as they take advantage of `test_scenario`'s ability to simulate multiple transactions from different senders, and interact with shared objects.

The guide focuses on the test for a successful swap, but you can find a link to all the tests later on.

As with the lock test, start by creating a function to mint a test coin. You also create some constants to represent our transaction senders, `ALICE`, `BOB`, and `DIANE`.

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" fun="test_coin" noComments />

The test body starts with a call to `test_scenario::begin` and ends with a call to `test_scenario::end`. It does not matter which address you pass to `begin`, because you pick one of `ALICE` or `BOB` at the start of each new transaction you write, so set it to `@0x0`:

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" tag="test"  />

The first transaction is from `BOB` who creates a coin and locks it. You must remember the ID of the coin and the ID of the key, which you need later. Then, you transfer the locked object and the key itself to `BOB`, because this is what would happen in a real transaction. When simulating transactions in a test, you should only keep around primitive values, not whole objects, which would need to be written to chain between transactions.

Write these transactions inside the `test_successful_swap` function, between the call to `begin` and `end`.

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" variable="i2" noComments />

Next, `ALICE` comes along and sets up the `Escrow`, which locks their coin. They register their interest for `BOB`'s coin by referencing `BOB`'s key's ID (`ik2`):

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" variable="i1" noComments />

Finally, `BOB` completes the trade by calling `swap`. The `take_shared` function is used to simulate accepting a shared input. It uses type inference to know that the object must be an `Escrow`, and finds the last object of this type that was shared (by `ALICE` in the previous transaction). Similarly, use `take_from_sender` to simulate accepting owned inputs (in this case, `BOB`'s lock and key). The coin returned by `swap` is transferred back to `BOB`, as if it was called as part of a PTB, followed by a transfer command.

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" tag="bob"  noComments />

The rest of the test is designed to check that `ALICE` has `BOB`'s coin and vice versa. It starts by calling `next_tx` to make sure the effects of the previous transaction have been committed, before running the necessary checks.

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" tag="finish"  noComments />

:::tip Additional resources

- Guides: [Test Scenario](../../../guides/developer/getting-started/hello-world#testing-a-package)

:::

### Observability

The `escrow` Move package is now functional. You could publish it on chain and perform trustless swaps by creating transactions. Creating those transactions requires knowing the IDs of `Locked`, `Key`, and `Escrow` objects.

`Locked` and `Key` objects are typically owned by the transaction sender, and so can be queried through the Sui RPC, but `Escrow` objects are shared, and it is useful to be able to query them by their sender and recipient (so that users can see the trades they have offered and received).

Querying `Escrow` objects by their sender or recipient requires custom indexing, and to make it easy for the indexer to spot relevant transactions, add the following **events** to `escrow.move`:

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" struct="EscrowCreated,EscrowSwapped,EscrowCancelled" noComments />

Functions responsible for various aspects of the escrow's lifecycle emit these events. The custom indexer can then subscribe to transactions that emit these events and process only those, rather than the entire chain state:

<details>

<summary>

`emit` events included in functions from `shared.move`

</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" dep="sui::event"  />

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" fun="create,swap,return_to_sender" noTitle noComments />

</details>

:::tip Additional resources

- Concepts: [Events in The Move Book](https://move-book.com/programmability/events.html)
- Guide: [Using Events](../sui-101/using-events.mdx)

:::

:::checkpoint

You now have `shared.move` and `locked.move` files in your `sources` folder. From the parent `escrow` folder, run `sui move test` in your terminal or console. If successful, you get a response similar to the following that confirms the package builds and your tests pass: 

```
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING escrow
Running Move unit tests
[ PASS    ] escrow::lock::test_lock_key_mismatch
[ PASS    ] escrow::shared::test_mismatch_object
[ PASS    ] escrow::lock::test_lock_unlock
[ PASS    ] escrow::shared::test_mismatch_sender
[ PASS    ] escrow::shared::test_object_tamper
[ PASS    ] escrow::shared::test_return_to_sender
[ PASS    ] escrow::shared::test_return_to_sender_failed_swap
[ PASS    ] escrow::shared::test_successful_swap
Test result: OK. Total tests: 8; passed: 8; failed: 0
```

:::

### Next steps

You have written the Move package. ðŸŽ‰ 

To turn this into a complete dApp, you need to create a frontend. However, for the frontend to be updated, it has to listen to the blockchain as escrows are made and swaps are fulfilled.

To achieve this, in the next step you create an indexing service.

## Backend indexer {#backend}

With the contract adapted to emit events, you can now write an indexer that keeps track of all active `Escrow` objects and exposes an API for querying objects by sender or recipient. 

The indexer is backed by a Prisma DB with the following schema:

<details>

<summary>

`schema.prisma`

</summary>

<ImportContent source="examples/trading/api/prisma/schema.prisma" mode="code"  />

</details>

The core of the indexer is an event loop, initialized in a function called `setupListeners`.

<ImportContent source="examples/trading/api/indexer.ts" mode="code"  />

The indexer queries events related to the `escrow` module, using a `queryEvent` filter, and keeps track of a cursor representing the latest event it has processed so it can resume indexing from the right place even if it is restarted. The filter is looking for any events whose type is from the `escrow` module of the Move package (see the `event-indexer.ts` code that follows).

The core event job works by polling. It queries RPC for events following its latest cursor and sends them to a callback for processing. If it detects more than one page of new events, it immediately requests the next page. Otherwise, the job waits for the next polling interval before checking again.

<details>

<summary>

`event-indexer.ts`

</summary>

<ImportContent source="examples/trading/api/indexer/event-indexer.ts" mode="code"  />

</details>

The callback is responsible for reading the event and updating the database accordingly. For demo purposes, SQLite is being used, and so you need to issue a separate `UPSERT` to the database for each escrowed object. In a production setting, however, you would want to batch requests to the database to optimize data flow.

<details>

<summary>

`escrow-handler.ts`

</summary>

<ImportContent source="examples/trading/api/indexer/escrow-handler.ts" mode="code"  />

</details>

:::tip Additional resources

- [Full source code](https://github.com/MystenLabs/sui/tree/705ee1ed3ce8cfadc4597c6facb6769d7dfb5896/examples/trading/api)
- Reference: [JSON-RPC](https://docs.sui.io/sui-api-ref)

:::


### API service

The data that the indexer captures can then be served over an API, so that a frontend can read it. Follow the next section to implement the API in TypeScript, to run on Node, using Express.

#### Query parameters

You want your API to accept the query string in the URL as the parameters for database `WHERE` query. Hence, you want a utility that can extract and parse the URL query string into valid query parameters for Prisma. With the `parseWhereStatement()` function, the callers filter the set of keys from the URL query string and transforms those corresponding key-value pairs into the correct format for Prisma.

<details>

<summary>

`parseWhereStatement` in `api-queries.ts`

</summary>

<ImportContent source="examples/trading/api/utils/api-queries.ts" mode="code" enumeration="WhereParamTypes"  />

<ImportContent source="examples/trading/api/utils/api-queries.ts" mode="code" type="WhereParam"  noTitle />

<ImportContent source="examples/trading/api/utils/api-queries.ts" mode="code" variable="parseWhereStatement" noTitle />

</details>


#### Query pagination

Pagination is another crucial part to ensure your API returns sufficient and ordered chunks of information instead of all the data that might be the vector for a DDOS attack. Similar to `WHERE` parameters, define a set of keys in the URL query string to be accepted as valid pagination parameters. The `parsePaginationForQuery()` utility function helps to achieve this by filtering the pre-determined keys `sort`, `limit`, `cursor` and parsing corresponding key-value pairs into `ApiPagination` that Prisma can consume.

In this example, the `id` field of the model in the database as the cursor that allows clients to continue subsequent queries with the next page.

<details>

<summary>

`parsePaginationForQuery` in `api-queries.ts`

</summary>

<ImportContent source="examples/trading/api/utils/api-queries.ts" mode="code" type="ApiPagination"  />

<ImportContent source="examples/trading/api/utils/api-queries.ts" mode="code" variable="parsePaginationForQuery" noTitle />

</details>

#### API endpoints

All the endpoints are defined in `server.ts`. There are two endpoints:

- `/locked` to query `Locked` objects.
    Valid query keys:
        - `deleted`: Boolean
        - `creator`: String
        - `keyId`: String
        - `objectId`: String
        
- `/escrows` to query `Escrow` objects.
    Valid query keys:
        - `cancelled`: Boolean
        - `swapped`: Boolean
        - `recipient`: String
        - `sender`: String

Pass the URL query string into the pre-defined utilities to output the correct parameters that Prisma can use.

<details>

<summary>

`server.ts`

</summary>

<ImportContent source="examples/trading/api/server.ts" mode="code"  />

</details>

### Deployment {#deployment}

Now that you have an indexer and an API service, you can deploy your move package and start the indexer and API service.

1. Install dependencies by running `pnpm install --ignore-workspace` or `yarn install --ignore-workspace`.

2. Setup the database by running `pnpm db:setup:dev` or `yarn db:setup:dev`.

3. Deploy the Sui package

<details>

<summary>

Deployment instructions

</summary>

<ImportContent source="initialize-sui-client-cli.mdx" mode="snippet" />

Next, configure the Sui CLI to use `testnet` as the active environment. 

Use the following command to list your available environments:

```sh
$ sui client envs
```

If you have not already set up a `testnet` environment, do so by running the following command in a terminal or console:

```sh
$ sui client new-env --alias testnet --rpc https://fullnode.testnet.sui.io:443
```

Run the following command to activate the `testnet` environment:

```sh
$ sui client switch --env testnet
```

Before being able to publish your package to Testnet, you need Testnet SUI tokens. To get some, run the following command: 

```sh
$ sui client faucet
```

For other ways to get SUI in your Testnet account, see [Get SUI Tokens](/guides/developer/getting-started/get-coins).

Now that you have an account with some Testnet SUI, you can deploy your contracts. 

There are some helper functions to publish the smart contracts so you can create some demo data (for Testnet). The helper function to publish the smart contracts expects built smart contracts in both the `escrow` and `demo` directories. Run `sui move build` in both directories, if necessary. Be sure to update the Sui dependency in the manifest to point to the correct source based on your environment. 

To publish the smart contracts and produce demo data: 

1. Publish the smart contracts by running the following command from your `api` folder: 

```sh
$ npx ts-node helpers/publish-contracts.ts
```

If successful, `demo-contract.json` and `escrow-contract.json` are created in the backend root directory. These files contain the contract addresses and are used by the backend and frontend to interact with the contracts.

2. Produce demo non-locked and locked objects

```sh
$ npx ts-node helpers/create-demo-data.ts
```

3. Produce demo escrows

```sh
$ npx ts-node helpers/create-demo-escrows.ts
```

If you want to reset the database (for a clean demo, for example), run `pnpm db:reset:dev && pnpm db:setup:dev` or `yarn db:reset:dev && yarn db:setup:dev`.

</details>

4. Run both the API and the indexer by running `pnpm dev` or `yarn dev`.

5. Visit [http://localhost:3000/escrows](http://localhost:3000/escrows) or [http://localhost:3000/locked](http://localhost:3000/locked)

:::checkpoint

You should now have an indexer running. 
- If you visit `localhost:3000`, you get a message that the service is running: `{"message":"ðŸš€ API is functional ðŸš€"}`.
- If you visit `localhost:3000/escrows`, you see the demo escrow data the helper scripts created for you. Likewise, visiting `http://localhost:3000/locked` displays the raw JSON the script created for demo objects.

:::


### Next steps

With the code successfully deployed on Testnet, you can now [create a frontend](#frontend) to display the trading data and to allow users to interact with the Move modules.

## Frontend {#frontend}

In this final part of the app example, you build a frontend (UI) that allows end users to discover trades and interact with listed escrows.

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install).

- [x] [Complete the smart contracts](#smart-contracts) and understand their design.

- [x] [Implement the backend](#backend) to learn how to index on-chain data and expose it through an API.

- [x] [Deploy your smart contracts and started the backend indexer](#deployment).
                 
- [x] Install [`pnpm`](https://pnpm.io/installation) or [`yarn`](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable) to use as the package manager.

</TabItem>
</Tabs>

<ImportContent source="app-examples-swap-source.mdx" mode="snippet" />

:::tip Additional resources

- [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript). For basic usage on how to interact with Sui with TypeScript.
- [Sui dApp Kit](https://sdk.mystenlabs.com/dapp-kit). To learn basic building blocks for developing a dApp in the Sui ecosystem with React.js.
- [`@mysten/dapp`](https://sdk.mystenlabs.com/dapp-kit/create-dapp). This is used within this project to quickly scaffold a React-based Sui dApp.

:::

### Overview

The UI design consists of three parts:

- A header containing the button allowing users to connect their wallet and navigate to other pages.
- A place for users to manage their owned objects to be ready for escrow trading called `Manage Objects`.
- A place for users to discover, create, and execute trades called `Escrows`.

### Scaffold a new app

The first step is to set up the client app. Run the following command to scaffold a new app from your `frontend` folder.

<Tabs groupId="packagemanager">

<TabItem label="PNPM" value="pnpm">

```sh
$ pnpm create @mysten/dapp --template react-client-dapp
```

</TabItem>

<TabItem label="Yarn" value="yarn">

```sh
$ yarn create @mysten/dapp --template react-client-dapp
```

</TabItem>

</Tabs>

When asked for a name for your dApp, provide one of your liking. The dApp scaffold gets created in a new directory with the name you provide. This is convenient to keep your working code separate from the example source code that might already populate this folder. The codeblocks that follow point to the code in the default example location. Be aware the path to your own code includes the dApp name you provide.

### Setting up import aliases

First, set up import aliases to make the code more readable and maintainable. This allows you to import files using `@/` instead of relative paths.

<details>

<summary>

Replace the content of `tsconfig.json` with the following:

</summary>

<ImportContent source="examples/trading/frontend/tsconfig.json" mode="code"  />

</details>

The paths option under `compilerOptions` is what defines the aliasing for TypeScript. Here, the alias `@/*` is mapped to the `./src/*` directory, meaning that any time you use `@/`, TypeScript resolves it as a reference to the `src` folder. This setup reduces the need for lengthy relative paths when importing files in your project.

<details>

<summary>

Replace the content of `vite.config.ts` with the following:

</summary>

<ImportContent source="examples/trading/frontend/vite.config.ts" mode="code"  />

</details>

Vite also needs to be aware of the aliasing to resolve imports correctly during the build process. In the `resolve.alias` configuration of `vite.config.ts`, map the alias `@` to the `/src` directory.

### Adding Tailwind CSS

To streamline the styling process and keep the codebase clean and maintainable, this guide uses Tailwind CSS, which provides utility-first CSS classes to rapidly build custom designs. Run the following command from the base of your dApp project to add Tailwind CSS and its dependencies:

<Tabs groupId="packagemanager">
<TabItem label="PNPM" value="pnpm">

```sh
$ pnpm add tailwindcss@latest postcss@latest autoprefixer@latest
```

</TabItem>
<TabItem label="Yarn" value="yarn">

```sh
$ yarn add tailwindcss@latest postcss@latest autoprefixer@latest
```

</TabItem>
</Tabs>

Next, generate the Tailwind CSS configuration file by running the following:

```sh
$ npx tailwindcss init -p
```

<details>

<summary>

Replace the content of `tailwind.config.js` with the following:

</summary>

<ImportContent source="examples/trading/frontend/tailwind.config.js" mode="code"  />

</details>

<details>

<summary>

Add the `src/styles/` directory and add `base.css`: 

</summary>

<ImportContent source="examples/trading/frontend/src/styles/base.css" mode="code"  />

</details>

### Connecting your deployed package

First, deploy your package through the [scripts in the api directory](#deployment).

<details>

<summary>

Then, create a `src/constants.ts` file and fill it with the following:

</summary>

<ImportContent source="examples/trading/frontend/src/constants.ts" mode="code"  />

</details>

:::warning

If you create a dApp using a project name so that your `src` files are in a subfolder of `frontend`, be sure to add another nesting level (`../`) to the import statements.

:::

### Add helper functions and UI components

<details>

<summary>

Create a `src/utils/` directory and add the following file: 

</summary>

<ImportContent source="examples/trading/frontend/src/utils/helpers.ts" mode="code"  />

</details>

Create a `src/components/` directory and add the following components: 

<details>

<summary>

`ExplorerLink.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/ExplorerLink.tsx" mode="code"  />

</details>

<details>

<summary>

`InfiniteScrollArea.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/InfiniteScrollArea.tsx" mode="code"  />

</details>

<details>

<summary>

`Loading.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/Loading.tsx" mode="code"  />

</details>

<details>

<summary>

`SuiObjectDisplay.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/SuiObjectDisplay.tsx" mode="code"  />

</details>

Install the necessary dependencies:

<Tabs groupId="packagemanager">
<TabItem label="PNPM" value="pnpm">

```sh
$ pnpm add react-hot-toast
```

</TabItem>
<TabItem label="Yarn" value="yarn">

```sh
$ yarn add react-hot-toast
```

</TabItem>
</Tabs>


### Set up routing {#routing}

The imported template only has a single page. To add more pages, you need to set up routing.

First, install the necessary dependencies:

<Tabs groupId="packagemanager">
<TabItem label="PNPM" value="pnpm">

```sh
$ pnpm add react-router-dom
```

</TabItem>
<TabItem label="Yarn" value="yarn">

```sh
$ yarn add react-router-dom
```

</TabItem>
</Tabs>

<details>

<summary>

Then, create a `src/routes/` directory and add `index.tsx`. This file contains the routing configuration:

</summary>

<ImportContent source="examples/trading/frontend/src/routes/index.tsx" mode="code"  />

</details>

Add the following respective files to the `src/routes/` directory:

<details>

<summary>

`root.tsx`. This file contains the root component that is rendered on every page:

</summary>

<ImportContent source="examples/trading/frontend/src/routes/root.tsx" mode="code"  />

</details>

<details>

<summary>

`LockedDashboard.tsx`. This file contains the component for the `Manage Objects` page.

</summary>

```tsx
export function LockedDashboard() {
return (
<div>
<h1>Locked Dashboard</h1>
</div>
)
}
```

</details>

<details>

<summary>

`EscrowDashboard.tsx`. This file contains the component for the `Escrows` page.

</summary>

```tsx
export function EscrowDashboard() {
return (
<div>
<h1>Escrow Dashboard</h1>
</div>
)
}
```

</details>

<details>

<summary>

Update `src/main.tsx` by replacing the `App` component with the `RouterProvider` and replace `"dark"` with `"light"` in the `Theme` component:

</summary>

<ImportContent source="examples/trading/frontend/src/main.tsx" mode="code"  />

</details>

The dApp Kit provides a set of hooks for making query and mutation calls to the Sui blockchain. These hooks are thin wrappers around query and mutation hooks from `@tanstack/react-query`.

:::tip Additional resources

- Docs: [React Router](https://reactrouter.com/en/main). Used to navigate between different routes in the website.
- Docs: [TanStack Query](https://tanstack.com/query/latest/docs/framework/react/overview).

:::

<details>

<summary>

Create `src/components/Header.tsx`. This file contains the navigation links and the connect wallet button:

</summary>

```tsx
import { ConnectButton } from "@mysten/dapp-kit";
import { SizeIcon } from "@radix-ui/react-icons";
import { Box, Container, Flex, Heading } from "@radix-ui/themes";
import { NavLink } from "react-router-dom";

const menu = [
  {
    title: "Escrows",
    link: "/escrows",
  },
  {
    title: "Manage Objects",
    link: "/locked",
  },
];

export function Header() {
  return (
    <Container>
      <Flex
        position="sticky"
        px="4"
        py="2"
        justify="between"
        className="border-b flex flex-wrap"
      >
        <Box>
          <Heading className="flex items-center gap-3">
            <SizeIcon width={24} height={24} />
            Trading Demo
          </Heading>
        </Box>

        <Box className="flex gap-5 items-center">
          {menu.map((item) => (
            <NavLink
              key={item.link}
              to={item.link}
              className={({ isActive, isPending }) =>
                `cursor-pointer flex items-center gap-2 ${
                  isPending
                    ? "pending"
                    : isActive
                      ? "font-bold text-blue-600"
                      : ""
                }`
              }
            >
              {item.title}
            </NavLink>
          ))}
        </Box>

        <Box className="connect-wallet-wrapper">
          <ConnectButton />
        </Box>
      </Flex>
    </Container>
  );
}
```

</details>

The dApp Kit comes with a pre-built React.js component called `ConnectButton` displaying a button to connect and disconnect a wallet. The connecting and disconnecting wallet logic is handled seamlessly so you do not need to worry about repeating yourself doing the same logic all over again.

:::checkpoint

At this point, you have a basic routing setup. Run your app and ensure you can:

- Navigate between the `Manage Objects` and `Escrows` pages.
- Connect and disconnect your wallet.

The styles should be applied. The `Header` component should look like this: 

![Header component](./images/styles.png)

:::

### Type definitions

<details>

<summary>

All the type definitions are in `src/types/types.ts`. Create this file and add the following:

</summary>

<ImportContent source="examples/trading/frontend/src/types/types.ts" mode="code"  />

</details>

`ApiLockedObject` and `ApiEscrowObject` represent the `Locked` and `Escrow` indexed data model the indexing and API service return.

`EscrowListingQuery` and `LockedListingQuery` are the query parameters model to provide to the API service to fetch from the endpoints `/escrow` and `/locked` accordingly.

### Display owned objects

Now, display the objects owned by the connected wallet address. This is the `Manage Objects` page.

<details>

<summary>

First add this file `src/components/locked/LockOwnedObjects.tsx`: 

</summary>

```tsx
import { useCurrentAccount, useSuiClientInfiniteQuery } from "@mysten/dapp-kit";
import { SuiObjectDisplay } from "@/components/SuiObjectDisplay";
import { InfiniteScrollArea } from "@/components/InfiniteScrollArea";

/**
 * A component that fetches all the objects owned by the connected wallet address
 * and allows the user to lock them, so they can be used in escrow.
 */
export function LockOwnedObjects() {
  const account = useCurrentAccount();

  const { data, fetchNextPage, isFetchingNextPage, hasNextPage, refetch } =
    useSuiClientInfiniteQuery(
      "getOwnedObjects",
      {
        owner: account?.address!,
        options: {
          showDisplay: true,
          showType: true,
        },
      },
      {
        enabled: !!account,
        select: (data) =>
          data.pages
            .flatMap((page) => page.data)
            .filter(
              // we're filtering out objects that don't have Display or image_url
              // for demo purposes. The Escrow contract works with all objects.
              (x) => !!x.data?.display && !!x.data?.display?.data?.image_url,
            ),
      },
    );

  return (
    <InfiniteScrollArea
      loadMore={() => fetchNextPage()}
      hasNextPage={hasNextPage}
      loading={isFetchingNextPage}
    >
      {data?.map((obj) => (
        <SuiObjectDisplay object={obj.data!}>
        </SuiObjectDisplay>
      ))}
    </InfiniteScrollArea>
  );
}
```

</details>

Fetch the owned objects directly from Sui blockchain using the `useSuiClientInfiniteQuery()` hook from dApp Kit. This hook is a thin wrapper around Sui blockchain RPC calls. Reference the documentation to learn more about these [RPC hooks](https://sdk.mystenlabs.com/dapp-kit/rpc-hooks). Supply the RPC endpoint you want to execute, in this case the [`getOwnedObjects` endpoint](https://docs.sui.io/sui-api-ref#suix_getownedobjects). Supply the connected wallet account as the `owner`. The returned data is stored inside the cache at query key `getOwnedObjects`. In a future step you invalidate this cache after a mutation succeeds, so the data is re-fetched automatically.


<details>

<summary>

Next, update `src/routes/LockedDashboard.tsx` to include the `LockOwnedObjects` component:

</summary>

```tsx
import { useState } from "react";
import { Tabs } from "@radix-ui/themes";
import { LockOwnedObjects } from "@/components/locked/LockOwnedObjects";

export function LockedDashboard() {
  const tabs = [
    {
      name: "Lock Owned objects",
      component: () => <LockOwnedObjects />,
    },
  ];

  const [tab, setTab] = useState(tabs[0].name);

  return (
    <Tabs.Root value={tab} onValueChange={setTab}>
      <Tabs.List>
        {tabs.map((tab, index) => {
          return (
            <Tabs.Trigger
              key={index}
              value={tab.name}
              className="cursor-pointer"
            >
              {tab.name}
            </Tabs.Trigger>
          );
        })}
      </Tabs.List>
      {tabs.map((tab, index) => {
        return (
          <Tabs.Content key={index} value={tab.name}>
            {tab.component()}
          </Tabs.Content>
        );
      })}
    </Tabs.Root>
  );
}
```

</details>

:::checkpoint

Run your app and ensure you can:

- View the owned objects of the connected wallet account.

If you do not see any objects, you might need to create some demo data or connect your wallet. You can mint objects after completing the next steps.

![Owned objects](./images/trustless-objects.png)

:::

### Execute transaction hook {#execute-transaction-hook}

In the frontend, you might need to execute a transaction block in multiple places. Extract the transaction execution logic and reuse it everywhere. Create and examine the execute transaction hook.


<details>

<summary>

Create `src/hooks/useTransactionExecution.ts`:

</summary>

<ImportContent source="examples/trading/frontend/src/hooks/useTransactionExecution.ts" mode="code"  />

</details>

A `Transaction` is the input. Sign it with the current connected wallet account, execute the transaction block, return the execution result, and finally display a basic toast message to indicate whether the transaction is successful or not.

Use the `useSuiClient()` hook from dApp Kit to retrieve the Sui client instance configured in `src/main.tsx`. The `useSignTransaction()` function is another hook from dApp kit that helps to sign the transaction block using the currently connected wallet. It displays the UI for users to review and sign their transactions with their selected wallet. To execute a transaction block, use the `executeTransaction()` on the Sui client instance of the Sui TypeScript SDK.

### Generate demo data

:::info

The full source code of the demo bear smart contract is available at [Trading Contracts Demo directory](https://github.com/MystenLabs/sui/tree/main/examples/trading/contracts/demo)

:::

You need a utility function to create a dummy object representing a real world asset so you can use it to test and demonstrate escrow users flow on the UI directly.

<details>

<summary>

Create `src/mutations/demo.ts`:

</summary>

<ImportContent source="examples/trading/frontend/src/mutations/demo.ts" mode="code"  />

</details>

As previously mentioned, this example uses `@tanstack/react-query` to query, cache, and mutate server state. Server state is data only available on remote servers, and the only way to retrieve or update this data is by interacting with these remote servers. In this case, it could be from an API or directly from Sui blockchain RPC.

When you execute a transaction call to mutate data on the Sui blockchain, use the `useMutation()` hook. The `useMutation()` hook accepts several inputs. However, you only need 2 of them for this example. The first parameter, `mutationFn`, accepts the function to execute the main mutating logic, while the second parameter, `onSuccess`, is a callback that runs when the mutating logic succeeds.

The main mutating logic includes executing a Move call of a package named `demo_bear::new` to create a dummy bear object and transferring it to the connected wallet account, all within the same `Transaction`. This example reuses the `executeTransaction()` hook from the [Execute Transaction Hook](#execute-transaction-hook) step to execute the transaction.

Another benefit of wrapping the main mutating logic inside `useMutation()` is that you can access and manipulate the cache storing server state. This example fetches the cache from remote servers by using query call in an appropriate callback. In this case, it is the `onSuccess` callback. When the transaction succeeds, invalidate the cache data at the cache key called `getOwnedObjects`, then `@tanstack/react-query` handles the re-fetching mechanism for the invalidated data automatically. Do this by using `invalidateQueries()` on the `@tanstack/react-query` configured client instance retrieved by `useQueryClient()` hook in the [Set up Routing](#routing) step.

Now the logic to create a dummy bear object exists. You just need to attach it into the button in the header.

<details>

<summary>

`Header.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/Header.tsx" mode="code"  />

</details>

:::checkpoint

Run your app and ensure you can:

- Mint a demo bear object and view it in the `Manage Objects` tab.

![New bear](./images/trustless-new-bear.png)

:::

### Locking owned objects

To lock the object, execute the `lock` Move function identified by `{PACKAGE_ID}::lock::lock`. The implementation is similar to what's in previous mutation functions. Use `useMutation()` from `@tanstack/react-query` to wrap the main logic inside it. The lock function requires an object to be locked and its type because the smart contract `lock` function is generic and requires type parameters. After creating a `Locked` object and its `Key` object, transfer them to the connected wallet account within the same transaction block.

Extract logic of locking owned objects into a separated mutating function to enhance discoverability and encapsulation.

<details>

<summary>

Create `src/mutations/locked.ts`:

</summary>

```tsx
import { CONSTANTS } from "@/constants";
import { useTransactionExecution } from "@/hooks/useTransactionExecution";
import { useCurrentAccount } from "@mysten/dapp-kit";
import { SuiObjectData } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { useMutation } from "@tanstack/react-query";
/**
 * Builds and executes the PTB to lock an object.
 */
export function useLockObjectMutation() {
  const account = useCurrentAccount();
  const executeTransaction = useTransactionExecution();

  return useMutation({
    mutationFn: async ({ object }: { object: SuiObjectData }) => {
      if (!account?.address)
        throw new Error("You need to connect your wallet!");
      const txb = new Transaction();

      const [locked, key] = txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::lock::lock`,
        arguments: [txb.object(object.objectId)],
        typeArguments: [object.type!],
      });

      txb.transferObjects([locked, key], txb.pure.address(account.address));

      return executeTransaction(txb);
    },
  });
}
```

</details>

Update `src/components/locked/LockOwnedObjects.tsx` to include the `useLockObjectMutation` hook:

<details>

<summary>

`LockOwnedObjects.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/locked/LockOwnedObjects.tsx" mode="code"  />

</details>

:::checkpoint

Run your app and ensure you can:

- Lock an owned object. 

The object should disappear from the list of owned objects. You view and unlock locked objects in later steps.

![Lock bear](./images/trustless-lock-bear.png)

:::

### Display owned locked objects

Take a look at the **My Locked Objects** tab by examining `src/components/locked/OwnedLockedList.tsx`. Focus on the logic on how to retrieve this list.

<details>

<summary>

`OwnedLockedList.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/locked/OwnedLockedList.tsx" mode="code"  />

</details>

This instance of `useSuiClientInfiniteQuery()` is similar to the one in the `LockOwnedObjects` component. The difference is that it fetches the locked objects instead of the owned objects. The `Locked` object is a struct type in the smart contract, so you need to supply the struct type to the query call as a `filter`. The struct type is usually identified by the format of `{PACKAGE_ID}::{MODULE_NAME}::{STRUCT_TYPE}`.

##### `LockedObject` and `Locked` component

The `<LockedObject />` (`src/components/locked/LockedObject.tsx`) component is mainly responsible for mapping an on-chain `SuiObjectData` `Locked` object to its corresponding `ApiLockedObject`, which is finally delegated to the `<Locked />` component for rendering. The `<LockedObject />` fetches the locked item object ID if the prop `itemId` is not supplied by using dApp Kit `useSuiClientQuery()` hook to call the `getDynamicFieldObject` RPC endpoint. Recall that in this smart contract, the locked item is put into a [dynamic object field](/concepts/dynamic-fields.mdx).

<details>

<summary>

`LockedObject.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/locked/LockedObject.tsx" mode="code"  />

</details>

The `<Locked />` (`src/components/locked/partials/Locked.tsx`) component is mainly responsible for rendering the `ApiLockedObject`. Later on, it also consists of several on-chain interactions: unlock the locked objects and create an escrow out of the locked object.

<details>

<summary>

`Locked.tsx`

</summary>

```tsx
import { useCurrentAccount, useSuiClientQuery } from "@mysten/dapp-kit";
import { SuiObjectDisplay } from "@/components/SuiObjectDisplay";
import { ExplorerLink } from "../../ExplorerLink";
import { ApiLockedObject } from "@/types/types";

/**
 * Prefer to use the `Locked` component only through `LockedObject`.
 *
 * This can also render data directly from the API, but we prefer
 * to also validate ownership from on-chain state (as objects are transferrable)
 * and the API cannot track all the ownership changes.
 */
export function Locked({
  locked,
  hideControls,
}: {
  locked: ApiLockedObject;
  hideControls?: boolean;
}) {
  const account = useCurrentAccount();

  const suiObject = useSuiClientQuery(
    "getObject",
    {
      id: locked.itemId,
      options: {
        showDisplay: true,
        showType: true,
        showOwner: true,
      },
    },
    {
      select: (data) => data.data,
    },
  );

  const getLabel = () => {
    if (locked.deleted) return "Deleted";
    if (hideControls) {
      if (locked.creator === account?.address) return "You offer this";
      return "You'll receive this if accepted";
    }
    return undefined;
  };

  const getLabelClasses = () => {
    if (locked.deleted)
      return "bg-red-50 rounded px-3 py-1 text-sm text-red-500";
    if (hideControls) {
      if (!!locked.creator && locked.creator === account?.address)
        return "bg-blue-50 rounded px-3 py-1 text-sm text-blue-500";
      return "bg-green-50 rounded px-3 py-1 text-sm text-green-700";
    }
    return undefined;
  };

  return (
    <SuiObjectDisplay
      object={suiObject.data!}
      label={getLabel()}
      labelClasses={getLabelClasses()}
    >
      <div className="p-4 pt-1 text-right flex flex-wrap items-center justify-between">
        {
          <p className="text-sm flex-shrink-0 flex items-center gap-2">
            <ExplorerLink id={locked.objectId} isAddress={false} />
          </p>
        }
      </div>
    </SuiObjectDisplay>
  );
}
```

</details>

Update `src/routes/LockedDashboard.tsx` to include the `OwnedLockedList` component:

<details>

<summary>

`LockedDashboard.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/routes/LockedDashboard.tsx" mode="code"  />

</details>

:::checkpoint

Run your app and ensure you can:

- View the locked objects of the connected wallet account.

![My locked bears](./images/trustless-my-locked.png)

:::

### Unlocking owned objects

To unlock the object, execute the `unlock` Move function identified by `{PACKAGE_ID}::lock::unlock`. Call the `unlock` function supplying the `Locked` object, its corresponding `Key`, the struct type of the original object, and transfer the unlocked object to the current connected wallet account. Also, implement the `onSuccess` callback to invalidate the cache data at query key `locked` after one second to force `react-query` to re-fetch the data at corresponding query key automatically.

Unlocking owned objects is another crucial and complex on-chain action in this application. Extract its logic into separated mutating functions to enhance discoverability and encapsulation.

<details>

<summary>

`src/mutations/locked.ts`

</summary>

<ImportContent source="examples/trading/frontend/src/mutations/locked.ts" mode="code"  />

</details>

Update `src/components/locked/partials/Locked.tsx` to include the `useUnlockObjectMutation` hook:

<details>

<summary>

`Locked.tsx`

</summary>

```tsx
import { useCurrentAccount, useSuiClientQuery } from "@mysten/dapp-kit";
import { SuiObjectDisplay } from "@/components/SuiObjectDisplay";
import { Button } from "@radix-ui/themes";
import {
  ArrowDownIcon,
  ArrowUpIcon,
  LockOpen1Icon,
} from "@radix-ui/react-icons";
import { ExplorerLink } from "../../ExplorerLink";
import { useState } from "react";
import { ApiLockedObject } from "@/types/types";
import { useUnlockMutation } from "@/mutations/locked";

/**
 * Prefer to use the `Locked` component only through `LockedObject`.
 *
 * This can also render data directly from the API, but we prefer
 * to also validate ownership from on-chain state (as objects are transferrable)
 * and the API cannot track all the ownership changes.
 */
export function Locked({
  locked,
  hideControls,
}: {
  locked: ApiLockedObject;
  hideControls?: boolean;
}) {
  const [isToggled, setIsToggled] = useState(false);
  const account = useCurrentAccount();
  const { mutate: unlockMutation, isPending } = useUnlockMutation();

  const suiObject = useSuiClientQuery(
    "getObject",
    {
      id: locked.itemId,
      options: {
        showDisplay: true,
        showType: true,
        showOwner: true,
      },
    },
    {
      select: (data) => data.data,
    },
  );

  const isOwner = () => {
    return !!locked.creator && account?.address === locked.creator;
  };

  const getLabel = () => {
    if (locked.deleted) return "Deleted";
    if (hideControls) {
      if (locked.creator === account?.address) return "You offer this";
      return "You'll receive this if accepted";
    }
    return undefined;
  };

  const getLabelClasses = () => {
    if (locked.deleted)
      return "bg-red-50 rounded px-3 py-1 text-sm text-red-500";
    if (hideControls) {
      if (!!locked.creator && locked.creator === account?.address)
        return "bg-blue-50 rounded px-3 py-1 text-sm text-blue-500";
      return "bg-green-50 rounded px-3 py-1 text-sm text-green-700";
    }
    return undefined;
  };

  return (
    <SuiObjectDisplay
      object={suiObject.data!}
      label={getLabel()}
      labelClasses={getLabelClasses()}
    >
      <div className="p-4 pt-1 text-right flex flex-wrap items-center justify-between">
        {
          <p className="text-sm flex-shrink-0 flex items-center gap-2">
            <ExplorerLink id={locked.objectId} isAddress={false} />
          </p>
        }
        {!hideControls && isOwner() && (
          <Button
            className="ml-auto cursor-pointer"
            disabled={isPending}
            onClick={() => {
              unlockMutation({
                lockedId: locked.objectId,
                keyId: locked.keyId,
                suiObject: suiObject.data!,
              });
            }}
          >
            <LockOpen1Icon /> Unlock
          </Button>
        )}
      </div>
    </SuiObjectDisplay>
  );
}
```

</details>

:::checkpoint

Run your app and ensure you can:

- Unlock a locked object.

![Unlock my locked bears](./images/trustless-unlock-bear.png)

:::

### Display locked objects to escrow

Update `src/routes/EscrowDashboard.tsx` to include the `LockedList` component:

<details>

<summary>

`EscrowDashboard.tsx`

</summary>

```tsx
import { useState } from "react";
import { Tabs, Tooltip } from "@radix-ui/themes";
import { LockedList } from "../components/locked/ApiLockedList";
import { InfoCircledIcon } from "@radix-ui/react-icons";

export function EscrowDashboard() {
  const tabs = [
    {
      name: "Browse Locked Objects",
      component: () => (
        <LockedList
          params={{
            deleted: "false",
          }}
          enableSearch
        />
      ),
      tooltip: "Browse locked objects you can trade for.",
    },
  ];

  const [tab, setTab] = useState(tabs[0].name);

  return (
    <Tabs.Root value={tab} onValueChange={setTab}>
      <Tabs.List>
        {tabs.map((tab, index) => {
          return (
            <Tabs.Trigger
              key={index}
              value={tab.name}
              className="cursor-pointer"
            >
              {tab.name}
              <Tooltip content={tab.tooltip}>
                <InfoCircledIcon className="ml-3" />
              </Tooltip>
            </Tabs.Trigger>
          );
        })}
      </Tabs.List>
      {tabs.map((tab, index) => {
        return (
          <Tabs.Content key={index} value={tab.name}>
            {tab.component()}
          </Tabs.Content>
        );
      })}
    </Tabs.Root>
  );
}
```

</details>

Add `src/components/locked/ApiLockedList.tsx`:

<details>

<summary>

`ApiLockedList.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/locked/ApiLockedList.tsx" mode="code"  />

</details>

This hook fetches all the non-deleted system `Locked` objects from the API in a paginated fashion. Then, it proceeds into fetching the on-chain state, to ensure the latest state of the object is displayed.

This component uses tanstack's `useInfiniteQuery` instead of `useSuiClientInfiniteQuery` since the data is being fetched from the example's API rather than Sui. 

<details>

<summary>

Add `src/hooks/useGetLockedObject.ts`

</summary>

<ImportContent source="examples/trading/frontend/src/hooks/useGetLockedObject.ts" mode="code"  />

</details>

:::checkpoint

Run your app and ensure you can:

- View the locked objects in the `Browse Locked Objects` tab in the `Escrows` page.

![Browse locked bears](./images/trustless-escrow-locked.png)

:::

### Create escrows

To create escrows, include a mutating function through the `useCreateEscrowMutation` hook in `src/mutations/escrow.ts`. It accepts the escrowed item to be traded and the `ApiLockedObject` from another party as parameters. Then, call the `{PACKAGE_ID}::shared::create` Move function and provide the escrowed item, the key ID of the locked object to exchange, and the recipient of the escrow (locked object's owner).

<details>

<summary>

`escrow.ts`

</summary>

```tsx
import { CONSTANTS } from "@/constants";
import { useTransactionExecution } from "@/hooks/useTransactionExecution";
import { ApiLockedObject } from "@/types/types";
import { useCurrentAccount } from "@mysten/dapp-kit";
import { SuiObjectData } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { useMutation } from "@tanstack/react-query";

/**
 * Builds and executes the PTB to create an escrow.
 */
export function useCreateEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();

  return useMutation({
    mutationFn: async ({
      object,
      locked,
    }: {
      object: SuiObjectData;
      locked: ApiLockedObject;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");

      const txb = new Transaction();
      txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::create`,
        arguments: [
          txb.object(object.objectId!),
          txb.pure.id(locked.keyId),
          txb.pure.address(locked.creator!),
        ],
        typeArguments: [object.type!],
      });

      return executeTransaction(txb);
    },
  });
}
```

</details>

<details>

<summary>

Update `src/components/locked/partials/Locked.tsx` to include the `useCreateEscrowMutation` hook

</summary>

<ImportContent source="examples/trading/frontend/src/components/locked/partials/Locked.tsx" mode="code"  />

</details>

<details>

<summary>

Add `src/components/escrows/CreateEscrow.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/escrows/CreateEscrow.tsx" mode="code"  />

</details>

:::checkpoint

Run your app and ensure you can:

- Create an escrow.

The object should disappear from the list of locked objects in the `Browse Locked Objects` tab in the `Escrows` page. You view and accept or cancel escrows in later steps.

![Start escrow](./images/trustless-start-escrow.png)

:::

### Cancel escrows

To cancel the escrow, create a mutation through the `useCancelEscrowMutation` hook in `src/mutations/escrow.ts`. The cancel function accepts the escrow `ApiEscrowObject` and its on-chain data. The `{PACKAGE_ID}::shared::return_to_sender` Move call is generic, thus it requires the type parameters of the escrowed object. Next, execute `{PACKAGE_ID}::shared::return_to_sender` and transfer the returned escrowed object to the creator of the escrow.

<details>

<summary>

`escrow.ts`

</summary>

```tsx
import { CONSTANTS, QueryKey } from "@/constants";
import { useTransactionExecution } from "@/hooks/useTransactionExecution";
import { ApiEscrowObject, ApiLockedObject } from "@/types/types";
import { useCurrentAccount } from "@mysten/dapp-kit";
import { SuiObjectData } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { useMutation, useQueryClient } from "@tanstack/react-query";

/**
 * Builds and executes the PTB to create an escrow.
 */
export function useCreateEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();

  return useMutation({
    mutationFn: async ({
      object,
      locked,
    }: {
      object: SuiObjectData;
      locked: ApiLockedObject;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");

      const txb = new Transaction();
      txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::create`,
        arguments: [
          txb.object(object.objectId!),
          txb.pure.id(locked.keyId),
          txb.pure.address(locked.creator!),
        ],
        typeArguments: [object.type!],
      });

      return executeTransaction(txb);
    },
  });
}

/**
 * Builds and executes the PTB to cancel an escrow.
 */
export function useCancelEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      escrow,
      suiObject,
    }: {
      escrow: ApiEscrowObject;
      suiObject: SuiObjectData;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");
      const txb = new Transaction();

      const item = txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::return_to_sender`,
        arguments: [txb.object(escrow.objectId)],
        typeArguments: [suiObject?.type!],
      });

      txb.transferObjects([item], txb.pure.address(currentAccount?.address!));

      return executeTransaction(txb);
    },

    onSuccess: () => {
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });
      }, 1_000);
    },
  });
}
```

</details>

<details>

<summary>

Add `src/components/escrows/Escrow.tsx`

</summary>

```tsx
import { useCurrentAccount, useSuiClientQuery } from "@mysten/dapp-kit";
import { SuiObjectDisplay } from "@/components/SuiObjectDisplay";
import { Button } from "@radix-ui/themes";
import {
  ArrowDownIcon,
  ArrowUpIcon,
  Cross1Icon,
} from "@radix-ui/react-icons";
import { CONSTANTS, QueryKey } from "@/constants";
import { ExplorerLink } from "../ExplorerLink";
import { useQuery } from "@tanstack/react-query";
import { useState } from "react";
import { ApiEscrowObject } from "@/types/types";
import {
  useCancelEscrowMutation,
} from "@/mutations/escrow";
import { useGetLockedObject } from "@/hooks/useGetLockedObject";
import { LockedObject } from "../locked/LockedObject";

/**
 * A component that displays an escrow and allows the user to accept or cancel it.
 * Accepts an `escrow` object as returned from the API.
 */
export function Escrow({ escrow }: { escrow: ApiEscrowObject }) {
  const account = useCurrentAccount();
  const [isToggled, setIsToggled] = useState(true);
  const { mutate: cancelEscrowMutation, isPending: pendingCancellation } =
    useCancelEscrowMutation();

  const suiObject = useSuiClientQuery("getObject", {
    id: escrow?.itemId,
    options: {
      showDisplay: true,
      showType: true,
    },
  });

  const lockedData = useQuery({
    queryKey: [QueryKey.Locked, escrow.keyId],
    queryFn: async () => {
      const res = await fetch(
        `${CONSTANTS.apiEndpoint}locked?keyId=${escrow.keyId}`,
      );
      return res.json();
    },
    select: (data) => data.data[0],
    enabled: !escrow.cancelled,
  });

  const { data: suiLockedObject } = useGetLockedObject({
    lockedId: lockedData.data?.objectId,
  });

  const getLabel = () => {
    if (escrow.cancelled) return "Cancelled";
    if (escrow.swapped) return "Swapped";
    if (escrow.sender === account?.address) return "You offer this";
    if (escrow.recipient === account?.address) return "You'll receive this";
    return undefined;
  };
  const getLabelClasses = () => {
    if (escrow.cancelled) return "text-red-500";
    if (escrow.swapped) return "text-green-500";
    if (escrow.sender === account?.address)
      return "bg-blue-50 rounded px-3 py-1 text-sm text-blue-500";
    if (escrow.recipient === account?.address)
      return "bg-green-50 rounded px-3 py-1 text-sm text-green-700";
    return undefined;
  };

  return (
    <SuiObjectDisplay
      object={suiObject.data?.data!}
      label={getLabel()}
      labelClasses={getLabelClasses()}
    >
      <div className="p-4 flex gap-3 flex-wrap">
        {
          <p className="text-sm flex-shrink-0 flex items-center gap-2">
            <ExplorerLink id={escrow.objectId} isAddress={false} />
          </p>
        }
        <Button
          className="ml-auto cursor-pointer bg-transparent text-black"
          onClick={() => setIsToggled(!isToggled)}
        >
          Details
          {isToggled ? <ArrowUpIcon /> : <ArrowDownIcon />}
        </Button>
        {!escrow.cancelled &&
          !escrow.swapped &&
          escrow.sender === account?.address && (
            <Button
              color="amber"
              className="cursor-pointer"
              disabled={pendingCancellation}
              onClick={() =>
                cancelEscrowMutation({
                  escrow,
                  suiObject: suiObject.data?.data!,
                })
              }
            >
              <Cross1Icon />
              Cancel request
            </Button>
          )}
        {isToggled && lockedData.data && (
          <div className="min-w-[340px] w-full justify-self-start text-left">
            {suiLockedObject?.data && (
              <LockedObject
                object={suiLockedObject.data}
                itemId={lockedData.data.itemId}
                hideControls
              />
            )}

            {!lockedData.data.deleted &&
              escrow.recipient === account?.address && (
                <div className="text-right mt-5">
                  <p className="text-xs pb-3">
                    When accepting the exchange, the escrowed item is
                    transferred to you and your locked item is transferred
                    to the sender.
                  </p>
                </div>
              )}
            {lockedData.data.deleted &&
              !escrow.swapped &&
              escrow.recipient === account?.address && (
                <div>
                  <p className="text-red-500 text-sm py-2 flex items-center gap-3">
                    <Cross1Icon />
                    The locked object has been deleted so you cannot accept this
                    anymore.
                  </p>
                </div>
              )}
          </div>
        )}
      </div>
    </SuiObjectDisplay>
  );
}
```

</details>

<details>

<summary>

Add `src/components/escrows/EscrowList.tsx`

</summary>

<ImportContent source="examples/trading/frontend/src/components/escrows/EscrowList.tsx" mode="code"  />

</details>

<details>

<summary>

Update `src/routes/EscrowDashboard.tsx` to include the `EscrowList` component

</summary>

```tsx
import { useState } from "react";
import { Tabs, Tooltip } from "@radix-ui/themes";
import { LockedList } from "../components/locked/ApiLockedList";
import { EscrowList } from "../components/escrows/EscrowList";
import { InfoCircledIcon } from "@radix-ui/react-icons";
import { useCurrentAccount } from "@mysten/dapp-kit";

export function EscrowDashboard() {
  const account = useCurrentAccount();
  const tabs = [
    {
      name: "Browse Locked Objects",
      component: () => (
        <LockedList
          params={{
            deleted: "false",
          }}
          enableSearch
        />
      ),
      tooltip: "Browse locked objects you can trade for.",
    },
    {
      name: "My Pending Requests",
      component: () => (
        <EscrowList
          params={{
            sender: account?.address,
            swapped: "false",
            cancelled: "false",
            
          }}
          enableSearch
        />
      ),
      tooltip: "Escrows you have initiated for third party locked objects.",
    },
  ];

  const [tab, setTab] = useState(tabs[0].name);

  return (
    <Tabs.Root value={tab} onValueChange={setTab}>
      <Tabs.List>
        {tabs.map((tab, index) => {
          return (
            <Tabs.Trigger
              key={index}
              value={tab.name}
              className="cursor-pointer"
            >
              {tab.name}
              <Tooltip content={tab.tooltip}>
                <InfoCircledIcon className="ml-3" />
              </Tooltip>
            </Tabs.Trigger>
          );
        })}
      </Tabs.List>
      {tabs.map((tab, index) => {
        return (
          <Tabs.Content key={index} value={tab.name}>
            {tab.component()}
          </Tabs.Content>
        );
      })}
    </Tabs.Root>
  );
}
```

</details>

:::checkpoint

Run your app and ensure you can:

- View the escrows in the `My Pending Requests` tab in the `Escrows` page.
- Cancel an escrow that you requested.

![Cancel escrow](./images/trustless-cancel-escrow.png)

:::

### Accept escrows

To accept the escrow, create a mutation through the `useAcceptEscrowMutation` hook in `src/mutations/escrow.ts`. The implementation should be fairly familiar to you now. The accept function accepts the escrow `ApiEscrowObject` and the locked object `ApiLockedObject`. The `{PACKAGE_ID}::shared::swap` Move call is generic, thus it requires the type parameters of the escrowed and locked objects. Query the objects details by using `multiGetObjects` on Sui client instance. Lastly, execute the `{PACKAGE_ID}::shared::swap` Move call and transfer the returned escrowed item to the connected wallet account. When the mutation succeeds, invalidate the cache to allow automatic re-fetch of the data.

<details>

<summary>

`escrow.ts`

</summary>

```tsx
import { CONSTANTS, QueryKey } from "@/constants";
import { useTransactionExecution } from "@/hooks/useTransactionExecution";
import { ApiEscrowObject, ApiLockedObject } from "@/types/types";
import { useCurrentAccount, useSuiClient } from "@mysten/dapp-kit";
import { SuiObjectData } from "@mysten/sui/client";
import { Transaction } from "@mysten/sui/transactions";
import { useMutation, useQueryClient } from "@tanstack/react-query";

/**
 * Builds and executes the PTB to create an escrow.
 */
export function useCreateEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();

  return useMutation({
    mutationFn: async ({
      object,
      locked,
    }: {
      object: SuiObjectData;
      locked: ApiLockedObject;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");

      const txb = new Transaction();
      txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::create`,
        arguments: [
          txb.object(object.objectId!),
          txb.pure.id(locked.keyId),
          txb.pure.address(locked.creator!),
        ],
        typeArguments: [object.type!],
      });

      return executeTransaction(txb);
    },
  });
}

/**
 * Builds and executes the PTB to cancel an escrow.
 */
export function useCancelEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const executeTransaction = useTransactionExecution();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      escrow,
      suiObject,
    }: {
      escrow: ApiEscrowObject;
      suiObject: SuiObjectData;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");
      const txb = new Transaction();

      const item = txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::return_to_sender`,
        arguments: [txb.object(escrow.objectId)],
        typeArguments: [suiObject?.type!],
      });

      txb.transferObjects([item], txb.pure.address(currentAccount?.address!));

      return executeTransaction(txb);
    },

    onSuccess: () => {
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });
      }, 1_000);
    },
  });
}

/**
 * Builds and executes the PTB to accept an escrow.
 */
export function useAcceptEscrowMutation() {
  const currentAccount = useCurrentAccount();
  const client = useSuiClient();
  const executeTransaction = useTransactionExecution();
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      escrow,
      locked,
    }: {
      escrow: ApiEscrowObject;
      locked: ApiLockedObject;
    }) => {
      if (!currentAccount?.address)
        throw new Error("You need to connect your wallet!");
      const txb = new Transaction();

      const escrowObject = await client.multiGetObjects({
        ids: [escrow.itemId, locked.itemId],
        options: {
          showType: true,
        },
      });

      const escrowType = escrowObject.find(
        (x) => x.data?.objectId === escrow.itemId,
      )?.data?.type;

      const lockedType = escrowObject.find(
        (x) => x.data?.objectId === locked.itemId,
      )?.data?.type;

      if (!escrowType || !lockedType) {
        throw new Error("Failed to fetch types.");
      }

      const item = txb.moveCall({
        target: `${CONSTANTS.escrowContract.packageId}::shared::swap`,
        arguments: [
          txb.object(escrow.objectId),
          txb.object(escrow.keyId),
          txb.object(locked.objectId),
        ],
        typeArguments: [escrowType, lockedType],
      });

      txb.transferObjects([item], txb.pure.address(currentAccount.address));

      return executeTransaction(txb);
    },

    onSuccess: () => {
      setTimeout(() => {
        queryClient.invalidateQueries({ queryKey: [QueryKey.Escrow] });
      }, 1_000);
    },
  });
}
```

</details>

<details>

<summary>

Update `src/components/escrows/Escrow.tsx` to include the `useAcceptEscrowMutation` hook

</summary>

<ImportContent source="examples/trading/frontend/src/components/escrows/Escrow.tsx" mode="code"  />

</details>

<details>

<summary>

Update `src/routes/EscrowDashboard.tsx` to include the `EscrowList` component

</summary>

<ImportContent source="examples/trading/frontend/src/routes/EscrowDashboard.tsx" mode="code"  />

</details>

:::checkpoint

Run your app and ensure you can:

- Accept an escrow that someone else requested.

![Accept escrow](./images/trustless-accept-escrow.png)

:::

### Finished frontend

At this point, you have a fully functional frontend that allows users to discover trades and interact with listed escrows. The UI is designed to be user-friendly and intuitive, allowing users to easily navigate and interact with the application. Have fun exploring the app and testing out the different features!
>>>> sui/docs/content/guides/developer/app-examples/turnip-town.mdx
---
title: Turnip Town
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/developer/app-examples/weather-oracle.mdx
---
title: Sui Weather Oracle
description: Write a module (smart contract) in Move that fetches the weather data from the OpenWeather API every 10 minutes and updates the weather conditions for over 1,000 locations around the world.
keywords: [ weather app, weather forecast example, weather forecast dapp, sui weather oracle, openweather api, randomness, nfts, example app, example dapp, oracle, create an oracle ] 
---

This guide demonstrates writing a module (smart contract) in Move, deploying it on Devnet, and adding a backend, which fetches the weather data from the OpenWeather API every 10 minutes and updates the weather conditions for each city. The dApp created in this guide is called Sui Weather Oracle and it provides real-time weather data for over 1,000 locations around the world.

You can access and use the weather data from the OpenWeather API for various applications, such as randomness, betting, gaming, insurance, travel, education, or research. You can also mint a weather NFT based on the weather data of a city, using the `mint` function of the Sui Weather Oracle smart contract.

<ImportContent source="prerequisites.mdx" mode="snippet" />

## Move smart contract

As with all Sui dApps, a Move package on chain powers the logic of Sui Weather Oracle. The following instruction walks you through creating and publishing the module.

### `weather_oracle` module

Before you get started, you must initialize a Move package. Open a terminal or console in the directory you want to store the example and run the following command to create an empty package with the name `weather_oracle`:

```sh
$ sui move new weather_oracle
```

With that done, it's time to jump into some code. Create a new file in the `sources` directory with the name `weather.move` and populate the file with the following code:

```rust title='weather.move'
// Copyright (c) Mysten Labs, Inc.
// SPDX-License-Identifier: Apache-2.0

module oracle::weather {
    use std::string::String;
    use sui::dynamic_object_field as dof;
    use sui::package;
}
```

There are few details to take note of in this code:

1. The fourth line declares the module name as `weather` within the package `oracle`.
1. Seven lines begin with the `use` keyword, which enables this module to use types and functions declared in other modules.

Next, add some more code to this module:

```rust title='weather.move'
/// Define a capability for the admin of the oracle.
public struct AdminCap has key, store { id: UID }

/// // Define a one-time witness to create the `Publisher` of the oracle.
public struct WEATHER has drop {}

// Define a struct for the weather oracle
public struct WeatherOracle has key {
    id: UID,
    /// The address of the oracle.
    address: address,
    /// The name of the oracle.
    name: String,
    /// The description of the oracle.
    description: String,
}

public struct CityWeatherOracle has key, store {
    id: UID,
    geoname_id: u32, // The unique identifier of the city
    name: String, // The name of the city
    country: String, // The country of the city
    latitude: u32, // The latitude of the city in degrees
    positive_latitude: bool, // Whether the latitude is positive (north) or negative (south)
    longitude: u32, // The longitude of the city in degrees
    positive_longitude: bool, // Whether the longitude is positive (east) or negative (west)
    weather_id: u16, // The weather condition code
    temp: u32, // The temperature in kelvin
    pressure: u32, // The atmospheric pressure in hPa
    humidity: u8, // The humidity percentage
    visibility: u16, // The visibility in meters
    wind_speed: u16, // The wind speed in meters per second
    wind_deg: u16, // The wind direction in degrees
    wind_gust: Option<u16>, // The wind gust in meters per second (optional)
    clouds: u8, // The cloudiness percentage
    dt: u32 // The timestamp of the weather update in seconds since epoch
}

fun init(otw: WEATHER, ctx: &mut TxContext) {
    package::claim_and_keep(otw, ctx); // Claim ownership of the one-time witness and keep it

    let cap = AdminCap { id: object::new(ctx) }; // Create a new admin capability object
    transfer::share_object(WeatherOracle {
        id: object::new(ctx),
        address: ctx.sender(),
        name: b"SuiMeteo".to_string(),
        description: b"A weather oracle.".to_string(),
    });
    transfer::public_transfer(cap, ctx.sender()); // Transfer the admin capability to the sender.
}
```

- The first struct, `AdminCap`, is a capability.
- The second struct, `WEATHER`, is a one-time witness that ensures only a single instance of this `Weather` ever exists. See [One Time Witness](https://move-book.com/programmability/one-time-witness.html) in The Move Book for more information.
- The `WeatherOracle` struct works as a registry and stores the `geoname_id`s of the `CityWeatherOracle`s as dynamic fields. See [The Move Book](https://move-book.com/programmability/dynamic-fields.html) to learn more about dynamic fields.
- The `init` function creates and sends the `Publisher` and `AdminCap` objects to the sender. Also, it creates a [shared object](concepts/object-ownership/shared.mdx) for all the `CityWeatherOracle`s. See [Module Initializer](https://move-book.com/programmability/module-initializer.html) in The Move Book for more information.

So far, you've set up the data structures within the module.
Now, create a function that initializes a `CityWeatherOracle` and adds it as dynamic fields to the `WeatherOracle` object:

```rust title='weather.move'
public fun add_city(
    _: &AdminCap, // The admin capability
    oracle: &mut WeatherOracle, // A mutable reference to the oracle object
    geoname_id: u32, // The unique identifier of the city
    name: String, // The name of the city
    country: String, // The country of the city
    latitude: u32, // The latitude of the city in degrees
    positive_latitude: bool, // The whether the latitude is positive (north) or negative (south)
    longitude: u32, // The longitude of the city in degrees
    positive_longitude: bool, // The whether the longitude is positive (east) or negative (west)
    ctx: &mut TxContext // A mutable reference to the transaction context
) {
    dof::add(&mut oracle.id, geoname_id, // Add a new dynamic object field to the oracle object with the geoname ID as the key and a new city weather oracle object as the value.
        CityWeatherOracle {
            id: object::new(ctx), // Assign a unique ID to the city weather oracle object
            geoname_id, // Set the geoname ID of the city weather oracle object
            name,  // Set the name of the city weather oracle object
            country,  // Set the country of the city weather oracle object
            latitude,  // Set the latitude of the city weather oracle object
            positive_latitude,  // Set whether the latitude is positive (north) or negative (south)
            longitude,  // Set the longitude of the city weather oracle object
            positive_longitude,  // Set whether the longitude is positive (east) or negative (west)
            weather_id: 0, // Initialize the weather condition code to be zero
            temp: 0, // Initialize the temperature to be zero
            pressure: 0, // Initialize the pressure to be zero
            humidity: 0, // Initialize the humidity to be zero
            visibility: 0, // Initialize the visibility to be zero
            wind_speed: 0, // Initialize the wind speed to be zero
            wind_deg: 0, // Initialize the wind direction to be zero
            wind_gust: option::none(), // Initialize the wind gust to be none
            clouds: 0, // Initialize the cloudiness to be zero
            dt: 0 // Initialize the timestamp to be zero
        }
    );
}
```

The `add_city` function lets the `AdminCap` holder add a new city to the Sui Weather Oracle. The caller must present their `AdminCap` and pass a mutable reference to the main `Oracle` object. The function accepts city metadataâ€”geoname ID, name, country and coordinates (latitude, longitude, and their positive flags). It then creates a `CityWeatherOracle` sub-object, initializes its weather fields to empty/zero, and inserts it into the oracleâ€™s dynamic fields keyed by the geoname ID. After this, the city is registered and ready to receive updates from the backend.

To delete a city, call `remove_city`. The admin again provides the `AdminCap` and a **mutable** oracle reference, plus the cityâ€™s geoname ID. The function removes the corresponding `CityWeatherOracle` sub-object and deletes its dynamic field entry from the oracle. This cleanly unregisters the city and frees the associated on-chain storage.

```rust title='weather.move'
public fun remove_city(
    _: &AdminCap,
    oracle: &mut WeatherOracle,
    geoname_id: u32
    ) {
        let CityWeatherOracle {
            id,
            geoname_id: _,
            name: _,
            country: _,
            latitude: _,
            positive_latitude: _,
            longitude: _,
            positive_longitude: _,
            weather_id: _,
            temp: _,
            pressure: _,
            humidity: _,
            visibility: _,
            wind_speed: _,
            wind_deg: _,
            wind_gust: _,
            clouds: _,
            dt: _ } = dof::remove(&mut oracle.id, geoname_id);
        object::delete(id);
}
```

After you implement `add_city` and `remove_city`, update each cityâ€™s weather data. Every 10 minutes, the backend service fetches conditions from the OpenWeather API and **calls** the `weather_oracle` module's `update` function with the results.

The `update` function accepts the cityâ€™s geoname ID and the new weather fields, then **writes** them to the corresponding `CityWeatherOracle` object. This keeps the on-chain weather data current and accurate.


```rust title='weather.move'
public fun update(
    _: &AdminCap,
    oracle: &mut WeatherOracle,
    geoname_id: u32,
    weather_id: u16,
    temp: u32,
    pressure: u32,
    humidity: u8,
    visibility: u16,
    wind_speed: u16,
    wind_deg: u16,
    wind_gust: Option<u16>,
    clouds: u8,
    dt: u32
) {
    let city_weather_oracle_mut = dof::borrow_mut<u32, CityWeatherOracle>(&mut oracle.id, geoname_id); // Borrow a mutable reference to the city weather oracle object with the geoname ID as the key
    city_weather_oracle_mut.weather_id = weather_id;
    city_weather_oracle_mut.temp = temp;
    city_weather_oracle_mut.pressure = pressure;
    city_weather_oracle_mut.humidity = humidity;
    city_weather_oracle_mut.visibility = visibility;
    city_weather_oracle_mut.wind_speed = wind_speed;
    city_weather_oracle_mut.wind_deg = wind_deg;
    city_weather_oracle_mut.wind_gust = wind_gust;
    city_weather_oracle_mut.clouds = clouds;
    city_weather_oracle_mut.dt = dt;
}
```

You have defined the data structure of the Sui Weather Oracle smart contract, but you need some functions to access and manipulate the data. Now, add some helper functions that read and return the weather data for a `WeatherOracle` object. These functions allow you to get the weather data for a specific city in the oracle. These functions also allow you to format and display the weather data in a user-friendly way.

```rust title='weather.move'
// --------------- Read-only References ---------------

/// Returns the `name` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_name(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): String {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.name
}
/// Returns the `country` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_country(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): String {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.country
}
/// Returns the `latitude` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_latitude(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.latitude
}
/// Returns the `positive_latitude` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_positive_latitude(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): bool {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.positive_latitude
}
/// Returns the `longitude` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_longitude(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.longitude
}
/// Returns the `positive_longitude` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_positive_longitude(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): bool {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.positive_longitude
}
/// Returns the `weather_id` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_weather_id(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u16 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.weather_id
}
/// Returns the `temp` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_temp(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.temp
}
/// Returns the `pressure` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_pressure(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.pressure
}
/// Returns the `humidity` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_humidity(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u8 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.humidity
}
/// Returns the `visibility` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_visibility(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u16 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.visibility
}
/// Returns the `wind_speed` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_wind_speed(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u16 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.wind_speed
}
/// Returns the `wind_deg` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_wind_deg(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u16 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.wind_deg
}
/// Returns the `wind_gust` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_wind_gust(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): Option<u16> {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.wind_gust
}
/// Returns the `clouds` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_clouds(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u8 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.clouds
}
/// Returns the `dt` of the `CityWeatherOracle` with the given `geoname_id`.
public fun city_weather_oracle_dt(
    weather_oracle: &WeatherOracle,
    geoname_id: u32
): u32 {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&weather_oracle.id, geoname_id);
    city_weather_oracle.dt
}
```

The `mint` function lets anyone create a `WeatherNFT` for a city by passing its geoname ID and the shared `WeatherOracle`. The function looks up the `CityWeatherOracle` for that ID, builds a new NFT from its values, assigns a fresh `UID`, and transfers the NFT to the transaction sender. You donâ€™t need an `AdminCap`.

Each `WeatherNFT` captures the cityâ€™s conditions at mint time and **copies** the fields from `CityWeatherOracle`: `geonameID`, `name`, `country`, `latitude`, `longitude`, positive-latitude/longitude flags, `weather_id`, `temperature`, `pressure`, `humidity`, `visibility`, `wind_speed`, `wind_degree`, `wind_gust`, `clouds`, and `timestamp`. Collectors can hold these NFTs as historical weather snapshots, and apps can use them wherever they need verifiable, immutable weather data.

```rust title='weather.move'
public struct WeatherNFT has key, store {
    id: UID,
    geoname_id: u32,
    name: String,
    country: String,
    latitude: u32,
    positive_latitude: bool,
    longitude: u32,
    positive_longitude: bool,
    weather_id: u16,
    temp: u32,
    pressure: u32,
    humidity: u8,
    visibility: u16,
    wind_speed: u16,
    wind_deg: u16,
    wind_gust: Option<u16>,
    clouds: u8,
    dt: u32
}

public fun mint(
    oracle: &WeatherOracle,
    geoname_id: u32,
    ctx: &mut TxContext
): WeatherNFT {
    let city_weather_oracle = dof::borrow<u32, CityWeatherOracle>(&oracle.id, geoname_id);
    WeatherNFT {
        id: object::new(ctx),
        geoname_id: city_weather_oracle.geoname_id,
        name: city_weather_oracle.name,
        country: city_weather_oracle.country,
        latitude: city_weather_oracle.latitude,
        positive_latitude: city_weather_oracle.positive_latitude,
        longitude: city_weather_oracle.longitude,
        positive_longitude: city_weather_oracle.positive_longitude,
        weather_id: city_weather_oracle.weather_id,
        temp: city_weather_oracle.temp,
        pressure: city_weather_oracle.pressure,
        humidity: city_weather_oracle.humidity,
        visibility: city_weather_oracle.visibility,
        wind_speed: city_weather_oracle.wind_speed,
        wind_deg: city_weather_oracle.wind_deg,
        wind_gust: city_weather_oracle.wind_gust,
        clouds: city_weather_oracle.clouds,
        dt: city_weather_oracle.dt
    }
}
```

And with that, your `weather.move` code is complete.

## Deployment

<ImportContent source="initialize-sui-client-cli.mdx" mode="snippet" />

<ImportContent source="publish-to-devnet-with-coins.mdx" mode="snippet" />

## Backend

You have successfully deployed the Sui Weather Oracle smart contract on the blockchain. Now, it's time to create an Express backend that can interact with it. The Express backend performs the following tasks:

- Initialize the smart contract with 1,000 cities using the `add_city` function of the smart contract. The backend passes the geoname ID, name, country, latitude, longitude, and positive latitude and longitude of each city as parameters to the function.
- Fetch the weather data for each city from the OpenWeather API every 10 minutes, using the API key that you obtained from the website. The backend parses the JSON response and extracts the weather data for each city, such as the weather ID, temperature, pressure, humidity, visibility, wind speed, wind degree, wind gust, clouds, and timestamp.
- Update the weather data for each city on the blockchain, using the `update` function of the smart contract. The backend passes the geoname ID and the new weather data of each city as parameters to the function.

The Express backend uses the [Sui Typescript SDK](https://sdk.mystenlabs.com/typescript), a TypeScript library that enables you to interact with the Sui blockchain and smart contracts. With the Sui Typescript SDK, you can connect to the Sui network, sign and submit transactions, and query the state of the smart contract. You also use the OpenWeather API to fetch the weather data for each city and update the smart contract every 10 minutes. Additionally, you can mint weather NFTs, if you want to explore that feature of the smart contract.

### Initialize the project

First, initialize your backend project. To do this, you need to follow these steps:

- Create a new folder named `weather-oracle-backend` and navigate to it in your terminal.
- Run `npm init -y` to create a package.json file with default values.
- Run `npm install express --save` to install Express as a dependency and save it to your package.json file.
- Run `npm install @mysten/bcs @mysten/sui axios csv-parse csv-parser dotenv pino retry-axios --save` to install the other dependencies and save them to your package.json file. These dependencies are:
  - **@mysten/bcs**: a library for blockchain services.
  - **@mysten/sui**: a library for smart user interfaces.
  - **axios**: a library for making HTTP requests.
  - **csv-parse**: a library for parsing CSV data.
  - **csv-parser**: a library for transforming CSV data into JSON objects.
  - **dotenv**: a library for loading environment variables from a .env file.
  - **pino**: a library for fast and low-overhead logging.
  - **retry-axios**: a library for retrying failed axios requests.
- Create a new file named `init.ts`

```typescript title='init.ts'
import { SuiClient } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import * as dotenv from 'dotenv';

import { City } from './city';
import { get1000Geonameids } from './filter-cities';
import { latitudeMultiplier, longitudeMultiplier } from './multipliers';
import { getCities, getWeatherOracleDynamicFields } from './utils';
import { logger } from './utils/logger';

dotenv.config({ path: '../.env' });

const phrase = process.env.ADMIN_PHRASE;
const fullnode = process.env.FULLNODE!;
const keypair = Ed25519Keypair.deriveKeypair(phrase!);
const client = new SuiClient({
	url: fullnode,
});

const packageId = process.env.PACKAGE_ID;
const adminCap = process.env.ADMIN_CAP_ID!;
const weatherOracleId = process.env.WEATHER_ORACLE_ID!;
const moduleName = 'weather';

const NUMBER_OF_CITIES = 10;

async function addCityWeather() {
	const cities: City[] = await getCities();
	const thousandGeoNameIds = await get1000Geonameids();

	const weatherOracleDynamicFields = await getWeatherOracleDynamicFields(client, weatherOracleId);
	const geonames = weatherOracleDynamicFields.map(function (obj) {
		return obj.name;
	});

	let counter = 0;
	let transaction = new Transaction();
	for (let c in cities) {
		if (
			!geonames.includes(cities[c].geonameid) &&
			thousandGeoNameIds.includes(cities[c].geonameid)
		) {
			transaction.moveCall({
				target: `${packageId}::${moduleName}::add_city`,
				arguments: [
					transaction.object(adminCap), // adminCap
					transaction.object(weatherOracleId), // WeatherOracle
					transaction.pure(cities[c].geonameid), // geoname_id
					transaction.pure(cities[c].asciiname), // asciiname
					transaction.pure(cities[c].countryCode), // country
					transaction.pure(cities[c].latitude * latitudeMultiplier), // latitude
					transaction.pure(cities[c].latitude > 0), // positive_latitude
					transaction.pure(cities[c].longitude * longitudeMultiplier), // longitude
					transaction.pure(cities[c].longitude > 0), // positive_longitude
				],
			});

			counter++;
			if (counter === NUMBER_OF_CITIES) {
				await signAndExecuteTransaction(transaction);
				counter = 0;
				transaction = new Transaction();
			}
		}
	}
	await signAndExecuteTransaction(transaction);
}

async function signAndExecuteTransaction(transaction: Transaction) {
	transaction.setGasBudget(5000000000);
	await client
		.signAndExecuteTransaction({
			signer: keypair,
			transaction,
			requestType: 'WaitForLocalExecution',
			options: {
				showObjectChanges: true,
				showEffects: true,
			},
		})
		.then(function (res) {
			logger.info(res);
		});
}

addCityWeather();
```

The code of init.ts does the following:

- Imports the necessary modules and classes from the library, such as `Ed25519Keypair`, `SuiClient`, and `Transaction`.
- Imports the `dotenv` module to load environment variables from a .env file.
- Imports some custom modules and functions from the local files, such as `City`, `get1000Geonameids`, `getCities`, `getWeatherOracleDynamicFields`, and `logger`.
- Derives a key pair from a phrase stored in the `ADMIN_PHRASE` environment variable.
- Creates a sui client object that connects to a Full node specified by the `FULLNODE` environment variable.
- Reads some other environment variables, such as `PACKAGE_ID`, `ADMIN_CAP_ID`, `WEATHER_ORACLE_ID`, and `MODULE_NAME`, which are used to identify the weather oracle contract and its methods.
- Defines a constant `NUMBER_OF_CITIES`, which is the number of cities to be added to the weather oracle in each batch.
- Defines an async function `addCityWeather`, which does the following:
  - Gets an array of cities from the `getCities` function.
  - Gets an array of 1,000 geonameids from the `get1000Geonameids` function.
  - Gets an array of weather oracle dynamic fields from the `getWeatherOracleDynamicFields` function, which contains the geonameids of the existing cities in the weather oracle.
  - Initializes a counter and a transaction block object.
  - Loops through the cities array and checks if the city's geonameid is not in the weather oracle dynamic fields array and is in the 1,000 geonameids array.
  - If the condition is met, adds a `moveCall` to the transaction block, which calls the `add_city` method of the weather oracle contract with the city's information, such as `geonameid`, `asciiname`, `country`, `latitude`, and `longitude`.
  - Increments the counter and checks if it reaches the `NUMBER_OF_CITIES`. If so, calls another async function, `signAndExecuteTransaction`, with the transaction block as an argument, which signs and executes the transaction block on the blockchain and logs the result. The code then resets the counter and the transaction block.
  - After the loop ends, calls the `signAndExecuteTransaction` function again with the remaining transaction block.

You have now initialized the `WeatherOracle` shared object. The next step is to learn how to update them every 10 minutes with the latest weather data from the OpenWeatherMap API.

```typescript title='index.ts'
import { SuiClient } from '@mysten/sui/client';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';
import * as dotenv from 'dotenv';

import { City } from './city';
import { tempMultiplier, windGustMultiplier, windSpeedMultiplier } from './multipliers';
import { getWeatherData } from './openweathermap';
import { getCities, getWeatherOracleDynamicFields } from './utils';
import { logger } from './utils/logger';

dotenv.config({ path: '../.env' });

const phrase = process.env.ADMIN_PHRASE;
const fullnode = process.env.FULLNODE!;
const keypair = Ed25519Keypair.deriveKeypair(phrase!);
const client = new SuiClient({
	url: fullnode,
});

const packageId = process.env.PACKAGE_ID;
const adminCap = process.env.ADMIN_CAP_ID!;
const weatherOracleId = process.env.WEATHER_ORACLE_ID!;
const appid = process.env.APPID!;
const moduleName = 'weather';

const CHUNK_SIZE = 25;
const MS = 1000;
const MINUTE = 60 * MS;
const TEN_MINUTES = 10 * MINUTE;

async function performUpdates(
	cities: City[],
	weatherOracleDynamicFields: {
		name: number;
		objectId: string;
	}[],
) {
	let startTime = new Date().getTime();

	const geonames = weatherOracleDynamicFields.map(function (obj) {
		return obj.name;
	});
	const filteredCities = cities.filter((c) => geonames.includes(c.geonameid));

	for (let i = 0; i < filteredCities.length; i += CHUNK_SIZE) {
		const chunk = filteredCities.slice(i, i + CHUNK_SIZE);

		let transaction = await getTransaction(chunk);
		try {
			await client.signAndExecuteTransaction({
				signer: keypair,
				transaction,
			});
		} catch (e) {
			logger.error(e);
		}
	}

	let endTime = new Date().getTime();
	setTimeout(
		performUpdates,
		TEN_MINUTES - (endTime - startTime),
		cities,
		weatherOracleDynamicFields,
	);
}

async function getTransaction(cities: City[]) {
	let transaction = new Transaction();

	let counter = 0;
	for (let c in cities) {
		const weatherData = await getWeatherData(cities[c].latitude, cities[c].longitude, appid);
		counter++;
		if (weatherData?.main?.temp !== undefined) {
			transaction.moveCall({
				target: `${packageId}::${moduleName}::update`,
				arguments: [
					transaction.object(adminCap), // AdminCap
					transaction.object(weatherOracleId), // WeatherOracle
					transaction.pure(cities[c].geonameid), // geoname_id
					transaction.pure(weatherData.weather[0].id), // weather_id
					transaction.pure(weatherData.main.temp * tempMultiplier), // temp
					transaction.pure(weatherData.main.pressure), // pressure
					transaction.pure(weatherData.main.humidity), // humidity
					transaction.pure(weatherData.visibility), // visibility
					transaction.pure(weatherData.wind.speed * windSpeedMultiplier), // wind_speed
					transaction.pure(weatherData.wind.deg), // wind_deg
					transaction.pure(
						weatherData.wind.gust === undefined ? [] : [weatherData.wind.gust * windGustMultiplier],
						'vector<u16>',
					), // wind_gust
					transaction.pure(weatherData.clouds.all), // clouds
					transaction.pure(weatherData.dt), // dt
				],
			});
		} else logger.warn(`No weather data for ${cities[c].asciiname} `);
	}
	return transaction;
}

async function run() {
	const cities: City[] = await getCities();
	const weatherOracleDynamicFields: {
		name: number;
		objectId: string;
	}[] = await getWeatherOracleDynamicFields(client, weatherOracleId);
	performUpdates(cities, weatherOracleDynamicFields);
}

run();
```

The code in `index.ts` does the following:

- Uses `dotenv` to load some environment variables from a `.env` file, such as `ADMIN_PHRASE`, `FULLNODE`, `PACKAGE_ID`, `ADMIN_CAP_ID`, `WEATHER_ORACLE_ID`, `APPID`, and `MODULE_NAME`. These variables are used to configure some parameters for the code, such as the key pair, the client, and the target package and module.
- Defines some constants, such as `CHUNK_SIZE`, `MS`, `MINUTE`, and `TEN_MINUTES`. These constants are used to control the frequency and size of the updates that the code performs.
- Defines an async function called `performUpdates`, which takes two arguments: `cities` and `weatherOracleDynamicFields`. This function is the main logic of the code, and it does the following:
  - Filters the `cities` array based on the `weatherOracleDynamicFields` array, which contains the names and object IDs of the weather oracle dynamic fields that the code needs to update.
  - Loops through the filtered cities in chunks of `CHUNK_SIZE`, and for each chunk, it calls another async function called `getTransaction`, which returns a transaction block that contains the Move calls to update the weather oracle dynamic fields with the latest weather data from the `OpenWeatherMap` API.
  - Tries to sign and execute the transaction block using the client and key pair, and catches any errors that may occur.
  - Calculates the time it took to perform the updates, and sets a timeout to call itself again after `TEN_MINUTES` minus the elapsed time.
- The code defines another async function called `getTransaction`, which takes one argument: `cities`. This function does the following:
  - Creates a new transaction block object.
  - Loops through the `cities` array, and for each city, it calls another async function called `getWeatherData`, which takes the `latitude`, `longitude`, and `appid` as arguments, and returns the weather data for the city from the OpenWeatherMap API.
  - Checks if the weather data is valid, and if so, adds a Move call to the transaction block, which calls the `update` function of the target package and module, and passes the admin cap, the weather oracle id, the geoname id, and the weather data as arguments.
  - Returns the transaction block object.
- An async `run` function is defined, which does the following:
  - Calls another async function called `getCities`, which returns an array of city objects that contain information such as name, geoname id, latitude, and longitude.
  - Calls another async function called `getWeatherOracleDynamicFields`, which takes the package id, the module name, and the client as arguments, and returns an array of weather oracle dynamic field objects that contain information such as name and object id.
  - Calls the `performUpdates` function with the cities and weather oracle dynamic fields arrays as arguments.

Congratulations, you completed the Sui Weather Oracle tutorial. You can carry the lessons learned here forward when building your next Sui project.

>>>> sui/docs/content/guides/developer/coin-index.mdx
---
title: Currencies and Tokens
description: Learn about creating and managing currencies and tokens on Sui using the Coin Registry system and `token` module, including regulated tokens, in-game currencies, and loyalty tokens.
keywords: [ coin, coins, sui coin, regulated coin, in-game token, loyalty token, token design, tokenomics, coin registry, currency registry ]
pagination_prev: null
---

Learn how to design and implement currencies and tokens on Sui.

<Cards>
<Card title="Create Currencies and Tokens" href="/guides/developer/currency">
Learn how to create currencies using the Coin Registry.
</Card>
<Card title="Regulated Currency and Deny List" href="/guides/developer/coin/regulated">
Create regulated currencies with deny list capabilities.
</Card>
<Card title="In-Game Currency" href="/guides/developer/coin/in-game-token">
Use Closed-Loop Tokens for in-game currencies and restricted-use tokens.
</Card>
<Card title="Loyalty Tokens" href="/guides/developer/coin/loyalty">
Implement loyalty programs using the Closed-Loop Token standard.
</Card>
</Cards>

>>>> sui/docs/content/guides/developer/coin/in-game-token.mdx
---
title: In-Game Currency
description: Use the Sui Closed-Loop Token standard to create tokens that you can use as currency within a game application.
keywords: [ closed-loop tokens, closed-loop, closed loop, in-game tokens, in-game currency, game currency, token example, create a token, how to create token, SUI token standards ]
---

Using the Sui [Closed-Loop Token](/standards/closed-loop-token.mdx) standard, you can create in-game currency (such as gems or diamonds in mobile games) that you can grant to players for their actions or make available to purchase. You mint the tokens on Sui, but players can only use the tokens within the economy of the game itself. These types of tokens are usually not transferrable and you typically mint them in predefined amounts to maintain scarcity and game balance.

The following example creates an in-game currency called a GEM, which represents a certain number of SUI. In the example, the user can buy fungible GEMs using SUI, which can then be used as currency within the game. Use the code comments to follow the logic of the example.

## Example 

The Sui repo hosts a basic example of creating in-game currency. The Move modules that create the economy of the example are in the `gems.move` source file.

### Module `examples::sword`

The `examples::sword` module creates 1 of the objects, a `sword`, that has in-game value. The module assigns a value in GEMs (the other valuable in-game item) to the sword. The module also provides the logic for trading GEMs to receive a sword. 

<ImportContent source="examples/move/token/sources/gems.move" mode="code" module="examples::sword" noComments />

### Module `examples::gem`

The `examples::gem` module creates the in-game currency, GEMs. Users spend SUI to purchase GEMs, which can then be traded for swords. The module defines 3 groups of GEMs (small, medium, and large), with each group representing a different in-game value. Constants hold both the value of each package and the actual number of GEMs the groups contain. 

The module's `init` function uses `coin::create_currency` to create the GEM. The `init` function, which runs only when the module publishes, also sets the policies for the in-game currency, freezes the metadata for the coin, and transfers the policy capability to the publisher of the package. 

<ImportContent source="examples/move/token/sources/gems.move" mode="code" fun="init" noComments />

The module handles the purchase of GEMs with the `buy_gems` function. 

<ImportContent source="examples/move/token/sources/gems.move" mode="code" fun="buy_gems" noComments />

Use the following toggle to control the display of the complete module. 

<details>

<summary>

`examples::gem` module in `gems.move`

</summary>

<ImportContent source="examples/move/token/sources/gems.move" mode="code" module="examples::gem" noComments />

</details>

### Complete code 

Toggle display of the complete source for this example, including comments, or use the link in the [Related links](#related-links) section to view the project source on GitHub.

<details>

<summary>

`gems.move`

</summary>

<ImportContent source="examples/move/token/sources/gems.move" mode="code" />

</details>

## Related links

<RelatedLink to="/standards/closed-loop-token.mdx" />
<RelatedLink href="https://github.com/MystenLabs/sui/blob/main/examples/move/token/sources/gems.move" label="Source code" desc="The source code in GitHub for this example." />
<RelatedLink to="/guides/developer/coin/loyalty.mdx" />
<RelatedLink to="/guides/developer/coin/regulated.mdx" />
>>>> sui/docs/content/guides/developer/coin/loyalty.mdx
---
title: Loyalty Tokens
description: Use the Sui Closed-Loop Token standard to create tokens that are only valid within specific workflows and services. One example of Closed-Loop Tokens is a loyalty token.
keywords: [ closed-loop tokens, closed-loop, closed loop, loyalty tokens, token example, create a token, how to create token, SUI token standards ]
---

Using the Sui [Closed-Loop Token](../../../standards/closed-loop-token.mdx) standard, you can create tokens that are valid only for a specific service, like an airline that wants to grant tokens to frequent flyers to purchase tickets or upgrades. 

The following example demonstrates the creation of a loyalty token that bearers can use to make purchases in a digital gift shop.

## Example

The loyalty token example illustrates a loyalty token that is created with the Closed Loop Token standard. If you were to implement this example, the Admin sends `LOYALTY` tokens to the users of your service as a reward for their loyalty. The example creates a `GiftShop` where holders can spend `LOYALTY` tokens to buy `Gift`s.

The `loyalty.move` source file contains the `examples::loyalty` module code that creates the loyalty token. The module includes the One-Time Witness (OTW) that creates the coin (with the same name as the module, `LOYALTY`), possesses only the `drop` ability, and has no fields. These are the characteristics of a OTW, which ensures the `LOYALTY` type has a single instance.

<ImportContent source="examples/move/token/sources/loyalty.move" mode="code" struct="LOYALTY" />

The `init` function of the module uses the `LOYALTY` OTW to create the token. All `init` functions run only during the package publish event. The initializer function makes use of the OTW `LOYALTY` type defined previously in its call to `create_currency`. The function also defines a policy, sending both the policy capability and treasury capability to the address associated with the publish event. The holder of these transferrable capabilities can mint new `LOYALTY` tokens and modify their policies.

<ImportContent source="examples/move/token/sources/loyalty.move" mode="code" fun="init" noComments />

The `LOYALTY` minting function is called `reward_user`. As mentioned previously, the holder of the `TreasuryCap` can call this function to mint new loyalty tokens and send them to the desired address. The function uses the `token::mint` function to create the token and `token::transfer` to send it to the intended recipient. 

<ImportContent source="examples/move/token/sources/loyalty.move" mode="code" fun="reward_user" noComments />

Finally, the example includes a `buy_a_gift` function to handle the redemption of `LOYALTY` tokens for `Gift` types. The function ensures the gift price matches the number of loyalty tokens spent, then uses the `token::spend` function to handle the treasury bookkeeping. 

<ImportContent source="examples/move/token/sources/loyalty.move" mode="code" fun="buy_a_gift" noComments />

### Complete code 

Toggle display of the complete source for this example, including comments, or use the link in the [Related links](#related-links) section to view the project source on GitHub.

<details>

<summary>

`loyalty.move`

</summary>

<ImportContent source="examples/move/token/sources/loyalty.move" mode="code" />

</details>

## Related links

<RelatedLink to="/standards/closed-loop-token.mdx" />
<RelatedLink href="https://github.com/MystenLabs/sui/blob/main/examples/move/token/sources/loyalty.move" label="Source code" desc="The source code in GitHub for this example." />
<RelatedLink to="/guides/developer/coin/in-game-token.mdx" />
<RelatedLink to="/guides/developer/coin/regulated.mdx" />
>>>> sui/docs/content/guides/developer/coin/regulated.mdx
---
title: Regulated Currency and Deny List
description: You can create regulated currencies on Sui using the Coin Registry system. These coins include the ability to control access using a deny list.
keywords: [ regulated coin list, regulated coins, regulate coin, allow list, deny list, stablecoins, token example, create a token, how to create token, SUI token standards, coin registry ]
---

You can create regulated currencies on Sui, such as stablecoins. These coins are similar to other coins, like SUI, but include the ability to control access to the currency using a deny list.

The Coin Registry system provides enhanced regulatory features through the `sui::coin_registry` module:

1. **During initialization:** Use the `make_regulated()` function on the `CurrencyInitializer<T>` before calling `finalize()`.
2. **Regulatory tracking:** The registry automatically tracks regulatory status in the `RegulatedState` enum.
3. **Enhanced compliance:** Built-in support for global pause functionality and better ecosystem integration.

Advantages of these regulatory features include:

- **Centralized tracking:** Regulatory status is stored in the registry for easy discovery.
- **Global pause support:** Enhanced pause or unpause functionality for emergency situations.
- **Compliance tooling:** Better integration with wallets, exchanges, and compliance systems.
- **Migration support:** Seamless migration from legacy regulated coins.

## `DenyList`

The `DenyList` is a singleton, shared object that the bearer of a `DenyCapV2` can access to specify a list of addresses that are unable to use a Sui core type. The initial use case for `DenyList`, however, focuses on limiting access to coins of a specified type. This is useful when creating a regulated coin on Sui that requires the ability to block certain addresses from using it as inputs to transactions. Regulated coins on Sui satisfy any regulations that require the ability to prevent known bad actors from having access to those coins.

:::info

The `DenyList` object is a system object that has the address `0x403`. You cannot create it yourself.

:::

To learn about the features available, see the [Currency Standard](/standards/currency.mdx) documentation and the `coin_registry` module in the Sui framework.

## Regulated coin example

The regulated coin example is in the `examples/regulated-coin` directory of the Sui repo. The example provides both TypeScript- and Rust-based command line access to an on-chain package that demonstrates some of the features of regulated coins on Sui.

<ImportContent source="prerequisites.mdx" mode="snippet" />

This topic assumes you are accessing the code from your own fork of the Sui repo. 

You do not need a Sui wallet to use this project, but having one available might help you visualize results.

This example assumes you're familiar with publishing packages on Sui and the Move language. For more detailed guides on example dApps, see [App Examples](../app-examples.mdx). For more information on the Move language, see [The Move Book](https://move-book.com/).

## Publishing to a network

You publish the smart contract to a network the same way as any other package. See "Hello, World!"(/guides/developer/getting-started/hello-world.mdx) if you would like more details on the publishing process. 

The example includes a `publish.sh` file that you can run to automate the publishing. The script assumes you are publishing to Testnet, so be sure to update it before running if you plan to run on a local network or Devnet.

The publish script also creates the necessary `.env` files in each of the frontend folders. If you don't use the script, you must create the `.env` file manually and provide the values for the variables the frontend expects to find. Even if you use the script, you must provide the `ADMIN_SECRET_KEY` and its value.

:::warning

Take care not to expose the secret key for your address to the public.

:::

| Constant name | Description |
| --- | --- |
| `PACKAGE_ID` | Object ID of the package you publish. This data is part of the response that Sui provides on publish. |
| `ADMIN_SECRET_KEY` | The secret key for the address that publishes the package. You can use `sui keytool export --key-identity <SUI-ADDRESS>` or a wallet UI to get the value. Take care not to expose the value to the public. |
| `ADMIN_ADDRESS` | The address that publishes the contract. |
| `DENY_CAP_ID` | Deny capability object ID. This data is part of the response that Sui provides on publish. |
| `TREASURY_CAP_ID` | The treasury cap object ID that allows the bearer to mint new coins. This data is part of the response that Sui provides on publish. |
| `MODULE_NAME` | The name of the module you publish. |
| `COIN_NAME` | The name of your regulated coin.  |
| `SUI_FULLNODE_URL` | The URL to the full node network that processes transactions. For Testnet this value is `https://fullnode.testnet.sui.io:443`. |

## Smart contract

The example uses a single file to create the smart contract for the project (`regulated_coin.move`). The contract defines the regulated coin when you publish it to the network. The treasury capability (`TreasuryCap`) and deny capability (`DenyCapV2`) are transferred to the address that publishes the contract. The `TreasuryCap` permits the bearer to mint or burn coins (`REGULATED_COIN` in this example), and the `DenyCapV2` bearer can add and remove addresses from the list of unauthorized users. 

<details>

<summary>

`regulated_coin.move`

</summary>

<ImportContent source="examples/regulated-coin/move/sources/regulated_coin.move" mode="code" />

</details>

### Creating regulated coins

The Sui Currency Standard provides a `new_currency_with_otw` function to create currency using a One-Time Witness. To make the currency regulated, the module provides a `make_regulated` function that initializes the regulated currency and returns a `DenyCapV2`. The `DenyCapV2` bearer can add and remove addresses from a list that controls, or regulates, access to the coin. This ability is a requirement for assets like stablecoins.

The TypeScript and Rust clients handle the call to the `coin` package's `mint` function. The `coin` package also includes a `mint_and_transfer` function you could use to perform the same task, but the composability of minting the coin in 1 command and transferring with another is preferable. Using 2 explicit commands allows you to implement future logic between the minting of the coin and the transfer. The structure of programmable transaction blocks means you're still making and paying for a single transaction on the network.

<Tabs groupId="code-language">

<TabItem label="TypeScript" value="typescript">

<ImportContent source="examples/regulated-coin/ts-client/src/main.ts" mode="code" tag="mint" />

</TabItem>

<TabItem label="Rust" value="rust">

<ImportContent source="examples/regulated-coin/rust-client/src/tx_run/coin.rs" mode="code" tag="mint" />

</TabItem>

</Tabs>

For all `Coin` functions available, see the Sui framework [`coin` module documentation](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/coin.md). The following functions are the most common. 

<details>

<summary>

  `coin::mint<T>`

</summary>

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="mint" />

</details>
<details>

<summary>

  `coin::mint_balance<T>`

</summary>

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="mint_balance" />

</details>

<details>

<summary>

  `coin::mint_and_transfer<T>`

</summary>

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="mint_and_transfer" />

</details>

<details>

<summary>

  `coin::burn<T>`

</summary>

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="burn" />

</details>

### Manage deny list

For the ability to manage the addresses assigned to the deny list for your coin, the frontend code provides a few additional functions. These additions call the `deny_list_v2_add` and `deny_list_v2_remove` functions in the `coin` module.

If you add an address to the deny list, you might notice that you can still send tokens to that address. If so, that's because the address is still able to receive coins until the end of the epoch in which you called the function. If you try to send the regulated coin from the now blocked address, your attempt results in an error. After the next epoch starts, the address can no longer receive the coins, either. If you remove the address, it can receive coins immediately but must wait until the epoch after removal before the address can include the coins as transaction inputs.

To use these functions, you pass the address you want to either add or remove. The frontend function then calls the relevant move module in the framework, adding the `DenyList` object (`0x403`) and your `DenyCapV2` object ID. You receive the `DenyCapV2` ID at the time of publishing the smart contract. In this example, you add that value to the `.env` file that the frontend function reads from.

<Tabs groupId="code-language">

<TabItem label="TypeScript" value="typescript">

<ImportContent source="examples/regulated-coin/ts-client/src/main.ts" mode="code" tag="deny" />

</TabItem>

<TabItem label="Rust" value="rust">

<ImportContent source="examples/regulated-coin/rust-client/src/tx_run/deny.rs" mode="code" tag="deny" />

</TabItem>

</Tabs>

## Related links

<RelatedLink to="/standards/closed-loop-token.mdx" />
<RelatedLink href="https://github.com/MystenLabs/sui/tree/main/examples/regulated-coin" label="Source code" desc="The source code in GitHub for this example." />
<RelatedLink to="/guides/developer/coin/in-game-token.mdx" />
<RelatedLink to="/guides/developer/coin/loyalty.mdx" />
>>>> sui/docs/content/guides/developer/cryptography.mdx
---
title: Cryptography
description: Learn how to use cryptography effectively in Sui smart contracts. 
keywords: [ signature verification, groth16, hashing, elliptic curve verifiable random function, ecvrf, multisig, multi-sig, ed25519 ]
pagination_prev: null
---

Effective use of cryptography keeps your smart contract transactions secure on the Sui blockchain. 

<Cards>
<Card title="Signature Verification" href="/guides/developer/cryptography/signing">
</Card>
<Card title="Groth16" href="/guides/developer/cryptography/groth16">
</Card>
<Card title="Hashing" href="/guides/developer/cryptography/hashing">
</Card>
<Card title="Elliptic Curve Verifiable Random Function (ECVRF)" href="/guides/developer/cryptography/ecvrf">
</Card>
<Card title="Multisig" href="/guides/developer/cryptography/multisig">
</Card>
<Card title="zkLogin Integration Guide" href="/guides/developer/cryptography/zklogin-integration" />
</Cards>


>>>> sui/docs/content/guides/developer/cryptography/ecvrf.mdx
---
title: Elliptic Curve Verifiable Random Function
sidebar_label: ECVRF
description: Elliptic curve verifiable random function is a cryptographic algorithm that enables you to generate a random number and provide proof that the number used a secret key for generation.
keywords: [ elliptic curve, elliptic, verifiable, verifiable randomness, VRF, verifiable random function ]
---

A verifiable random function (VRF) is a cryptographic primitive that enables you to generate a random number and provide proof that the number used a secret key for generation. Anyone can verify the proof using the public key corresponding to the secret key, so you can use it as a random number generator (RNG) that generates outputs that anyone can verify. Applications that need verifiable randomness on chain can also benefit from its use.

## VRF construction

The VRF used in the Move API in Sui is an elliptic curve VRF (ECVRF) following the [CFRG VRF draft specifications version 15](https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/15/). It uses [Ristretto255](https://ristretto.group) elliptic curve group construction with the SHA-512 hash function. The nonce is generated according to [RFC6979](https://www.rfc-editor.org/info/rfc6979).

Any implementation following the same specifications with suite string `sui_vrf` (see section 5 in the [VRF specs](https://datatracker.ietf.org/doc/draft-irtf-cfrg-vrf/15/)) can be used to compute VRF output and generate proofs.

The [fastcrypto](https://github.com/MystenLabs/fastcrypto) library provides a CLI tool for such an implementation and is used in the following example.

### Generate keys

From the root of the `fastcrypto` repository, run the following command to generate a key pair:

```sh
$ cargo run --bin ecvrf-cli keygen
```
This outputs a secret key and a public key in hex format. Both the secret and public keys are 32-byte strings:

```sh
Secret key: c0cbc5bf0b2f992fe14fee0327463c7b03d14cbbcb38ce2584d95ee0c112b40b
Public key: 928744da5ffa614d65dd1d5659a8e9dd558e68f8565946ef3d54215d90cba015
```

### Compute VRF output and proof

To compute the VRF output and proof for the input string `Hello, World!`, which is `48656c6c6f2c20776f726c6421` in hexadecimal, with the key pair generated previously, run the following command:

```sh
$ cargo run --bin ecvrf-cli prove --input 48656c6c6f2c20776f726c6421 --secret-key c0cbc5bf0b2f992fe14fee0327463c7b03d14cbbcb38ce2584d95ee0c112b40b
```

This should the 80-byte proof and VRF 64-byte output, both in hex format:
```sh
Proof:  18ccf8bf316f00b387fc6e7b26f2d3ddadbf5e9c66d3a30986f12b208108551f9c6da87793a857d79261338a50430074b1dbc7f8f05e492149c51313381248b4229ebdda367146dbbbf95809c7fb330d
Output: 2b7e45821d80567761e8bb3fc519efe5ad80cdb4423227289f960319bbcf6eea1aef30c023617d73f589f98272b87563c6669f82b51dafbeb5b9cf3b17c73437
```

### Verify proof

You can verify the proof and output in a smart contract using `sui::ecvrf::ecvrf_verify` from the Sui Move framework:

```move
module math::ecvrf_test {
    use sui::ecvrf;
    use sui::event;

    /// Event on whether the output is verified
    struct VerifiedEvent has copy, drop {
        is_verified: bool,
    }

    public fun verify_ecvrf_output(output: vector<u8>, alpha_string: vector<u8>, public_key: vector<u8>, proof: vector<u8>) {
        event::emit(VerifiedEvent {is_verified: ecvrf::ecvrf_verify(&output, &alpha_string, &public_key, &proof)});
    }
}
```

You can also use the CLI tool for verification:

```sh
$ cargo run --bin ecvrf-cli verify --output 2b7e45821d80567761e8bb3fc519efe5ad80cdb4423227289f960319bbcf6eea1aef30c023617d73f589f98272b87563c6669f82b51dafbeb5b9cf3b17c73437 --proof 18ccf8bf316f00b387fc6e7b26f2d3ddadbf5e9c66d3a30986f12b208108551f9c6da87793a857d79261338a50430074b1dbc7f8f05e492149c51313381248b4229ebdda367146dbbbf95809c7fb330d --input 48656c6c6f2c20776f726c6421 --public-key 928744da5ffa614d65dd1d5659a8e9dd558e68f8565946ef3d54215d90cba015
```

The preceding command returns the verification:

```sh
Proof verified correctly!
```

>>>> sui/docs/content/guides/developer/cryptography/groth16.mdx
---
title: Groth16
description: Zero-knowledge proofs are used to validate statements without revealing information about the proof's inputs. 
keywords: [ groth16, zero knowledge, zero-knowledge, zero-knowledge proof, zkproof, zero-knowledge succinct non-interactive argument, circom, verification key ]
---

A zero-knowledge proof allows a prover to validate that a statement is true without revealing any information about the inputs. For example, a prover can validate that they know the solution to a sudoku puzzle without revealing the solution.

Zero-knowledge succinct non-interactive argument of knowledge (zk-SNARKs) are a family of zero-knowledge proofs that are non-interactive, have succinct proof size and efficient verification time. An important and widely used variant of them is pairing-based zk-SNARKs like the [Groth16](https://eprint.iacr.org/2016/260.pdf) proof system, which is one of the most efficient and widely used.

The Move API in Sui enables you to verify any statement that can be expressed in a NP-complete language efficiently using Groth16 zk-SNARKs over either the BN254 or BLS12-381 elliptic curve constructions.

There are high-level languages for expressing these statements, such as [Circom](https://docs.circom.io), used in the following example.

Groth16 requires a trusted setup for each circuit to generate the verification key. The API is not pinning any particular verification key and each user can generate their own parameters or use an existing verification to their apps.

## Usage

The following example demonstrates how to create a Groth16 proof from a statement written in Circom and then verify it using the Sui Move API. The API currently supports up to eight public inputs.

### Create circuit

In this example, we create a proof which demonstrates that we know a factorisation `a * b = c` of a publicly known number `c` without revealing `a` and `b`.

```circom
pragma circom 2.1.5;

template Main() {
    signal input a;
    signal input b;
    signal output c;

    c <== a * b;
}
component main = Main();
```
Assuming that the [circom compiler has been installed](https://docs.circom.io/getting-started/installation/), the above circuit is compiled using the following command:

```sh
$ circom main.circom --r1cs --wasm
```

This outputs the constraints in R1CS format and the circuit in Wasm format.

### Generate proof

To generate a proof verifiable in Sui, you need to generate a witness. This example uses Arkworks' [ark-circom](https://github.com/gakonst/ark-circom) Rust library. The code constructs a witness for the circuit and generates a proof for it for a given input. Finally, it verifies that the proof is correct.

```rust
use ark_bn254::Bn254;
use ark_circom::CircomBuilder;
use ark_circom::CircomConfig;
use ark_groth16::{Groth16, prepare_verifying_key};
use ark_serialize::CanonicalSerialize;
use ark_snark::SNARK;
use rand::rngs::StdRng;
use rand::SeedableRng;

fn main() {
    // Load the WASM and R1CS for witness and proof generation
    let cfg = CircomConfig::<Bn254>::new("../circuit/main_js/main.wasm", "../circuit/main.r1cs").unwrap();
    let mut builder = CircomBuilder::new(cfg);

    // Private inputs: A factorisation of a number
    builder.push_input("a", 641);
    builder.push_input("b", 6_700_417);

    let circuit = builder.setup();

    // Generate a random proving key. WARNING: This is not secure. A proving key generated from a ceremony should be used in production.
    let mut rng: StdRng = SeedableRng::from_seed([0; 32]);
    let pk =
        Groth16::<Bn254>::generate_random_parameters_with_reduction(circuit, &mut rng).unwrap();

    let circuit = builder.build().unwrap();
    let public_inputs = circuit.get_public_inputs().unwrap();

    // Create proof
    let proof = Groth16::<Bn254>::prove(&pk, circuit, &mut rng).unwrap();

    // Verify proof
    let pvk = prepare_verifying_key(&pk.vk);
    let verified = Groth16::<Bn254>::verify_with_processed_vk(&pvk, &public_inputs, &proof).unwrap();
    assert!(verified);

    // Print verifying key
    let mut pk_bytes = Vec::new();
    pk.vk.serialize_compressed(&mut pk_bytes).unwrap();
    println!("Verifying key: {}", hex::encode(pk_bytes));

    // Print proof
    let mut proof_serialized = Vec::new();
    proof.serialize_compressed(&mut proof_serialized).unwrap();
    println!("Proof: {}", hex::encode(proof_serialized));

    // Print public inputs. Note that they are concatenated.
    let mut public_inputs_serialized = Vec::new();
    public_inputs.iter().for_each(|input| {
        input.serialize_compressed(&mut public_inputs_serialized).unwrap();
    });
    println!("Public inputs: {}", hex::encode(public_inputs_serialized));
}
```
Recall that this creates a proof that the prover knows a factorisation, in this case of the [5th Fermat number](https://en.wikipedia.org/wiki/Fermat_number#Factorization) (<i>2<sup>32</sup> + 1 = 4294967297 = 641 * 6700417</i>).

The output of the above function will be
```
Verifying key: 94d781ec65145ed90beca1859d5f38ec4d1e30d4123424bb7b0c6fc618257b1551af0374b50e5da874ed3abbc80822e4378fdef9e72c423a66095361dacad8243d1a043fc217ea306d7c3dcab877be5f03502c824833fc4301ef8b712711c49ebd491d7424efffd121baf85244404bded1fe26bdf6ef5962a3361cef3ed1661d897d6654c60dca3d648ce82fa91dc737f35aa798fb52118bb20fd9ee1f84a7aabef505258940dc3bc9de41472e20634f311e5b6f7a17d82f2f2fcec06553f71e5cd295f9155e0f93cb7ed6f212d0ccddb01ebe7dd924c97a3f1fc9d03a9eb915020000000000000072548cb052d61ed254de62618c797853ad3b8a96c60141c2bfc12236638f1b0faf9ecf024817d8964c4b2fed6537bcd70600a85cdec0ca4b0435788dbffd81ab
Proof: 212d4457550f258654a24a6871522797ab262dee4d7d1f89af7da90dc0904eac57ce183e6f7caca9a98755904c1398ff6288cec9877f98f2d3c776c448b9ad166839e09d77967b66129c4942eee6d3eaf4a0ce2a841acc873a46ae35e40f0088288d038857c70a1415300544d7cf376949a372049679afa35ee5206b58266184
Public inputs: 0100000001000000000000000000000000000000000000000000000000000000
```
All these outputs are needed to verify the proof.

### Verification in Sui

The API in Sui for verifying a proof expects a special processed verification key, where only a subset of the values are used. Ideally, computation for this prepared verification key happens only once per circuit. You can perform this processing using the `sui::groth16::prepare_verifying_key` method of the Sui Move API with a serialization of the `params.vk` value used previously.

The output of the `prepare_verifying_key` function is a vector with four byte arrays, which corresponds to the `vk_gamma_abc_g1_bytes`, `alpha_g1_beta_g2_bytes`, `gamma_g2_neg_pc_bytes`, `delta_g2_neg_pc_bytes`.

To verify a proof, you also need two more inputs, `public_inputs_bytes` and `proof_points_bytes`, which are printed by the program above.

The following example smart contract uses the output from the program above. It first prepares a verification key and verifies the corresponding proof. This example uses the BN254 elliptic curve construction, which is given as the first parameter to the `prepare_verifying_key` and `verify_groth16_proof` functions. You can use the `bls12381` function instead for BLS12-381 construction.

```rust
use sui::groth16;

public fun groth16_bn254_test() {
    let pvk = groth16::prepare_verifying_key(&groth16::bn254(), &x"94d781ec65145ed90beca1859d5f38ec4d1e30d4123424bb7b0c6fc618257b1551af0374b50e5da874ed3abbc80822e4378fdef9e72c423a66095361dacad8243d1a043fc217ea306d7c3dcab877be5f03502c824833fc4301ef8b712711c49ebd491d7424efffd121baf85244404bded1fe26bdf6ef5962a3361cef3ed1661d897d6654c60dca3d648ce82fa91dc737f35aa798fb52118bb20fd9ee1f84a7aabef505258940dc3bc9de41472e20634f311e5b6f7a17d82f2f2fcec06553f71e5cd295f9155e0f93cb7ed6f212d0ccddb01ebe7dd924c97a3f1fc9d03a9eb915020000000000000072548cb052d61ed254de62618c797853ad3b8a96c60141c2bfc12236638f1b0faf9ecf024817d8964c4b2fed6537bcd70600a85cdec0ca4b0435788dbffd81ab");
    let proof_points = groth16::proof_points_from_bytes(x"212d4457550f258654a24a6871522797ab262dee4d7d1f89af7da90dc0904eac57ce183e6f7caca9a98755904c1398ff6288cec9877f98f2d3c776c448b9ad166839e09d77967b66129c4942eee6d3eaf4a0ce2a841acc873a46ae35e40f0088288d038857c70a1415300544d7cf376949a372049679afa35ee5206b58266184");
    let public_inputs = groth16::public_proof_inputs_from_bytes(x"0100000001000000000000000000000000000000000000000000000000000000");
    assert!(groth16::verify_groth16_proof(&groth16::bn254(), &pvk, &public_inputs, &proof_points));
}
```

>>>> sui/docs/content/guides/developer/cryptography/hashing.mdx
---
title: Hashing
description: Sui supports SHA2-256, SHA3-256, Keccak256, and Blake2b-256 cryptographic hash functions.
keywords: [ SHA2-256, SHA3-256, Keccak256, Blake2b-256, hash functions, hashing, cryptographic hashing, hashing functions, cryptographic hash ]
---

A cryptographic hash function is a widely used cryptographic primitive that maps an arbitrary length input to a fixed length output, the hash value. The hash function is designed to be a one-way function, which means that it is infeasible to invert the function to find the input data from a given hash value, and to be collision resistant, which means that it is infeasible to find two different inputs that map to the same hash value.

The Sui Move API supports the following cryptographic hash functions:

* SHA2-256 as `std::hash::sha2_256`
* SHA3-256 as `std::hash::sha3_256`
* Keccak256 as `sui::hash::keccak256`
* Blake2b-256 as `sui::hash::blake2b256`

## Usage

The SHA2-256 and SHA3-256 hash functions are available in the Move Standard Library in the `std::hash` module. The following example shows how to use the SHA2-256 hash function in a smart contract:

```move
module test::hashing_std {
    use std::hash;
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;
    use sui::transfer;
    use std::vector;

    /// Object that holds the output hash value.
    struct Output has key, store {
        id: UID,
        value: vector<u8>
    }

    public fun hash_data(data: vector<u8>, recipient: address, ctx: &mut TxContext) {
        let hashed = Output {
            id: object::new(ctx),
            value: hash::sha2_256(data),
        };
        // Transfer an output data object holding the hashed data to the recipient.
        transfer::public_transfer(hashed, recipient)
    }
}
```

The Keccak256 and Blake2b-256 hash functions are available through the `sui::hash` module in the Sui Move Library. An example of how to use the Keccak256 hash function in a smart contract is shown below. Notice that here, the input to the hash function is given as a reference. This is the case for both Keccak256 and Blake2b-256.

```move
module test::hashing_sui {
    use sui::hash;
    use sui::object::{Self, UID};
    use sui::tx_context::TxContext;
    use sui::transfer;
    use std::vector;

    /// Object that holds the output hash value.
    struct Output has key, store {
        id: UID,
        value: vector<u8>
    }

    public fun hash_data(data: vector<u8>, recipient: address, ctx: &mut TxContext) {
        let hashed = Output {
            id: object::new(ctx),
            value: hash::keccak256(&data),
        };
        // Transfer an output data object holding the hashed data to the recipient.
        transfer::public_transfer(hashed, recipient)
    }
}
```

>>>> sui/docs/content/guides/developer/cryptography/multisig.mdx
---
title: Multisig Authentication
description: Guide on how to create a multisig transaction and then submit it against a local network using the Sui CLI.
keywords: [ multisig, multi-sig, multisig auth, multi-sig auth, multi signatures, multiple signatures, multisig transaction, multi-sig transaction ]
---

The following steps demonstrate how to create a multisig transaction and then submit it against a network using the [Sui CLI](/references/cli.mdx). A transaction can be the transfer of an object, the publish or upgrade of a package, the payment of SUI, and so on.

To learn more about how to create multisig addresses and create multisig transactions using the TypeScript SDK, see the [SDK documentation](https://sdk.mystenlabs.com/typescript/cryptography/multisig) for details.

<ImportContent source="prerequisites.mdx" mode="snippet" />

This topic assumes you are somewhat familiar with the Sui CLI, specifically the `sui client` and `sui keytool` commands. Consequently, a command might be introduced without any context. If you are unsure about the details of a referenced command, see the Sui CLI documentation for more information.

You need an existing address on the network you are working on to receive an object. The topic assumes that this address is the current active address (`sui client active-address`), but any address you have access to is fine.

The topic also assumes that your active environment is Testnet (`sui client active-env`). You can perform these steps on Devnet or a local network as well, but you must adjust the commands appropriately.

## Executing multisig transactions

To demonstrate multisig, this topic guides you through setting up and executing a multisig transaction using the Sui CLI.

### Create addresses with different schemes

To begin, create three addresses that will act as the signers for the transaction you perform later in the instruction. Use the `sui client new-address` command to generate a Sui address and public key for three supported key schemes.

```sh
$ sui client new-address ed25519
```
```sh
$ sui client new-address secp256k1
```
```sh
$ sui client new-address secp256r1
```

The console displays a response to each successful call that is similar to the following:

```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Created new key pair and saved it to keystore.    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ alias          â”‚ <ALIAS>                         â”‚
â”‚ address        â”‚ <SUI-ADDRESS>                   â”‚
â”‚ keyScheme      â”‚ <KEY-SCHEME>                    â”‚
â”‚ recoveryPhrase â”‚ <RECOVERY-PHRASE>               â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

When working with blockchain data, addresses and hashed values create large strings that can be cumbersome to work with in a CLI environment. To make referencing values easier in subsequent commands (and facilitate copy and paste), this topic uses shell variables. Use the values you receive from the console responses to set shell variables for these addresses, replacing the `<SUI-ADDRESS-*>` variables with the appropriate address. 

```sh
$ ADDRESS1=<SUI-ADDRESS-ED25519>
```
```sh
$ ADDRESS2=<SUI-ADDRESS-SECP256K1>
```
```sh
$ ADDRESS3=<SUI-ADDRESS-SECP256R1>
```

Create one more shell variable assigned to your active address.

```sh
$ ACTIVE=<ACTIVE-ADDRESS>
```

:::tip

You can set the shell variables to the alias values instead of addresses if you want.

:::

### Verify addresses

Use `sui keytool` to list the addresses you created in the previous section.

```sh
$ sui keytool list
```

The response resembles the following, but displays actual alias names, addresses, keys, and peer IDs:

```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
| | alias           |  <ALIAS-NAME>                                | |
â”‚ â”‚ suiAddress      â”‚  <SUI-ADDRESS>                               â”‚ â”‚
â”‚ â”‚ publicBase64Key â”‚  <PUBLIC-KEY>                                â”‚ â”‚
â”‚ â”‚ keyScheme       â”‚  ed25519                                     â”‚ â”‚
â”‚ â”‚ flag            â”‚  0                                           â”‚ â”‚
â”‚ â”‚ peerId          â”‚  <PEER-ID>                                   â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
| | alias           |  <ALIAS-NAME>                                | |
â”‚ â”‚ suiAddress      â”‚  <SUI-ADDRESS>                               â”‚ â”‚
â”‚ â”‚ publicBase64Key â”‚  <PUBLIC-KEY>                                â”‚ â”‚
â”‚ â”‚ keyScheme       â”‚  secp256k1                                   â”‚ â”‚
â”‚ â”‚ flag            â”‚  0                                           â”‚ â”‚
â”‚ â”‚ peerId          â”‚  <PEER-ID>                                   â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
| | alias           |  <ALIAS-NAME>                                | |
â”‚ â”‚ suiAddress      â”‚  <SUI-ADDRESS>                               â”‚ â”‚
â”‚ â”‚ publicBase64Key â”‚  <PUBLIC-KEY>                                â”‚ â”‚
â”‚ â”‚ keyScheme       â”‚  secp256r1                                   â”‚ â”‚
â”‚ â”‚ flag            â”‚  0                                           â”‚ â”‚
â”‚ â”‚ peerId          â”‚  <PEER-ID>                                   â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

The output includes public key data that you use later, so create shell variables to store the information. Don't forget to replace `<PUBLIC-KEY-*>` with the actual values you receive from the previous console response.

```sh
$ PKEY_1=<PUBLIC-KEY-ED25519>
```
```sh
$ PKEY_2=<PUBLIC-KEY-SECP256K1>
```
```sh
$ PKEY_3=<PUBLIC-KEY-SECP256R1>
```

### Create a multisig address

To sign a transaction using multisig, you need to create a multisig address using `sui keytool multi-sig-address`. The multisig address is created using the public keys from each individual participating address. Each address is also assigned a `weight` value that determines how many are needed to create a valid signature. When summed, the `weight` of the included signatures must be greater than or equal to the `threshold` value you also set with the command. For this example, use the following command, which states that the first two addresses require at least one more signature to create a valid multisig. The last address has a weight of `3`, which is equal to the `threshold` value, so its owner can create a valid signature without the others.

```sh
$ sui keytool multi-sig-address --pks $PKEY_1 $PKEY_2 $PKEY_3 --weights 1 2 3 --threshold 3
```

The response resembles the following:

```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ multisigAddress â”‚  <MULTISIG-ADDRESS>                                     â”‚
â”‚ multisig        â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚                 â”‚ â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ â”‚
â”‚                 â”‚ â”‚ â”‚ address         â”‚  <SUI-ADDRESS>                â”‚ â”‚ â”‚
â”‚                 â”‚ â”‚ â”‚ publicBase64Key â”‚  <PUBLIC-KEY>                 â”‚ â”‚ â”‚
â”‚                 â”‚ â”‚ â”‚ weight          â”‚  1                            â”‚ â”‚ â”‚
â”‚                 â”‚ â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚ â”‚
â”‚                 â”‚ â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ â”‚
â”‚                 â”‚ â”‚ â”‚ address         â”‚  <SUI-ADDRESS>                â”‚ â”‚ â”‚
â”‚                 â”‚ â”‚ â”‚ publicBase64Key â”‚  <PUBLIC-KEY>                 â”‚ â”‚ â”‚
â”‚                 â”‚ â”‚ â”‚ weight          â”‚  2                            â”‚ â”‚ â”‚
â”‚                 â”‚ â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚ â”‚
â”‚                 â”‚ â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ â”‚
â”‚                 â”‚ â”‚ â”‚ address         â”‚  <SUI-ADDRESS>                â”‚ â”‚ â”‚
â”‚                 â”‚ â”‚ â”‚ publicBase64Key â”‚  <PUBLIC-KEY>                 â”‚ â”‚ â”‚
â”‚                 â”‚ â”‚ â”‚ weight          â”‚  3                            â”‚ â”‚ â”‚
â”‚                 â”‚ â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚ â”‚
â”‚                 â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Add SUI to the multisig address

Before getting SUI, set a `MULTISIG` shell variable to the multisig address provided at the top of the previous response (substituting the actual address for `<MULTISIG-ADDRESS>`).

```sh
$ MULTISIG=<MULTISIG-ADDRESS>
```

If you use the `sui client objects $MULTISIG` command, you can see that the newly created multisig address has no objects. This means you need to get SUI before you can perform any transactions. To get SUI for your multisig account, use the `sui client faucet` command and provide the multisig address using the `--address` flag. Run this command twice so that the multisig address owns at least two SUI. This example uses two SUI so that one can be transferred and the other can pay for gas.

```sh
$ sui client faucet --address $MULTISIG
```

Use the `sui client gas` command to verify the address now has at least two SUI.

```sh
$ sui client gas $MULTISIG
```

### Transfer SUI to your active address

It's now time to transfer an object from the multisig address. For simplicity, this example uses one of the coins your multisig address owns as the transfer object. Copy the object ID for one of the address' coins and use it to set a shell variable value.

```sh
$ COIN=<COIN-OBJECT-ID>
```

Use the `sui client transfer` command to set up the transfer. The `--serialize-unsigned-transaction` flag outputs the Base64-encoded transaction bytes.

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client transfer --to $ACTIVE --object-id $COIN --gas-budget <GAS-AMOUNT> --serialize-unsigned-transaction
```

The console displays the result (`<TX-BYTES-RESULT>`), which you can assign to another shell variable.

```sh
$ TXBYTES=<TX-BYTES-RESULT>
```

### Sign the transaction with two public keys

Use the `sui keytool sign` command to sign the transaction using two of the addresses you created previously. 

:::info

You can create the signature with other tools, as well, as long as you serialize it to `flag || sig || pk`.

:::

```sh
$ sui keytool sign --address $ADDRESS1 --data $TXBYTES
```
```sh
$ sui keytool sign --address $ADDRESS2 --data $TXBYTES
```

Each successful call to the command receives a response similar to the following.

```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ suiAddress   â”‚ <ADDRESS>                   â”‚
â”‚ rawTxData    â”‚ <TRANSACTION-HASH>          â”‚
â”‚ intent       â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â•®           â”‚
â”‚              â”‚ â”‚ scope   â”‚  0  â”‚           |
â”‚              â”‚ â”‚ version â”‚  0  â”‚           |
â”‚              â”‚ â”‚ app_id  â”‚  0  â”‚           |
|              | â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â•¯           â”‚
â”‚ rawIntentMsg â”‚ <INTENT-MSG-HASH>           â”‚
â”‚ digest       â”‚ <DIGEST-HASH>               â”‚
â”‚ suiSignature â”‚ <SIGNATURE-HASH>            â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

Create two more shell variables to store the signatures, replacing `<SIGNATURE-HASH-*>` with the values from the previous command responses.

```sh
$ SIG_1=<SIGNATURE-HASH-ED25519>
```
```sh
$ SIG_2=<SIGNATURE-HASH-SECP256K1>
```

### Combine individual signatures into a multisig

As mentioned, the multisig must be composed of enough individual signatures such that the sum of the participating signer weights is greater than the `threshold` value. Use the `sui keytool multi-sig-combine-partial-sig` command to combine the ed25519 signature (`weight: 1`) and the secp256k1 (`weight: 2`). To complete the command, you must provide all public keys, their weights, and the threshold that defined the multisig address.

```sh
$ sui keytool multi-sig-combine-partial-sig --pks $PKEY_1 $PKEY_2 $PKEY_3 --weights 1 2 3 --threshold 3 --sigs $SIG_1 $SIG_2
```

If successful, the console responds with a message similar to the following.

```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ multisigAddress    â”‚  <MULTISIG-ADDRESS>          â”‚
â”‚ multisigParsed     â”‚  <MULTISIG-PARSED-HASH>      â”‚
â”‚ multisigSerialized â”‚  <MULTISIG-SERIALIZED-HASH>  â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Execute the transaction

Use `sui client execute-signed-tx` to execute the multisig transaction. Set a shell variable equal to the `multisigSerialized` value you receive from the previous response, then use it to build the `execute-signed-tx` command.

```sh
$ MULTISIG_SERIALIZED=<MULTISIG-SERIALIZED-HASH>
```

```sh
$ sui client execute-signed-tx --tx-bytes $TXBYTES --signatures $MULTISIG_SERIALIZED
```

If successful, the console responds with transaction details. 

<details>
<summary>
Transaction response
</summary>
This response contains the actual values from a test signing. Your response should be formatted the same but the values you receive are going to be different.

```sh
Transaction Digest: 7mBWUxT6HUVDa8bii3PZJc7nhWqefTLNTsGbHYnx7ZA4
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Data                                                                                                                                                                                                                                                                                                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sender: 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35                                                                                                                                                                                                                                                              â”‚
â”‚ Gas Owner: 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35                                                                                                                                                                                                                                                           â”‚
â”‚ Gas Budget: 2997880 MIST                                                                                                                                                                                                                                                                                                                â”‚
â”‚ Gas Price: 1000 MIST                                                                                                                                                                                                                                                                                                                    â”‚
â”‚ Gas Payment:                                                                                                                                                                                                                                                                                                                            â”‚
â”‚  â”Œâ”€â”€                                                                                                                                                                                                                                                                                                                                    â”‚
â”‚  â”‚ ID: 0xc62a5e163e599729509d6cebde097cac04e5d1b3bbc9a169144e8dfa602a0768                                                                                                                                                                                                                                                               â”‚
â”‚  â”‚ Version: 289574879                                                                                                                                                                                                                                                                                                                   â”‚
â”‚  â”‚ Digest: 2PMc8L67YbZmna4hoaryX9cZZFSgFNPEYPEeCqcDPCcX                                                                                                                                                                                                                                                                                 â”‚
â”‚  â””â”€â”€                                                                                                                                                                                                                                                                                                                                    â”‚
â”‚                                                                                                                                                                                                                                                                                                                                         â”‚
â”‚ Transaction Kind: Programmable                                                                                                                                                                                                                                                                                                          â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                                                                                                                                                                                                            â”‚
â”‚ â”‚ Input Objects                                                                                            â”‚                                                                                                                                                                                                                            â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                                                                                                                                                                                                            â”‚
â”‚ â”‚ 0   Pure Arg: Type: address, Value: "0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241" â”‚                                                                                                                                                                                                                            â”‚
â”‚ â”‚ 1   Imm/Owned Object ID: 0xe7acb59c190d7fcfcb622916e929c92007f6da15128fd84c8a2afd94a39edf11              â”‚                                                                                                                                                                                                                            â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                                                                                                                                                                                                            â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                                                                                                                                                                                                                                                                                                â”‚
â”‚ â”‚ Commands             â”‚                                                                                                                                                                                                                                                                                                                â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                                                                                                                                                                                                                                                                                                â”‚
â”‚ â”‚ 0  TransferObjects:  â”‚                                                                                                                                                                                                                                                                                                                â”‚
â”‚ â”‚  â”Œ                   â”‚                                                                                                                                                                                                                                                                                                                â”‚
â”‚ â”‚  â”‚ Arguments:        â”‚                                                                                                                                                                                                                                                                                                                â”‚
â”‚ â”‚  â”‚   Input  1        â”‚                                                                                                                                                                                                                                                                                                                â”‚
â”‚ â”‚  â”‚ Address: Input  0 â”‚                                                                                                                                                                                                                                                                                                                â”‚
â”‚ â”‚  â””                   â”‚                                                                                                                                                                                                                                                                                                                â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                                                                                                                                                                                                                                                                                                â”‚
â”‚                                                                                                                                                                                                                                                                                                                                         â”‚
â”‚ Signatures:                                                                                                                                                                                                                                                                                                                             â”‚
â”‚    AwICIrr3sYG1hx2DaVkS3levGuTv68GA1RL+6ZFbtnFV5PBPkEHuysjme9nG0hZ3hQ0eDds2CedbKkLqDyCUXMNQDwEUtr9SYWRGiJJih21cAXgpSxf5Y53HFcmzJPWfxac54l21YVx6hc7vhI1xunMzhVeQlCa53vVJiAtWKLKz+H7FBgADAPZrm85y/Gn83R6kUhXme9J8W2ilJyda6cAObtuyJ3CqAQICAwSWHr3Q2vGVFH4SQckaQs76X89S6hX3NUarydSY3jgCAQNqj1MFWmTysOPFDXdNfD2kJlQhWTiT3AbxdlJDDWozIgMDAA== â”‚
â”‚                                                                                                                                                                                                                                                                                                                                         â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: 7mBWUxT6HUVDa8bii3PZJc7nhWqefTLNTsGbHYnx7ZA4                                              â”‚
â”‚ Status: Success                                                                                   â”‚
â”‚ Executed Epoch: 600                                                                               â”‚
â”‚ Mutated Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xc62a5e163e599729509d6cebde097cac04e5d1b3bbc9a169144e8dfa602a0768                         â”‚
â”‚  â”‚ Owner: Account Address ( 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35 )  â”‚
â”‚  â”‚ Version: 289574880                                                                             â”‚
â”‚  â”‚ Digest: DWmLziJZEHwhkAfdBWVhn8HnJU7DMepDmjVLps2peSx8                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xe7acb59c190d7fcfcb622916e929c92007f6da15128fd84c8a2afd94a39edf11                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  â”‚
â”‚  â”‚ Version: 289574880                                                                             â”‚
â”‚  â”‚ Digest: JBA6PrhWuTUJ3P8NXBpgBetFBaSJacEvQKS4USK9EfAr                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Object:                                                                                       â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xc62a5e163e599729509d6cebde097cac04e5d1b3bbc9a169144e8dfa602a0768                         â”‚
â”‚  â”‚ Owner: Account Address ( 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35 )  â”‚
â”‚  â”‚ Version: 289574880                                                                             â”‚
â”‚  â”‚ Digest: DWmLziJZEHwhkAfdBWVhn8HnJU7DMepDmjVLps2peSx8                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Cost Summary:                                                                                 â”‚
â”‚    Storage Cost: 1976000 MIST                                                                     â”‚
â”‚    Computation Cost: 1000000 MIST                                                                 â”‚
â”‚    Storage Rebate: 1956240 MIST                                                                   â”‚
â”‚    Non-refundable Storage Fee: 19760 MIST                                                         â”‚
â”‚                                                                                                   â”‚
â”‚ Transaction Dependencies:                                                                         â”‚
â”‚    F6TBXbvdK9fi4BnxZMBkL7QeNyv1612778i12ZPhafJD                                                   â”‚
â”‚    HFi4TniDvgL1jDzgPHjzJhxR8nbavLmPH3LLDnNL5Tqd                                                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ No transaction block events â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Mutated Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0xc62a5e163e599729509d6cebde097cac04e5d1b3bbc9a169144e8dfa602a0768                  â”‚
â”‚  â”‚ Sender: 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35                    â”‚
â”‚  â”‚ Owner: Account Address ( 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35 ) â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    â”‚
â”‚  â”‚ Version: 289574880                                                                            â”‚
â”‚  â”‚ Digest: DWmLziJZEHwhkAfdBWVhn8HnJU7DMepDmjVLps2peSx8                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0xe7acb59c190d7fcfcb622916e929c92007f6da15128fd84c8a2afd94a39edf11                  â”‚
â”‚  â”‚ Sender: 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 ) â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    â”‚
â”‚  â”‚ Version: 289574880                                                                            â”‚
â”‚  â”‚ Digest: JBA6PrhWuTUJ3P8NXBpgBetFBaSJacEvQKS4USK9EfAr                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Balance Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ Owner: Account Address ( 0x65437300e280695a40df8cf524c7bca6ad62574cac3a52d3b085ad628c797241 )  â”‚
â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
â”‚  â”‚ Amount: 1000000000                                                                             â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ Owner: Account Address ( 0xfc9a64c928a09725cfe01478ad50c2418320b4c079d944ed430eff0f30666a35 )  â”‚
â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
â”‚  â”‚ Amount: -1001019760                                                                            â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```
</details>

## Related links

<RelatedLink to="/concepts/cryptography/transaction-auth/multisig.mdx" />
<RelatedLink href="https://sdk.mystenlabs.com/typescript/cryptography/multisig" label="Multisig TypeScript SDK" desc=" How to create multisig addresses and sign transactions using the Sui SDK." />
<RelatedLink href="https://sdk.mystenlabs.com/typescript/cryptography/multisig" label="SDK documentation" desc="See the Sui TypeScript SDK documentation to learn how to use the library with multisig transactions." />
<RelatedLink to="/references/cli.mdx" />
>>>> sui/docs/content/guides/developer/cryptography/signing.mdx
---
title: Sui On-Chain Signatures Verification in Move
description: Sui supports verification within Move smart contracts through several signature schemes. Signature schemes include Ed25519, Secp256k1 recoverable, Secp256k1 non-recoverable, Secp256r1 non-recoverable, Secp256r1 recoverable, BLS G1, and BLS G2.
keywords: [ Ed25519, Secp256k1 recoverable, Secp256k1 non-recoverable, Secp256r1 non-recoverable, Secp256r1 recoverable, BLS G1, BLS G2, signature schemes, signature verification fastcrypto, on-chain verification ]
---

Move contracts in Sui support verifications for several signature schemes on-chain. Not all signatures supported in on-chain verification are supported as user signature verification. See [Sui Signatures](/concepts/cryptography/transaction-auth/signatures.mdx#user-signature) for valid signature schemes for transaction authorization.

This topic covers:
1. How to use [fastcrypto](https://github.com/MystenLabs/fastcrypto)'s CLI tool to create a signature of a given scheme. For testing and debugging only, DO NOT use in production.
1. Call the Move method on-chain to verification by submitting the signature, the message and the public key. 

Signature schemes covered: 
- Ed25519 signature (64 bytes)
- Secp256k1 non-recoverable signature (64 bytes)
- Secp256k1 recoverable signature (65 bytes)
- Secp256r1 non-recoverable signature (64 bytes)
- Secp256r1 recoverable signature (65 bytes)
- BLS G1 signature (minSig setting)
- BLS G2 signature (minPk setting)

## Usage

### Set up fastcrypto CLI binary

```sh
git@github.com:MystenLabs/fastcrypto.git
cd fastcrypto/
cargo build --bin sigs-cli
```

### Sign with CLI and submit to on-chain Move method

#### Ed25519 signature (64 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme ed25519 --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme ed25519 --msg $MSG --secret-key  $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move. All inputs are represented in bytes in hex format:

```move
    use sui::ed25519;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    let verify = ed25519::ed25519_verify(&sig, &pk, &msg);
    assert!(verify == true, 0);
```

#### Secp256k1 non-recoverable signature (64 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme secp256k1 --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme secp256k1 --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move.

```move
    use sui::ecdsa_k1;
    
    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    // The last param 1 represents the hash function used is SHA256, the default hash function used when signing in CLI.
    let verify = ecdsa_k1::secp256k1_verify(&sig, &pk, &msg, 1);
    assert!(verify == true, 0);
```

#### Secp256k1 recoverable signature (65 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme secp256k1-rec --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme secp256k1-rec --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the ecrecover method in Move and check equality.
```move
    use sui::ecdsa_k1;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    // The last param 1 represents the hash function used is SHA256, the default hash function used when signing in CLI.
    let recovered = ecdsa_k1::secp256k1_ecrecover(&sig, &msg, 1);
    assert!(pk == recovered, 0);
```

#### Secp256r1 non-recoverable signature (64 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme secp256r1 --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme secp256r1 --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move.

```move
    use sui::ecdsa_r1;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    // The last param 1 represents the hash function used is SHA256, the default hash function used when signing in CLI.
    let verify = ecdsa_r1::secp256r1_verify(&sig, &pk, &msg, 1);
    assert!(verify == true, 0);
```

#### Secp256r1 recoverable signature (65 bytes)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme secp256r1-rec --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme secp256r1-rec --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the ecrecover method in Move and check equality.

```move
    use sui::ecdsa_r1;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    // The last param 1 represents the hash function used is SHA256, the default hash function used when signing in CLI.
    let recovered = ecdsa_r1::secp256r1_ecrecover(&sig, &msg, 1);
    assert!(pk == recovered, 0);
```

#### BLS G1 signature (48 bytes, minSig setting)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme bls12381-minsig --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme bls12381-minsig --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move.

```move
    use sui::bls12381;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    let verified = bls12381::bls12381_min_sig_verify(&sig, &pk, &msg);
    assert!(verified == true, 0);
```

#### BLS G1 signature (96 bytes, minPk setting)

1. Generate a key and sign a message. 

```sh
target/debug/sigs-cli keygen --scheme bls12381-minpk --seed 0000000000000000000000000000000000000000000000000000000000000000                
Private key in hex: $SK
Public key in hex: $PK

target/debug/sigs-cli sign --scheme bls12381-minpk --msg $MSG --secret-key $SK

Signature in hex: $SIG
Public key in hex: $PK
```

2. Call the verify method in Move.

```move
    use sui::bls12381;

    let msg = x"$MSG";
    let pk = x"$PK";
    let sig = x"$SIG";
    let verified = bls12381::bls12381_min_pk_verify(&sig, &pk, &msg);
    assert!(verified == true, 0);
```

>>>> sui/docs/content/guides/developer/cryptography/zklogin-integration.mdx
---
title: zkLogin Integration Guide
description: zkLogin can be integrated into applications deployed on Sui.
keywords: [ zklogin, how to use zklogin, generate ephemeral key pair, fetch JWT, decode JWT, generate salt, generate user Sui address, fetch ZK proof, assemble zkLogin signature, oauth, openid ]
---

Here is the high-level flow the wallet or frontend application must implement to support zkLogin-enabled transactions:

1. The wallet creates an ephemeral key pair.
1. The wallet prompts the user to complete an OAuth login flow with the nonce corresponding to the ephemeral public key.
1. After receiving the JSON Web Token (JWT), the wallet obtains a zero-knowledge proof.
1. The wallet obtains a unique user salt based on a JWT. Use the OAuth subject identifier and salt to compute the zkLogin Sui address.
1. The wallet signs transactions with the ephemeral private key.
1. The wallet submits the transaction with the ephemeral signature and the zero-knowledge proof.

Let's dive into the specific implementation details.

## Install the zkLogin TypeScript SDK

To use the zkLogin TypeScript SDK in your project, run the following command in your project root:

```sh npm2yarn
$ npm install @mysten/sui
```

If you want to use the latest experimental version:

```sh npm2yarn
$ npm install @mysten/sui@experimental
```

## Get JWT

1. Generate an ephemeral key pair. Follow the same process as you would generating a key pair in a traditional wallet. See [Sui SDK](https://sdk.mystenlabs.com/typescript/cryptography/keypairs) for details.

1. Set the expiration time for the ephemeral key pair. The wallet decides whether the maximum epoch is the current epoch or later. The wallet also determines whether this is adjustable by the user.

1. Assemble the OAuth URL with configured client ID, redirect URL, ephemeral public key and nonce: This is what the application sends the user to complete the login flow with a computed [nonce](#notations).

```typescript
import { generateNonce, generateRandomness } from '@mysten/sui/zklogin';

const FULLNODE_URL = 'https://fullnode.devnet.sui.io'; // replace with the RPC URL you want to use
const suiClient = new SuiClient({ url: FULLNODE_URL });
const { epoch, epochDurationMs, epochStartTimestampMs } = await suiClient.getLatestSuiSystemState();

const maxEpoch = Number(epoch) + 2; // this means the ephemeral key will be active for 2 epochs from now.
const ephemeralKeyPair = new Ed25519Keypair();
const randomness = generateRandomness();
const nonce = generateNonce(ephemeralKeyPair.getPublicKey(), maxEpoch, randomness);
```

The auth flow URL can be constructed with `$CLIENT_ID`, `$REDIRECT_URL` and `$NONCE`.

For some providers ("Yes" for "Auth Flow Only"), the JWT can be found immediately in the redirect URL after the auth flow.

For other providers ("No" for "Auth Flow Only"), the auth flow only returns a code (`$AUTH_CODE`) in redirect URL. To retrieve the JWT, an additional POST call is required with "Token Exchange URL".

| Provider  | Auth Flow URL                                                                                                                                                                       | Token Exchange URL                                                                                                                  | Auth Flow Only |
| --------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | -------------- |
| Google    | `https://accounts.google.com/o/oauth2/v2/auth?client_id=$CLIENT_ID&response_type=id_token&redirect_uri=$REDIRECT_URL&scope=openid&nonce=$NONCE`                                     | N/A                                                                                                                                 | Yes            |
| Facebook  | `https://www.facebook.com/v17.0/dialog/oauth?client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&scope=openid&nonce=$NONCE&response_type=id_token`                                      | N/A                                                                                                                                 | Yes            |
| Twitch    | `https://id.twitch.tv/oauth2/authorize?client_id=$CLIENT_ID&force_verify=true&lang=en&login_type=login&redirect_uri=$REDIRECT_URL&response_type=id_token&scope=openid&nonce=$NONCE` | N/A                                                                                                                                 | Yes            |
| Kakao     | `https://kauth.kakao.com/oauth/authorize?response_type=code&client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&nonce=$NONCE`                                                           | `https://kauth.kakao.com/oauth/token?grant_type=authorization_code&client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&code=$AUTH_CODE` | No             |
| Apple     | `https://appleid.apple.com/auth/authorize?client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&scope=email&response_mode=form_post&response_type=code%20id_token&nonce=$NONCE`           | N/A                                                                                                                                 | Yes            |
| Slack     | `https://slack.com/openid/connect/authorize?response_type=code&client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URL&nonce=$NONCE&scope=openid`                                           | `https://slack.com/api/openid.connect.token?code=$AUTH_CODE&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET`                      | Yes            |
| Microsoft | `https://login.microsoftonline.com/common/oauth2/v2.0/authorize?client_id=$CLIENT_ID&scope=openid&response_type=id_token&nonce=$NONCE&redirect_uri=$REDIRECT_URL`                   | Yes                                                                                                                                 |

## Decoding JWT

Upon successful redirection, the OpenID provider attaches the JWT as a URL parameter. The following is an example using the Google flow.

```
http://host/auth?id_token=tokenPartA.tokenPartB.tokenPartC&authuser=0&prompt=none
```

The `id_token` param is the JWT in encoded format. You can validate the correctness of the encoded token and investigate its structure by pasting it in the [jwt.io](https://jwt.io) website.

To decode the JWT you can use a library like: `jwt_decode:` and map the response to the provided type `JwtPayload`:

```typescript
const decodedJwt = jwt_decode(encodedJWT) as JwtPayload;

export interface JwtPayload {
	iss?: string;
	sub?: string; //Subject ID
	aud?: string[] | string;
	exp?: number;
	nbf?: number;
	iat?: number;
	jti?: string;
}
```

## User salt management

zkLogin uses the user salt to compute the zkLogin Sui address (see [definition](../../../concepts/cryptography/zklogin.mdx#address-definition)). The salt must be a 16-byte value or a integer smaller than `2n**128n`. There are several options for the application to maintain the user salt:

1. Client side:
   - Option 1: Request user input for the salt during wallet access, transferring the responsibility to the user, who must then remember it.
   - Option 2: Browser or Mobile Storage: Ensure proper workflows to prevent users from losing wallet access during device or browser changes. One approach is to email the salt during new wallet setup.
2. Backend service that exposes an endpoint that returns a unique salt for each user consistently.
   - Option 3: Store a mapping from user identifier (e.g. `sub`) to user salt in a conventional database (e.g. `user` or `password` table). The salt is unique per user.
   - Option 4: Implement a service that keeps a master seed value, and derive a user salt with key derivation by validating and parsing the JWT. For example, use `HKDF(ikm = seed, salt = iss || aud, info = sub)` defined [here](https://github.com/MystenLabs/fastcrypto/blob/e6161f9279510e89bd9e9089a09edc018b30fbfe/fastcrypto/src/hmac.rs#L121). Note that this option does not allow any rotation on master seed or change in client ID (i.e. aud), otherwise a different user address will be derived and will result in loss of funds.

Here's an example request and response for the Mysten Labs-maintained salt server (using option 4). If you want to use the Mysten Labs salt server, please refer to [Enoki docs](https://docs.enoki.mystenlabs.com/) and contact us. Only valid JWT authenticated with whitelisted client IDs are accepted.

```sh
$ curl -X POST https://salt.api.mystenlabs.com/get_salt -H 'Content-Type: application/json' -d '{"token": "$JWT_TOKEN"}'
```

```sh
Response: {"salt":"129390038577185583942388216820280642146"}
```

User salt is used to disconnect the OAuth identifier (sub) from the on-chain Sui address to avoid linking Web2 credentials with Web3 credentials. While losing or misusing the salt could enable this link, it wouldn't compromise fund control or zkLogin asset authority. See more discussion [here](#security-and-privacy).

## Get the user's Sui address

Once the OAuth flow completes, the JWT can be found in the redirect URL. Along with the user salt, the zkLogin address can be derived as follows:

```typescript
import { jwtToAddress } from '@mysten/sui/zklogin';

const zkLoginUserAddress = jwtToAddress(jwt, userSalt);
```

## Get the zero-knowledge proof

The next step is to fetch the ZK proof. This is an attestation (proof) over the ephemeral key pair that proves the ephemeral key pair is valid.

First, generate the extended ephemeral public key to use as an input to the ZKP.

```typescript
import { getExtendedEphemeralPublicKey } from '@mysten/sui/zklogin';

const extendedEphemeralPublicKey = getExtendedEphemeralPublicKey(ephemeralKeyPair.getPublicKey());
```

You need to fetch a new ZK proof if the previous ephemeral key pair is expired or is otherwise inaccessible.

Because generating a ZK proof can be resource-intensive and potentially slow on the client side, it's advised that wallets utilize a backend service endpoint dedicated to ZK proof generation.

There are two options:

1. Call the Mysten Labs-maintained proving service.
1. Run the proving service in your backend using the provided Docker images.

### Call the Mysten Labs-maintained proving service

If you want to use the Mysten hosted ZK Proving Service for Mainnet, please refer to [Enoki docs](https://docs.enoki.mystenlabs.com/) and contact us for accessing it.


You can use BigInt or Base64 encoding for `extendedEphemeralPublicKey`, `jwtRandomness`, and `salt`. The following examples show two sample requests with the first using BigInt encoding and the second using Base64.

```sh
$ curl -X POST $PROVER_URL -H 'Content-Type: application/json' \
-d '{"jwt":"$JWT_TOKEN", \
"extendedEphemeralPublicKey":"84029355920633174015103288781128426107680789454168570548782290541079926444544", \
"maxEpoch":"10", \
"jwtRandomness":"100681567828351849884072155819400689117", \
"salt":"248191903847969014646285995941615069143", \
"keyClaimName":"sub" \
}'
```

```sh
$ curl -X POST $PROVER_URL -H 'Content-Type: application/json' \
-d '{"jwt":"$JWT_TOKEN", \
"extendedEphemeralPublicKey":"ucbuFjDvPnERRKZI2wa7sihPcnTPvuU//O5QPMGkkgA=", \
"maxEpoch":"10", \
"jwtRandomness":"S76Qi8c/SZlmmotnFMr13Q==", \
"salt":"urgFnwIxJ++Ooswtf0Nn1w==", \
"keyClaimName":"sub" \
}'
```

Response:

```json
{
	"proofPoints": {
		"a": [
			"17267520948013237176538401967633949796808964318007586959472021003187557716854",
			"14650660244262428784196747165683760208919070184766586754097510948934669736103",
			"1"
		],
		"b": [
			[
				"21139310988334827550539224708307701217878230950292201561482099688321320348443",
				"10547097602625638823059992458926868829066244356588080322181801706465994418281"
			],
			[
				"12744153306027049365027606189549081708414309055722206371798414155740784907883",
				"17883388059920040098415197241200663975335711492591606641576557652282627716838"
			],
			["1", "0"]
		],

		"c": [
			"14769767061575837119226231519343805418804298487906870764117230269550212315249",
			"19108054814174425469923382354535700312637807408963428646825944966509611405530",
			"1"
		]
	},
	"issBase64Details": {
		"value": "wiaXNzIjoiaHR0cHM6Ly9pZC50d2l0Y2gudHYvb2F1dGgyIiw",
		"indexMod4": 2
	},
	"headerBase64": "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEifQ"
}
```

### How to handle CORS error

To avoid possible CORS errors in Frontend apps, it is suggested to delegate this call to a backend service.

The response can be mapped to the inputs parameter type of `getZkLoginSignature` of zkLogin SDK.

```typescript
const proofResponse = await post('/your-internal-api/zkp/get', zkpRequestPayload);

export type PartialZkLoginSignature = Omit<
	Parameters<typeof getZkLoginSignature>['0']['inputs'],
	'addressSeed'
>;
const partialZkLoginSignature = proofResponse as PartialZkLoginSignature;
```

### Run the proving service in your backend

1. Install [Git Large File Storage](https://git-lfs.com/) (an open source Git extension for large file versioning) before downloading the zkey.

1. Download the [Groth16 proving key zkey file](https://docs.circom.io/getting-started/proving-circuits/). There are zkeys available for all Sui networks. See [the Ceremony section](#ceremony) for more details on how the main proving key is generated.

   - Main zkey (for Mainnet and Testnet)
     ```sh
     $ wget -O - https://raw.githubusercontent.com/sui-foundation/zklogin-ceremony-contributions/main/download-main-zkey.sh | bash
     ```
   - Test zkey (for Devnet)

     ```sh
     $ wget -O - https://raw.githubusercontent.com/sui-foundation/zklogin-ceremony-contributions/main/download-test-zkey.sh | bash
     ```

   - To verify the download contains the correct zkey file, you can run the following command to check the Blake2b hash: `b2sum ${file_name}.zkey`.

     | Network          | zkey file name      | Hash                                                                                                                               |
     | ---------------- | ------------------- | ---------------------------------------------------------------------------------------------------------------------------------- |
     | Mainnet, Testnet | `zkLogin-main.zkey` | `060beb961802568ac9ac7f14de0fbcd55e373e8f5ec7cc32189e26fb65700aa4e36f5604f868022c765e634d14ea1cd58bd4d79cef8f3cf9693510696bcbcbce` |
     | Devnet           | `zkLogin-test.zkey` | `686e2f5fd969897b1c034d7654799ee2c3952489814e4eaaf3d7e1bb539841047ae8ee5fdcdaca5f4ddd76abb5a8e8eb77b44b693a2ba9d4be57e94292b26ce2` |

1. For the next step, you need two Docker images from the [mysten/zklogin repository](https://hub.docker.com/r/mysten/zklogin) (tagged as `prover` and `prover-fe`). To simplify, a docker compose file is available that automates this process. Run `docker compose` with the downloaded zkey from the same directory as the YAML file.

```yaml
services:
  backend:
    image: mysten/zklogin:prover-stable
    volumes:
      # The ZKEY environment variable must be set to the path of the zkey file.
      - ${ZKEY}:/app/binaries/zkLogin.zkey
    environment:
      - ZKEY=/app/binaries/zkLogin.zkey
      - WITNESS_BINARIES=/app/binaries

  frontend:
    image: mysten/zklogin:prover-fe-stable
    command: '8080'
    ports:
      # The PROVER_PORT environment variable must be set to the desired port.
      - '${PROVER_PORT}:8080'
    environment:
      - PROVER_URI=http://backend:8080/input
      - NODE_ENV=production
      - DEBUG=zkLogin:info,jwks
      # The default timeout is 15 seconds. Uncomment the following line to change it.
      # - PROVER_TIMEOUT=30
```

```
ZKEY=<path_to_zkLogin.zkey> PROVER_PORT=<PROVER_PORT> docker compose up
```

1. To call the service, the following two endpoints are supported:
   - `/ping`: To test if the service is up. Running `curl http://localhost:PROVER_PORT/ping` should return `pong`.
   - `/v1`: The request and response are the same as the Mysten Labs maintained service.

A few important things to note:

- The backend service (mysten/zklogin:prover-stable) is compute-heavy. Use at least the minimum recommended 16 cores and 16GB RAM. Using weaker instances can lead to timeout errors with the message "Call to rapidsnark service took longer than 15s". You can adjust the environment variable `PROVER_TIMEOUT` to set a different timeout value, for example, `PROVER_TIMEOUT=30` for a timeout of 30 seconds.

- If you want to compile the prover from scratch (for performance reasons), please see our fork of [rapidsnark](https://github.com/MystenLabs/rapidsnark#compile-prover-in-server-mode). You'd need to compile and launch the prover in server mode.

- Setting `DEBUG=*` turns on all logs in the prover-fe service some of which may contain PII. Consider using DEBUG=zkLogin:info,jwks in production environments.

## Assemble the zkLogin signature and submit the transaction

First, sign the transaction bytes with the ephemeral private key using the key pair generated previously. This is the same as [traditional key pair signing](https://sdk.mystenlabs.com/typescript/cryptography/keypairs). Make sure that the transaction `sender` is also defined.

```typescript
const ephemeralKeyPair = new Ed25519Keypair();

const client = new SuiClient({ url: '<YOUR_RPC_URL>' });

const txb = new Transaction();

txb.setSender(zkLoginUserAddress);

const { bytes, signature: userSignature } = await txb.sign({
	client,
	signer: ephemeralKeyPair, // This must be the same ephemeral key pair used in the ZKP request
});
```

Next, generate an address seed by combining `userSalt`, `sub` (subject ID), and `aud` (audience).

Set the address seed and the partial zkLogin signature to be the `inputs` parameter.

You can now serialize the zkLogin signature by combining the ZK proof (`inputs`),
the `maxEpoch`, and the ephemeral signature (`userSignature`).

```typescript
import { genAddressSeed, getZkLoginSignature } from '@mysten/sui/zklogin';

const addressSeed = genAddressSeed(
	BigInt(userSalt!),
	'sub',
	decodedJwt.sub,
	decodedJwt.aud,
).toString();

const zkLoginSignature = getZkLoginSignature({
	inputs: {
		...partialZkLoginSignature,
		addressSeed,
	},
	maxEpoch,
	userSignature,
});
```

Finally, execute the transaction.

```typescript
client.executeTransactionBlock({
	transactionBlock: bytes,
	signature: zkLoginSignature,
});
```

## Caching the ephemeral private key and ZK proof

As previously documented, each ZK proof is tied to an ephemeral key pair. So you can reuse the proof to sign any number of transactions until the ephemeral key pair expires (until the current epoch crosses `maxEpoch`).

You might want to cache the ephemeral key pair along with the ZKP for future uses.

However, the ephemeral key pair needs to be treated as a secret akin to a key pair in a traditional wallet. This is because if both the ephemeral private key and ZK proof are revealed to an attacker, then they can typically sign any transaction on behalf of the user (using the same process described previously).

Consequently, you should not store them persistently in a storage location that is not secure, on any platform. For example, on browsers, use session storage instead of local storage to store the ephemeral key pair and the ZK proof. This is because session storage automatically clears its data when the browser session ends, while data in local storage persists indefinitely.

## Efficiency considerations

Compared to traditional signatures, zkLogin signatures take a longer time to generate. For example, the prover that Mysten Labs maintains typically takes about three seconds to return a proof, which runs on a machine with 16 vCPUs and 64 GB RAM. Using more powerful machines, such as those with physical CPUs or graphics processing units (GPUs), can reduce the proving time further.

Carefully consider how many requests your application needs to make to the prover. Broadly speaking, the right metric to consider is the number of active user sessions and not the number of signatures. This is because you can cache the same ZK proof and reuse it across the session, as previously explained. For example, if you expect a million active user sessions per day, then you need a prover that can handle one or two requests per second (RPS), assuming evenly distributed traffic.

The prover that Mysten Labs maintains is set to auto-scale to handle traffic surges. If you are not sure whether Mysten Labs can handle a specific number of requests or expect a sudden spike in the number of prover requests your application needs to make, please reach out to us on [Discord](https://discord.gg/sui). Our plan is to horizontally scale the prover to handle any RPS you require.

## Related links

<RelatedLink to="/concepts/cryptography/zklogin.mdx" />
<RelatedLink to="/guides/developer/cryptography/zklogin-integration/zklogin-example.mdx" />
<RelatedLink to="/guides/developer/cryptography/zklogin-integration/developer-account.mdx" />

>>>> sui/docs/content/guides/developer/currency.mdx
---
title: Create Currencies and Tokens
description: Learn how to create currencies and mint coins and tokens on the Sui network using the Coin Registry system.
keywords: [ mint tokens, create tokens, use tokens, publish token, custom tokens, sui CLI, denylist, regulated coins, coin registry, currency registry ]
pagination_prev: null
---

The Coin Registry system provides a centralized approach to currency management through the `sui::coin_registry` module. The registry is a shared object located at address `0xc` that stores metadata, supply information, and regulatory status for all registered coin types.

The `sui::token` module handles token creation on the network. Refer to the [Closed-Loop Token](/standards/closed-loop-token.mdx) and [Currency](/standards/currency.mdx) Standards documentation for more information on these features.

### Currency creation process

The registry system supports two currency creation methods:

1. **Standard creation:** Call `new_currency<T>()` when creating the coin outside of the `init` function of your package.
1. **OTW creation:** Use `new_currency_with_otw<T>()` with a One-Time Witness for uniqueness proof.

Both methods return a `CurrencyInitializer<T>` that allows configuration before finalization:

<details>
<summary>
Regular currency creation
</summary>
<ImportContent source="examples/move/coin/sources/non_otw_currency.move" mode="code" />
</details>

<details>
<summary>
OTW currency creation
</summary>
<ImportContent source="examples/move/coin/sources/my_coin_new.move" mode="code" />
</details>

The initialization process allows for:

- **Supply model selection:** Choose fixed, burn-only, or flexible supply.
- **Regulatory configuration:** Add deny list capabilities if needed.

:::caution Important

After initialization of a currency using the OTW method, you must call `finalize_registration` to create the shared `Currency` object that the Coin Registry can track.

:::

## `DenyList`

The Sui framework provides a `DenyList` singleton, shared object that the bearer of a `DenyCapV2` can access to specify a list of addresses that are unable to use a Sui core type. The initial use case for `DenyList`, however, focuses on limiting access to coins of a specified type. This is useful, for example, when creating a regulated coin on Sui that requires the ability to block certain addresses from using it as inputs to transactions. Regulated coins on Sui satisfy any regulations that require the ability to prevent known bad actors from having access to those coins. 

:::info

The `DenyList` object is a system object that has the address `0x403`. You cannot create it yourself.

:::

## Create regulated currency

Use the `make_regulated()` function during the initialization phase before calling `finalize()`. This adds deny list capabilities to the `Currency<T>` and tracks the regulatory status within the registry system.

<details>
<summary>
Regulated currency creation
</summary>
<ImportContent source="examples/move/coin/sources/regcoin_new.move" mode="code" />
</details>

## Create tokens

Tokens reuse the `TreasuryCap` defined in the `sui::coin` module and therefore have the same initialization process. The `coin::create_currency` function guarantees the uniqueness of the `TreasuryCap` and forces the creation of a `CoinMetadata` object.

Coin-like functions perform the minting and burning of tokens. Both require the `TreasuryCap`:

- `token::mint`: Mint a token
- `token::burn`: Burn a token

See [Closed-Loop Token](../../standards/closed-loop-token.mdx) standard for complete details of working with tokens.

## Related links

<RelatedLink to="/guides/developer/coin/regulated.mdx" />
<RelatedLink to="/guides/developer/coin/loyalty.mdx" />
<RelatedLink to="/guides/developer/coin/in-game-token.mdx" />
<RelatedLink to="/concepts/sui-move-concepts/derived-objects.mdx" />
<RelatedLink href="https://move-book.com/programmability/one-time-witness.html" label="One Time Witness" desc="The Move Book documentation of the one time witness pattern. " />

>>>> sui/docs/content/guides/developer/dev-cheat-sheet.mdx
---
title: Sui Developer Cheat Sheet
sidebar_label: Dev Cheat Sheet
description: A quick reference document regarding best practices for Sui developers.
keywords: [ cheat sheet, quick reference, best practices, general best practices, composability, testing, apps, signing, zklogin, app best practices, dev best practices, testing best practices, signing best practices ]
pagination_prev: null
---

Quick reference on best practices for Sui Network developers.

## Move

### General

- Read the [Code Quality Checklist](https://move-book.com/guides/code-quality-checklist/) for best practices in Move development.
- Follow the [Move conventions](/concepts/sui-move-concepts/conventions.mdx) for consistent naming and coding style.
- Use `vector`-backed collections (`vector`, `VecSet`, `VecMap`, `PriorityQueue`) with a known maximum size of â‰¤ 1000 items.
  - Use dynamic field-backed collections (`Table`, `Bag`, `ObjectBag`, `ObjectTable`, `LinkedTable`) for any collection that allows third-party addition, larger collections, and collections of unknown size.
  - Move objects have a maximum size of 250KB. Any attempt to create a larger object leads to an aborted transaction. Ensure that your objects do not have an ever-growing `vector`-backed collection.
- If your function `f` needs a payment in, for example, SUI from the caller, use `fun f(payment: Coin<SUI>)` not `fun f(payment: &mut Coin<SUI>, amount: u64)`. This is safer for callers; they know exactly how much they are paying, and do not need to trust `f` to extract the right amount.

### Composability

- Use the [Sui Object Display](https://move-book.com/programmability/display) to customize how your objects show up in wallets, apps, and explorers.
- Avoid â€œself-transfers." When possible, return the object from the current function, so it can be used in a different command in a [programmable transaction block](/guides/developer/sui-101/working-with-ptbs.mdx).

### Package upgrades

- Read about [package upgrades](../../concepts/sui-move-concepts/packages/upgrade.mdx) before publishing your package.
- Packages are immutable, so any published package can be called forever. Use [object versioning](/concepts/sui-move-concepts/packages/upgrade.mdx#versioned-shared-objects) to prevent older versions from being called.
- If you upgrade a package `P1` to `P2`, other packages and clients that depend on `P1` will continue using `P1`. They do not auto-update to `P2`. Both dependent packages and client code must be explicitly updated to point at `P2`.
- Packages that expect to be extended by dependent packages can avoid breaking their extensions with each upgrade by providing a standard (unchanging) interface that all versions conform to. See the [message sending](https://github.com/wormhole-foundation/wormhole/blob/74dea3bf22f0e27628b432c3e9eac05c85786a99/sui/wormhole/sources/publish_message.move) across a bridge example from Wormhole. Extension packages that produce outbound messages can use [`prepare_message`](https://github.com/wormhole-foundation/wormhole/blob/74dea3bf22f0e27628b432c3e9eac05c85786a99/sui/wormhole/sources/publish_message.move#L68-L90) from any version of the Wormhole package to produce a [`MessageTicket`](https://github.com/wormhole-foundation/wormhole/blob/74dea3bf22f0e27628b432c3e9eac05c85786a99/sui/wormhole/sources/publish_message.move#L52-L66) while client code that sends the message must pass that `MessageTicket` into [`publish_message`](https://github.com/wormhole-foundation/wormhole/blob/74dea3bf22f0e27628b432c3e9eac05c85786a99/sui/wormhole/sources/publish_message.move#L92-L152) in the latest version of the package.
  - `public` function signatures cannot be deleted or changed, but `public(friend)` functions can. Use `public(friend)` or private visibility liberally unless you are exposing library functions that will live forever.
  - It is not possible to delete `struct` types, change their definition or add new [abilities](https://move-book.com/reference/abilities) via an upgrade. Introduce new types carefully as they will live forever.

### Testing

- Use the [`sui::test_scenario`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/test/test_scenario.move) module to mimic multi-transaction, multi-sender test scenarios.
- Use the [`std::unit_test`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/move-stdlib/sources/unit_test.move) module for `assert_eq!` and `assert_ref_eq!` macros for better test error messages.
- Use the [`sui::test_utils`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/test/test_utils.move#L5) module for black-hole function `destroy`.
- Use the [`std::debug`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/move-stdlib/sources/debug.move) module for debug printing via `print`.
- Use `sui move test --coverage` to compute code coverage information for your tests, and `sui move coverage source --module <name>` to see uncovered lines highlighted in red. Push coverage all the way to 100% if feasible.

## Apps

- For optimal performance and data consistency, apps should submit writes and reads for the same full node. In the TS SDK, this means that apps should use the wallet's [`signTransactionBlock`](https://sdk.mystenlabs.com/dapp-kit) API, then submit the transaction via a call to [`execute_transactionBlock`](/references/sui-api/sui-graphql/beta/reference/operations/mutations/execute-transaction.mdx) on the app's full node, _not_ use the wallet's `signAndExecuteTransactionBlock` API. This ensures read-after-write-consistency--reads from the app's full node will reflect writes from the transaction right away instead of waiting for a checkpoint.
- For lower latency, use [`executeTransactionBlock`](/references/sui-api/sui-graphql/beta/reference/operations/mutations/execute-transaction.mdx) with `"showEffects": false` and `"showEvents": false` if your app needs to know that a transaction was confirmed, but does not immediately need to see the transaction effects or read the objects/events written by the transaction.
- Apps should implement a local cache for frequently read data rather than over-fetching from the full node.
- Whenever possible, use programmable transaction blocks to compose existing on-chain functionality rather than publishing new smart contract code. Programmable transaction blocks allow large-scale batching and heterogeneous composition, driving already-low gas fees down even further.
- Apps should leave gas budget, gas price, and coin selection to the wallet. This gives wallets more flexibility, and it's the wallet's responsibility to dry run a transaction to ensure it doesn't fail.

## Signing

- **Never** sign two concurrent transactions that are touching the same owned object. Either use independent owned objects, or wait for one transaction to conclude before sending the next one. Violating this rule might lead to client [equivocation](/references/sui-glossary.mdx#equivocation), which locks up the owned objects involved in the two transactions until the end of the current epoch.
- Any `sui client` command that crafts a transaction (e.g., `sui client publish`, `sui client call`) can accept the `--serialize-output` flag to output a base64 transaction to be signed.
- Sui supports several signature schemes for transaction signing, including native multisig.

## zkLogin

- Call the proving service as sparingly as possible. Design your app flows such that you call the proving service only when the user is about to perform a real transaction.
- Beware of how you cache the ephemeral private key. Treat the private key akin to a piece of highly sensitive data, e.g., password. If an (unexpired) ephemeral private key and its corresponding ZK proof are leaked, then an attacker can steal user's assets.

>>>> sui/docs/content/guides/developer/first-app/debug.mdx
---
title: Debugging
description: Move does not have a native debugger. You can, however, use the std::debug module to monitor variable values while your code executes.
keywords: [ debugging, debug move, how to debug move, debugging move, std::debug, debug, how to debug, debug code, debugging code ]
draft: true
---

Move does not currently have a native debugger. You can use the `std::debug` module, however, to print arbitrary values to the console. Monitoring variable values in this manner can provide insight into the logic of your modules. To do so, first declare an alias to the debug module in your source file for more concise access:

```move
use std::debug;
```

Then in places where you want to print out a value `v`, regardless of its type, add the following code:

```move
debug::print(&v);
```

or the following if `v` is already a reference:

```move
debug::print(v);
```

The debug module also provides a function to print out the current stacktrace:

```move
debug::print_stack_trace();
```

Alternatively, any call to abort or assertion failure also prints the stacktrace at the point of failure.

## Using debug in `my_module`

To see the module in action, update your `my_module` code to include debug calls. Specifically, update the `new_sword` function so that you print the value of `forge` before and after updating `swords_created`. Also, include a `print_stack_trace` so that the function looks like the following:

```move
public fun new_sword(
    forge: &mut Forge,
    magic: u64,
    strength: u64,
    ctx: &mut TxContext,
): Sword {
    debug::print(forge);
    forge.swords_created = forge.swords_created + 1;
    debug::print(forge);
    debug::print_stack_trace();
    Sword {
        id: object::new(ctx),
        magic: magic,
        strength: strength,
    }
}
```

To see the results, run the module's tests.

```sh
$ sui move test
```

The response prints out the expected results as the test calls the `new_sword` function.

```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING my_first_package
Running Move unit tests
[ PASS    ] 0x0::my_module::test_module_init
[debug] 0x0::my_module::Forge {
  id: 0x2::object::UID {
    id: 0x2::object::ID {
      bytes: @0x34401905bebdf8c04f3cd5f04f442a39372c8dc321c29edfb4f9cb30b23ab96
    }
  },
  swords_created: 0
}
[debug] 0x0::my_module::Forge {
  id: 0x2::object::UID {
    id: 0x2::object::ID {
      bytes: @0x34401905bebdf8c04f3cd5f04f442a39372c8dc321c29edfb4f9cb30b23ab96
    }
  },
  swords_created: 1
}
Call Stack:
    [0] 0000000000000000000000000000000000000000000000000000000000000000::my_module::test_module_init

        Code:
            [35] LdU64(7)
            [36] MutBorrowLoc(3)
            [37] Call(15)
          > [38] Call(5)
            [39] LdConst(0)
            [40] CallGeneric(2)
            [41] ImmBorrowLoc(3)

        Locals:
            [0] -
            [1] { { { <OBJECT-ID-WITHOUT-0x> } }, 1 }
            [2] -
            [3] { 2, { 00000000000000000000000000000000000000000000000000000000000000ad, [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0, 0, 0 } }


Operand Stack:

[ PASS    ] 0x0::my_module::test_sword_transactions
Test result: OK. Total tests: 2; passed: 2; failed: 0
```

The output shows the value of the `swords_created` field of the `Forge` change after the increment. The stack trace shows the bytecode instructions that have been executed so far, and the next few instructions to execute. 

:::info

The specific bytecode offsets and the indices of the local variables might vary depending on the version of the Sui toolchain.

:::

## Related links

<RelatedLink to="/guides/developer/getting-started/hello-world.mdx" />

>>>> sui/docs/content/guides/developer/getting-started.mdx
---
title: Getting Started
description: Get started with Sui, the first internet-scale programmable blockchain platform.
keywords: [ install sui, sui data, get started, how to get started, connect to a network, get SUI, sui tokens ]
pagination_prev: null
---

<Cards type="steps">

<Card className="plausible-event-name=Index+install+button" title="Install Sui" href="/guides/developer/getting-started/sui-install" />
<Card className="plausible-event-name=Index+client+button" title="Configure a Sui Client" href="/guides/developer/getting-started/configure-sui-client" />
<Card className="plausible-event-name=Index+address+button" title="Create a Sui Address" href="/guides/developer/getting-started/get-address" />
<Card className="plausible-event-name=Index+faucet+button" title="Get SUI from Faucet" href="/guides/developer/getting-started/get-coins" />
<Card className="plausible-event-name=Index+dapp+button" title="Hello, World!" href="/guides/developer/getting-started/hello-world" />
<Card className="plausible-event-name=Index+next+button" title="Next Steps" href="/guides/developer/getting-started/next-steps" />

</Cards>
>>>> sui/docs/content/guides/developer/getting-started/app-frontends.mdx
---
title: Connect a Frontend to a Move Package
sidebar_label: Connect a Frontend
description: Connect a React interface to a basic Move package to create a full stack application.
keywords: [ first dapp, first package, move package, first move package, hello world, hello, world, react, react dapp, react ui, connect react dapp, add frontend, add ui, create fullstack app, fullstack app, full stack, full stack dapp ]
pagination_prev: null
pagination_next: null
---

In the previous guide, ["Hello, World!"](/guides/developer/getting-started/hello-world.mdx), you deployed a Move package and interacted with it to create an object that stored the text "Hello world!".

This guide demonstrates how to connect a React interface to that "Hello, World!" package, giving any user a way to interact with the Move package from their browser and set a custom greeting.

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install.mdx).

- [x] [Configure the Sui client](/guides/developer/getting-started/configure-sui-client.mdx).

- [x] [Create a Sui address](/guides/developer/getting-started/get-address.mdx).

- [x] [Get SUI Testnet tokens](/guides/developer/getting-started/get-coins.mdx).

- [x] Complete the ["Hello, World!"](/guides/developer/getting-started/hello-world.mdx) guide and have your published Move package's ID. 

- [x] Install [`pnpm`](https://pnpm.io/installation) to use as the package manager.

- [x] Create a [Slush](https://slush.app/) wallet.

</TabItem>
</Tabs>

## Call the Move package 

First, confirm that you have [followed the "Hello, World!"](https://github.com/MystenLabs/sui-stack-hello-world.git) example guide and are within the `sui-stack-hello-world/move/hello-world` directory in your CLI.

Then, verify your Move package is still available on Testnet by obtaining its object information:

```
$ sui client object <PACKAGE_ID>
```

Replace `<PACKAGE_ID>` with your Move package's ID. 

:::danger

If your package no longer exists, or if you need to obtain the package ID again, follow the steps in the ["Hello, World!"](https://github.com/MystenLabs/sui-stack-hello-world.git) guide.

:::

## View the frontend source code

In the "Hello, World!" example project, the subdirectory `sui-stack-hello-world/ui` contains the frontend interface source code files:

```
.
â”œâ”€â”€ index.html
â”œâ”€â”€ package.json
â”œâ”€â”€ pnpm-lock.yaml
â”œâ”€â”€ prettier.config.cjs
â”œâ”€â”€ src
â”‚   â”œâ”€â”€ App.tsx
â”‚   â”œâ”€â”€ constants.ts
â”‚   â”œâ”€â”€ CreateGreeting.tsx
â”‚   â”œâ”€â”€ Greeting.tsx
â”‚   â”œâ”€â”€ main.tsx
â”‚   â”œâ”€â”€ networkConfig.ts
â”‚   â””â”€â”€ vite-env.d.ts
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ tsconfig.node.json
â””â”€â”€ vite.config.mts
```

### `App.tsx`

The `App.tsx` file contains code that creates a basic starter template for your React dApp. It includes a button to connect a Slush wallet to the dApp and a button to open the Sui Faucet to obtain Testnet SUI. 

<ImportContent source="/ui/src/App.tsx" mode="code" org="MystenLabs" repo="sui-stack-hello-world" />

### `CreateGreeting.tsx`

The `CreateGreeting.tsx` file contains logic that creates and sends a transaction to your Move package. The transaction calls the `new` function of the package, which creates a Move object with the value `Hello world!`. In the ["Hello, World!"](/guides/developer/getting-started/hello-world.mdx) guide, you called this function manually through the CLI with the command `sui client call --package <PACKAGE_ID> --module greeting --function new`.

<ImportContent source="/ui/src/CreateGreeting.tsx" mode="code" org="MystenLabs" repo="sui-stack-hello-world" />

### `Greeting.tsx`

The `Greeting.tsx` file also contains logic that creates and sends a transaction to your Move package. However, this transaction calls the `update_text` function of the package, which modifies the text to replace "Hello world!" with the text of your choosing.

<ImportContent source="/ui/src/Greeting.tsx" mode="code" org="MystenLabs" repo="sui-stack-hello-world" />

## Connect the React interface to your Move package

The `constants.ts` file is where you connect the React dApp to your Move package. This file contains a single line that sets your Move package ID as a constant `TESTNET_HELLO_WORLD_PACKAGE_ID`. By default, this file contains a sample package ID. 

Modify this file to include your Move package ID instead.

<ImportContent source="/ui/src/constants.ts" mode="code" org="MystenLabs" repo="sui-stack-hello-world" />

This constant is used in the `networkConfig.ts` file:

<ImportContent source="/ui/src/networkConfig.ts" mode="code" org="MystenLabs" repo="sui-stack-hello-world" />

## Install frontend dependencies 

Now, navigate into the `sui-stack-hello-world/ui` directory if you are not already there and install the necessary frontend dependencies:

```sh
$ pnpm install
```

## Run the React application

Start the React application in your local development environment:

```sh
$ pnpm dev
```

Then, open `http://localhost:5173/` in your browser. The dApp prompts you to connect your Slush wallet. Click **Connect Wallet**, authenticate when prompted, then approve the connection.

## Send SUI tokens to your Slush wallet

If you sent SUI tokens to an address used in the CLI in previous guides, then created a new Slush wallet in your browser, you likely need to send SUI tokens to the Slush wallet. The Slush wallet address is different and separate from the address created and used in the CLI.

Follow the [Testnet SUI](/guides/developer/getting-started/get-coins.mdx) instructions to send Testnet tokens to your Slush address. 

## Use the frontend interface

Next, click the **Create Greeting** button. In the code, this button activates the logic stored in `CreateGreeting.ts` to send a transaction to the Move package that calls the `new` function and creates the `Greeting` object. 

The Slush wallet prompts you to approve this transaction. 

:::danger 

If there is a problem, the prompt to approve the transaction displays the error message. Common errors include "Unable to Process Transaction" due to either insufficient gas coins or an incorrect Move package ID. 

[Obtain Testnet SUI](/guides/developer/getting-started/get-coins.mdx) or [confirm you have the correct Move package ID](/guides/developer/getting-started/hello-world.mdx) to resolve these errors.

:::

After you approve the transaction, the browser window displays the `Greeting` object's ID and its content, which by default is "Hello world!"

To change this text, enter a different greeting in the text box below the default value and click **Update**. The Slush wallet prompts you to approve the transaction.

!["Hello, World!" default greeting](./images/hello-world-default.png)

After you approve the transaction, the new greeting is displayed:

!["Hello, World!" modified greeting](./images/hello-world-modified.png)

<div className="next-steps-module">
  <div className="next-steps-header">
    <h3>Next steps</h3>
  </div>
  <div className="next-steps-grid">
    <Card className="plausible-event-name=hello+data+button"
      title="Access Sui Data" 
      href="/guides/developer/sui-101/data-serving"
    >
      Learn more about accessing data on Sui.
    </Card>
    <Card className="plausible-event-name=hello+community+button"
      title="Join the Community" 
      href="/guides/developer/getting-started/next-steps"
    >
      Join the Sui developer community, try out other example projects, or read more documentation.
    </Card>
  </div>
</div>
>>>> sui/docs/content/guides/developer/getting-started/configure-sui-client.mdx
---
title: Configure a Sui Client
description: The Sui client configuration specifies which network to connect to and which address to send transactions.
keywords: [ sui client, sui configuration, client.yaml, client config, local config, configure tooling, configure sui client, configure sui, config sui ]
pagination_prev: null
pagination_next: null
---

The Sui client configuration specifies which network to connect to and which address to send transactions. 

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

First, confirm that Sui has been installed successfully:

```
$ sui --version
```

If this command returns `sui not found`, then Sui is not installed and you must [follow the installation instructions](/guides/developer/getting-started/sui-install.mdx).

</TabItem>
</Tabs>

## `sui client` 

Run the Sui CLI with the command:

```
$ sui client
```

:::info 

If the Sui client is already configured, running this command returns the `sui client --help` output rather than interactive prompts. If this happens, skip to [learning about the `client.yaml`](#client-yaml) file.

:::

The first prompt confirms if you want to create the `client.yaml` file, select `Y`:

```
Config file ["<PATH-TO-FILE>/client.yaml"] doesn't exist, do you want to connect to a Sui full node server [y/N]?
```

The second prompt configures the network server URL to connect to:

```
Sui full node server URL (Defaults to Sui Testnet if not specified) :
```

If you specify nothing, the client uses Testnet by default. Using Testnet is recommended for developers new to Sui that do not have a project already developed. 

The options are:

- `https://fullnode.testnet.sui.io:443`: The RPC URL for Testnet.

- `https://fullnode.devnet.sui.io:443`: The RPC URL for Devnet. Devnet is not recommended for new Sui developers, as it is better suited for more advanced use cases and the network wipes data weekly as part of its update process.

- `https://fullnode.mainnet.sui.io:443`: The RPC URL for Mainnet network. Publishing applications to Mainnet costs real SUI tokens. 

- `http://0.0.0.0:9000`: The RPC URL for a Localnet network, if configured. Learn how to [setup a local network](/guides/developer/sui-101/local-network.mdx).

<ImportContent source="data-wipe.mdx" mode="snippet" />

The final prompt is to select an encryption scheme. You must select a key scheme by pressing <kbd>0</kbd>, <kbd>1</kbd>, or <kbd>2</kbd>. After you select a scheme, the client generates a new Sui address.

```
Select key scheme to generate key pair (0 for ed25519, 1 for secp256k1, 2 for secp256r1):
```

<ImportContent source="crypto-schemes.mdx" mode="snippet" />

:::caution 

Store recovery phrases securely and do not share them with anyone, as they provide access to any objects and tokens that an address owns.

It will not be visible again once the CLI history disappears.

[Learn more](/guides/developer/getting-started/get-address.mdx) about Sui addresses, key generation, and recovery phrases.

:::

## `client.yaml`

Your Sui client is now configured. By default, Sui stores this information in either the `~/.sui/sui_config/client.yaml` file (macOS/Linux) or `%USERPROFILE%\.sui\sui_config\client.yaml` file (Windows). You can store a `client.yaml` file in a different location, if preferred, and specify it's location with the `--client.config` flag. 

Sui stores the key for the Sui address in a separate file, `~/.sui/sui_config/sui.keystore` (macOS/Linux) or `%USERPROFILE/.sui/sui_config/sui.keystore` (Windows). Learn more about Sui addresses in [Create a Sui Address](/guides/developer/getting-started/get-address.mdx).

:::caution 

If a previous Sui installation stored a `client.yaml` file locally, you will receive the `sui client --help` output in the console. You can delete the existing `~/.sui/sui_config/client.yaml` file if you'd like to start fresh, or you can continue using the existing configuration. 

:::

The `client.yaml` file contains the following configuration information:

```yaml
keystore:
  File: /Users/your_user/.sui/sui_config/sui.keystore
external_keys: ~
envs:
  - alias: testnet
    rpc: "https://fullnode.testnet.sui.io:443"
    ws: ~
    basic_auth: ~
active_env: testnet
active_address: "0x7df01d3935b7ab3cd1da6828eed763ee2cc556670528a47baa6af8c251866e48"
```

<div className="next-steps-module">
  <div className="next-steps-header">
    <h3>Next steps</h3>
  </div>
  <div className="next-steps-grid">
    <Card className="plausible-event-name=client+address+button"
      title="Learn More About Sui Addresses" 
      href="/guides/developer/getting-started/get-address"
    >
      Now that you have created a Sui address, learn about address management, key pairs, and recovery phrase best practices. 
    </Card>
    <Card className="plausible-event-name=client+faucet+button"
      title="Get SUI from Faucet" 
      href="/guides/developer/getting-started/get-coins"
    >
      Obtain SUI from a faucet to deploy packages on Testnet.
    </Card>
        <Card className="plausible-event-name=client+hello+button"
      title="Hello, World!" 
      href="/guides/developer/getting-started/hello-world"
    >
      Clone the "Hello, World!" project.
    </Card>
  </div>
</div>

>>>> sui/docs/content/guides/developer/getting-started/get-address.mdx
---
title: Create a Sui Address
description: You need an address on the Sui network before you can build packages and own objects.
keywords: [ create an address, sui address, how to get sui address, sui wallets, slush, suiet, glass wallet, martian extension, surf wallet, private keys ]
pagination_prev: null
pagination_next: null
---

An _address_ is a unique, anonymous identity on a blockchain network. On Sui, an address specifically represents a location on-chain that can:

- Hold and send tokens 

- Own objects like NFTs and Move packages

- Submit transactions and interact with smart contracts

You do not need to provide any personally identifying information to create an address. A single individual can create and own multiple addresses. 

Every Sui address is a unique 32-byte identifier and appears in hexadecimal encoding with a `0x` prefix, unless referred to by an [alias](#address-aliases). For example:

```
0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331
```

A cryptographic hash function generates a public key from which every address derives. Each public key has a corresponding private key that accesses the address and the objects that it owns. An address and its associated key pair together is an _account_. 

[Learn more](/concepts/cryptography/transaction-auth/keys-addresses.mdx) about how a Sui address is derived and other cryptography related topics.

## Obtain a Sui address 

:::caution 

If you already have an address or created a new address in [Configure a Sui Client](/guides/developer/getting-started/configure-sui-client.mdx), you can skip to [Get SUI from Faucet](/guides/developer/getting-started/get-coins.mdx) to continue the onboarding steps.

:::

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Download and install Sui](/guides/developer/getting-started/sui-install.mdx).

- [x] [Configure your Sui client](/guides/developer/getting-started/configure-sui-client.mdx).

</TabItem>
</Tabs>

By default, when the Sui client runs for the first time, it prompts you to [configure the client](/guides/developer/getting-started/configure-sui-client.mdx). This initial configuration generates a new Sui address, its key pair, and its associated secret recovery phrase. 

To create a new Sui address outside of the initial client configuration, run:

```
$ sui client new-address ed25519
```

This command specifies the key pair scheme to be of type `ed25519`.

<ImportContent source="crypto-schemes.mdx" mode="snippet" />

### Recovery phrases

Every Sui address has a _recovery phrase_. Recovery phrases are a series of 12 randomly generated words that you use to recover the address if you lose access to the address's key pair. 

:::danger

Recovery phrases are only shown once. They are not stored anywhere automatically and cannot be retrieved if you do not save them yourself.

Store recovery phrases securely and do not share them with anyone, as they provide access to any objects and tokens that an address owns.

:::

To recover an address using the recovery phrase, use the command:

```
$ sui client import-address
```

Then, enter the 12-word recovery phrase. You must enter the words in the correct order. If successful, the CLI restores your address and prints it in the CLI output.

## `sui.keystore`

Sui stores a private key for every address in either the  `~/.sui/sui_config/sui.keystore` or `%USERPROFILE/.sui/sui_config/sui.keystore` file on macOS/Linux or Windows systems, respectively.

This file contains content similar to the following:

```
[
  "AK6q1/Yzz5qmTfHGLot4wkbRP5lP5NUQVDlf3FggLrKZ",
  "ADAWAFS+J9KcDjFmAiVI/e9ZluG0id9AnI6a7Bk5tH+G",
  "AJ42rQfCrPIfrQvzCgeHVDCcQZ4R1qAzKtob61VTw5k5",
  "AHoKrY7DDnUOq2RgP7gXLPa86bFfzqEMvmOs7TmHtST+"
]
```

When you create a new address on your system, a new line is added to this file that consists of the address's private key. Make sure you do not expose this to anyone, as they can use it to get access to your account.

:::danger 

The `sui.keystore` file is **not** the same as your machine's local keystore that contains passwords for websites, biometric data like fingerprints, or other authentication credentials. Your machine's local keystore cannot sign and submit transactions on Sui. Only addresses with their associated keys included in the `sui.keystore` file can sign and submit transactions.

:::

## Address aliases 

An _alias_ is a human-readable name that can be used in place of a Sui address's full 32-byte hexadecimal string. They can be used anywhere an address would be used to make referencing the address easier in scripts and CLI commands. 

When an address is created, it is given a random alias by default. You can view an address's current alias with the command:

```
$ sui client addresses
```

The output will include the address, its alias, and an indication of which address is active if there are multiple local addresses available:

```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ alias                 â”‚ address                                                            â”‚ active address â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ vigorous-spinel       â”‚ 0x6ebb36a3c1ab2124c082d93f60f518f70494b82d8d13c5aabb3abad6ec8cd82d â”‚ *              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

Then, to update the alias to something else, use the command:

```
$ sui keytool update-alias <OLD-ALIAS> <NEW-ALIAS>
```

You can now use the alias in place of the address in commands, such as:

```
$ sui client objects <NEW-ALIAS>
```

## View all local Sui addresses

The _active address_ is the address that the Sui client is currently using. This address owns any objects you create and transactions you submit, unless you specify otherwise with the `--address` flag in a command. 

To view the current active address, use the command:

```
$ sui client active-address
```

To view all addresses on your local machine, run:

```
$ sui keytool list
```

This returns all addresses, along with their alias, public key, key scheme, and peer ID. 

```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ alias           â”‚  vigorous-spinel                                                     â”‚ â”‚
â”‚ â”‚ suiAddress      â”‚  0x6ebb36a3c1ab2124c082d93f60f518f70494b82d8d13c5aabb3abad6ec8cd82d  â”‚ â”‚
â”‚ â”‚ publicBase64Key â”‚  AKDCajKN877Uc7o8NP2cQVJkSewhq1ZbWgw5LgpWVqbj                        â”‚ â”‚
â”‚ â”‚ keyScheme       â”‚  ed25519                                                             â”‚ â”‚
â”‚ â”‚ flag            â”‚  0                                                                   â”‚ â”‚
â”‚ â”‚ peerId          â”‚  a0c26a328df3bed473ba3c34fd9c41526449ec21ab565b5a0c392e0a5656a6e3    â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

For more information about the `keytool` command, see the [Sui Keytool CLI](/references/cli/keytool.mdx) documentation.

### Change the active address 

If you want to switch to another address, first confirm which address is the active address and which addresses are available for you to switch to:

```
$ sui client addresses
```

Then, to switch to another address, use the command:

```
$ sui client switch --address <ADDRESS>
```

## Query information about an address 

You can use a Sui network explorer to find more information about an address, its token balances, and the objects it owns. Popular Sui explorers include:

- [SuiVision](https://suivision.xyz/)

- [SuiScan](https://suiscan.xyz/mainnet/accounts)

:::danger

Data displayed on an explorer differs depending on which network you created your address on. If you've followed the [Configure a Sui Client](/guides/developer/getting-started/configure-sui-client.mdx) page previously, you are most likely using Testnet. Be sure to select Testnet on the Sui explorer or use the dedicated URL, such as https://**testnet**.suivision.xyz/.

:::

From the CLI, you can view all objects an address owns with the command:

```
$ sui client objects <ADDRESS>
```

If an address is not provided, this command returns all objects owned by the active address.

<div className="next-steps-module">
  <div className="next-steps-header">
    <h3>Next steps</h3>
  </div>
  <div className="next-steps-grid">
    <Card className="plausible-event-name=address+faucet+button"
      title="Get SUI from Faucet" 
      href="/guides/developer/getting-started/get-coins"
    >
      Obtain SUI from a faucet to deploy packages on Testnet.
    </Card>
        <Card className="plausible-event-name=address+hello+button"
      title="Hello, World!" 
      href="/guides/developer/getting-started/hello-world"
    >
      Clone and build the "Hello, World!" project.
    </Card>
  </div>
</div>

>>>> sui/docs/content/guides/developer/getting-started/get-coins.mdx
---
title: Get SUI from Faucet
description: Use the Sui faucet to obtain free SUI tokens for use on the Sui Devnet and Testnet networks. 
keywords: [ sui faucet, faucet, token faucet, sui devnet, sui testnet, devnet, testnet, get free tokens, free tokens ]
pagination_prev: null
pagination_next: null
---

To perform transactions on a Sui network, you need SUI tokens to pay for gas and storage. 

For applications on Mainnet, you must buy real SUI on exchanges like Coinbase, OKX, or Robinhood. Its value is determined by market factors such as supply and demand, network utility, and perceived value.

Because Mainnet tokens cost real money, development can be expensive. That's why Sui provides Devnet and Testnet networks, which mirror Mainnet features and enable you to build and test safely for an affordable cost.

:::important

SUI tokens on Devnet and Testnet are free and hold no monetary value.

:::

You can get free SUI tokens from the Sui faucet, which lets you deploy and interact with smart contracts and objects on Devnet, Testnet, or a local network. There is no faucet for Mainnet.

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install).

- [x] Set up your Sui account and CLI environment. 

<details className="nudge-details">

<summary>

Create Sui account and setup CLI environment.

</summary>

```sh
$ sui client
```

If this is the first time running the `sui client` CLI tool, it asks you to provide a Sui full node server URL (or press enter for the default Testnet), select an encryption scheme to generate an address, and stores the configuration in a `client.yaml` file. For more information, refer to the [Sui client CLI tutorial](/references/cli/client.mdx).

If this is not your first time running `sui client`, then you already have a `client.yaml` file in your local environment. If you'd like to create a new address for this tutorial, use the command:

```sh 
$ sui client new-address ed25519
```

</details>

</TabItem>
</Tabs>

## Request SUI tokens from faucet {#online-faucet}

Visit the online faucet to request SUI tokens: https://faucet.sui.io/

Then, follow these steps: 

1. Connect your wallet or paste your wallet address in the address field. Get your wallet address in the CLI with the command `sui client active-address`. 
1. Use the network dropdown to select the correct network: Testnet, Devnet, or Localnet. It is recommended to use the Testnet for most use cases before deploying to Mainnet for production. [Learn more](/guides/developer/getting-started/configure-sui-client.mdx) about the available networks and their differences. 
1. Click the **Request SUI** button. 

To request more SUI, refresh your browser and click the **Request SUI** button again. The requests are rate limited, however, so too many requests results in a waiting period before you are able to request more tokens.

### Community faucets 

You can also use the following community-provided faucets to obtain SUI tokens:

- http://faucet.n1stake.com/

- http://faucet.suilearn.io/

These faucets have their own separate limits, such as one request per day or one request every few hours.

### Verify token balance 

To check your balance of SUI tokens and confirm you received some from the faucet, use the command:

```
$ sui client balance 
```

Alternatively, use a Sui Explorer such as [SuiVision](https://suivision.xyz/) or [SuiScan](https://suiscan.xyz/mainnet/accounts) to check the SUI token balance of an address.

You should have a balance of SUI tokens:

```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Balance of coins owned by this address     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ coin       balance (raw)  balance      â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ Sui        56804696124     0.50 SUI    â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

If you do not have a balance, repeat the [request SUI tokens from faucet](#online-faucet) steps, or use an [alternative faucet method](#alternative-faucets).

### Return unused Testnet SUI

The faucet drains from a finite pool of SUI. If the pool empties, it disrupts faucet service for the rest of the community. To help ensure this doesn't happen, you can use the online faucet to return your unused SUI to the Testnet pool. You cannot return SUI to the Devnet or Localnet pools.

There are two ways to return unused Testnet SUI tokens:

- Connect your wallet to the online faucet, and click the **Return tokens to faucet** button. Approve the transaction using your wallet and your SUI tokens are returned to the pool.

- If you prefer not to connect your wallet, send the tokens to the address `0x7a9d19d4c210663926eb549da59a54e25777fef63161bfccda08277b58b4212e` via a [separate transaction](/guides/developer/sui-101/sign-and-send-txn.mdx).

## Alternative methods for getting SUI tokens {#alternative-faucets}

If you need an alternative method to get SUI tokens for deployment on Testnet or Devnet, you have several options.

:::tip

Every method to obtain SUI tokens for Testnet and Devnet is rate limited. If you need a large amount of SUI tokens, use a local network.

:::

<Tabs>

<TabItem value="discord" label="Discord">

1. Join [Discord](https://discord.gg/sui).
   
   If you try to join the Sui Discord channel using a newly created Discord account, you might need to wait a few days for validation.
1. Request SUI tokens in the Sui [#devnet-faucet](https://discord.com/channels/916379725201563759/971488439931392130) or [#testnet-faucet](https://discord.com/channels/916379725201563759/1037811694564560966) Discord channels. Send the following message to the channel, replacing `<YOUR SUI ADDRESS>` with your client address:
   ```sh
   !faucet <YOUR SUI ADDRESS>
   ```

</TabItem>
<TabItem value="curl" label="cURL">

Use the following cURL commands to set console variables and request tokens directly from the faucet server. Set `NETWORK` to either `testnet` or `devnet`.

```sh
$ ADDRESS=$(sui client active-address)
$ NETWORK=testnet
$ curl --location --request POST "https://faucet.${NETWORK}.sui.io/v2/gas" \
--header "Content-Type: application/json" \
--data-raw "{
    \"FixedAmountRequest\": {
        \"recipient\": \"${ADDRESS}\"
    }
}"
```

If you're working with a local network, replace `"https://faucet.${NETWORK}.sui.io/v2/gas"` with the appropriate value based on which package runs your network:

- `sui-faucet`: `http://127.0.0.1:5003/gas`
- `sui`: `http://127.0.0.1:9123/gas`

</TabItem>
<TabItem value="typescript" label="TypeScript SDK">

You can access the faucet using the [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript).

```typescript
import { getFaucetHost, requestSuiFromFaucetV2 } from '@mysten/sui/faucet';

// get tokens from the Devnet faucet server
await requestSuiFromFaucetV2({
	// connect to Devnet
	host: getFaucetHost('devnet'),
	recipient: '<YOUR SUI ADDRESS>',
});
```
</TabItem>
</Tabs>

## SUI tokens on a local network

If you are running a local Sui network, you can get SUI tokens from your local faucet. See the [Connect to a Local Network](/guides/developer/sui-101/local-network.mdx#use-the-local-faucet) topic for details.

<div className="next-steps-module">
  <div className="next-steps-header">
    <h3>Next steps</h3>
  </div>
  <div className="next-steps-grid">
        <Card className="plausible-event-name=faucet+hello+button"
      title="Hello, World!" 
      href="/guides/developer/getting-started/hello-world"
    >
      Clone and build the "Hello, World!" project.
    </Card>
    <Card className="plausible-event-name=faucet+apps+button"
      title="View More Example Apps" 
      href="/guides/developer/app-examples"
    >
      Clone and build the "Hello, World!" project.
    </Card>
  </div>
</div>

>>>> sui/docs/content/guides/developer/getting-started/hello-world.mdx
---
title: Hello, World!
description: Create and publish your first Move package using a basic 'Hello, World!' example.
keywords: [ first dapp, first package, move package, first move package, hello world, hello, world, what is move, what is a package, what is an object, move object, sui move object, sui move package, sui move module, move module, build package, publish package, call package, make call to package, how to call package ]
pagination_prev: null
pagination_next: null
---

You'll build a "Hello, World!" program to learn the fundamentals of programming on Sui. You create programs on Sui by writing and deploying smart contracts to the network.

The most basic unit of storage on Sui is an [_object_](/concepts/object-model.mdx). Other blockchains typically structure storage using key-value stores. Sui centers storage around objects with unique ID addresses on-chain. Every Sui smart contract is an object that manipulates other objects.

Objects can be immutable or mutable:

- **Immutable** objects cannot be transferred, changed, or deleted. No one owns them and anyone can access them publicly.

- **Mutable** objects can be transferred, changed, and deleted. A Sui address can own them, or they can be shared for public access.

Every object's unique ID and version number references it on-chain. Every transaction on the network takes objects as input, then reads, writes, and mutates the inputs to produce new or altered objects as output. Every object knows the hash of the transaction that produced it. 

When an object is modified by a transaction, the transaction's output writes the object's mutated contents to the same object ID but with a new version number. 

Sui has limits on the maximum transaction size (128KB) and number of objects (2,048) used in a transaction. For more information on limits, see [Building Against Limits](https://move-book.com/guides/building-against-limits/) in The Move Book.

## What is Move? 

[Move](/concepts/sui-move-concepts.mdx) is the programming language Sui uses to create smart contracts. It is platform agnostic and enables common libraries, tooling, and developer communities across blockchains with vastly different data and execution models. There are three ways to use Move in the context of Sui: Move packages, Move modules, and Move objects.

A Sui **Move package** is also referred to as a Move smart contract. It is a set of Move bytecode published to the Sui network. It is immutable and cannot be changed or removed, however you can upgrade it. Upgrading creates a new version of the package object on-chain, leaving the original intact. All prior versions of a package still exist on-chain. Once you publish it, other packages can import and use the modules it provides. Anyone can view a package's contents and use a Sui Explorer to see how its logic manipulates other objects. 

Every Move package on Sui includes one or more **Sui Move modules** that define the package's interaction with on-chain objects. A module's name is always unique within the package that contains it.

A Sui Move module governs a Sui **Move object**, which is typed data from a Sui Move package. Each Move object value is a struct with fields that can contain primitive types, such as integers and addresses, other objects, and non-object structs.

## Clone "Hello, World!"

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install.mdx).

- [x] [Configure the Sui client](/guides/developer/getting-started/configure-sui-client.mdx).

- [x] [Create a Sui address](/guides/developer/getting-started/get-address.mdx).

- [x] [Get SUI Testnet tokens](/guides/developer/getting-started/get-coins.mdx).

- [x] Download and install an IDE. The following are recommended, as they offer Move extensions:

    - [VSCode](https://code.visualstudio.com/), corresponding [Move extension](https://marketplace.visualstudio.com/items?itemName=mysten.move)

    - [Emacs](https://www.gnu.org/software/emacs/), corresponding [Move extension](https://github.com/amnn/move-mode)

    - [Vim](https://www.vim.org/download.php), corresponding [Move extension](https://github.com/yanganto/move.vim)

    - [Zed](https://zed.dev/), corresponding [Move extension](https://github.com/Tzal3x/move-zed-extension)
    
        Alternatively, you can use the [Move web IDE](https://www.playmove.dev/), which does not require a download. It does not support all functions necessary for this guide, however.

- [x] [Download and install Git](https://git-scm.com/downloads).

</TabItem>
</Tabs>

To demonstrate creating objects, packages, and how to build your first Sui application, start by cloning the "Hello, World!" example:

```
$ git clone \
  https://github.com/MystenLabs/sui-stack-hello-world.git
$ cd sui-stack-hello-world/move/hello-world
```

In this project, there are two important files that define the package's logic, information, and its dependencies:

- `move/hello-world/sources/greeting.move`: Defines the package's logic. In this example, it defines a basic shared greeting object and public functions to interact with it. 

- `move/hello-world/Move.toml`: The package's configuration file that defines the package name, dependencies, and addresses.

<details>

<summary>`move/hello-world/Move.toml`</summary>

<ImportContent source="/move/hello-world/Move.toml" mode="code" org="MystenLabs" repo="sui-stack-hello-world" />

</details>

### View the smart contract code 

Open the `greeting.move` file in your IDE of choice. You can see the following Move code:

<ImportContent source="/move/hello-world/sources/greeting.move" mode="code" org="MystenLabs" repo="sui-stack-hello-world" />

### Code explanation 

First, this code defines a module called `greeting`:

```move 
module hello_world::greeting {
  use std::string;
  ...
}
```

Then, it defines a public struct called `Greeting` that contains a unique object ID and text. A struct is a type of _resource_:

<ImportContent source="/move/hello-world/sources/greeting.move" mode="code" struct="Greeting" org="MystenLabs" repo="sui-stack-hello-world" />

Then, it defines the function `new` that makes an API call to the `Greeting` struct and initializes it with the text `"Hello world!"`, storing it in a new shared object:

<ImportContent source="/move/hello-world/sources/greeting.move" mode="code" fun="new" org="MystenLabs" repo="sui-stack-hello-world" />

Lastly, the package defines a function called `update_text` that can be called to update the text stored in `Greeting`:

<ImportContent source="/move/hello-world/sources/greeting.move" mode="code" fun="update_text" org="MystenLabs" repo="sui-stack-hello-world" />

### Resource safety 

A unique aspect of programming applications on Sui is the resource safety enforced by the Move Bytecode Verifier. Move packages must satisfy the following resource safety parameters:

- All resources must be either moved into global storage or destroyed by the end of a transaction. 

- Resources cannot be copied. 

In the "Hello, World!" example, the struct `Greeting` is a resource type. 

To satisfy the requirement that all resources must be moved or destroyed by the end of a transaction, `Greeting` is assigned to `new_greeting`, which the call to `transfer::share_object(new_greeting)` then moves into global storage.

To mutate `Greeting`, the function `update_text` takes the input `(&mut Greeting)` rather than the resource itself. This function satisfies resource safety as the function does not copy the resource and mutates it via a reference.

[Learn more](https://github.com/MystenLabs/sui/blob/main/external-crates/move/move-execution/v1/crates/move-bytecode-verifier/README.md) about the Move Bytecode Verifier.

#### How does this differ from EVM applications?

The Ethereum Virtual Machine adopts a gas-based resource safety strategy. Every opcode on an EVM chain has an associated gas price that makes transactions costly, preventing the network from running a single transaction indefinitely. 

## Build the Move package 

Before you can publish a Move package to the network, you must first build it. Building your package is necessary because the `.move` source file is a human-readable piece of code, while the network can only understand bytecode.

To build your "Hello, World!" package, first confirm your working directory is `~/sui-stack-hello-world/move/hello-world`, then run the following command:

```
$ sui move build 
```

The build process fetches and compiles the dependencies defined in the `Move.toml` file. The Move compiler checks your `.move` code for type errors, syntax errors, and enforces [resource safety](#resource-safety), then translates your `.move` code into bytecode that Sui can execute.

:::info 

You must build your package before you can publish it, but also before you test it. You cannot run tests (`sui move test`) on your code until it has been built.

:::

## Publish the Move package 

Now that your package has been built, you need to publish it. After you publish it, other packages and users can use the package's modules and functions by making calls to the package ID.

First, confirm your client is configured to use Testnet as the active environment:

```
$ sui client active-env
```

This should return `testnet`. If it does not return `testnet`, follow the [client configuration instructions](/guides/developer/getting-started/configure-sui-client.mdx) before continuing.

Then, check your balance of SUI tokens to confirm you have enough to publish to Testnet:

```
$ sui client balance 
```

You should have a balance of SUI tokens:

```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Balance of coins owned by this address     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ coin       balance (raw)  balance      â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ Sui        56804696124     0.50 SUI    â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

If you do not have a balance, follow the [SUI faucet instructions](/guides/developer/getting-started/get-coins.mdx).

Now, publish the package to Testnet with the command:

```
$ sui client publish 
```

<details>

<summary>Output</summary>

```
Transaction Digest: 8R39iKKLGPDG3QkW2SrRW3QX71csRP2BLhK9H7oz9SwW
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Data                                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sender: 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803                                   â”‚
â”‚ Gas Owner: 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803                                â”‚
â”‚ Gas Budget: 9843200 MIST                                                                                     â”‚
â”‚ Gas Price: 1000 MIST                                                                                         â”‚
â”‚ Gas Payment:                                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                                         â”‚
â”‚  â”‚ ID: 0x816e5ec6ff457f18232498b57af8a0e1e219307a3a43fb5df5a4c2198296510c                                    â”‚
â”‚  â”‚ Version: 591332925                                                                                        â”‚
â”‚  â”‚ Digest: FLC4NXntT7WiHcqCkpDuBUq14DFTfi3EFeUiJcSNHdPu                                                      â”‚
â”‚  â””â”€â”€                                                                                                         â”‚
â”‚                                                                                                              â”‚
â”‚ Transaction Kind: Programmable                                                                               â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ Input Objects                                                                                            â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ 0   Pure Arg: Type: address, Value: "0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803" â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                  â”‚
â”‚ â”‚ Commands                                                                â”‚                                  â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                  â”‚
â”‚ â”‚ 0  Publish:                                                             â”‚                                  â”‚
â”‚ â”‚  â”Œ                                                                      â”‚                                  â”‚
â”‚ â”‚  â”‚ Dependencies:                                                        â”‚                                  â”‚
â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000001 â”‚                                  â”‚
â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000002 â”‚                                  â”‚
â”‚ â”‚  â””                                                                      â”‚                                  â”‚
â”‚ â”‚                                                                         â”‚                                  â”‚
â”‚ â”‚ 1  TransferObjects:                                                     â”‚                                  â”‚
â”‚ â”‚  â”Œ                                                                      â”‚                                  â”‚
â”‚ â”‚  â”‚ Arguments:                                                           â”‚                                  â”‚
â”‚ â”‚  â”‚   Result 0                                                           â”‚                                  â”‚
â”‚ â”‚  â”‚ Address: Input  0                                                    â”‚                                  â”‚
â”‚ â”‚  â””                                                                      â”‚                                  â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                  â”‚
â”‚                                                                                                              â”‚
â”‚ Signatures:                                                                                                  â”‚
â”‚    mUxqMIofPq+yIzPxxYM+2mSIPTFneDxhWGGxJ7tM02hnRBRy5/FosnnWKxd4OSAjmaw6FNylwVdqUoUlJSxWCQ==                  â”‚
â”‚                                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: 8R39iKKLGPDG3QkW2SrRW3QX71csRP2BLhK9H7oz9SwW                                              â”‚
â”‚ Status: Success                                                                                   â”‚
â”‚ Executed Epoch: 875                                                                               â”‚
â”‚                                                                                                   â”‚
â”‚ Created Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x136e41f505888066f189fb823d710ec96ab4fd75144b3d8008b91d58de85fd12                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803 )  â”‚
â”‚  â”‚ Version: 591332926                                                                             â”‚
â”‚  â”‚ Digest: BGfc1tihsYPTLLozrj58HmRkDeQ1DWZfqeaR4SZDb1cX                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xa7ed855d30500c485a94c0849f70b508d6b6adf6b0767ab93cc0756c075ecbb1                         â”‚
â”‚  â”‚ Owner: Immutable                                                                               â”‚
â”‚  â”‚ Version: 1                                                                                     â”‚
â”‚  â”‚ Digest: EtGAG9RHHCsguX4iuX1cbRDvW4QAkJXgDCMJjiufHtxB                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Mutated Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x816e5ec6ff457f18232498b57af8a0e1e219307a3a43fb5df5a4c2198296510c                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803 )  â”‚
â”‚  â”‚ Version: 591332926                                                                             â”‚
â”‚  â”‚ Digest: CiU5KNZALUmuckc2YUFmJq5YXgbB8oG3rs4cnh2rdDXd                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Object:                                                                                       â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x816e5ec6ff457f18232498b57af8a0e1e219307a3a43fb5df5a4c2198296510c                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803 )  â”‚
â”‚  â”‚ Version: 591332926                                                                             â”‚
â”‚  â”‚ Digest: CiU5KNZALUmuckc2YUFmJq5YXgbB8oG3rs4cnh2rdDXd                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Cost Summary:                                                                                 â”‚
â”‚    Storage Cost: 7843200 MIST                                                                     â”‚
â”‚    Computation Cost: 1000000 MIST                                                                 â”‚
â”‚    Storage Rebate: 978120 MIST                                                                    â”‚
â”‚    Non-refundable Storage Fee: 9880 MIST                                                          â”‚
â”‚                                                                                                   â”‚
â”‚ Transaction Dependencies:                                                                         â”‚
â”‚    2dkJtqsoQcyCZJvjZnskNVPQeynwVtwCcA9goAru6tTi                                                   â”‚
â”‚    7PStztXyh92keJmrDD1aghHaKVdgCoVkVx4ZmLUfmQeK                                                   â”‚
â”‚    Dd9pn1zFcSJjinxQewFd2gQdR4XKsHxFioD5MYnwLZQz                                                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ No transaction block events â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Created Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0x136e41f505888066f189fb823d710ec96ab4fd75144b3d8008b91d58de85fd12                  â”‚
â”‚  â”‚ Sender: 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803 ) â”‚
â”‚  â”‚ ObjectType: 0x2::package::UpgradeCap                                                          â”‚
â”‚  â”‚ Version: 591332926                                                                            â”‚
â”‚  â”‚ Digest: BGfc1tihsYPTLLozrj58HmRkDeQ1DWZfqeaR4SZDb1cX                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚ Mutated Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0x816e5ec6ff457f18232498b57af8a0e1e219307a3a43fb5df5a4c2198296510c                  â”‚
â”‚  â”‚ Sender: 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803 ) â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    â”‚
â”‚  â”‚ Version: 591332926                                                                            â”‚
â”‚  â”‚ Digest: CiU5KNZALUmuckc2YUFmJq5YXgbB8oG3rs4cnh2rdDXd                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚ Published Objects:                                                                               â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ PackageID: 0xa7ed855d30500c485a94c0849f70b508d6b6adf6b0767ab93cc0756c075ecbb1                 â”‚
â”‚  â”‚ Version: 1                                                                                    â”‚
â”‚  â”‚ Digest: EtGAG9RHHCsguX4iuX1cbRDvW4QAkJXgDCMJjiufHtxB                                          â”‚
â”‚  â”‚ Modules: greeting                                                                             â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Balance Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ Owner: Account Address ( 0x9ac241b2b3cb87ecd2a58724d4d182b5cd897ad307df62be2ae84beddc9d9803 )  â”‚
â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
â”‚  â”‚ Amount: -7865080                                                                               â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

</details>

When you publish a Move package to the network, the network uploads and stores the bytecode as a Move package with a unique package ID and version number. The network consumes SUI tokens as gas and processes the transaction on-chain.

After successfully executing, the output provides details about the transaction used to publish the package, including the gas cost, transaction digest, dependencies, owner, and sender. 

For this guide, the most important section is **Published Objects**, which includes the package's ID, version, and its modules:

```
â”‚ Published Objects:                                                                               â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ PackageID: 0xa7ed855d30500c485a94c0849f70b508d6b6adf6b0767ab93cc0756c075ecbb1                 â”‚
â”‚  â”‚ Version: 1                                                                                    â”‚
â”‚  â”‚ Digest: EtGAG9RHHCsguX4iuX1cbRDvW4QAkJXgDCMJjiufHtxB                                          â”‚
â”‚  â”‚ Modules: greeting                                                                             â”‚
â”‚  â””â”€â”€     
```

Both the package ID and module are required to interact with the package from the command line. Take note of both values for future use in the [Connecting a Frontend](/guides/developer/getting-started/app-frontends.mdx) guide.

## Interact with the Move package

Interact with the newly published package by first making a call to the `new` function that creates a new `Greeting` object and initialize it with the text `"Hello world!"`:

```
$ sui client call --package <PACKAGE_ID> --module greeting --function new  
```

Replace `<PACKAGE_ID>` with the package ID the output of the `sui client publish` command returned. You must include the `--package`, `--module`, and `--function` flags. 

The output of this call includes a newly created object:

```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: 6xB9Foy5vyhXG99xppaCxrNvpPTV3UZsH39zqUKNoGsD                                              â”‚
â”‚ Status: Success                                                                                   â”‚
â”‚ Executed Epoch: 875                                                                               â”‚
â”‚                                                                                                   â”‚
â”‚ Created Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x2834aa3d2ed1b5060f4e5d400092544fa9c95430fd894b139b7dfb0312501594                         â”‚
â”‚  â”‚ Owner: Shared( 591332927 )                                                                     â”‚
â”‚  â”‚ Version: 591332927                                                                             â”‚
â”‚  â”‚ Digest: 8xJRijHHp3gNXLExTG98KX5jYAQDVKqsBD8ATFMJXCbA                                           â”‚
â”‚  â””â”€â”€                               
...                       
```

To verify that the object contains the text `"Hello world!"`, make a call to query the object's information:

```
$ sui client object <OBJECT_ID>
```

Replace `<OBJECT_ID>` with the value under `Created Objects, ID:`.

You should see the object's details, including a value of `text: Hello world!`:

```
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ objectId      â”‚  0x2834aa3d2ed1b5060f4e5d400092544fa9c95430fd894b139b7dfb0312501594                                              â”‚
â”‚ version       â”‚  591332927                                                                                                       â”‚
â”‚ digest        â”‚  8xJRijHHp3gNXLExTG98KX5jYAQDVKqsBD8ATFMJXCbA                                                                    â”‚
â”‚ objType       â”‚  0xa7ed855d30500c485a94c0849f70b508d6b6adf6b0767ab93cc0756c075ecbb1::greeting::Greeting                          â”‚
â”‚ owner         â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                                            â”‚
â”‚               â”‚ â”‚ Shared â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚                                                            â”‚
â”‚               â”‚ â”‚        â”‚ â”‚ initial_shared_version â”‚  591332927  â”‚ â”‚                                                            â”‚
â”‚               â”‚ â”‚        â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚                                                            â”‚
â”‚               â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                                            â”‚
â”‚ prevTx        â”‚  6xB9Foy5vyhXG99xppaCxrNvpPTV3UZsH39zqUKNoGsD                                                                    â”‚
â”‚ storageRebate â”‚  1413600                                                                                                         â”‚
â”‚ content       â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚               â”‚ â”‚ dataType          â”‚  moveObject                                                                              â”‚ â”‚
â”‚               â”‚ â”‚ type              â”‚  0xa7ed855d30500c485a94c0849f70b508d6b6adf6b0767ab93cc0756c075ecbb1::greeting::Greeting  â”‚ â”‚
â”‚               â”‚ â”‚ hasPublicTransfer â”‚  false                                                                                   â”‚ â”‚
â”‚               â”‚ â”‚ fields            â”‚ â•­â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ â”‚
â”‚               â”‚ â”‚                   â”‚ â”‚ id   â”‚ â•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ â”‚ â”‚
â”‚               â”‚ â”‚                   â”‚ â”‚      â”‚ â”‚ id â”‚  0x2834aa3d2ed1b5060f4e5d400092544fa9c95430fd894b139b7dfb0312501594  â”‚ â”‚ â”‚ â”‚
â”‚               â”‚ â”‚                   â”‚ â”‚      â”‚ â•°â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚ â”‚ â”‚
â”‚               â”‚ â”‚                   â”‚ â”‚ text â”‚  Hello world!                                                                 â”‚ â”‚ â”‚
â”‚               â”‚ â”‚                   â”‚ â•°â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚ â”‚
â”‚               â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Important transaction considerations 

You cannot send 2 or more transactions simultaneously, otherwise you encounter an error such as:

```
Failed to sign transaction by a quorum of validators because one or more of its objects is reserved for another transaction.
```

If you receive this error, you must wait until the current epoch is over before submitting your transaction again. You can see how long is left in the current epoch using [Sui Explorer](https://suivision.xyz/) or another network explorer like [SuiScan](https://suiscan.xyz/mainnet/home). 

To prevent the same object from being modified by multiple transactions at once, your address 'locks' the object to prevent conflicting modifications. If you'd like to batch multiple transaction commands together, you can use [programmable transaction blocks](/concepts/transactions/prog-txn-blocks.mdx).

Transactions also have limitations regarding total size, number of objects, and number of inputs. Learn more about limitations in [Building Against Limits](https://move-book.com/guides/building-against-limits/) in The Move Book.

<div className="next-steps-module">
  <div className="next-steps-header">
    <h3>Next steps</h3>
  </div>
  <div className="next-steps-grid">
      <Card className="plausible-event-name=hello+frontend+button"
      title="Create a Full Stack dApp" 
      href="/guides/developer/getting-started/app-frontends"
    >
      Connect a frontend interface to your "Hello, World!" smart contract.
    </Card>
    <Card className="plausible-event-name=hello+data+button"
      title="Access Sui Data" 
      href="/guides/developer/sui-101/data-serving"
    >
      Learn more about accessing data on Sui.
    </Card>
    <Card className="plausible-event-name=hello+community+button"
      title="Join the Community" 
      href="/guides/developer/getting-started/next-steps"
    >
      Join the Sui developer community, try out other example projects, or read more documentation.
    </Card>
  </div>
</div>

>>>> sui/docs/content/guides/developer/getting-started/install-binaries.mdx
---
title: Install from Binaries
description: Each Sui release provides a set of binaries for several operating systems. You can download these binaries from GitHub and use them to install Sui.
keywords: [ install sui, install sui binaries, binaries ]
---

<ImportContent source="info-easy-install" mode="snippet" />

Each Sui release provides a set of binaries for several operating systems. You can download these binaries from GitHub and use them to install Sui.

<Tabs groupId="operating-systems">

<TabItem value="linux" label="Linux">

1. Go to https://github.com/MystenLabs/sui.
1. In the right pane, find the **Releases** section.

    ![Sui releases in GitHub](./images/releases.png)
1. Click the release tagged **Latest** to open the release's page.
1. In the **Assets** section of the release, select the .tgz compressed file that corresponds to your operating system.
1. Extract all files from the .tgz file into the preferred location on your system. These instructions assume you extract the files into a `sui` folder at the user root of your system for demonstration purposes. Replace references to this location in subsequent steps if you choose a different directory.
1. Navigate to the expanded folder. You should have the following extracted files:

    <ImportContent source="lists/binaries-file-list.mdx" mode="snippet" />

1. Add the folder containing the extracted files to your `PATH` variable. To do so, you can update your `~/.bashrc` to include the location of the Sui binaries. If using the suggested location, you type `export PATH=$PATH:~/sui` and press Enter.
1. Start a new terminal session or type `source ~/.bashrc` to load the new `PATH` value.

</TabItem>

<TabItem value="mac" label="macOS">

1. Go to https://github.com/MystenLabs/sui.
1. In the right pane, find the **Releases** section.

    ![Sui releases in GitHub](./images/releases.png)
1. Click the release tagged **Latest** to open the release's page.
1. In the **Assets** section of the release, select the .tgz compressed file that corresponds to your operating system.
1. Extract all files from the .tgz file into the preferred location on your system. These instructions assume you extract the files into a `sui` folder at the user root of your system. Replace references to this location in subsequent steps if you choose a different directory.
1. Navigate to the expanded folder. You should have the following extracted files:

    <ImportContent source="lists/binaries-file-list.mdx" mode="snippet" />

1. Add the folder containing the extracted files to your `PATH` variable. To do so, you can update your `~/.zshrc` or `~/.bashrc` to include the location of the Sui binaries. If using the suggested location, you type `export PATH=$PATH:~/sui` and press Enter.
1. Start a new console session or type `source ~/.zshrc` (or `.bashrc`) to load the new `PATH` value.
1. If running the binaries for the first time, you might receive an error from MacOS that prevents the binaries from running. If you receive this error, close the dialog and type `xattr -d com.apple.quarantine ~/sui/*` in your console and press <kbd>Enter</kbd> (be sure to adjust the path if different).

</TabItem>

<TabItem value="win" label="Windows">

1. Go to https://github.com/MystenLabs/sui.
1. In the right pane, find the **Releases** section.

    ![Sui releases in GitHub](./images/releases.png)
1. Click the release tagged **Latest** to open the release's page.
1. In the **Assets** section of the release, select the .tgz compressed file that corresponds to your operating system.
1. Extract all files from the .tgz file into the preferred location on your system. These instructions assume you extract the files into a `sui` folder at the root of your C drive. Replace references to this location in subsequent steps if you choose a different directory.

    :::info

    Windows does not natively support .tgz files, but you can use a free compressed file app like [7Zip](https://7-zip.org/) to extract.

    :::

1. Navigate to the expanded folder. You should have the following extracted files:

    <ImportContent source="lists/binaries-file-list.mdx" mode="snippet" />

1. Add the folder containing the extracted files to your `PATH` variable. There are several ways to get to the setting depending on your version of Windows. One way that works on all versions of Windows is to type `sysdm.cpl` in a console to open the System Properties window. Under the **Advanced** tab, click the **Environment Variables...** button.
1. In the Environment Variables window, select the `Path` variable and click the **Edit...** button.
1. In the Edit environment variable window, click **New** and add the path to your expanded folder. Using the example path, this would be `C:\sui`.
1. Click **OK**.

</TabItem>

</Tabs>

## Build binaries locally

You can download the Sui repo and build the binaries locally. The binaries are exported to the `target/release` directory.
    
```sh
$ cargo build --profile release --bin sui
```

Include other packages as needed.

<ImportContent source="lists/binaries-file-list.mdx" mode="snippet" />

## Upgrade from Cargo

If you previously installed the Sui binaries, you can update them to the most recent release with the same command you used to install them (changing `testnet` to the desired branch):

```sh
$ cargo install --locked --git https://github.com/MystenLabs/sui.git --branch testnet sui --features tracing
```

:::info

The `tracing` feature enables Move test coverage and debugger support in the Sui CLI. These features are not available unless you enable tracing.

:::

## Install `sui-node` for Ubuntu from AWS {#aws-sui-node}

<ImportContent source="install-sui-node.mdx" mode="snippet" />

## Related links

<RelatedLink to="/guides/developer/getting-started/sui-install.mdx" />
<RelatedLink to="/guides/developer/getting-started/install-source.mdx" />

>>>> sui/docs/content/guides/developer/getting-started/install-source.mdx
---
title: Install from Source
description: Install the Sui framework from source, either locally or directly from GitHub.
keywords: [ install sui, how to install sui, install sui cli, sui command line interface, install from source, source install ]
hide_table_of_contents: true
---

<ImportContent source="info-easy-install" mode="snippet" /> 

You can install Sui from source, either locally or directly from GitHub. At minimum, you will need Rust and Cargo installed for the Sui framework: 

- [x] Download and install Rust: 
  <div className="pl-8">
    ```sh
    $ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    ```

    If you have Rust installed, update to the latest version: 
  
    ```sh
    $ rustup update stable
    ```
  </div>
- [x] Download and install Cargo:
  <div className="pl-8">
    ```sh
    $ curl https://sh.rustup.rs -sSf | sh
    ```
  </div>
  
  Depending on your operating system, you may require additional prerequisites.

<details>
<summary>
Additional prerequisites
</summary>
<ImportContent source="install-prereqs.mdx" mode="snippet" />
</details>

You can install from source either directly from GitHub or from your local drive. Regardless of which install from source method you use, the Sui components are found in the `~/.cargo/bin` folder.

You can also download the [source code](/references/contribute/sui-environment) to locally access files.

<Tabs>

<TabItem label="GitHub source" value="github">

Use Cargo to install Sui directly from the GitHub repo: 

```sh
$ cargo install --locked --git https://github.com/MystenLabs/sui.git --branch testnet sui --features tracing
```

:::info

The tracing feature enables Move test coverage and debugger support in the Sui CLI. These features are not available unless you enable tracing.

:::

Replace the `testnet` branch in the previous command if necessary. Available options are:

    - `main`: Latest updates. Least stable.
    - `devnet`: Includes experimental features.
    - `testnet`: Includes beta features.
    - `mainnet`: Stable release.

You can build and install additional packages as needed. Replace `sui` in the previous command with the package name in the following table.

<ImportContent source="lists/binaries-file-list.mdx" mode="snippet" />

</TabItem>

<TabItem label="Local source" value="local">

You can clone the public Sui repo and install from source on your local machine.

1. Fork the [Sui repo](https://github.com/MystenLabs/sui).

1. Use a console to clone the fork to the desired directory. 

    ```sh
    $ git clone https://github.com/YourOrg/sui.git
    ```
1. Navigate to the repo directory and switch to the branch you want to build against.

    - `main`: Latest updates. Least stable.
    - `devnet`: Includes experimental features.
    - `testnet`: Includes beta features.
    - `mainnet`: Stable release.

    ```sh
    $ git switch testnet
    ```

1. Run the `cargo install` command from the repo root.

    ```sh
    $ cargo install --locked --path crates/sui --features tracing
    ```

:::info

The tracing feature enables Move test coverage and debugger support in the Sui CLI. These features are not available unless you enable tracing.

:::

</TabItem>

</Tabs>

## Related links

<RelatedLink to="/guides/developer/getting-started/sui-install.mdx" />
<RelatedLink to="/guides/developer/getting-started/install-binaries.mdx" />

>>>> sui/docs/content/guides/developer/getting-started/next-steps.mdx
---
title: Next Steps
description: To continue your journey building on Sui, you can review other documentation, join the community of other Sui builders, or check out the Awesome Sui repo.
keywords: [ next steps, now what, sui community, developer help, builder help ]
---

If you have followed the Getting Started path, you should be ready to continue your journey on Sui. This page details how to continue learning, additional resources, and ways to join the developer community. 

<details>

<summary>Verify "Getting Started" essentials</summary>

To make sure you have everything you need, paste the following commands into a console in your local environment:

```sh
$ sui --version
$ sui client active-address
$ sui client active-env
$ sui client gas
```

If all commands are successful, your console displays output similar to the following:

```sh
sui [version_number]-[commit_hash]
0x6543...7241
testnet
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ gasCoinId     â”‚ mistBalance (MIST) â”‚ suiBalance (SUI) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0x1e86...63b2 â”‚ 5041161576         â”‚ 5.04             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

If you receive an error, revisit the content relevant to the command that caused the error or lacked output.

| Command | Successful if |
| ------- | -------------- |
| `sui --version` | You [installed Sui](/guides/developer/getting-started/sui-install.mdx) correctly. |
| `sui client active-address` | You have a [Sui address](/guides/developer/getting-started/get-address.mdx) that is currently active. |
| `sui client active-env` | You have set up a [connection to Testnet](/guides/developer/getting-started/configure-sui-client.mdx) that is currently active. |
| `sui client objects` | You address owns [SUI for testing](/guides/developer/getting-started/get-coins.mdx). |

</details>

## Continue learning

Check out the [Counter example dApp](/guides/developer/app-examples/e2e-counter.mdx) to continue your learning and build a full-stack Sui app. 


## Additional documentation

The rest of the documentation on this site contains important concepts, guides, and examples for you to continue your Sui journey. There are also resources beyond this documentation that you can reference, as well as a large and growing community whose experience and knowledge you can leverage to get the most out of Sui. 

### SDK documentation

Mysten Labs, the company that initiated the creation of Sui, provides SDKs to interact with the network and associated assets. Visit the [SDK docs](https://sdk.mystenlabs.com/typescript) to learn more.

### The Move Book

Move is the language of smart contracts on Sui. [The Move Book](https://move-book.com/) details the language.

## Connect with the Sui community

- Join the [Sui Discord](https://discord.gg/sui) 
- Join **Suinami Riders** on [Telegram](https://web.telegram.org/z/?ref=blog.sui.io#-1742460518)
- Checkout the [Sui Developer Forum](https://forums.sui.io/)
- Follow [@SuiFoundation](https://twitter.com/@SuiFoundation) on X

### Schedule office hours 

[Sign up](https://cal.com/forms/08983b87-8001-4df6-896a-0d7b60acfd79) for 1:1 sessions to get developer support or advice from the Sui team.

### Awesome Sui

The [Awesome Sui](/references/awesome-sui.mdx) repo is a curated list of developer tools and infrastructure projects within the Sui ecosystem. 

### Upcoming hackathons 

Check out [upcoming hackathon events](https://sui.io/ecosystem-hub) to build applications alongside other developers. 

### Developer newsletter

Sign up for the [Sui Developer Newsletter](https://sui.io/dev-newsletter) to receive hyperfocused content to help you build on Sui.

### Developer portal

Visit the [Sui Developer Portal](https://sui.io/developers) to find links to courses, videos, and other learning resources.

>>>> sui/docs/content/guides/developer/getting-started/sui-install.mdx
---
title: Install Sui
description: Install the Sui framework and its required prerequisites on your system.
keywords: [ install sui, how to install sui, install sui cli, interact with sui networks, connect to sui networks, sui command line interface ]
pagination_prev: null
pagination_next: null
---

# Install Sui

Sui is a scalable and performant layer-1 blockchain that is home to a complete stack of native primitives ideal for building decentralized applications. Such primitives, such as those for [encryption](https://seal-docs.wal.app/UsingSeal/), [data storage](https://docs.wal.app/usage/setup.html), verification, and access control, provide developers with every piece of the application stack without needing to use layer-2 chains or off-chain solutions. 

In contrast to other chains, Sui uses an [object-centric model](/concepts/object-model.mdx), where every item on the network is an object. [Transactions](/concepts/transactions.mdx) use objects as input, which mutate an existing object or create new objects. Each object has a unique on-chain ID.

To create objects, submit transactions, and start building an application on Sui, first you must install Sui. This installation includes the [Sui CLI](/references/cli.mdx), a tool that creates and manages address balances, builds and publishes smart contracts, and queries information from the network. 

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] Have a machine with one of the following supported operating systems:
    - Linux: Ubuntu version 22.04 (Jammy Jellyfish) or newer
    - macOS: macOS Monterey or newer
    - Microsoft Windows: Windows 10 or 11

</TabItem>
</Tabs>

## Quick install 

The Sui CLI is used to interact with the Sui network, deploy packages, and manage assets. To install the Sui CLI, you can use [`suiup`](https://github.com/MystenLabs/suiup).

[`suiup`](https://github.com/MystenLabs/suiup) is the most effective installation method, as it allows you to easily install and switch between different versions of not only the Sui CLI but also other Sui stack components like [`walrus`](https://docs.wal.app/usage/setup.html) and [`mvr`](https://github.com/MystenLabs/mvr). 

Alternative quick install instructions for [Homebrew](https://brew.sh/) or [Chocolately](https://chocolatey.org/) do not support installing other Sui stack components. Other components will need to be installed through their individual binaries if you'd like to use them in the future. 

:::caution 

Installations using Homebrew or Chocolatey might take several minutes if you do not have any of the [Sui prerequisites](/guides/developer/getting-started/install-source) installed. Using `suiup` is often much faster and highly recommended.

:::

<ImportContent source="quick-install.mdx" mode="snippet" />

The quick install is suitable for most use cases. For those wanting more control over the installation process, you can [install from source](/guides/developer/getting-started/install-source.mdx) or [install binaries](/guides/developer/getting-started/install-binaries.mdx). 

If Sui is already installed from a previous development environment, be sure to upgrade to the [latest version](/guides/developer/getting-started/install-binaries.mdx).

:::info Looking for a project to clone?

Before you can create and publish a smart contract, you must [configure a Sui client](/guides/developer/getting-started/configure-sui-client.mdx) and [obtain SUI tokens](/guides/developer/getting-started/get-coins.mdx).

Then, you can [create a "Hello, World!" example](/guides/developer/getting-started/hello-world.mdx) or [clone another example](/guides/developer/app-examples.mdx) to start building.

:::

## Installation details 

Regardless of using `suiup`, Homebrew, or Chocolately, your Sui installation will include the following packages:

<ImportContent source="lists/binaries-file-list.mdx" mode="snippet" />

### `suiup` installation details 

`suiup` copies the binaries to `$HOME/.local/bi`n by default on macOS and Linux systems by default, unless the `SUIUP_DEFAULT_BIN_DIR` environment variable has been set. macOS and Linux installations also include environment variables for `XDG_DATA_HOME`, `XDG_CACHE_HOME`, and `XDG_CONFIG_HOME`.

On Windows, `suiup` copies the binaries to `LOCALAPPDATA\bin`, and will use `LOCALAPPDATA` or `USERPROFILE\AppData\Local` for storing data and `TEMP` or `USERPROFILE\AppData\Local\Temp` for caching.

### Default configuration file

Regardless of whether you used `suiup`, Homebrew, or Chocolately, Sui will store a primary configuration in the `~/.sui/sui_config/client.yaml` file. This file defines settings and preferences for your environment, such as:

- Network environment details for Mainnet, Testnet, Devnet, and Localnet networks.

- Active environment, which specifies the network the CLI commands will target.

- Active address, which specifies the Sui address the CLI will use for transactions and queries.

- Keystore location, which specifies where Sui stores your address' private keys.

<div className="next-steps-module">
  <div className="next-steps-header">
    <h3>Next steps</h3>
  </div>
  <div className="next-steps-grid">
    <Card className="plausible-event-name=install+client+button"
      title="Configure a Sui Client" 
      href="/guides/developer/getting-started/configure-sui-client"
    >
      Configure a Sui client to get a Sui address and connect to Testnet.
    </Card>
    <Card className="plausible-event-name=install+faucet+button"
      title="Get SUI from Faucet" 
      href="/guides/developer/getting-started/get-coins"
    >
      Obtain SUI from a faucet to deploy packages on Testnet.
    </Card>
        <Card className="plausible-event-name=install+hello+button"
      title="Hello, World!" 
      href="/guides/developer/getting-started/hello-world"
    >
      Clone the "Hello, World!" project.
    </Card>
  </div>
</div>
>>>> sui/docs/content/guides/developer/getting-started/sui-wallets.mdx
---
title: SUI Wallets
description: placeholder
keywords: [ placeholder ]
draft: true
---

Unlike the CLI option used in [Obtain a Sui Address](/guides/developer/getting-started/get-address), wallets connected to the Sui network provide visual workflows that might be preferable to some users. 

The following Chrome extension wallets integrate with your browser and have a UI workflow that walks you through the process of creating an address. Consult documentation for your chosen extension for the exact process of obtaining an address.

:::info

Links to these extensions are provided for your convenience. Their inclusion is not an endorsement, recommendation, or approval of any kind. Perform your own due diligence before making a decision on what extension to use.

:::

- [Slush â€” A Sui wallet](https://chromewebstore.google.com/detail/sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil): Formerly known as Sui Wallet, Slush is a wallet from the same team that built Sui - Mysten Labs.
- [Suiet | Sui Wallet](https://chromewebstore.google.com/detail/suiet-sui-wallet/khpkpbbcccdmmclmpigdgddabeilkdpd): The Suiet wallet for everyone, built on the Sui blockchain. 
- [Glass wallet](https://chromewebstore.google.com/detail/glass-wallet-sui-wallet/loinekcabhlmhjjbocijdoimmejangoa): Glass Wallet is a non-custodial wallet that allows you to control your coins, keys, and NFT securely.
- [Martian Aptos & Sui Wallet Extension](https://chromewebstore.google.com/detail/martian-aptos-sui-wallet/efbglgofoippbgcjepnhiblaibcnclgk): Martian is a self-custodial crypto wallet for Aptos and Sui.
- [Surf Wallet](https://chromewebstore.google.com/detail/surf-wallet/emeeapjkbcbpbpgaagfchmcgglmebnen): Surf Wallet is a platform that allows for convenient and secure transfer of tokens and collection of NFTs on the blockchain.
- Visit the [chrome web store](https://chromewebstore.google.com/search/sui%20wallet) for a complete list of available Sui wallet extensions.
>>>> sui/docs/content/guides/developer/nft-index.mdx
---
title: NFTs
description: Learn how to design, build, and extend NFTs on Sui, including soulbound tokens, rental mechanics, and asset tokenization.
keywords: [ nft, nfts, soulbound nft, nft rental, asset tokenization, digital assets, sui nft ]
pagination_prev: null
---

Learn how to create and extend non-fungible tokens on Sui. 

<Cards>
<Card title="Create a Non-Fungible Token" href="/guides/developer/nft">
</Card>
<Card title="Soulbound NFT Example" href="/guides/developer/nft/nft-soulbound">
</Card>
<Card title="NFT Rental Example" href="/guides/developer/nft/nft-rental">
</Card>
<Card title="Asset Tokenization with NFTs" href="/guides/developer/nft/asset-tokenization">
</Card>
</Cards>

>>>> sui/docs/content/guides/developer/nft.mdx
---
title: Create a Non-Fungible Token
description: On Sui, everything is an object. Moreover, everything is a non-fungible token (NFT) as its objects are unique, non-fungible, and owned.
keywords: [ERC-721, NFT]
pagination_prev: null
---

On Sui, everything is an object. Moreover, everything is a non-fungible token (NFT) as its objects are unique, non-fungible, and owned.

Creating NFTs on Sui differs from other blockchains that are not object based. Those blockchains require a dedicated standard to handle the properties that define NFTs because they are based on a mapping between smart contracts and the token's ID. For instance, the ERC-721 standard on Ethereum was necessary to pair a globally unique ID with the relevant smart contract address to create a unique token instance on the network. 

On Sui, every object already has a unique ID, so whether you're dealing with a million fungible tokens, like coins, or thousands of NFTs with individual characteristics, like SuiFrens, your smart contracts on Sui always interact with individual objects. 

Imagine you create an Excitable Chimp NFT collection on Sui and another blockchain that isn't object based. To get an attribute like the Chimp's name on the other blockchain, you would need to interact with the smart contract that created the NFT to get that information (typically from off-chain storage) using the NFT ID. On Sui, the name attribute can be a field on the object that defines the NFT itself. This construct provides a much more straightforward process for accessing metadata for the NFT as the smart contract that wants the information can just return the name from the object itself.

## Example

The following example creates a basic NFT on Sui. The `TestnetNFT` struct defines the NFT with an `id`, `name`, `description`, and `url` fields. 

<ImportContent source="examples/move/nft/sources/testnet_nft.move" mode="code" struct="TestnetNFT" noComments />

In this example, anyone can mint the NFT by calling the `mint_to_sender` function. As the name suggests, the function creates a new `TestnetNFT` and transfers it to the address that makes the call. 

<ImportContent source="examples/move/nft/sources/testnet_nft.move" mode="code" fun="mint_to_sender" noComments />

The module includes functions to return NFT metadata, too. Referencing the hypothetical used previously, you can call the `name` function to get that value. As you can see, the function simply returns the name field value of the NFT itself.

<ImportContent source="examples/move/nft/sources/testnet_nft.move" mode="code" fun="name" noComments />

<details>

<summary>

`testnet_nft.move` 

</summary>

<ImportContent source="examples/move/nft/sources/testnet_nft.move" mode="code" />

</details>

## Related links

<RelatedLink to="/guides/developer/nft/nft-soulbound.mdx" />
<RelatedLink to="/guides/developer/nft/nft-rental.mdx" />
<RelatedLink to="/guides/developer/nft/asset-tokenization.mdx" />
<RelatedLink to="/standards/kiosk.mdx" />
<RelatedLink to="/standards/kiosk-apps.mdx" />
>>>> sui/docs/content/guides/developer/nft/asset-tokenization.mdx
---
title: Asset Tokenization
description: Learn how to tokenize assets on the Sui blockchain. Asset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network.
---

Asset tokenization refers to the process of representing real-world assets, such as real estate, art, commodities, stocks, or other valuable assets, as digital tokens on the blockchain network. This involves converting the ownership or rights of an asset into digital tokens, which are then recorded and managed on the blockchain.

## High-level overview

The concept is to divide high-value assets into smaller, more affordable units, representing ownership or a fraction of the asset.

This strategy enables wider participation from investors who might want to mitigate risk by investing in a portion of a digital asset rather than being the sole owner, thereby expanding accessibility to a broader range of investors.

This pattern is similar to the [ERC1155](https://eips.ethereum.org/EIPS/eip-1155) multi-token standard with additional functionality. This makes it a suitable choice for Solidity based use cases that one might want to implement on Sui.

- **Asset creation**

  Each asset is fractionalized into a total supply, with each fraction represented as either a non-fungible token (NFT) or fungible token (FT) type collectible. This ensures that each individual fraction maintains a balance equal to or greater than one, and when combined, all fractions collectively reach the total supply of the asset.

  Besides the total supply, each asset is defined by various other fields such as name, description, and more. These fields collectively form the metadata for the asset, and they remain consistent across all fractions of the asset.

- **NFTs vs FTs distinction**

  Each time a tokenized asset is minted, the system can create it with new metadata. If new metadata is incorporated, the tokenized asset becomes unique, transforming it into an NFT. In this case, its balance is limited to 1, signifying that only a single instance of this asset exists.

  If no additional metadata exists, the system categorizes the tokenized asset as an FT, allowing its balance to exceed 1, enabling multiple identical instances of the asset to exist.

  FTs possess the capability to merge (join) among themselves or be split when the balance is greater than 1. This functionality allows for the aggregation or division of units of the token, offering flexibility in handling varying quantities as needed.

  As previously mentioned, all the collectibles of tokenized assets, whether NFTs or FTs, when combined, can amount to the maximum total supply of the asset.

- **Burnability**

  When you create the asset, you can define whether the fractions of the asset are eligible for removal or destruction from circulation. The process of removing or destroying assets is called burning.

  If a tokenized asset is burnable, then burning a fraction causes the circulating supply to decrease by the balance of the burnt item. The total supply, however, remains constant, allowing you to mint the burned fractions again if needed, thus maintaining the predetermined total supply of the asset.

## Move packages

As with all smart contracts on Sui, Move provides the logic that powers asset tokenization.

### `asset_tokenization` package

:::info

This reference implementation uses the [Kiosk standard](../../../standards/kiosk.mdx) to ensure that tokenized assets operate within their defined policy. Use the implementation as presented to have marketable tokenized assets that support rules like royalties, commissions, and so on.

If Kiosk is not a requirement, then you can exclude the unlock module and some of the proxy's methods related to transfer policies.

:::

Select a module to view its details:

<Tabs groupId="modules">

<TabItem label="tokenized_asset" value="tokenized_asset">

The `tokenized_asset` module operates in a manner similar to the `coin` library.

When it receives a new One-Time Witness type, it creates a unique representation of a fractional asset. This module employs similar implementations to some methods found in the `Coin` module. It encompasses functionalities pertinent to asset tokenization, including new asset creation, minting, splitting, joining, and burning. See [One Time Witness](https://move-book.com/programmability/one-time-witness.html) in The Move Book for more information.

**Structs**

- `AssetCap`

  Generate an `AssetCap` for each new asset represented as a fractional NFT. In most scenarios, create it as an owned object, which you can then transfer to the platform's administrator for access-restricted method invocation.

  ```rust
  struct AssetCap<phantom T> {
      id: UID,
      // the current supply in circulation
      supply: Supply<T>,
      // the total max supply allowed to exist at any time
      total_supply: u64,
      // Determines if the asset can be burned or not
      burnable: bool
  }
  ```

- `AssetMetadata`

  The `AssetMetadata` struct defines the metadata representing the entire asset to fractionalize. This should be a shared object.

  ```rust
  struct AssetMetadata<phantom T> has key, store {
          id: UID,
          /// Name of the asset
          name: String,
          // the total max supply allowed to exist at any time
          total_supply: u64,
          /// Symbol for the asset
          symbol: ascii::String,
          /// Description of the asset
          description: String,
          /// URL for the asset logo
          icon_url: Option<Url>
      }
  ```

- `TokenizedAsset`

  The `TokenizedAsset` is minted with a specified balance that is less than or equal to the remaining supply. If the `VecMap` of an asset is populated with values, indicating multiple unique entries, it is considered an NFT. Conversely, if the `VecMap` of an asset is not populated, indicating an absence of individual entries, it is considered an FT.

  ```rust
  struct TokenizedAsset<phantom T> has key, store {
          id: UID,
          /// The balance of the tokenized asset
          balance: Balance<T>,
          /// If the VecMap is populated, it is considered an NFT, else the asset is considered an FT.
          metadata: VecMap<String, String>,
          /// URL for the asset image (optional)
          image_url: Option<Url>,
      }
  ```

- `PlatformCap`

  The `PlatformCap` refers to the capability issued to the individual who deploys the contract. This capability grants specific permissions or authority related to the platform's functionalities, allowing the deployer certain controlled actions or access rights within the deployed contract.

  ```rust
  /// Capability that is issued to the one deploying the contract
  struct PlatformCap has key, store { id: UID }
  ```

**Functions**

- `init`

  This function creates a `PlatformCap` and transfers it to the transaction sender.

  ```rust
  fun init(ctx: &mut TxContext) {}
  ```

- `new_asset`

  This function holds the responsibility of creating a fresh representation of an asset, defining its crucial attributes. Upon execution, it returns 2 distinct objects: the `AssetCap` and `AssetMetadata`. These objects encapsulate the necessary information and characteristics defining the asset within the system.

  ```rust
  public fun new_asset<T: drop>(
          witness: T,
          total_supply: u64,
          symbol: ascii::String,
          name: String,
          description: String,
          icon_url: Option<Url>,
          burnable: bool,
          ctx: &mut TxContext
      ): (AssetCap<T>, AssetMetadata<T>) {}
  ```

- `mint`

  The function performs the minting of a tokenized asset. If new metadata is introduced during this process, the tokenized asset becomes unique, resulting in the creation of an NFT with a balance set to 1. Alternatively, if no new metadata is added, the system classifies the tokenized asset as an FT, permitting its balance to surpass 1, as specified by a provided argument. Upon execution, the function returns the tokenized asset object.

  ```rust
  public fun mint<T>(
          cap: &mut AssetCap<T>,
          keys: vector<String>,
          values: vector<String>,
          value: u64,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `split`

  This function receives a tokenized asset of the FT type and a balance greater than 1, along with a value less than the object's balance, and performs a split operation on the tokenized asset. The operation divides the existing tokenized asset into 2 separate tokenized assets. The newly created tokenized asset has a balance equal to the given value, while the balance of the provided object is reduced by the specified value. Upon completion, the function returns the newly created tokenized asset. This function does not accept or operate on tokenized assets of the NFT type.

  ```rust
  public fun split<T>(
          self: &mut TokenizedAsset<T>,
          split_amount: u64,
          ctx: &mut TxContext
      ): TokenizedAsset<T> {}
  ```

- `join`

  This function receives 2 tokenized assets of the FT type and executes a merge operation on the tokenized assets. The operation involves increasing the balance of the first tokenized asset by the balance of the second one. Subsequently, the system burns or removes the second tokenized asset from circulation. After the process concludes, the function returns the ID of the burned tokenized asset.

  This function does not accept or operate on tokenized assets of the NFT type.

  ```rust
  public fun join<T>(
          self: &mut TokenizedAsset<T>,
          other: TokenizedAsset<T>
      ): ID {}
  ```

- `burn`

  This function requires the `assetCap` as a parameter, restricting its invocation solely to the platform admin. Additionally, it accepts a tokenized asset that is burned as part of its operation. Upon burning the provided tokenized asset, the circulating supply decreases by the balance of the burnt item. It requires a tokenized asset that is burnable.

  ```rust
  public fun burn<T>(
          cap: &mut AssetCap<T>,
          tokenized_asset: TokenizedAsset<T>
      )
  ```

- `total_supply`

  This function returns the maximum supply of the asset.

  ```rust
  public fun total_supply<T>(cap: &AssetCap<T>): u64 {}
  ```

- `supply`

  This function returns the current circulating supply of the asset.

  ```rust
  public fun supply<T>(cap: &AssetCap<T>): u64 {}
  ```

- `value`

  This function returns the balance of a tokenized asset.

  ```rust
  public fun value<T>(tokenized_asset: &TokenizedAsset<T>): u64 {}
  ```

- `create_vec_map_from_arrays`

  This internal helper function populates a `VecMap<String, String>`. It assists in the process of filling or setting key-value pairs within the `VecMap` data structure.

  ```rust
  fun create_vec_map_from_arrays(
          keys: vector<String>,
          values: vector<String>
      ): VecMap<String, String> {}
  ```

</TabItem>

<TabItem label="proxy" value="proxy">

The `proxy` module comprises methods that the type owner utilizes to execute publisher-related operations.

**Structs**

- `Proxy`

  The `PROXY` struct represents the One-Time Witness (OTW) to claim the publisher.

  ```rust
  struct PROXY has drop {}
  ```

- `Registry`

  This shared object serves as a repository for the `Publisher` object, specifically intended to control and restrict access to the creation and management of transfer policies for tokenized assets. Mutable access to this object is exclusively granted to the actual publisher.

  ```rust
  struct Registry has key {
          id: UID,
          publisher: Publisher
      }
  ```

- `ProtectedTP`

  This is a shared object that stores an empty transfer policy. It is required to create one per type `<T>` generated by a user. Its involvement is apparent in the unlock module.

  ```rust
  struct ProtectedTP<phantom T> has key, store {
          id: UID,
          policy_cap: TransferPolicyCap<T>,
          transfer_policy: TransferPolicy<T>
      }
  ```

**Functions**

- `init`

  This function is responsible for creating the `Publisher` object, encapsulating it within the registry, and subsequently sharing the `Registry` object.

  ```rust
  fun init(otw: PROXY, ctx: &mut TxContext) {}
  ```

- `setup_tp`

  This function leverages the publisher nested within the registry and the sender's publisher. It generates and returns a transfer policy and the associated transfer policy cap specific to the `TokenizedAsset<T>`. This type 'T' is derived from the `Publisher` object.

  It also generates an empty transfer policy wrapped in a `ProtectedTP<T>` object, which is shared. You can use this functionality under specific conditions to override the Kiosk lock rule.

  ```rust
  public fun setup_tp<T: drop>(
          registry: &Registry,
          publisher: &Publisher,
          ctx: &mut TxContext
      ): (TransferPolicy<TokenizedAsset<T>>,
          TransferPolicyCap<TokenizedAsset<T>>) {}
  ```

- `new_display`

  This function utilizes the publisher nested within the registry and the sender's publisher to generate and return an empty `Display` for the type `TokenizedAsset<T>`, where `T` is encapsulated within the `Publisher` object.

  ```rust
  public fun new_display<T: drop>(
          registry: &Registry,
          publisher: &Publisher,
          ctx: &mut TxContext
      ): Display<TokenizedAsset<T>> {}
  ```

- `transfer_policy`

  This function, provided with the `protectedTP`, returns the transfer policy specifically designed for the type `TokenizedAsset<T>`

  ```rust
  public(friend) fun transfer_policy<T>(
          protected_tp: &ProtectedTP<T>
      ): &TransferPolicy<T> {}

  ```

- `publisher_mut`

  This function can only be accessed by the owner of the platform cap. It requires the registry as an argument to obtain a mutable reference to the publisher.

  ```rust
  public fun publisher_mut(
      _: &PlatformCap,
      registry: &mut Registry
  ): &mut Publisher {}
  ```

</TabItem>

<TabItem label="unlock" value="unlock">

The `unlock` module facilitates the unlocking of a tokenized asset specifically for authorized burning and joining.

It allows tokenized asset type creators to enable these operations for kiosk assets without necessitating adherence to the default set of requirements, such as rules or policies.

**Structs**

- `JoinPromise`

  A promise object is established to prevent attempts of permanently unlocking an object beyond the intended scope of joining.

  ```rust
  struct JoinPromise {
      /// the item where the balance of the burnt tokenized asset will be added.
      item: ID,
      /// burned is the id of the tokenized asset that will be burned
      burned: ID,
      /// the expected final balance of the item after merging
      expected_balance: u64
  }
  ```

- `BurnPromise`

  A promise object created to ensure the permanent burning of a specified object.

  ```rust
  struct BurnPromise {
    expected_supply: u64
  }
  ```

**Functions**

- `asset_from_kiosk_to_join`

  This helper function is intended to facilitate the joining of tokenized assets locked in a kiosk. It aids in unlocking the tokenized asset that is set for burning and ensures that another tokenized asset of the same type will eventually contain its balance by returning a `JoinPromise.`

  ```rust
  public fun asset_from_kiosk_to_join<T>(
    self: &TokenizedAsset<T>, // A
    to_burn: &TokenizedAsset<T>, // B
    protected_tp: &ProtectedTP<TokenizedAsset<T>>, // unlocker
    transfer_request: TransferRequest<TokenizedAsset<T>> // transfer request for b
  ): JoinPromise {}
  ```

- `prove_join`

  A function utilized to demonstrate that the unlocked tokenized asset is successfully burned and its balance is incorporated into an existing tokenized asset.

  ```rust
  public fun prove_join<T>(
    self: &TokenizedAsset<T>,
    promise: JoinPromise,
    proof: ID) {
  }
  ```

- `asset_from_kiosk_to_burn`

  Helper function that facilitates the burning of tokenized assets locked in a kiosk. It assists in their unlocking while ensuring a promise that the circulating supply will be reduced, achieved by returning a `BurnPromise`.

  ```rust
  public fun asset_from_kiosk_to_burn<T>(
      to_burn: &TokenizedAsset<T>,
      asset_cap: &AssetCap<T>,
      protected_tp: &ProtectedTP<TokenizedAsset<T>>,
      transfer_request: TransferRequest<TokenizedAsset<T>>,
    ): BurnPromise {
  }
  ```

- `prove_burn`

  Ensures that the circulating supply of the asset cap is reduced by the balance of the burned tokenized asset.

  ```rust
  public fun prove_burn<T>(
    asset_cap: &AssetCap<T>,
    promise: BurnPromise) {
  }
  ```

</TabItem>

</Tabs>

### `template` package

An example use case package that enables utilization of Rust WASM functionality to support seamless asset creation on the browser.

This is similar to the launchpad approach and serves as the template package whenever a new asset requires representation as a tokenized asset.

Effectively allowing users to edit fields of this template contract on the fly and publish it with the edits included.
This package implements two essential modules, each catering to distinct functionalities required for asset tokenization.
More details regarding how Rust WASM was implemented can be found in the [Web Assembly](#webassembly-wasm-and-template-package) section.

- **Modules**

  - `template`

    This is the module that supports defining a new asset.

    When you need to represent a new asset as a fractional asset, modify this module to `<template>::<TEMPLATE>`, with the `<template>` (in capitals) being the OTW of this new asset.

    This module calls the `asset_tokenization::tokenized_asset::new_asset(...)` method, which facilitates the declaration of new fields for the asset:

    - `witness`: The OTW `NEW_ASSET`
    - `total_supply`: The total supply allowed to exist at any time
    - `symbol`: The symbol for the asset
    - `name`: The name of the asset
    - `description`: The description of the asset
    - `icon_url`: The URL for the asset logo (optional)
    - `burnable`: Boolean that defines if the asset can be burned by an admin

  - `genesis`

    A genesis type of module that includes a OTW so that the sender can claim the publisher.

### Publish and mint tokenized sequence diagram

```mermaid
sequenceDiagram
    participant Platform Admin
    participant Asset Creator
    participant Kiosk
    participant tokenized_asset
    participant proxy
    participant template
    participant genesis
    participant genesis
    participant Blockchain
    Platform Admin->>Blockchain: Publish asset_tokenization package (tokenized_asset, proxy, unlock modules)
    Blockchain-->>tokenized_asset: tokenized_asset module is published
    Blockchain-->>proxy: proxy module is published
    tokenized_asset->>Platform Admin: Send Platform Cap (owned object)
    proxy->>Blockchain: Share Registry (shared object)
    Asset Creator->>template: Pass Asset Info, AssetOTW as input
    Asset Creator->>genesis: Pass PublisherOTW as input
    Asset Creator->>Blockchain: Publish template package (template, genesis modules)
    Blockchain-->>genesis: genesis module is published
    Blockchain-->>template: template module is published
    genesis->>Asset Creator: Send Publisher (owned object)
    template->>tokenized_asset: Create new asset using Asset Info as input
    tokenized_asset-->>Asset Creator: Send Asset Cap (owned object)
    tokenized_asset-->>Blockchain: Share Asset Metadata (shared object)
    Asset Creator->>proxy: Use Publisher as input to setup_tp
    Blockchain->>proxy: Use Registry as input to setup_tp
    proxy-->>Blockchain: Share created Transfer Policy, ProtectedTP (shared objects)
    proxy-->>Asset Creator: Send created Transfer Policy Cap (owned object)
    Asset Creator->>tokenized_asset: Define type of tokenized asset (FT, NFT) to mint
    tokenized_asset-->>Asset Creator: Return minted Tokenized Asset
    Asset Creator->>Kiosk: Place Tokenized Asset
```

### Join sequence diagram

The following sequence diagram presenting how the join flow would take place. The following flow assumes that:

- Tokenized assets X and Y have already been minted by the creator of their type.
- Tokenized assets X and Y are already placed and locked inside the user's kiosk.
- Everything is executed in the same programmable transaction block (PTB).

```mermaid
sequenceDiagram
    participant User
    participant User's Kiosk
    participant kiosk module
    participant unlock module
    participant tokenized asset module
    participant blockchain

User's Kiosk->>kiosk module: Borrow Tokenized Asset X
kiosk module-->>User: Returns Promise, Tokenized Asset X
User's Kiosk->>kiosk module: List Tokenized Asset Y for zero price
User's Kiosk->>kiosk module: Purchase Tokenized Asset Y
kiosk module-->>User: Returns Transfer Request, Tokenized Asset Y
User->>unlock module: Use Transfer Request, Tokenized Asset X, Y as input to asset_from_kiosk_to_join
blockchain->>unlock module: Use Protected TP as input to asset_from_kiosk_to_join
unlock module-->>User: Returns Join Promise, Tokenized Asset X,Y Objects
User->>tokenized asset module: Use Tokenized Asset X,Y as input to join
tokenized asset module-->>User: Return Burn Proof, Tokenized Asset X
User->>unlock module: Use Burn Proof, Join Promise, Tokenized Asset X as input to prove_join
unlock module-->>User: Return Tokenized Asset X
User->>User's Kiosk: Resolve Promise by returning Tokenized Asset X in user's Kiosk
```

### Burn sequence diagram

The following sequence diagram shows the burn flow and assumes that:

- Tokenized asset has already been minted by the creator of its type.
- Tokenized asset is already placed and locked inside the user's Kiosk.
- Everything is executed in the same PTB.

```mermaid
sequenceDiagram
    participant User
    participant User's Kiosk
    participant kiosk module
    participant unlock module
    participant tokenized asset module
    participant blockchain

User's Kiosk->>kiosk module: List Tokenized Asset for zero price
User's Kiosk->>kiosk module: Purchase Tokenized Asset
kiosk module-->>User: Returns Transfer Request, Tokenized Asset Object
User->>unlock module: Use Transfer Request, Tokenized Asset Object, Asset Cap as input to asset_from_kiosk_to_burn
blockchain->>unlock module: Use Protected TP as Input to asset_from_kiosk_to_burn
unlock module-->>User: Returns Burn Promise, Tokenized Asset Object, Asset Cap
User->>tokenized asset module: Use Tokenized Asset Object, Asset Cap as input to burn
tokenized asset module-->>User: Returns Asset Cap
User->>unlock module: Use Burn Proof, Asset Cap as input to prove_burn
unlock module-->>User: Returns Asset Cap
```

## Variations

The packages and modules provided demonstrate how you could implement asset tokenization for your project. Your particular use case probably necessitates altering the contract for convenience or to introduce new features.

### Example convenience alteration

Instead of implementing the unlock functionality in multiple steps inside of a PTB, it would also be possible to create a method that performs the purchase, borrowing, unlocking and joining of an asset all on one function. This is how that would look like for the joining operation:

```rust
public fun kiosk_join<T>(
	kiosk: &mut Kiosk,
  kiosk_cap: &KioskOwnerCap,
	protected_tp: &ProtectedTP<TokenizedAsset<T>>,
  ta1_id: ID,
  ta2_id: ID,
  ctx: &mut TxContext
) {

	kiosk::list<TokenizedAsset<T>>(kiosk, kiosk_cap, ta2_id, 0);
	let (ta1, promise_ta1) = kiosk::borrow_val(kiosk, kiosk_cap, ta1_id);
	let coin = coin::zero<SUI>(ctx);
	let (ta2, request) = kiosk::purchase(kiosk, ta2_id, coin);

	let tp_ref = proxy::transfer_policy(protected_tp);
	let (_item, _paid, _from) = transfer_policy::confirm_request(
	    tp_ref,
	    request
	);

	tokenized_asset::join(&mut ta1, ta2);

	kiosk::return_val(kiosk, ta1, promise_ta1);
}
```

### Example alteration for use case

:::caution

The following example splits (effectively replacing) the `AssetCap<T>` into two new objects: the `Treasury<T>` and the `AdminCap<T>`. The access to methods defined in the original package, should now be carefully re-designed as this change can introduce unwanted effects. This required re-design is not entirely contained in this example and only some methods are changed for demonstration purposes (or as a thorough exercise).

:::

Assume you want to allow the users to also burn assets, not only admins. This still needs to be an authorized operation but it would allow the flexibility of consuming tokenized assets for a use case specific purpose (for example, burning all of the collectibles you've gathered to combine them). To achieve this, the admin can mint tickets that contain the ID of the asset they are allowed to burn. To support this functionality you must redesign the smart contract and separate the admin from the asset's treasury of each asset, which now holds only supply related information. Sample changes that need to happen follow:

**Structs**

Create a ticket that has only the `key` ability so that the receiver cannot trade it.

```rust
struct BurnTicket<phantom T> has key {
	id: UID,
	tokenized_asset_id: ID // the tokenized asset that this ticket gives access to burn
}
```

The struct that now only holds treasury related information (results from splitting the `AssetCap`, meaning it's no longer part of this design) is created as a shared object. Change functions like `mint` to also take as input both the `Treasury` object and the `AdminCap` object.

```rust
struct Treasury<phantom T> has key, store {
	id: UID,
	supply: Supply<T>,
  total_supply: u64,
}
```

The other half of the `AssetCap` functionality which retains the admin capability and the configuration of burnability is an owned object sent to the creator of type `<T>`.

```rust
struct AdminCap<phantom T> has key, store {
	id: UID,
	burnable: bool
}
```

**Method Signatures**

The `AdminCap` here acts both as an admin capability and a type insurance. Encoding the information of both the asset type that is allowed to be deleted with this ticket.
This function should assert that the asset T is burnable and return a `BurnTicket<T>`.

```rust
public fun mint_burn_ticket<T>(
	cap: &AdminCap<T>,
	tokenized_asset_id: ID,
	ctx: &mut TxContext
): BurnTicket
```

Burning on the user side requires for them to access the shared `Treasury` object. This function burns the tokenized asset and decreases the supply.

```rust
public fun burn_with_ticket<T>(
	treasury: &mut Treasury<T>,
	self: TokenizedAsset<T>,
	ticket: BurnTicket<T>)
```

# Deployment

<ImportContent source="initialize-sui-client-cli.mdx" mode="snippet" />

## Publishing

At this stage, you can choose to manually deploy the contracts or utilize the publish bash script that automatically deploys the contracts and sets up most of the `.env` Asset Tokenization related fields for you.
The `.env.template` file denotes variables that the script automatically fills in.
You can see a reference here:

```
SUI_NETWORK = rpc endpoint of the network of your choice | auto filled by publish script
ASSET_TOKENIZATION_PACKAGE_ID = Created by publishing `asset_tokenization` package | auto filled by publish script
REGISTRY = Created by publishing `asset_tokenization` package | auto filled by publish script

TEMPLATE_PACKAGE_ID = Created by publishing `template` package
ASSET_CAP_ID = Created by publishing `template` package
ASSET_METADATA_ID = Created by publishing `template` package
ASSET_PUBLISHER = Created by publishing `template` package

PROTECTED_TP = Created by calling `setup_tp` function
TRANSFER_POLICY = Created by calling `setup_tp` function

OWNER_MNEMONIC_PHRASE = your mnemonic | can be exported locally in the terminal before publishing
BUYER_MNEMONIC_PHRASE = buyer's mnemonic | can be exported locally in the terminal before publishing
TARGET_KIOSK = kiosk id
BUYER_KIOSK = kiosk id


TOKENIZED_ASSET = tokenized asset id (created by minting)
FT1 = tokenized asset id (to be joined)
FT2 = tokenized asset id (to be joined)
```

For more details on publishing, please check the setup folder's [README](https://github.com/MystenLabs/asset-tokenization/tree/main/setup).

### Publishing packages

Select a package for specific instructions.

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

<Tabs>

<TabItem label="asset_tokenization" value="asset_tokenization">

### Manually

In a terminal or console at the `move/asset_tokenization` directory of the project enter:

```sh
$ sui client publish --gas-budget <GAS-BUDGET>
```

For the gas budget, use a standard value such as `20000000`.

The package should successfully deploy, and you then see:

```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING asset_tokenization
Successfully verified dependencies on-chain against source.
```

You can also view a multitude of information and transactional effects.

You should choose and store the `package ID` and the `registry ID` from the created objects in the respective fields within your `.env` file.

Afterward, it's necessary to modify the `Move.toml` file. Under the `[addresses]` section, replace `0x0` with the same `package ID`. Optionally, under the `[package]` section, add `published-at = <package ID>` (this step is not needed if you see a `Move.lock` file after running `sui client publish`).

### Automatically

The fields that are automatically filled are: `SUI_NETWORK`, `ASSET_TOKENIZATION_PACKAGE_ID` and `REGISTRY`.

To publish with the bash script run:

```sh
$ npm run publish-asset-tokenization
```

After publishing, you can now edit the `Move.toml` file like described in the Manual flow.

For more details regarding this process, please consult the setup folder's [README](https://github.com/MystenLabs/asset-tokenization/tree/main/setup).

</TabItem>

<TabItem label="template" value="template">

### Manually

In a terminal or console at the `move/template` directory of the project enter:

```sh
$ sui client publish --gas-budget <GAS-BUDGET>
```

For the gas budget, use a standard value such as `20000000`.

The package should successfully deploy, and you then see:

```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY asset_tokenization
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING template
Successfully verified dependencies on-chain against source.
```

You can also view a multitude of information and transactional effects.

You should choose and store the `package ID`, asset `metadata ID`, `asset cap ID` and the `Publisher ID` from the created objects in the respective fields within your `.env` file.

### Automatically

The process of automatic deployment for the template package refers to publishing a new asset via the WASM library. Quick start steps:

- Ensure that the `asset_tokenization` package address is set in the `[addresses]` section of `asset_tokenization/Move.toml`. This address should be the same as the original package deployment.
- If a `Move.lock` file exists after running`sui client publish`, go on to the next step. If not, ensure that the `asset_tokenization/Move.toml` file has its `published-at` field uncommented and populated with the address of the latest package deployment.
- Make any changes to the template fields by changing the input parameters of the `publishNewAsset` function.
- Run `npm run publish-template`.
- You should choose and store the _Template Package ID_, _asset metadata ID_, _asset cap ID_ and the _publisher ID_ from the created objects in the respective fields within your **`.env`** file.

For more details regarding this process, please consult the setup folder's [README](https://github.com/MystenLabs/asset-tokenization/tree/main/setup).

</TabItem>

</Tabs>

## WebAssembly (WASM) and template package {#webassembly-wasm-and-template-package}

:::tip

You can find a public facing reference to the WASM library in the [move-binary-format-wasm](https://www.npmjs.com/package/@mysten/move-bytecode-template) Sui repo subfolder.

:::

This feature was developed with the intent to enable Move bytecode serialization and deserialization on the web. In essence, this feature allows you to edit existing contracts in a web environment.

In the case of asset tokenization, these edits allow you to create and publish new types that represent physical or digital assets that we want to tokenize.

### Bytecode manipulation {#bytecode-manipulation}

:::caution

On modifications that are made to the template package this process needs to be repeated. Note that some alterations, like changing a constant name, do not affect the produced bytecode.

:::

Before proceeding to how to make these edits, it's important to understand how the library exposes the template module bytecode. The process is currently manual. This requires that you build and retrieve the compiled bytecode. To do this, navigate inside the template folder and run the following command:

```sh
$ xxd -c 0 -p build/template/bytecode_modules/template.mv | head -n 1
```

<details>
  <summary>
  Console response
  </summary>

The response you should receive looks similar to the following:

```sh
a11ceb0b060000000a010010021026033637046d0a05776807df01ec0108cb03800106cb043
e0a8905050c8e0549001303140107010d01120215021602170004020001000c01000101010c
010001020307000302070100000403070006050200070607000009000100010a0a0b0102021
2050700030c010401000311060401000418050800050e0601010c050f1001010c06100d0e00
070b050300030304030109060c070f02080007080600040b040108070b010108000b0201080
00b04010807010807010b04010900010a020109000108030108050108000809000308030805
08050b0401080701070806020b010109000b02010900010b02010800010608060105010b010
10800020900050841737365744361700d41737365744d65746164617461064f7074696f6e06
537472696e670854454d504c415445095478436f6e746578740355726c0561736369690b647
56d6d795f6669656c6404696e6974096e65775f6173736574156e65775f756e736166655f66
726f6d5f6279746573046e6f6e65066f7074696f6e137075626c69635f73686172655f6f626
a6563740f7075626c69635f7472616e736665720673656e64657204736f6d6506737472696e
670874656d706c6174650f746f6b656e697a65645f6173736574087472616e736665720a747
85f636f6e746578740375726c04757466380000000000000000000000000000000000000000
000000000000000000000000000000000000000000000000000000000000000000000000000
000000000000100000000000000000000000000000000000000000000000000000000000000
02d9ebdef1e3cb5eb135362572b18faeb61259afe651a463f1384745ebd7fd51da030864000
000000000000a02070653796d626f6c0a0205044e616d650a020c0b4465736372697074696f
6e0a02090869636f6e5f75726c0101010a02010000020108010000000002230704070621040
738000c02050b0704110938010c020b020c050b0007000701110207021105070311050b0507
050a0138020c040c030b0438030b030b012e110838040200
```

</details>

Copy the output you receive and paste it in the return instruction of the `getBytecode` method, which is located inside the [bytecode-template.ts](https://github.com/MystenLabs/asset-tokenization/blob/main/setup/src/utils/bytecode-template.ts) file.

Additionally, because the template package contains two modules, and therefore has another dependency, you also need to retrieve the bytecode of the genesis module in a similar fashion. This module bytecode, however, is not edited and isn't used as is. This operation is not directly relevant to the WASM library, but is necessary to successfully deploy the edited template module. To acquire the bytecode for genesis, navigate to the `template` folder and run:

```sh
$ xxd -c 0 -p build/template/bytecode_modules/genesis.mv | head -n 1
```

The output format is similar to the template module but smaller in length. Similarly to what you did with the template module, you need to copy this output but this time paste it in the bytecode constant variable located in the [genesis_bytecode.ts](https://github.com/MystenLabs/asset-tokenization/blob/main/setup/src/utils/genesis_bytecode.ts) file.

With the above setup, the library can now manipulate the bytecode by deserializing it, editing it, and serializing it again so that you can publish it.

### Closer view of the template module

Taking a look at the template module, you should see that a few constants have been defined:

```rust
...
const TOTAL_SUPPLY: u64 = 100;
const SYMBOL: vector<u8> = b"Symbol";
const NAME: vector<u8> = b"Name";
const DESCRIPTION: vector<u8> = b"Description";
const ICON_URL: vector<u8> = b"icon_url";
const BURNABLE: bool = true;
...
```

These constants act as a reference point that the WASM library is able to modify. If you take a look at the TypeScript code that performs the edit and deploys, you can see in action how these fields are identified and updated:

```tsx
...
const template = getBytecode();

const compiledModule = new CompiledModule(
  JSON.parse(wasm.deserialize(template))
)
  .updateConstant(0, totalSupply, "100", "u64")
  .updateConstant(1, symbol, "Symbol", "string")
  .updateConstant(2, asset_name, "Name", "string")
  .updateConstant(3, description, "Description", "string")
  .updateConstant(4, iconUrl, "icon_url", "string")
  .updateConstant(5, burnable, "true", "bool")
  .changeIdentifiers({
    template: moduleName,
    TEMPLATE: moduleName.toUpperCase(),
  });

const bytesToPublish = wasm.serialize(JSON.stringify(compiledModule));
...
```

Examine the `updateConstant` method, which is used to update constants. This method takes four arguments:

- An `idx` (index) that the declared constant would have in the constant pool. The order is sequential, starting from 0 for the first constant defined in the Move file and stepping plus one for each consecutive constant.
- A `value` that contains an updated value of the constant you want to change.
- An `expectedValue` that contains the current value of the constant.
- An `expectedType` that contains the current type of the constant.

The last two arguments are required to minimize the risk of accidentally updating the wrong constant since this library is directly manipulating compiled bytecode, which is quite dangerous.

Additionally, the `changeIdentifiers` method updates identifiers, which in our case are the module name and the struct name. This method takes a JSON object as an argument with keys of the current identifier names in the module and values being the desired names you want to change them into.

Lastly, to deploy the changed template module, build and publish:

```tsx
...
const tx = new Transaction();
  tx.setGasBudget(100000000);
  const [upgradeCap] = tx.publish({
    modules: [[...fromHex(bytesToPublish)], [...fromHex(genesis_bytecode)]],
    dependencies: [
      normalizeSuiObjectId("0x1"),
      normalizeSuiObjectId("0x2"),
      normalizeSuiObjectId(packageId),
    ],
  });

  tx.transferObjects(
    [upgradeCap],
    tx.pure(signer.getPublicKey().toSuiAddress(), "address")
  );
...
```

As mentioned in the [Bytecode manipulation](#bytecode-manipulation) section, the modules that you need to publish are the template and the genesis, hence the reason you have 2 elements in the `modules` array. It's also important to include any dependencies defined in the `Move.toml` file of the involved packages. The `packageId` used previously is the address the `asset_tokenization` package has been deployed to.

## TypeScript

Now, you can begin interacting with the deployed smart contract and your tokenized asset.

In a terminal or console within the project's setup directory, utilize the following commands:

- **`create-tp`**

  First, create a `TransferPolicy` and a `ProtectedTP` with the following command:

  ```sh
  $ npm run call create-tp
  ```

  After executing the command, the console displays the effects of the transaction.

  By searching the transaction digest on a Sui network explorer, you can locate the created objects. Subsequently, select and save the `TransferPolicy ID` and the `ProtectedTP ID` from these objects into the respective fields within your `.env` file.

- **Add rules**

  In the project's file `transferPolicyRules.ts` located in the directory `setup/src/functions`, you can modify the code to include the desired rules for your transfer policy.

  Code snippet to be modified:

  ```rust
  // A demonstration of using all the available rule add/remove functions.
      // You can chain these commands.
      tpTx
          .addFloorPriceRule('1000')
          .addLockRule()
          .addRoyaltyRule(percentageToBasisPoints(10), 0)
          // .addPersonalKioskRule()
          // .removeFloorPriceRule()
          // .removeLockRule()
          // .removeRoyaltyRule()
          // .removePersonalKioskRule()
  ```

  By running the command `npm run call tp-rules`, the rules are added to your transfer policy.

  Now, investors can trade the fractions of your asset according to the rules you've set.

- **`select-kiosk`**

  You must place the tokenized assets within a kiosk if marketable assets are desired. Subsequently, you can list and sell them to other users. Lock the objects in the kiosk to prevent any future unauthorized usage outside the defined policy that you set.

  Best practices recommend a single, comprehensive kiosk for all operations. However, this might not always be the case. Therefore, this project requires the use of only 1 personal kiosk to ensure consistency and better management, even if you own multiple kiosks.

  To enforce this rule, execute the command `npm run call select-kiosk`. This provides you with the specific kiosk ID to use for this project.

  Then, store the provided Kiosk ID in the appropriate field within your `.env` file.

- **`mint`**

  In the project's file `mint.ts`, found in the directory `setup/src/functions`, you can edit the code to mint the desired type (NFT/FT) and balance for your asset.

  As previously mentioned, if additional metadata is provided, the tokenized asset is treated as an NFT with a value of 1. However, if there is no extra metadata, the tokenized asset is regarded as an FT, and you have the flexibility to select its balance, which can exceed 1.

  Here is an example from the code that needs modification:

  ```rust
  // example without metadata -> FT
  function getVecMapValues() {

    const keys : string[] = [];
    const values : string[] = [];

    return { keys, values };
  }
  ```

  or

  ```rust
  // example with metadata -> NFT
  function getVecMapValues() {
  	const keys = [
  	  "Piece",
  	  "Is it Amazing?",
  	  "In a scale from 1 to 10, how good?",
    ];
    const values = ["8/100", "Yes", "11"];

    return { keys, values };
  }
  ```

  Upon executing the command `npm run call mint`, a new tokenized asset is minted. You can save the object's `ID` in the `.env` file for future reference.

- **`lock`**

  Locking the objects within the kiosk is crucial to prevent any unauthorized usage beyond the established policy.

  Upon executing the command `npm run call lock`, your newly minted tokenized asset is secured within your kiosk.

  Before running the command, make sure that the field `TOKENIZED_ASSET` within your `.env` file is populated with the object you intend to lock.

- **`mint-lock`**

  Executing the command `npm run call mint-lock` performs both the mint and lock functions sequentially, ensuring the minted asset is created and immediately locked within the kiosk.

- **`list`**

  Now that your tokenized asset is placed and locked within your kiosk, you can proceed to list it for sale.

  In the project's file `listItem.ts`, found in the directory `setup/src/functions`, you can adjust the code to specify the desired asset for listing.

  Code snippet to be modified:

  ```rust
  const SALE_PRICE = '100000';
    kioskTx
      .list({
          itemId,
          itemType,
          price: SALE_PRICE,
      })
      .finalize();
  ```

  By running the command `npm run call list`, your tokenized asset is listed and made available for sale.

- **`purchase`**

  When a user intends to purchase an item, it needs to be listed for sale. After the user selects the item to buy, they are required to modify the following snippet of code found in the file `purchaseItem.ts`, located in the `setup/src/functions` directory.

  ```rust
  const item = {
      itemType: tokenizedAssetType,
      itemId: tokenized_asset ?? tokenizedAssetID,
      price: "100000",
      sellerKiosk: targetKioskId,
  };
  ```

  Apart from specifying the item and its type, the buyer must set the specific price and the seller's kiosk ID to execute the purchase transaction successfully, accomplished by running `npm run call purchase`.

- **`join`**

  When you execute the command `npm run call join`, 2 specified tokenized assets of the FT type are merged together. Before running the command, make sure that the fields `FT1` and `FT2` within your `.env` file are populated with the objects you intend to merge.

- **`burn`**

  When you intend to burn a tokenized asset, execute the command `npm run call burn`. Following this action, the specified asset is destroyed. Before running the command, make sure that the field `TOKENIZED_ASSET` within your `.env` file is populated with the object you intend to burn.

- **`get-balance`**

  By executing the command `npm run call get-balance`, you can retrieve the balance value associated with the specified tokenized asset.

- **`get-supply`**

  By executing the command `npm run call get-supply`, you can retrieve the value representing the current circulating supply of the asset.

- **`get-total-supply`**

  By executing the command `npm run call get-total-supply`, you can retrieve the value representing the current circulating supply of the asset.

>>>> sui/docs/content/guides/developer/nft/nft-rental.mdx
---
title: NFT Rental Example
description: An example using the Kiosk Apps standard that provides the ability for users to rent NFTs according to the rules of a provided policy instead of outright owning them. This approach closely aligns with the ERC-4907 renting standard, making it a suitable choice for Solidity-based use cases intended for implementation on Sui.
keywords: [ERC-721, NFT]
---

NFT renting is a mechanism that allows individuals without ownership or possession of a specific NFT to temporarily utilize or experience it. The implementation of this process leverages the [Kiosk Apps standard](../../../standards/kiosk-apps.mdx) to establish an infrastructure for rental transactions. This approach closely aligns with the [Ethereum ERC-4907](https://eips.ethereum.org/EIPS/eip-4907) renting standard, making it a suitable choice for Solidity-based use cases intended for implementation on Sui.

The NFT Rental example satisfies the following project requirements:

- Enable a lender to offer their assets for renting for a specified period of time (list for renting).
- Enable a lender to define the rental duration.
    - Borrower has to comply with the renting period.
- Borrower can gain mutable or immutable access to the NFT.
    - Immutable access is read-only.
    - Mutable, the lender should consider downgrade and upgrade operations and include them in the renting fee.
- After the renting period has finished, the item can be sold normally.
- Creator-defined royalties are respected by encompassing [transfer policy rules](../../../concepts/transfers/custom-rules.mdx).

## Use cases

Some use cases for real-world NFT rental example include:

- [Gaming](#gaming)
- [Ticketing](#ticketing) 
- [Virtual land](#virtual-land)
- [Temporary assets and subscriptions](#temp-assets-subs)

### Gaming

There are multiple cases in gaming where renting NFTs can be beneficial to user experience:

- **In-game assets:** NFTs can represent unique in-game items, characters, skins, or accessories. Players can rent these assets securely.
- **Ownership and authenticity:** NFTs provide a transparent and immutable record of ownership, ensuring that players who truly own their in-game items can rent them and receive back the item under rent after the renting period expires. This can combat issues like fraud and counterfeiting.
- **Cross-game integration:** Renting NFTs can work across multiple games, allowing players to carry and rent their unique items or characters from one game to another, fostering interoperability.
- **Gaming collectibles:** NFTs can represent digital collectibles within games, creating a digital asset ecosystem where players can rent unique items.

### Ticketing

In the realm of ticketing, NFTs play a pivotal role in enhancing transferability. These digital assets facilitate a secure and traceable transfer, resale, or rental of tickets, mitigating the risk of counterfeit tickets within the secondary market. The blockchain-based nature of NFTs ensures transparency and authenticity in each transaction, providing users with a reliable and fraud-resistant means to engage in ticket-related activities. This innovation not only simplifies the process for ticket holders but also contributes to a more trustworthy and efficient secondary ticket market.

### Virtual land {#virtual-land}

Renting virtual lands and offices in the metaverse provides businesses with flexible solutions, enabling event companies to host gatherings without the commitment of permanent acquisitions and facilitating remote work through virtual offices. This approach not only offers cost-effective alternatives but also aligns with the evolving dynamics of digital business operations.

### Temporary assets and subscriptions {#temp-assets-subs}

Temporary assets and subscriptions are notable applications of rental NFTs, offering accessibility to virtual experiences like high-end virtual casinos or curated digital fashion. These NFTs cater to diverse budgets, broadening audience reach. Subscription rentals extend to pools of digital assets, allowing users to pay monthly for a set number of items, fostering accessibility, user retention, and acquisition. Holders can rent out unused subscriptions, ensuring no loss for them, potential customer gains for the protocol, and a commitment-free trial for temporary holders. This showcases the adaptability and user-centric appeal of rental NFTs in diverse scenarios.

## Smart contract design

:::warning

Transferring kiosks might result in unexpected behaviors while an asset is being rented. If you want to disallow kiosk transferring all together, consider using personal kiosks.

:::

The rental smart contract uses the [Kiosk Apps](../../../standards/kiosk-apps.mdx) standard. Both the lender and borrower must install a Kiosk extension to take part, and the creator of the borrowed asset type must create a rental policy and `ProtectedTP` object to allow the extension to manage rentals while enforcing royalties.

:::info

This implementation is charging a rental fee based on days. You can re-purpose and update the logic to support charging per hour, or even seconds.

:::

## Move modules

The NFT Rental example uses a single module, `nft_rental.move`. You can find the source for this file hosted in the [sui repository](https://github.com/MystenLabs/sui/tree/main/examples/move/nft-rental/sources/nft_rental.move) in the `examples` directory. The source code includes extensive comments to help you follow the example's logic and structure. 

### `nft_rental`

The `nft_rental` module provides an API that facilitates lending or borrowing through the following operations:

- List for renting
- Delist from renting
- Rent
- Borrow by reference and borrow by value
- Reclaim for the lender

### Structs

The object model of the `nft_rental` module provides the structure of the app, beginning with the `Rentables` object. The struct has only the `drop` ability and acts as the extension key for the Kiosk `Rentables` extension.

```move
public struct Rentables has drop {}
```

The `Rented` struct represents a rented item. The only field the struct includes is the ID of the object. It is used as the dynamic field key in the borrower's `Bag` entry when someone is actively borrowing an item. The struct has `store`, `copy`, and `drop` abilities because they are necessary for all dynamic field keys.

```move
public struct Rented has store, copy, drop { id: ID }
```

The `Listed` struct represents a listed item. The only field the struct includes is the ID of the object. It is used as the dynamic field key in the renter's `Bag` entry after an item is listed for renting. Like `Rented`, this struct has `store`, `copy`, and `drop` abilities because they are necessary for all dynamic field keys.

```move
public struct Listed has store, copy, drop { id: ID }
```

The `Promise` struct is created for borrowing by value. The `Promise` operates as the hot potato (a struct that has no capabilities that you can only pack and unpack in its module) that can only be resolved by returning the item back to the extension's `Bag`.

The `Promise` field lacks the `store` ability as it shouldn't be wrapped inside other objects.
It also lacks the `drop` ability because only the `return_val` function can consume it.

```move
public struct Promise {
  item: Rented,
  duration: u64,
  start_date: u64,
  price_per_day: u64,
  renter_kiosk: address,
  borrower_kiosk: ID
}
```

The `Rentable` struct is a wrapper object that holds an asset that is being rented. Contains information relevant to the rental period, cost, and renter.
This struct requires the `store` ability because it stores a value `T` that definitely also has `store`.

```move
public struct Rentable<T: key + store> has store {
  object: T,
  /// Total amount of time offered for renting in days.
  duration: u64,
  /// Initially undefined, is updated once someone rents it.
  start_date: Option<u64>,
  price_per_day: u64,
  /// The kiosk ID that the object was taken from.
  kiosk_id: ID,
}
```

The `RentalPolicy` struct is a shared object that every creator mints. The struct defines the royalties the creator receives from each rent invocation.

```move
public struct RentalPolicy<phantom T> has key, store {
  id: UID,
  balance: Balance<SUI>,
  /// Note: Move does not support float numbers.
  ///
  /// If you need to represent a float, you need to determine the desired
  /// precision and use a larger integer representation.
  ///
  /// For example, percentages can be represented using basis points:
  /// 10000 basis points represent 100% and 100 basis points represent 1%.
  amount_bp: u64
}
```

The `ProtectedTP` object is a shared object that creators mint to enable renting. The object provides authorized access to an empty `TransferPolicy`.
This is in part required because of the restrictions that Kiosk imposes around royalty enforced items and their tradability. 
Additionally it allows the rental module to operate within the Extension framework while maintaining the guarantee that the assets 
handled will always be tradable.

A protected empty transfer policy is required to facilitate the rental process so that the extension can transfer the asset without any additional rules to resolve (like lock rule, loyalty rule, and so on). If creators want to enforce royalties on rentals, they can use the `RentalPolicy` detailed previously.

```move
public struct ProtectedTP<phantom T> has key, store {
  id: UID,
  transfer_policy: TransferPolicy<T>,
  policy_cap: TransferPolicyCap<T>
}
```

### Function signatures

The NFT Rental example includes the following functions that define the project's logic. 

The `install` function enables installation of the `Rentables` extension in a kiosk. The party facilitating the rental process is responsible for making sure that the user installs the extension in their kiosk.

```move
public fun install(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  ctx: &mut TxContext
){
  kiosk_extension::add(Rentables {}, kiosk, cap, PERMISSIONS, ctx);
}
```

The `remove` function enables the owner (and only the owner) of the kiosk to remove the extension. The extension storage must be empty for the transaction to succeed. The extension storage empties after the user is no longer borrowing or renting any items. The `kiosk_extension::remove` function performs the ownership check before executing. 

```move
public fun remove(kiosk: &mut Kiosk, cap: &KioskOwnerCap, _ctx: &mut TxContext){
  kiosk_extension::remove<Rentables>(kiosk, cap);
}
```

The `setup_renting` function mints and shares a `ProtectedTP` and a `RentalPolicy` object for type `T`. The publisher of type `T` is the only entity that can perform the action.

```move
public fun setup_renting<T>(publisher: &Publisher, amount_bp: u64, ctx: &mut TxContext) {
  // Creates an empty TP and shares a ProtectedTP<T> object.
  // This can be used to bypass the lock rule under specific conditions.
  // Storing inside the cap the ProtectedTP with no way to access it
  // as we do not want to modify this policy
  let (transfer_policy, policy_cap) = transfer_policy::new<T>(publisher, ctx);

  let protected_tp = ProtectedTP {
    id: object::new(ctx),
    transfer_policy,
    policy_cap,
  };

  let rental_policy = RentalPolicy<T> {
    id: object::new(ctx),
    balance: balance::zero<SUI>(),
    amount_bp,
  };

  transfer::share_object(protected_tp);
  transfer::share_object(rental_policy);
}
```

The `list` function enables listing of an asset within the `Rentables` extension's bag, creating a bag entry with the asset's ID as the key and a `Rentable` wrapper object as the value. Requires the existence of a `ProtectedTP` transfer policy that only the creator of type `T` can create. The function assumes an item is already placed (and optionally locked) in a kiosk.

```move
public fun list<T: key + store>(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  protected_tp: &ProtectedTP<T>,
  item_id: ID,
  duration: u64,
  price_per_day: u64,
  ctx: &mut TxContext,
) {
    
  // Aborts if Rentables extension is not installed.
  assert!(kiosk_extension::is_installed<Rentables>(kiosk), EExtensionNotInstalled);

  // Sets the kiosk owner to the transaction sender to keep metadata fields up to date.
  // This is also crucial to ensure the correct person receives the payment.
  // Prevents unexpected results in cases where the kiosk could have been transferred 
  // between users without the owner being updated.
  kiosk.set_owner(cap, ctx);

  // Lists the item for zero SUI.
  kiosk.list<T>(cap, item_id, 0);

  // Constructs a zero coin.
  let coin = coin::zero<SUI>(ctx);
  // Purchases the item with 0 SUI.
  let (object, request) = kiosk.purchase<T>(item_id, coin);

  // Resolves the TransferRequest with the empty TransferPolicy which is protected and accessible only via this module.
  let (_item, _paid, _from) = protected_tp.transfer_policy.confirm_request(request);

  // Wraps the item in the Rentable struct along with relevant metadata.
  let rentable = Rentable {
    object,
    duration,
    start_date: option::none<u64>(),
    price_per_day,
    kiosk_id: object::id(kiosk),
  };

  // Places the rentable as listed in the extension's bag (place_in_bag is a helper method defined in nft_rental.move file).
  place_in_bag<T, Listed>(kiosk, Listed { id: item_id }, rentable);
}
```

The `delist` function allows the renter to delist an item, as long as it's not currently being rented. The function also places (or locks, if a lock rule is present) the object back to owner's kiosk. You should mint an empty `TransferPolicy` even if you don't want to apply any royalties. If at some point you do want to enforce royalties, you can always update the existing `TransferPolicy`.

```move
public fun delist<T: key + store>(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  transfer_policy: &TransferPolicy<T>,
  item_id: ID,
  _ctx: &mut TxContext,
) {

  // Aborts if the cap doesn't match the Kiosk.
  assert!(kiosk.has_access(cap), ENotOwner);

  // Removes the rentable item from the extension's Bag (take_from_bag is a helper method defined in nft_rental.move file). 
  let rentable = take_from_bag<T, Listed>(kiosk, Listed { id: item_id });

  // Deconstructs the Rentable object.
  let Rentable {
    object,
    duration: _,
    start_date: _,
    price_per_day: _,
    kiosk_id: _,
  } = rentable;

  // Respects the lock rule, if present, by re-locking the asset in the owner's Kiosk.
  if (has_rule<T, LockRule>(transfer_policy)) {
    kiosk.lock(cap, transfer_policy, object);
  } else {
    kiosk.place(cap, object);
  };
}
```

The `rent` function enables renting a listed `Rentable`. It permits anyone to borrow an item on behalf of another user, provided they have the `Rentables` extension installed. The `rental_policy` defines the portion of the coin that is retained as fees and added to the rental policy's balance.

```move
public fun rent<T: key + store>(
  renter_kiosk: &mut Kiosk,
  borrower_kiosk: &mut Kiosk,
  rental_policy: &mut RentalPolicy<T>,
  item_id: ID,
  mut coin: Coin<SUI>,
  clock: &Clock,
  ctx: &mut TxContext,
) {

  // Aborts if Rentables extension is not installed.
  assert!(kiosk_extension::is_installed<Rentables>(borrower_kiosk), EExtensionNotInstalled);

  let mut rentable = take_from_bag<T, Listed>(renter_kiosk, Listed { id: item_id });

  // Calculates the price of the rental based on the days it was rented for by ensuring the outcome can be stored as a u64.
  let max_price_per_day = MAX_VALUE_U64 / rentable.duration;
  assert!(rentable.price_per_day <= max_price_per_day, ETotalPriceOverflow);
  let total_price = rentable.price_per_day * rentable.duration;

  // Accepts only exact balance for the payment and does not give change.
  let coin_value = coin.value();
  assert!(coin_value == total_price, ENotEnoughCoins);

  // Calculate fees_amount using the given basis points amount (percentage), ensuring the
  // result fits into a 64-bit unsigned integer.
  let mut fees_amount = coin_value as u128;
  fees_amount = fees_amount * (rental_policy.amount_bp as u128);
  fees_amount = fees_amount / (MAX_BASIS_POINTS as u128);

  // Calculate fees_amount using the given basis points amount (percentage), ensuring the result fits into a 64-bit unsigned integer.
  let fees = coin.split(fees_amount as u64, ctx);

  // Merges the fee balance of the given coin with the RentalPolicy balance.
  coin::put(&mut rental_policy.balance, fees);
  // Transfers the payment to the renter.
  transfer::public_transfer(coin, renter_kiosk.owner());
  rentable.start_date.fill(clock.timestamp_ms());

  place_in_bag<T, Rented>(borrower_kiosk, Rented { id: item_id }, rentable);
}
```

The `borrow` function enables the borrower to acquire the `Rentable` by reference from their bag.

```move
public fun borrow<T: key + store>(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  item_id: ID,
  _ctx: &mut TxContext,
): &T {
  // Aborts if the cap doesn't match the Kiosk.
  assert!(kiosk.has_access(cap), ENotOwner);
  let ext_storage_mut = kiosk_extension::storage_mut(Rentables {}, kiosk);
  let rentable: &Rentable<T> = &ext_storage_mut[Rented { id: item_id }];
  &rentable.object
}
```

The `borrow_val` function enables the borrower to temporarily acquire the `Rentable` with an agreement or promise to return it. The `Promise` stores all the information about the `Rentable`, facilitating the reconstruction of the `Rentable` upon object return.

```move
public fun borrow_val<T: key + store>(
  kiosk: &mut Kiosk,
  cap: &KioskOwnerCap,
  item_id: ID,
  _ctx: &mut TxContext,
): (T, Promise) {
  // Aborts if the cap doesn't match the Kiosk.
  assert!(kiosk.has_access(cap), ENotOwner);
  let borrower_kiosk = object::id(kiosk);

  let rentable = take_from_bag<T, Rented>(kiosk, Rented { id: item_id });

  // Construct a Promise struct containing the Rentable's metadata.
  let promise = Promise {
    item: Rented { id: item_id },
    duration: rentable.duration,
    start_date: *option::borrow(&rentable.start_date),
    price_per_day: rentable.price_per_day,
    renter_kiosk: rentable.kiosk_id,
    borrower_kiosk
  };

  // Deconstructs the rentable and returns the promise along with the wrapped item T.
  let Rentable {
    object,
    duration: _,
    start_date: _,
    price_per_day: _,
    kiosk_id: _,
  } = rentable;

  (object, promise)
}
```

The `return_val` function enables the borrower to return the borrowed item.

```move
public fun return_val<T: key + store>(
  kiosk: &mut Kiosk,
  object: T,
  promise: Promise,
  _ctx: &mut TxContext,
) {
  assert!(kiosk_extension::is_installed<Rentables>(kiosk), EExtensionNotInstalled);

  let Promise {
    item,
    duration,
    start_date,
    price_per_day,
    renter_kiosk,
    borrower_kiosk,
  } = promise;

  let kiosk_id = object::id(kiosk);
  assert!(kiosk_id == borrower_kiosk, EInvalidKiosk);

  let rentable = Rentable {
    object,
    duration,
    start_date: option::some(start_date),
    price_per_day,
    kiosk_id: renter_kiosk,
  };

  place_in_bag(kiosk, item, rentable);
}
```
:::note

The `reclaim` functionality is manually invoked and the rental service provider is responsible for ensuring that the renter is reminded to `reclaim`. As such, this can cause the borrower to hold the asset for longer than the rental period. This can be mitigated through modification of the current contract by adding an assertion in the `borrow` and `borrow_val` functions to check if the rental period has expired.

:::

The `reclaim` function enables an owner to claim back their asset after the rental period is over and place it inside their kiosk. If a lock rule is present, the example also locks the item inside the owner kiosk. 

```move
public fun reclaim<T: key + store>(
  renter_kiosk: &mut Kiosk,
  borrower_kiosk: &mut Kiosk,
  transfer_policy: &TransferPolicy<T>,
  clock: &Clock,
  item_id: ID,
  _ctx: &mut TxContext,
) {

  // Aborts if Rentables extension is not installed.
  assert!(kiosk_extension::is_installed<Rentables>(renter_kiosk), EExtensionNotInstalled);

  let rentable = take_from_bag<T, Rented>(borrower_kiosk, Rented { id: item_id });

  // Destructures the Rentable struct to place it back to the renter's Kiosk.
  let Rentable {
    object,
    duration,
    start_date,
    price_per_day: _,
    kiosk_id,
  } = rentable;

  // Aborts if provided kiosk is different that the initial kiosk the item was borrowed from.
  assert!(object::id(renter_kiosk) == kiosk_id, EInvalidKiosk);

  let start_date_ms = *option::borrow(&start_date);
  let current_timestamp = clock.timestamp_ms();
  let final_timestamp = start_date_ms + duration * SECONDS_IN_A_DAY;

  // Aborts if rental duration has not elapsed.
  assert!(current_timestamp > final_timestamp, ERentingPeriodNotOver);

  // Respects the lock rule, if present, by re-locking the asset in the owner's kiosk.
  if (transfer_policy.has_rule<T, LockRule>()) {
    kiosk_extension::lock<Rentables, T>(
      Rentables {},
      renter_kiosk,
      object,
      transfer_policy,
    );
  } else {
    kiosk_extension::place<Rentables, T>(
      Rentables {},
      renter_kiosk,
      object,
      transfer_policy,
    );
  };
}
```

## Sequence diagrams

:::note

This implementation assumes that each creator, as an enabling action, creates a `TransferPolicy` even if empty, so that the `Rentables` extension can operate. This is a requirement in addition to invoking the `setup_renting` method.

:::

### Initialize

The initialization process is part of the flow but only happens once for each entity:

- For a new type that a creator would like to allow to be rented
    - Involves invoking `setup_renting` and `TransferPolicy` creation with optional lock rule
- For a Borrower that has never borrowed before using this framework
    - If no kiosk exists for the user, one should be created
    - Involves installing the extension in their kiosk
- For a Renter that has never rented before using this framework
    - If no kiosk exists for the user, one should be created
    - Involves installing the extension in their kiosk

```mermaid
sequenceDiagram
    participant Creator
    participant Renter
    participant Borrower
    participant nft_rental module
    participant Renter's Extension
    participant Borrower's Extension
	participant transfer_policy module
    participant kiosk_lock_rule module
    participant blockchain
rect rgba(191, 223, 255, 0.2) 
		note right of Creator: Setup Renting
    Creator->>nft_rental module: Use Publisher and amountBP as inputs
    nft_rental module-->>blockchain: Shares ProtectedTP and RentalPolicy
    end
rect rgba(191, 223, 255, 0.2) 
		note right of Creator: Create TransferPolicy
    Creator ->> transfer_policy module: Use Publisher as input to create TransferPolicy
    transfer_policy module -->> blockchain: Shares TransferPolicy
    transfer_policy module-->> Creator: Returns TransferPolicyCap
    end
opt Add lock rule
    Creator ->> kiosk_lock_rule module: Use TransferPolicyCap as input in kiosk_lock_rule::add
    blockchain ->> kiosk_lock_rule module: Use TransferPolicy as input in kiosk_lock_rule::add
    kiosk_lock_rule module -->> blockchain: Shares TransferPolicy with lock rule
    kiosk_lock_rule module -->> Creator: Returns TransferPolicyCap
    end
rect rgba(191, 223, 255, 0.2)
		note right of Renter: Install Extension
    Renter->>nft_rental module: Use kiosk, kioskOwnerCap as input to install extension
    nft_rental module-->>Renter's Extension: Extension is installed to kiosk
    end
rect rgba(191, 223, 255, 0.2)
		note right of Borrower: Install Extension
    Borrower->>nft_rental module: Use kiosk, kioskOwnerCap as input to install extension
    nft_rental module-->>Borrower's Extension: Extension is installed to kiosk
    end
```

### List-Rent-Borrow-Reclaim

```mermaid
sequenceDiagram
    participant Creator's Rental Policy
    participant Renter
    participant Borrower
    participant nft_rental module
    participant Renter's Extension Bag
    participant Borrower's Extension Bag
    participant kiosk module
    participant Renter's Kiosk
    participant coin module
    participant blockchain
rect rgba(191, 223, 255, 0.2) 
    note right of Renter: List for rent
    Renter->>nft_rental module: Use kiosk, kioskOwnerCap, ProtectedTP, ObjectID and Renting info as inputs in list
    blockchain->>nft_rental module: Use protectedTP as input in list
    nft_rental module->>kiosk module: List object for zero price
    nft_rental module->>kiosk module: Purchase Object
    Renter's Kiosk->>kiosk module: Take object from kiosk
    kiosk module-->>nft_rental module: Returns Object
    nft_rental module-->>Renter's Extension Bag: Place Object in renter's bag
    end
rect rgba(191, 223, 255, 0.2)
		note right of Borrower: Rent
    Borrower->>nft_rental module: Use renter_kiosk, borrower_kiosk, RentalPolicy, objectID, coin and clock as inputs in rent
    blockchain->>nft_rental module: Use RentalPolicy as input in rent
    nft_rental module->>coin module: Calculate payment and fees
    coin module -->> Renter: Payment
    coin module -->> Creator's Rental Policy: Fees
    Renter's Extension Bag->>nft_rental module: Take object from renter's bag
    nft_rental module-->>Borrower's Extension Bag: Place rented Object in borrower's bag
    end
rect rgba(191, 223, 255, 0.2)
		note right of Borrower: Borrow
    Borrower->>nft_rental module: Use kiosk, kioskOwnerCap, ObjectID as input in borrow
    Borrower's Extension Bag->>nft_rental module: Take object from borrower's bag
    nft_rental module-->>Borrower: Object, Promise
        note right of Borrower: Perform operation & return Borrowed Item
    Borrower->>Borrower: Operation on Object
    Borrower->>nft_rental module: Resolve return promise by returning Object, Promise
    nft_rental module-->>Borrower's Extension Bag: Place rented Object in borrower's bag
    end
rect rgba(191, 223, 255, 0.2)
		note right of Renter: Reclaim
    Renter->>nft_rental module: Use renter_kiosk, borrower_kiosk, clock as inputs in reclaim
    blockchain ->>nft_rental module: Use TransferPolicy as input in reclaim
    Borrower's Extension Bag->>nft_rental module: Take Object from borrower's bag if renting period is over
    alt Empty Transfer Policy
        nft_rental module-->>Renter's Kiosk: Place Object
    else TransferPolicy with lock rule
        nft_rental module-->>Renter's Kiosk: Lock Object
    end 
    end
```

### List-Delist

```mermaid
sequenceDiagram
    participant Renter
    participant nft_rental module
    participant Renter's Extension Bag
    participant kiosk module
    participant Renter's Kiosk
    participant blockchain
rect rgba(191, 223, 255, 0.2) 
	note right of Renter: List for rent
    Renter->>nft_rental module: Use kiosk, kioskOwnerCap, ProtectedTP, ObjectID and Renting info as inputs in list
    blockchain->>nft_rental module: Use protectedTP as input in list
    nft_rental module->>kiosk module: List object for zero price
    nft_rental module->>kiosk module: Purchase Object
    Renter's Kiosk->>kiosk module: Take object from kiosk
    kiosk module-->>nft_rental module: Returns Object
    nft_rental module-->>Renter's Extension Bag: Place Object in renter's bag
    end
rect rgba(191, 223, 255, 0.2)
		note right of Renter: Delist
    Renter->>nft_rental module: Use renter_kiosk, borrower_kiosk, ObjectID as inputs in delist
    blockchain->>nft_rental module: Use transferPolicy as input in delist
    Renter's Extension Bag->>nft_rental module: Take Object from renter's bag
    alt Empty Transfer Policy
        nft_rental module-->>Renter's Kiosk: Place Object
    else TransferPolicy with lock rule
        nft_rental module-->>Renter's Kiosk: Lock Object
    end 
    end
```

## Deployment

<ImportContent source="initialize-sui-client-cli.mdx" mode="snippet" />

<ImportContent source="publish-to-devnet-with-coins.mdx" mode="snippet" />

## Related links

<RelatedLink href="https://github.com/MystenLabs/sui/tree/main/examples/move/nft-rental" label="NFT Rental example" desc="The source code that this document references." />
<RelatedLink to="/standards/kiosk.mdx" />
<RelatedLink to="/standards/kiosk-apps.mdx" />
<RelatedLink to="/concepts/transfers/custom-rules.mdx" />

>>>> sui/docs/content/guides/developer/nft/nft-soulbound.mdx
---
title: Soulbound NFT Example
description: An example using Sui Move struct abilities and the Sui Framework's `transfer` module to make a NFT soulbound (non-transferable).
keywords: [ERC-721, NFT, Soulbound]
---

A soulbound NFT is an NFT that is non-transferable. After an NFT is minted to a Sui account, the NFT is bound to that account and cannot be transferred. This implementation leverages the custom logic of the Sui framework's transfer functions. The <UnsafeLink href="/references/framework/sui-framework/sui_sui/transfer">`sui::transfer` module</UnsafeLink> contains 2 functions that transfer objects: <UnsafeLink href="/references/framework/sui-framework/sui_sui/transfer#function-transfer">`transfer::transfer`</UnsafeLink> and <UnsafeLink href="/references/framework/sui-framework/sui_sui/transfer#function-public_transfer">`transfer::public_transfer`</UnsafeLink>.

Typically, when defining new NFTs or object types on Sui, you don't need to create a transfer function because the Sui Framework offers `transfer::public_transfer` which anyone can use to transfer objects. However, `transfer::public_transfer` requires that transferred objects have the `key` and `store` ability. Therefore, if you define a new NFT type that has the `key` ability, meaning it is a Sui object, but not the `store` ability, the holders cannot use `transfer::public_transfer`. This results in a soulbound NFT.

You can also create custom transfer logic for NFTs on Sui. The `transfer::transfer` function has custom rules performed by the Sui Move bytecode verifier that ensures that the transferred objects are defined in the module where transfer is invoked. While removing the `store` ability from a struct definition makes `transfer::public_transfer` unusable, `transfer::transfer` can still be used as long as you use it in the module that defined that object's type. This allows the module owner to provide custom transfer logic for their soulbound NFTs. 

## Example

The following example creates a basic soulbound NFT on Sui. The `TestnetSoulboundNFT` struct defines the NFT with `id`, `name`, `description`, and `url` fields. 

<ImportContent source="examples/move/nft-soulbound/sources/testnet_soulbound_nft.move" mode="code" struct="TestnetSoulboundNFT" noComments />

This `TestnetSoulboundNFT` struct is defined with the `key` ability but without the `store` ability. This means you cannot transfer it with `transfer::public_transfer`. Instead, use `transfer::transfer` with custom transfer logic implemented in the same module. 

This example also shows how to provide custom transfer logic using the `transfer::transfer` function. This is where you can add additional logic, such as resetting the NFT's stats or requiring a payment. Don't provide this functionality if the NFT is fully soulbound. 

<ImportContent source="examples/move/nft-soulbound/sources/testnet_soulbound_nft.move" mode="code" fun="transfer" />

<details>

<summary>

`testnet_soulbound_nft.move` 

</summary>

<ImportContent source="examples/move/nft-soulbound/sources/testnet_soulbound_nft.move" mode="code" />

</details>

## Related links

<RelatedLink href="https://github.com/MystenLabs/sui/tree/main/examples/move/nft-soulbound" label="Soulbound NFT example source code" desc="The source code that this document references." />
<RelatedLink to="/guides/developer/nft/nft-rental.mdx" />
<RelatedLink to="/guides/developer/nft/asset-tokenization.mdx" />

>>>> sui/docs/content/guides/developer/stablecoins.mdx
---
title: Stablecoins on Sui
sidebar_label: Stablecoins
description: Stablecoins are a type of cryptocurrency that are designed to maintain a stable value relative to a fiat currency or a basket of assets. 
keywords: [ stablecoins, USDT, tether, agora, USDC, USD coin, AUSD, ondo USDY, USDY, using stablecoins, stablecoins in ptbs, ptbs, programmable transaction blocks, stablecoins in programmable transaction blocks ]
pagination_prev: null
draft: true
---

Stablecoins are a type of cryptocurrency that are designed to maintain a stable value relative to a fiat currency or a basket of assets. They are widely used for trading, lending, and as a store of value. 

## Available stablecoins

On Sui, you can interact with various stablecoins such as USDC, USDT, Agora, and Ondo USDY.

### USDC (USD Coin)

USDC is a fully collateralized US dollar stablecoin issued by regulated financial institutions. Each USDC token is backed by one US dollar held in reserve. USDC is widely used for trading, payments, and as a stable store of value.

For more detailed information on how to interact with USDC on Sui, refer to the [USDC guide](#usdc-guide).

**Site:** [Circle](https://www.circle.com/en/usdc)

### USDT (Tether)

USDT, also known as Tether, is one of the oldest and most widely used stablecoins. It is pegged to the US dollar and is backed by a mix of reserves, including cash, cash equivalents, and other assets.

USDT is currently not issued natively on Sui. For more information on bridging USDT to Sui, refer to [SUI Bridging](../../concepts/tokenomics/sui-bridging.mdx).

**Site:** [Tether](https://tether.to/)

### Agora

AUSD is a fully collateralized US dollar stablecoin issued by Agora Finance.

**Site:** [Agora Finance](https://www.agora.finance/)

### Ondo USDY
USDY is a fully collateralized US dollar stablecoin issued by Ondo Finance, allowing users to earn yield from US Treasury Bills.

**Site:** [Ondo Finance](https://ondo.finance/)

## How to use USDC on Sui {#usdc-guide}

:::info
While this example uses USDC, the same principles can be applied to any asset on Sui that uses the [Sui Currency Standard](/standards/currency.mdx).
:::


<Tabs className="tabsHeadingCentered--small--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install).

- [x] Make sure you have some USDC tokens. Get Testnet tokens from Circle's [faucet](https://faucet.circle.com/).

</TabItem>
</Tabs>

### USDC stablecoin source code

The USDC stablecoin source code is available in the [circlefin/stablecoin-sui](https://github.com/circlefin/stablecoin-sui/blob/master/packages/usdc/sources/usdc.move) repository.

### Import the USDC module in your Move package

To import the USDC module, add the following line to the `[dependencies]` section of your Move package's `Move.toml` file:

```toml
usdc = { git = "https://github.com/circlefin/stablecoin-sui.git", subdir = "packages/usdc", rev = "master" }
```

After importing the module, your Move package should look like the following:

<ImportContent source="examples/move/usdc_usage/Move.toml" mode="code" />

:::warning
The `usdc` package uses a specific version of the `sui` package, which causes a version conflict with the `Sui` package in the Sui framework. You can override the version of the `Sui` package in your `Move.toml` file to use a different version. Add the `override = true` flag to the `Sui` package in your `Move.toml` file.
:::

### Using USDC in Move

USDC uses the [Sui Currency Standard](/standards/currency.mdx) and can be used just like any other coin type in the Sui framework.

After importing the `usdc` package, you can use the `USDC` type.

```move
use usdc::usdc::USDC;
```

Then use the `USDC` type just as you would use the `SUI` type when accepting a `Coin<SUI>` parameter.

<ImportContent source="examples/move/usdc_usage/sources/example.move" mode="code" fun="buy_sword_with_usdc" />

The following example demonstrates how to use the USDC stablecoin in a Move package and how it relates to using the `SUI` type as well as any generic coin types.

<ImportContent source="examples/move/usdc_usage/sources/example.move" mode="code" />

### Using USDC in PTBs

Use USDC in your [PTBs](/guides/developer/sui-101/building-ptb) just like any other coin type.

Create a `Coin<USDC>` object with the `coinWithBalance` function.

```typescript
const usdcCoin = coinWithBalance({
  type: '0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC',
  balance: 1_000_000
})
```

:::info
`0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29` is the [Testnet address](https://suiscan.xyz/testnet/coin/0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC) for USDC, while `0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7` is the [Mainnet address](https://suiscan.xyz/coin/0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC).
:::

This coin object can be used as a parameter for any function that accepts a `Coin<USDC>` parameter or a generic `Coin` parameter.

```typescript
const [sword] = tx.moveCall({
  target: '0xcbbf37a851ed7b625731ca497e2d4aea18cf18145fac3b78bd64f274f6a09d30::usdc_usage::buy_sword_with_usdc', 
  arguments: [
    usdcCoin
  ]
});
```

```typescript
const [sword] = tx.moveCall({
  target: '0xcbbf37a851ed7b625731ca497e2d4aea18cf18145fac3b78bd64f274f6a09d30::usdc_usage::buy_sword_with_arbitrary_coin', 
  typeArguments: ['0xa1ec7fc00a6f40db9693ad1415d0c193ad3906494428cf252621037bd7117e29::usdc::USDC'],
  arguments: [
    usdcCoin
  ]
});
```

This coin object can also be used as input for the `transferObjects` function.

```typescript
tx.transferObjects([usdcCoin], recipientAddress);
```

## Related links

<RelatedLink to="/guides/developer/coin/regulated.mdx" />
<RelatedLink to="/guides/developer/coin/loyalty.mdx" />
<RelatedLink to="/guides/developer/coin/in-game-token.mdx" />

>>>> sui/docs/content/guides/developer/starter-templates.mdx
---
title: Starter Templates
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/developer/sui-101.mdx
---
title: Sui Essentials
description: Collection of core Sui concepts that developers use to create objects and interact with them on the Sui blockchain. 
keywords: [ working with ptbs, ptbs, using events, shared object, owned objects, on-chain time, objects, events, programmable transaction blocks, sui 101, essential sui ]
pagination_prev: null
---

Follow these guides to learn about essential Sui concepts.

<Cards>
<Card title="Object Ownership" href="/guides/developer/sui-101/object-ownership" />
<Card title="Using Events" href="/guides/developer/sui-101/using-events" />
<Card title="Access Sui Data" href="/guides/developer/sui-101/data-serving" />
<Card title="Access On-Chain Time" href="/guides/developer/sui-101/access-time" />
<Card title="Connect to a Local Network" href="/guides/developer/sui-101/local-network" />
</Cards>

## Signing & sending transactions 

Learn about signing and sending transactions.

<Cards>
<Card title="Sponsored Transactions" href="/guides/developer/sui-101/sponsor-txn" />
<Card title="Avoid Equivocation" href="/guides/developer/sui-101/avoid-equivocation" />
<Card title="Building PTBs" href="/guides/developer/sui-101/building-ptb" />
<Card title="Coin Management" href="/guides/developer/sui-101/coin-mgt" />
<Card title="Simulating References" href="/guides/developer/sui-101/simulating-refs" />
</Cards>

>>>> sui/docs/content/guides/developer/sui-101/access-time.mdx
---
title: Access On-Chain Time
description: Access network-based time for your transactions. Sui provides a Clock module to capture near-real time or epoch time in your Sui packages.
keywords: [ network-based time, on-chain time, on-chain time, sui::clock::Clock, clock module, sui::clock::timestamp_ms, epoch timestamps, timestamps, use time in transactions, sui::tx_context ] 
---

You have several options for accessing network-based time for your transactions. If you need a near real-time measurement (within a few seconds), use the immutable reference of time provided by the `Clock` module in Move. The reference value from this module updates with every network checkpoint. If you don't need as current a time slice, use the `epoch_timestamp_ms` function to capture the precise moment the current epoch started.

## The `sui::clock::Clock` module

To access a current timestamp, you must pass a read-only reference of `sui::clock::Clock` as an entry function parameter in your transactions. Sui provides an instance of `Clock` at address `0x6`. You cannot create new instances.

Use the `timestamp_ms` function from the `sui::clock` module to extract a unix timestamp in milliseconds.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/clock.move" mode="code" fun="timestamp_ms" noComments />

The example below demonstrates an entry function that emits an event containing a timestamp from the `Clock`:

<ImportContent source="examples/move/basics/sources/clock.move" mode="code" noComments />

Call the previous entry function with the following format, passing `0x6` as the address for the `Clock` parameter:

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client call --package <EXAMPLE> --module 'clock' --function 'access' --args '0x6' --gas-budget <GAS-AMOUNT>
```

Expect the `Clock` timestamp to change at the rate the network generates checkpoints, which is about **every 1/4 second** with Mysticeti consensus. Find the current network checkpoint rate on this [public dashboard](https://metrics.sui.io/public-dashboards/4ceb11cc210d4025b122294586961169).

Successive calls to `sui::clock::timestamp_ms` in the same transaction always produce the same result (transactions take effect instantly), but timestamps from `Clock` are otherwise monotonic across transactions that touch the same shared objects. Successive transactions see a greater or equal timestamp to their predecessors.

Any transaction that requires access to a `Clock` must go through consensus because the only available instance is a shared object. As a result, this technique is not suitable for transactions that must use the single-owner fastpath (see Epoch timestamps for a single-owner-compatible source of timestamps).

Transactions that use the clock must accept it as an **immutable reference** (not a mutable reference or value). This prevents contention, as transactions that access the `Clock` can only read it, so do not need to be sequenced relative to each other. Validators refuse to sign transactions that do not meet this requirement and packages that include entry functions that accept a `Clock` or `&mut Clock` fail to publish.

The following functions test `Clock`-dependent code by manually creating a `Clock` object and manipulating its timestamp. This is possible only in test code:

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/clock.move" mode="code" fun="create_for_testing,share_for_testing,increment_for_testing,set_for_testing,destroy_for_testing" noComments />

The next example presents a basic test that creates a `Clock`, increments it, and then checks its value:

<ImportContent source="crates/sui-framework/packages/sui-framework/tests/clock_tests.move" mode="code" noComments />

## Epoch timestamps

Use the following function from the `sui::tx_context` module to access the timestamp for the start of the current epoch for all transactions (including ones that do not go through consensus):

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/tx_context.move" mode="code" fun="epoch_timestamp_ms" noComments />

This function returns the point in time when the current epoch started, as a millisecond granularity unix timestamp in a `u64`. This value changes roughly **once every 24 hours**, when the epoch changes.

Tests based on `sui::test_scenario` can use `later_epoch` (following code), to exercise time-sensitive code that uses `epoch_timestamp_ms` (previous code):

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/test/test_scenario.move" mode="code" fun="later_epoch" noComments />

`later_epoch` behaves like `sui::test_scenario::next_epoch` (finishes the current transaction and epoch in the test scenario), but also increments the timestamp by `delta_ms` milliseconds to simulate the progress of time.
>>>> sui/docs/content/guides/developer/sui-101/avoid-equivocation.mdx
---
title: Avoiding Equivocation
description: Avoid unintentionally locking objects with your smart contract logic. 
keywords: [ equivocation, how to avoid equivocation, unintentionally locking objects, accidentally locking objects ]
---

On Sui, object versioning ensures that each object is referenced by a unique (`ObjectId`, `SequenceNumber`) pair, where `SequenceNumber` refers to the object's version. Only a single transaction can modify an object at a specific version. After a transaction modifies an object, the version is incremented. Only the latest version can be used in subsequent transactions.

Object versioning tracks the state of objects across transactions and epochs. 

## What is equivocation?

*Equivocation* occurs when an owned object pair (`ObjectId`, `SequenceNumber`) is used concurrently in multiple non-finalized transactions. Any object used in multiple transactions can become a source of equivocation if not managed correctly. 

Equivocation can occur when:

- A user or smart contract submits 2 transactions using the same (`ObjectId`, `SequenceNumber`) before the first is finalized.
- Inadvertent logic traps in smart contract code, for example, when handling [sponsored transactions](/guides/developer/sui-101/sponsor-txn#client-equivocation-risk).

Even though both transactions aren't finalized, submitting equivocated transactions still causes other problems for both developers and users. For example, when equivocation is detected, the involved objects are locked until the end of the current epoch. Neither transaction can proceed, and the objects cannot be used in any other transaction. Bad actors could intentionally submit equivocated transactions to lock up important objects and intentionally disrupt dApps.

## Double spending 

Equivocation might also occur when a user attempts to pay for gas with the same coin object across multiple transactions.

Sui's versioning architecture enables the safe reuse of the same gas coin across a series of transactions. Among other processing, the first transaction advances the version number of the coin and returns it to the sender. The next transaction can then use the updated version of that coin to pay for gas. This prevents equivocation because each transaction references a different version of the same coin.

To prevent double spending, validators lock objects as they validate transactions.

## Punishment for equivocation

The Sui network has safeguards to punish validators who engage in equivocation. While Sui's object versioning is designed to prevent equivocation, punishment is still necessary. Prevention does not stop users from submitting transactions that attempt equivocation, which lock objects and degrade network usability. Punishing equivocation also discourages both accidental and intentional abuse, motivating developers to ensure their code does not accidentally cause equivocation.

## Common pitfalls to avoid

1. For most smart contracts, equivocation is not an intended behavior. A common source of unintentional equivocation comes from multiple transactions performed by the same address. If you don't take care to handle the gas fees properly, you could lock up your smart contract by trying to use the same coin (and version) for more than 1 transaction.

    **Recommendation**: If you use a single thread, serialize transactions that use the same owned object. PTBs allow your transactions to use multiple operations against the same owned object. A PTB is essentially a single, serialized transaction, which can prevent `SequenceNumber` errors.

    **Recommendation**: Always take advantage of the inherent batching that PTBs provide. For example, consider an airdrop scenario where you want to mint and transfer an object to many users. Because PTBs allow up to 1,024 operations in a single PTB, you can mint and transfer the airdrop object to 512 users in a single transaction. This approach is much more cost efficient than looping over 512 individual transactions that mint and transfer to a single user each time. Batching transactions might remove the need for parallel execution, but you must consider the atomic nature of PTBs; if 1 instruction fails, the whole PTB fails. Consequently, parallel transactions might be preferred for some use cases.

2. Parallel transactions from multiple threads can cause unintentional equivocation errors if not managed properly. A way to avoid owned object equivocation is to create a separate owned object for each transaction thread. This ensures that each thread uses the correct version of its object input.

    **Recommendation**: In cases where creating multiple owned objects is not practical or desired, you can create a wrapper around an object used across threads. The wrapper is a shared object that authorizes access to its object through an allowlist. Any time a transaction needs to access the wrapped object, it gets permission from the wrapper in the same PTB. When authorization needs transferring, the allowlist for the wrapper gets updated accordingly. This approach can create a latency bottleneck as the object wrapper creates sequentialized transactions that rely on its object for input. The Sui TypeScript SDK provides an executor class, `ParallelTransactionExecutor`, to process parallel transactions efficiently.

## Sui SDK

The Sui SDK offers transaction executors to help process multiple transactions from the same address.

### `SerialTransactionExecutor`

Use the `SerialTransactionExecutor` when you process transactions one after another. The executor grabs all the coins from the sender and combines them into a single coin that is used for all transactions.

Using the `SerialTransactionExecutor` prevents `SequenceNumber` errors by handling the versioning of object inputs across a PTB.

### `ParallelTransactionExecutor`

Use the `ParallelTransactionExecutor` when you want to process transactions with the same sender at the same time. This class creates a pool of gas coins that it manages to ensure parallel transactions don't equivocate those coins. The class tracks objects used across transactions and orders their processing so that the object inputs are also not equivocated.

## Debug tools

If you find your smart contracts unintentionally locking objects, there are some tools you can use to help fix the issue.

### `sui-tool`

You can install the `sui-tool` (https://github.com/MystenLabs/sui/tree/main/crates/sui-tool) utility and use the `locked-object` command to check the locked status of the passed asset on a specific RPC network (`--fullnode-rpc-url` value). If you provide an address, locked-object checks if all the gas objects owned by that address are locked. Pass an object ID to check if that specific object is locked.

```sh
$ cargo run --bin sui-tool
```

```sh
$ sui-tool locked-object --address 0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331 --fullnode-rpc-url <https://rpc.mainnet.sui.io:443>
```

```sh
$ sui-tool locked-object --id 0xd4c3ecf5eaa211da58c36495613899e70349f6048baaeca99596f1682e89c837 --fullnode-rpc-url <https://rpc.mainnet.sui.io:443>
```

:::tip

Include the `--rescue` flag to try and unlock the object the command targets. Rescue is possible if the object isn't already locked by a majority of validators.

:::

## Related links

<RelatedLink to="/guides/developer/sui-101/building-ptb.mdx" />
<RelatedLink to="/concepts/versioning.mdx" />
<RelatedLink to="/guides/developer/sui-101/sponsor-txn.mdx" />
<RelatedLink href="https://sdk.mystenlabs.com/typescript" label="Sui TypeScript SDK" desc="The Sui TypeScript SDK is a modular library of tools for interacting with the Sui blockchain." />
>>>> sui/docs/content/guides/developer/sui-101/building-ptb.mdx
---
title: Building Programmable Transaction Blocks
description: Using the Sui TypeScript SDK, you can create programmable transaction blocks to perform multiple commands in a single transaction.
keywords: [ ptbs, programmable transaction blocks, typescript SDK, how to use typescript SDK, typescript, transaction blocks, transactions as arguments, passing transactions ]
---

This guide explores creating a programmable transaction block (PTB) on Sui using the TypeScript SDK. For an overview of what a PTB is, see [Programmable Transaction Blocks](/concepts/transactions/prog-txn-blocks.mdx) in the Concepts section. If you don't already have the Sui TypeScript SDK, follow the [install instructions](https://sdk.mystenlabs.com/typescript/install) on the Sui TypeScript SDK site.

This example starts by constructing a PTB to send Sui. If you are familiar with the legacy Sui transaction types, this is similar to a `paySui` transaction. To construct transactions, import the `Transaction` class, and construct it:

```ts
import { Transaction } from '@mysten/sui/transactions';

const tx = new Transaction();
```

Using this, you can then add transactions to this PTB.

```ts
// Create a new coin with balance 100, based on the coins used as gas payment.
// You can define any balance here.
const [coin] = tx.splitCoins(tx.gas, [tx.pure('u64', 100)]);

// Transfer the split coin to a specific address.
tx.transferObjects([coin], tx.pure('address', '0xSomeSuiAddress'));
```

You can attach multiple transaction commands of the same type to a PTB as well. For example, to get a list of transfers, and iterate over them to transfer coins to each of them:

```ts
interface Transfer {
	to: string;
	amount: number;
}

// Procure a list of some Sui transfers to make:
const transfers: Transfer[] = getTransfers();

const tx = new Transaction();

// First, split the gas coin into multiple coins:
const coins = tx.splitCoins(
	tx.gas,
	transfers.map((transfer) => tx.pure('u64', transfer.amount)),
);

// Next, create a transfer transaction for each coin:
transfers.forEach((transfer, index) => {
	tx.transferObjects([coins[index]], tx.pure('address', transfer.to));
});
```

After you have the Transaction defined, you can directly execute it with a `SuiClient` and `KeyPair` using `client.signAndExecuteTransaction`.

```ts
client.signAndExecuteTransaction({ signer: keypair, transaction: tx });
```

## Constructing inputs

Inputs are how you provide external values to PTBs. For example, defining an amount of Sui to transfer, or which object to pass into a Move call, or a shared object.

There are currently 2 ways to define inputs:

- For objects: the `tx.object(objectId)` function is used to construct an input that contains an object reference.
- For pure values: the `tx.pure(type, value)` function is used to construct an input for a non-object input.
  - If value is a `Uint8Array`, then the value is assumed to be raw bytes and is used directly: `tx.pure(SomeUint8Array)`.
  - Otherwise, it's used to generate the BCS serialization layout for the value.
  - In the new version, a more intuitive way of writing is provided, for example: `tx.pure.u64(100)`, `tx.pure.string('SomeString')`, `tx.pure.address('0xSomeSuiAddress')`, `tx.pure.vector('bool', [true, false])`...

## Available transactions

Sui supports the following transaction commands:

- `tx.splitCoins(coin, amounts)`: Creates new coins with the defined amounts, split from the provided coin. Returns the coins so that it can be used in subsequent transactions.
  - Example: `tx.splitCoins(tx.gas, [tx.pure.u64(100), tx.pure.u64(200)])`
- `tx.mergeCoins(destinationCoin, sourceCoins)`: Merges the sourceCoins into the destinationCoin.
  - Example: `tx.mergeCoins(tx.object(coin1), [tx.object(coin2), tx.object(coin3)])`
- `tx.transferObjects(objects, address)`: Transfers a list of objects to the specified address.
  - Example: `tx.transferObjects([tx.object(thing1), tx.object(thing2)], tx.pure.address(myAddress))`
- `tx.moveCall({ target, arguments, typeArguments })`: Executes a Move call. Returns whatever the Sui Move call returns.
  - Example: `tx.moveCall({ target: '0x2::devnet_nft::mint', arguments: [tx.pure.string(name), tx.pure.string(description), tx.pure.string(image)] })`
- `tx.makeMoveVec({ type, elements })`: Constructs a vector of objects that can be passed into a moveCall. This is required as there's no other way to define a vector as an input.
  - Example: `tx.makeMoveVec({ elements: [tx.object(id1), tx.object(id2)] })`
- `tx.publish(modules, dependencies)`: Publishes a Move package. Returns the upgrade capability object.

## Passing transaction results as arguments

You can use the result of a transaction command as an argument in subsequent transaction commands. Each transaction command method on the transaction builder returns a reference to the transaction result.

```ts
// Split a coin object off of the gas object:
const [coin] = tx.splitCoins(tx.gas, [tx.pure.u64(100)]);
// Transfer the resulting coin object:
tx.transferObjects([coin], tx.pure.address(address));
```

When a transaction command returns multiple results, you can access the result at a specific index either using destructuring, or array indexes.

```ts
// Destructuring (preferred, as it gives you logical local names):
const [nft1, nft2] = tx.moveCall({ target: '0x2::nft::mint_many' });
tx.transferObjects([nft1, nft2], tx.pure.address(address));

// Array indexes:
const mintMany = tx.moveCall({ target: '0x2::nft::mint_many' });
tx.transferObjects([mintMany[0], mintMany[1]], tx.pure.address(address));
```

## Use the gas coin

With PTBs, you can use the gas payment coin to construct coins with a set balance using `splitCoin`. This is useful for Sui payments, and avoids the need for up-front coin selection. You can use `tx.gas` to access the gas coin in a PTB, and it is valid as input for any arguments; with the exception of `transferObjects`, `tx.gas` must be used by-reference. Practically speaking, this means you can also add to the gas coin with `mergeCoins` or borrow it for Move functions with `moveCall`.

You can also transfer the gas coin using `transferObjects`, in the event that you want to transfer all of your coin balance to another address.

Of course, you can also transfer other coins in your wallet using their `Object ID`. For example,

```ts
const otherCoin = tx.object('0xCoinObjectId');
const coin = tx.splitCoins(otherCoin, [tx.pure.u64(100)]);
tx.transferObjects([coin], tx.pure.address(address));
```

## Get PTB bytes

If you need the PTB bytes, instead of signing or executing the PTB, you can use the `build` method on the transaction builder itself.

:::tip

You might need to explicitly call `setSender()` on the PTB to ensure that the `sender` field is populated. This is normally done by the signer before signing the transaction, but will not be done automatically if you're building the PTB bytes yourself.

:::

```ts
const tx = new Transaction();

// ... add some transactions...

await tx.build({ provider });
```

In most cases, building requires your JSON RPC provider to fully resolve input values.

If you have PTB bytes, you can also convert them back into a `Transaction` class:

```ts
const bytes = getTransactionBytesFromSomewhere();
const tx = Transaction.from(bytes);
```

## Building offline

If you want to build a PTB offline (as in with no `provider` required), you need to fully define all of your input values, and gas configuration (see the following example). For pure values, you can provide a `Uint8Array` which is used directly in the transaction. For objects, you can use the `Inputs` helper to construct an object reference.

```ts
import { Inputs } from '@mysten/sui/transactions';

// For pure values:
tx.pure(pureValueAsBytes);

// For owned or immutable objects:
tx.object(Inputs.ObjectRef({ digest, objectId, version }));

// For shared objects:
tx.object(Inputs.SharedObjectRef({ objectId, initialSharedVersion, mutable }));
```

You can then omit the `provider` object when calling `build` on the transaction. If there is any required data that is missing, this will throw an error.

## Gas configuration

The new transaction builder comes with default behavior for all gas logic, including automatically setting the gas price, budget, and selecting coins to be used as gas. This behavior can be customized.

### Gas price

By default, the SDK sets the gas price to the reference gas price of the network. You can also explicitly set the gas price of the PTB by calling `setGasPrice` on the transaction builder.

```ts
tx.setGasPrice(gasPrice);
```

### Budget

By default, the SDK automatically derives the gas budget by executing a dry-run of the PTB beforehand. The SDK then uses the dry run gas consumption to determine a balance for the transaction. You can override this behavior by explicitly setting a gas budget for the transaction, by calling `setGasBudget` on the transaction builder.

:::info

Sui represents the gas budget in Sui, and you should take the gas price of the PTB into account.

:::

```ts
tx.setGasBudget(gasBudgetAmount);
```

### Gas payment

By default, the SDK automatically determines the gas payment. The SDK selects all coins at the provided address that are not used as inputs in the PTB.

The SDK merges the list of coins used as gas payment down into a single gas coin before executing the PTB, and deletes all but 1 of the gas objects. The gas coin at the 0-index is the coin that all others are merged into.

```ts
// NOTE: You need to ensure that the coins do not overlap with any
// of the input objects for the PTB.
tx.setGasPayment([coin1, coin2]);
```

Gas coins should be objects containing the coins objectId, version, and digest (ie `{ objectId: string, version: string | number, digest: string }`).

### dApp / Wallet integration

The Wallet Standard interface now supports the `Transaction` kind directly. All `signTransaction` and `signAndExecuteTransaction` calls from dApps into wallets must provide a `Transaction` class. You can then serialize this PTB class and send it to your wallet for execution.

To serialize a PTB for sending to a wallet, Sui recommends using the `tx.serialize()` function, which returns an opaque string representation of the PTB that can be passed from the Wallet Standard dApp context to your wallet. You can then convert this back into a `Transaction` using `Transaction.from()`.

:::tip

You should not build the PTB from bytes in the dApp code. Using `serialize` instead of `build` allows you to build the PTB bytes within the wallet itself. This allows the wallet to perform gas logic and coin selection as needed.

:::

```ts
// Within a dApp
const tx = new Transaction();
wallet.signTransaction({ transaction: tx });

// Your Wallet Standard code:
function handleSignTransaction(input) {
	sendToWalletContext({ transaction: input.transaction.serialize() });
}

// Within your wallet context:
function handleSignRequest(input) {
	const userTx = Transaction.from(input.transaction);
}
```

## Sponsored PTBs

The PTB builder can support sponsored PTBs by using the `onlyTransactionKind` flag when building the PTB.

```ts
const tx = new Transaction();
// ... add some transactions...

const kindBytes = await tx.build({ provider, onlyTransactionKind: true });

// Construct a sponsored transaction from the kind bytes:
const sponsoredTx = Transaction.fromKind(kindBytes);

// You can now set the sponsored transaction data that is required:
sponsoredTx.setSender(sender);
sponsoredTx.setGasOwner(sponsor);
sponsoredTx.setGasPayment(sponsorCoins);
```
>>>> sui/docs/content/guides/developer/sui-101/client-tssdk.mdx
---
title: Client App with Sui TypeScript SDK
description: Build a client-side application using the Sui TypeScript SDK.
keywords: [ typescript, typescript SDK, build app, create app, client app, client-side, client-side application, build client app, build client, dApp kit, dApp-kit ]
---

This exercise diverges from the example built in the previous topics in this section. Rather than adding a frontend to the running example, this guide walks you through setting up dApp Kit in a React App. You can connect to wallets and query data from Sui RPC nodes to display in your app. You can use this to create your own frontend for the example used previously, but if you want to get a fully functional app up and running quickly, run the following command in a terminal or console to scaffold a new app with all steps in this exercise already implemented:

<ImportContent source="info-pnpm-required.mdx" mode="snippet" />

```sh
$ pnpm create @mysten/dapp --template react-client-dapp
```

or

```sh
$ yarn create @mysten/dapp --template react-client-dapp
```

## What is the Sui TypeScript SDK?

The Sui TypeScript SDK (@mysten/sui) provides all the low-level functionality needed to interact with the Sui ecosystem from TypeScript. You can use it in any TypeScript or JavaScript project, including web apps, Node.js apps, or mobile apps written with tools like React Native that support TypeScript.

For more information on the Sui TypeScript SDK, see the [Sui TypeScript SDK documentation](https://sdk.mystenlabs.com/typescript).

## What is dApp Kit?

dApp Kit (@mysten/dapp-kit) is a collection of React hooks, components, and utilities that make building dApps on Sui straightforward. For more information on dApp Kit, see the [dApp Kit documentation](https://sdk.mystenlabs.com/dapp-kit).

## Installing dependencies

To get started, you need a React app. The following steps apply to any React app, so you can follow the same steps to add dApp Kit to an existing React app. If you are starting a new project, you can use Vite to scaffold a new React app.

Run the following command in your terminal or console, and select React as the framework, and then select a TypeScript template:

```sh npm2yarn
$ npm init vite
```

Now that you have a React app, you can install the necessary dependencies to use dApp Kit:

```sh npm2yarn
$ npm install @mysten/sui @mysten/dapp-kit @tanstack/react-query
```

## Setting up Provider components

To use all the features of dApp Kit, wrap your app with `Provider` components.

Open the root component that renders your app (the default location the Vite template uses is `src/main.tsx`) and integrate or replace the current code with the following.

The first `Provider` to set up is the `QueryClientProvider` from `@tanstack/react-query`. This `Provider` manages request state for various hooks in dApp kit. If you're already using `@tanstack/react-query`, dApp Kit can share the same `QueryClient` instance.

```ts
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<QueryClientProvider client={queryClient}>
			<App />
		</QueryClientProvider>
	</React.StrictMode>,
);
```

Next, set up the `SuiClientProvider`. This `Provider` delivers a `SuiClient` instance from `@mysten/sui` to all the hooks in dApp Kit. This `Provider` manages which network dApp Kit connects to, and can accept configuration for multiple networks. In this exercise, you connect to `devnet`.

```ts
import { SuiClientProvider } from '@mysten/dapp-kit';
import { getFullnodeUrl } from '@mysten/sui/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();
const networks = {
	devnet: { url: getFullnodeUrl('devnet') },
	mainnet: { url: getFullnodeUrl('mainnet') },
};

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<QueryClientProvider client={queryClient}>
			<SuiClientProvider networks={networks} defaultNetwork="devnet">
				<App />
			</SuiClientProvider>
		</QueryClientProvider>
	</React.StrictMode>,
);
```

Finally, set up the `WalletProvider` from `@mysten/dapp-kit`, and import styles for the `dapp-kit` components.

```ts
import '@mysten/dapp-kit/dist/index.css';

import { SuiClientProvider, WalletProvider } from '@mysten/dapp-kit';
import { getFullnodeUrl } from '@mysten/sui/client';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();
const networks = {
	devnet: { url: getFullnodeUrl('devnet') },
	mainnet: { url: getFullnodeUrl('mainnet') },
};

ReactDOM.createRoot(document.getElementById('root')!).render(
	<React.StrictMode>
		<QueryClientProvider client={queryClient}>
			<SuiClientProvider networks={networks} defaultNetwork="devnet">
				<WalletProvider>
					<App />
				</WalletProvider>
			</SuiClientProvider>
		</QueryClientProvider>
	</React.StrictMode>,
);
```

## Connecting to a wallet

With all `Providers` set up, you can use dApp Kit hooks and components. To allow users to connect their wallets to your dApp, add a `ConnectButton`.

```ts
import { ConnectButton } from '@mysten/dapp-kit';

function App() {
	return (
		<div className="App">
			<header className="App-header">
				<ConnectButton />
			</header>
		</div>
	);
}
```

The `ConnectButton` component displays a button that opens a modal when clicked, enabling the user to connect their wallet. Upon connection, the component displays their address and provides the option to disconnect.

## Getting the connected wallet address

Now that you have a way for users to connect their wallets, you can start using the `useCurrentAccount` hook to get details about the connected wallet account.

```ts
import { ConnectButton, useCurrentAccount } from '@mysten/dapp-kit';

function App() {
	return (
		<div className="App">
			<header className="App-header">
				<ConnectButton />
			</header>

			<ConnectedAccount />
		</div>
	);
}

function ConnectedAccount() {
	const account = useCurrentAccount();

	if (!account) {
		return null;
	}

	return <div>Connected to {account.address}</div>;
}
```

## Querying data from Sui RPC nodes

Now that you have the account to connect to, you can query for objects the connected account owns:

```ts
import { useCurrentAccount, useSuiClientQuery } from '@mysten/dapp-kit';

function ConnectedAccount() {
	const account = useCurrentAccount();

	if (!account) {
		return null;
	}

	return (
		<div>
			<div>Connected to {account.address}</div>;
			<OwnedObjects address={account.address} />
		</div>
	);
}

function OwnedObjects({ address }: { address: string }) {
	const { data } = useSuiClientQuery('getOwnedObjects', {
		owner: address,
	});
	if (!data) {
		return null;
	}

	return (
		<ul>
			{data.data.map((object) => (
				<li key={object.data?.objectId}>
					<a href={`https://example-explorer.com/object/${object.data?.objectId}`}>
						{object.data?.objectId}
					</a>
				</li>
			))}
		</ul>
	);
}
```

You now have a dApp connected to wallets and can query data from RPC nodes.

## Related links

The next step from here is to start interacting with Move modules, constructing transaction blocks, and making Move calls. This exercise continues in the Counter end-to-end example.

<RelatedLink to="/guides/developer/app-examples/e2e-counter.mdx" />
<RelatedLink to="/guides/developer/sui-101.mdx" />
<RelatedLink to="/references/cli/move.mdx" />
>>>> sui/docs/content/guides/developer/sui-101/coin-mgt.mdx
---
title: Coin Management
description: Because Sui uses coins as owned objects for transactions, you need to explicitly manage them in your programmable transaction block development.
keywords: [ owned objects, address-owned objects, parallel transactions, coins, coin management, typescript, rust, typescript SDK, rust SDK, gas smashing, concurrency, generic coins, coin<sui>, ]
---

A key concept when programming on Sui is that of owned objects. Address-owned objects are important in that they allow for highly parallelizable transactions. They also logically map to assets or resources that someone exclusively owns. Coins are a typical case of owned object usage, with cash being a real-life reference. The owned objects paradigm, however, and particularly as related to coins, is somewhat of a divergence from other blockchains that have a concept of balance. In other words, in other systems, especially account-based systems, coins are held in a single location (field) that can be thought of as a balance in a bank account.

Because Sui uses owned objects instead of a balance, it is common to own a number of coins, at times even a significant number of them. Some scenarios necessitate merging some or all of those coins into a single object. At times, merging coins together might even be required because the amount necessary to execute a transaction is more than any single coin the sender owns, thus making merging an inevitable step.

## SDK usage

The Sui SDKs ([TypeScript](https://sdk.mystenlabs.com/typescript) and [Rust](/references/rust-sdk.mdx)) manage coins on your behalf, removing the overhead of having to deal with coin management manually. The SDKs attempt to merge coins whenever possible and assume that transactions are executed in sequence. That's a reasonable assumption with wallet-based transactions and for common scenarios in general. Sui recommends relying on this feature if you do not have a need for heavy parallel or concurrent execution.

## Gas smashing

When executing a transaction, Sui allows you to provide a number of coins as payment. In other words, the payment can be a vector of coins rather than a single coin. That feature, known as gas smashing, performs merging of coins automatically and presents the PTBs you write with a single gas coin that can be used for other purposes besides just gas.

Basically, you can provide as many coins as you want (with a max limit defined in the protocol configuration) and have all of them merged (smashed) into the first coin provided as payment. That coin, minus the gas budget, is then available inside the transaction and can be used in any command. If the coin is unused, it is returned to the user.

Gas smashing is an important feature and key concept to understand for the optimal management of coins. See [Gas Smashing](/concepts/transactions/gas-smashing.mdx) for more details.

## Generic coins

Gas smashing works well for `Coin<Sui>` objects, which is the only coin type that can be used for gas payment.

Any other coin type requires explicit management from users. PTBs offer a `mergeCoins` command that you can use to combine multiple coins into a single one and a `splitCoins` as the complementary operation to break them up.

From a cost perspective, those are very cheap transactions, however they require a user to be aware of their coin distribution and their own needs.

## Concurrency

Merging coins, and particularly `Coin<Sui>`, into a single coin or a very small number of coins might prove problematic in scenarios where heavy or high concurrency is required.

If you merge all `Coin<Sui>` into a single one, you need to sequentially submit every transaction. The coin (being an owned object) needs to be provided with a version, and it is locked by the system when signing a transaction, effectively making it impossible to use it in any other transaction until the one that locked it is executed. Moreover, an attempt to sign multiple transactions with the same coin might result in equivocation and the coin being unusable and locked until the end of the epoch.

So when you require heavy concurrency, you should first split a coin into as many coins as the number of transactions to execute concurrently. Alternatively, you could provide multiple and different coins (gas smashing) to the different transactions. It is critically important that the set of coins you use in the different transactions has no intersection at all.

The possible pitfalls in dealing with heavy concurrency are many. Concurrency in transaction execution is not the only performance bottleneck. In creating and submitting a transaction, several round trips with a full node might be required to discover and fetch the right objects and to dry run a transaction. Those round trips might affect performance significantly.

Concurrency is a difficult subject and is beyond the scope of this documentation. You must take maximum care when dealing with coin management in the face of concurrency, and the right strategy is often tied to the specific scenario, rather than universally available.
>>>> sui/docs/content/guides/developer/sui-101/common-errors.mdx
---
title: Troubleshooting Common Errors
description: Find solutions to common issues with addresses, transactions, and Move packages.
keywords: [ address errors, package errors, system errors, transaction errors, troubleshooting ]
---

This page provides troubleshooting solutions to common errors.

## Address errors 

Errors in this section relate to Sui addresses.

#### `Failed to build Move modules: Unresolved addresses found.`

Indicates that you are trying to use a named address, such as `std` or similar, within your code or a dependency, but you have not assigned that address a value in the `Move.toml` file. 

##### Solution

Add an entry for each unresolved address to the `[addresses]` section of your `Move.toml` file. 

```toml
[addresses]
std = "0x1"
```

**Resources**

- [The Move Book: Manifests](https://move-book.com/concepts/manifest)

---

#### `Invalid Sui Address`

Indicates that the address you provided does not conform to a valid Sui address format. Sui addresses must:

- Be a 32-byte hex-encoded string.

- Start with `0x` and only contain hexadecimal characters (0-9, a-f, A-F).

##### Solution 

Verify the address you provide starts with `0x`, is 64 hex digits long, and does not contain invalid characters.

**Resources**

- [Create a Sui Address](/guides/developer/getting-started/get-address.mdx)

---

## Move package errors 

Errors in this section relate to Move packages.

#### `Invalid URL: Invalid URL: relative URL without a base`

This error occurs when the system interprets a URL string as a relative URL (`/path/to/file`), but your code expects an absolute URL (`https://example.com/path/to/file`). This error originates from the `sui::url` module that provides a `Url` struct and functions to interact with URLs. Move does not validate the format of a URL itself.

##### Solution 

Specify the full URL path, including `http://` or `https://`. 

**Resources**

- [`sui::url`](/references/framework/sui_sui/url.md)

- [`sui::url` source code](https://github.com/MystenLabs/sui/blob/c5f8b33b8090d75b1922f1497916b4010d9140d7/crates/sui-framework/sources/url.move).

---

#### `Failed to build Move modules: Failed to resolve dependencies for package`

Indicates that the system cannot find one or more of the dependencies you list in your Move package's `Move.toml` file. The system cannot find a dependency if:

- Your path is incorrect, contains a typo, or does not exist.

- Your manifest file does not exist.

- You have not initialized it properly. 

##### Solution

Check your `Move.toml` and verify each dependency you list has the correct path, and each path contains a valid `Move.toml` file. Ensure there are no typos and that you have initialized all dependencies. 

**Resources**

- [The Move Book: Manifests](https://move-book.com/concepts/manifest)

---

#### `Duplicate module found: 0x0000000000000000000000000000000000000000000000000000000000000002::groth16`

Indicates that you have defined two or more modules with the same name or address in your project or its dependencies. You must give each module a unique name and address combination. 

##### Solution 

Verify that your source files do not use the same module name or address twice. Check your package's dependencies to see if there is a duplicate name defined. Check if you have a conflicting address assignment in the `Move.toml` file. 

**Resources**

- [The Move Book: Modules](https://move-book.com/move-basics/module)

---

#### `Internal error occurred while processing request: Error resolving Move location: Linkage not found for package`

Indicates that your environment or tooling cannot find a Move package at the specified address. Possible causes include:

- You have not published the package to the network.

- Your address is incorrect. 

##### Solution 

Verify the package exists on the network at the specified address.

**Resources**

- [Error definition](https://github.com/MystenLabs/sui/blob/63cbf0dc26d0f2329d3e0a03639e31ded9f93561/crates/sui-graphql-e2e-tests/tests/stable/errors/clever_errors.snap)

---

#### `Failed to build Move modules: Compilation error.`

This is a generic error that indicates that something in your Move code violates the compiler's rules and therefore the compiler cannot compile your package into bytecode. 

##### Solution 

Some common reasons for this error include:

- Unbound variable or module: Make sure you declare all modules and variables you reference in your package and they are in scope.

- Duplicate declaration, item, or annotation: Ensure all functions, structs, and module names are unique within the namespace.

- Invalid declaration: Always specify an address for a module to properly declare it.

- Unbound type or member: You must define and import all types and members correctly.

- Edition not specified: You must define an edition field in all `Move.toml` files: `edition = "2024"`.

**Resources**

- [Move Concepts](/concepts/sui-move-concepts.mdx)

- [The Move Book](https://move-book.com/)

---

#### `Failed to publish the Move module(s), reason: Modules must all have 0x0 as their addresses.`

Indicates that a module in your package does not have the address `0x0`. In Move, you must set all modules to have their self-address as `0x0` in the source code. When you publish the package, Sui automatically assigns it the correct address. 


##### Solution 

Remove any explicit address blocks from your Move source files. Do not wrap your modules in `address ... { ... }` blocks.

**Resources**

- [Error definition](https://github.com/MystenLabs/sui/blob/63cbf0dc26d0f2329d3e0a03639e31ded9f93561/crates/sui-adapter-transactional-tests/tests/sui/publish_module_non_zero_address.snap)

---

#### `The signer only expects one signature, not two`

Indicates that a function you are calling in your Move module expects 1 signer argument, yet you provided 2. On Sui, the number of signer arguments in your function's signature must match the number of signers you provide. 

##### Solution 

Verify if you define your function as `fun main(s: signer)`, then you must provide only 1 signer. 

If you want to use 2 signers, define your function as `fun main(s1: signer, s2: signer) { ... }`.

**Resources**

- [Error definition](https://github.com/MystenLabs/sui/blob/63cbf0dc26d0f2329d3e0a03639e31ded9f93561/external-crates/move/crates/bytecode-verifier-transactional-tests/tests/script_signature/signer_double_signer.snap)

---


#### `destroy_zero`

Indicates that you are trying to destroy a resource that has a non-zero value. 

##### Solution 

Ensure the resource's value is zero. For coins or tokens, split or burn the value until it is zero.

**Resources**

- Learn more about [resource safety](/guides/developer/getting-started/hello-world.mdx#resource-safety).

---


## System errors

Errors in this section relate to the system.

##### `"Segmentation fault (core dumped)"`

Indicates a low-level memory crash. This is not a Move error, but rather an error with a portion of the toolchain such as the Move compiler or a dependency. 

##### Solution 

In some situations, old or corrupted build files can cause this crash. Clean your build:

```
$ sui move clean 
```

In other scenarios, outdated or mismatched tooling versions might cause this error. Upgrade your tooling and verify that versions match. 

**Resources**

- [Install Sui](/guides/developer/getting-started/sui-install.mdx)

---

#### `Failed to build Move modules: Permission denied (os error 13).`

This error means that Move cannot access the file or directory due to insufficient permissions. 

##### Solution 

Ensure your user account has the necessary read, write, or execute permissions for the target file or directory.

On Unix and macOS systems, you can edit permissions with the `chmod` command:
```
$ chmod -R u+rw /path/to/project/files
```

This gives you read and write permissions to all files and subdirectories at the specified file path.

**Resources**

- [chmod](https://linux.die.net/man/1/chmod)

---

#### `sui move build` command hangs 

This behavior often occurs when you run commands on Windows 11 machines. 

##### Solution 

Try using [Windows Subsystem for Linux](https://learn.microsoft.com/en-us/windows/wsl/install) on your Windows machine instead of running commands in a Windows-native terminal. 

**Resources**

- [Install Sui](/guides/developer/getting-started/sui-install.mdx)

- [Install Linux on Windows](https://learn.microsoft.com/en-us/windows/wsl/install)

---


#### `Fetch failed error (cause: Header Timeout)`

Indicates the network does not receive a response within a certain time period. This error is not specific to Sui.

##### Solution 

Retry the request or increase the timeout duration if you control the client. 

---

## Transaction errors 

Errors in this section relate to transactions.

#### `Requires a connection to the network. Current active network is [testnet/mainnet/devnet] but failed to connect to it.`

This error occurs when the network is down, unreachable due to an unstable internet connection, or there is a misconfiguration in your Sui client configuration.

##### Solution

First determine your client's configured environments:

```
$ sui client envs
```

You see something similar to:

```
localnet => http://0.0.0.0:9000
testnet => https://fullnode.testnet.sui.io:443 
devnet => https://fullnode.devnet.sui.io:443 (active)
```

Then, try switching to another network:

```
$ sui client switch --env testnet
```

If this does not resolve the error, check your internet connection or restart your CLI client. 

**Resources**

- [Configure a Sui Client](/guides/developer/getting-started/configure-sui-client.mdx)

---

#### `Unable to process transaction. Dry run failed, could not automatically determine a budget: UnusedValueWithoutDrop { result_idx: 0, secondary_idx: 0 }`

This error occurs when a Move transaction does not have a `drop` ability, or you do not explicitly drop it. The Sui runtime system enforces resource safety that throws this error when you leave values unused at the end of a transaction. 

##### Solution 

In Sui Move packages, you must either transfer every value that does not have the `drop` ability to another address, explicitly destroy it, or use it as input for another function to consume. 

**Resources**

- Learn more about [resource safety](/guides/developer/getting-started/hello-world.mdx#resource-safety).

--- 

#### `Error executing transaction: VMVerificationOrDeserializationError in command 0`

This is a generic error that indicates that your Move code fails either during bytecode verification or during deserialization. 

##### Solution 

Some common reasons for this error include:

- `ZERO_SIZED_STRUCT`: You define a struct that has no fields. Add at least one field to the struct.

- `FIELD_MISSING_TYPE_ABILITY`: Your struct is missing a required ability such as `key` or `store`. Ensure all fields have the necessary abilities. 

- `UNKNOWN_VERSION`: Your module or enum uses a version or feature the system does not recognize. Ensure you are using supported features and the correct Sui toolchain version. 

- `CONSTRAINT_NOT_SATISFIED`: Your struct or type parameter does not satisfy the required abilities. Add the required abilities to the struct or type.

- `WRITEREF_WITHOUT_DROP_ABILITY`: Your code tries to write a reference to a type that does not have a drop ability. Add the drop ability to the type.

**Resources**

- [Error: `ZERO_SIZED_STRUCT`](https://github.com/MystenLabs/sui/blob/63cbf0dc26d0f2329d3e0a03639e31ded9f93561/crates/sui-verifier-transactional-tests/tests/one_time_witness/no_field.snap)

- [Error: `FIELD_MISSING_TYPE_ABILITY`](https://github.com/MystenLabs/sui/blob/63cbf0dc26d0f2329d3e0a03639e31ded9f93561/crates/sui-verifier-transactional-tests/tests/struct_with_key/key_struct_with_drop.snap)

- [Error: `CONSTRAINT_NOT_SATISFIED`](https://github.com/MystenLabs/sui/blob/63cbf0dc26d0f2329d3e0a03639e31ded9f93561/crates/sui-verifier-transactional-tests/tests/private_generics/receive_without_key.snap)

---

#### `Failed to sign transaction by a quorum of validators because one or more of its objects is reserved for another transaction. Other transactions locking these objects`

Indicates that your transaction is trying to use one or more Sui objects that another transaction already uses. When you use an object in a transaction, the system locks that object to prevent multiple, possibly conflicting modifications to an object. For DeFi objects, this prevents double-spending.

##### Solution 

Wait for other transactions to complete, then retry your transaction. If transactions are stuck or fail, you might need to wait for the next epoch before you can retry the transaction.

Make sure your code does not use multiple objects simultaneously.

**Resources**

- [Signing and Sending Transactions](/guides/developer/sui-101/sign-and-send-txn.mdx)

---

#### `Failed to sign transaction by a quorum of validators because one or more of its objects is equivocated until the next epoch.`

Indicates that an object you are trying to use is in an equivocated state, meaning the network cannot reach consensus about its state due to conflicting transactions. The system subsequently freezes the object and you cannot use it until the next epoch.

##### Solution 

Wait for the next epoch.

**Resources**

- [Avoiding Equivocation](/guides/developer/sui-101/avoid-equivocation.mdx)

---

#### `Unable to process transaction. Unexpected status code: 403`

Indicates the Sui network responds to an RPC or API request with `HTTP 403: Forbidden` status. This might happen if an RPC provider:

- Requires authentication and you do not provide any.

- Has restricted your region or IP address.

- Has rate limited you by sending too many requests in a given time period.

##### Solution 

Check for required API authentication and verify you are using a valid authentication method. Review the documentation to ensure you are following all requirements. 

Check for rate limiting and try sending requests over a long period of time. 

---


#### `Failed to submit transaction: ErrorObject { code: ServerError(-32002), message: "Transaction validator signing failed due to issues with transaction inputs, please review the errors and try again`

Indicates the Sui network rejects a transaction due to invalid transaction inputs. 

##### Solution 

Ensure all objects you reference in your transaction:

- Exist

- Use the current version

- Are not referenced twice

- Do not exceed a protocol limit of maximum objects. 

Verify you have a sufficient gas balance and that your transaction signature is valid.

---

#### `Unable to process transaction. No valid gas coins found for the transaction.`

Indicates you do not have enough tokens to pay the transaction gas fee. 

##### Solution 

Obtain tokens.

**Resources**

- [Get SUI from Faucet](/guides/developer/getting-started/get-coins.mdx)

>>>> sui/docs/content/guides/developer/sui-101/connect.mdx
---
title: Connect to a Sui Network
description: Besides Mainnet, Sui offers Testnet, Devnet, and local networks that you can connect to for development. You can also configure a custom RPC endpoint. 
keywords: [ testnet, devnet, mainnet, connect to network, available networks, sui networks, connect to a network, connect to testnet, connect to devnet, connect to mainnet, sui testnet, sui devnet, sui mainnet ]
draft: true
---

Sui offers 3 networks: Mainnet, Devnet, and Testnet. You can use one of the test networks, Devnet or Testnet, to experiment with the version of Sui running on that network. You can also spin up a [local Sui network](/guides/developer/sui-101/local-network.mdx) for local development. 

The Sui Testnet and Devnet networks consist of several validator nodes to validate each network's transactions. Clients send transactions and read requests through this endpoint: `https://fullnode.<SUI-NETWORK-VERSION>.sui.io:443` using [JSON-RPC](/references/sui-api.mdx).

You can [request test SUI tokens](#request-test-tokens) through the Sui [#devnet-faucet](https://discordapp.com/channels/916379725201563759/971488439931392130) and [#testnet-faucet](https://discord.com/channels/916379725201563759/1037811694564560966) Discord channels, depending on which version of the network you use. If connected to Localnet, use cURL to request tokens from your [local faucet](/guides/developer/sui-101/local-network.mdx#use-the-local-faucet). The coins on these networks have no financial value. There is no faucet service for Mainnet.

See announcements about Sui in the [#announcements](https://discord.com/channels/916379725201563759/925109817834631189) Discord channel.

See the [terms of service](https://sui.io/terms/) for using Sui networks.

<ImportContent source="data-wipe.mdx" mode="snippet" />

## Sui CLI

Sui provides [Sui command line interface (CLI)](/references/cli/client.mdx) to interact with Sui networks:

- Create and manage your private keys
- Create example NFTs
- Call and publish Move modules


## Environment setup

First, [Install Sui](/guides/developer/getting-started/install-binaries.mdx). After you install Sui, [request SUI test tokens](#request-gas-tokens) through Discord for the network you are using: [Devnet](https://discordapp.com/channels/916379725201563759/971488439931392130) or [Testnet](https://discord.com/channels/916379725201563759/1037811694564560966). If connected to a local network, use cURL to request tokens from your [local faucet](/guides/developer/sui-101/local-network.mdx#use-the-local-faucet).

To check whether Sui is already installed, run the following command:

```sh
$ which sui
```

If Sui is installed, the command returns the path to the Sui binary. If Sui is not installed, it returns `sui not found`.

See the [Sui Releases](https://github.com/MystenLabs/sui/releases) page to view the changes in each Sui release.

## Configure Sui client

If you previously ran `sui genesis` to create a local network, it created a Sui client configuration file (client.yaml) that connects to `localhost` at `http://0.0.0.0:9000`. See [Connect to a custom RPC endpoint](#connect-to-a-custom-rpc-endpoint) to update the client.yaml file.

To connect the Sui client to a network, run the following command:

```sh
$ sui client
```

If you receive the `sui-client` help output in the console, you already have a `client.yaml` file. See [Connect to a custom RPC endpoint](#connect-to-a-custom-rpc-endpoint) to add a new environment alias or to switch the currently active network.

The first time you start a Sui client without having a `client.yaml` file, the console displays the following message:

```
Config file ["<PATH-TO-FILE>/client.yaml"] doesn't exist, do you want to connect to a Sui full node server [y/N]?
```

Press **y** and then press **Enter**. The process then requests the RPC server URL: 

```
Sui full node server URL (Defaults to Sui Testnet if not specified) :
```

Press **Enter** to connect to Sui Testnet. To use a custom RPC server, Sui Devnet, or Sui Mainnet, enter the URL to the correct RPC endpoint and then press **Enter**.

If you enter a URL, the process prompts for an alias for the environment:

```
Environment alias for [<URL-ENTERED>] :
```
Type an alias name and press **Enter**.

```
Select key scheme to generate key pair (0 for ed25519, 1 for secp256k1, 2 for secp256r1):
```

Press <kbd>0</kbd>, <kbd>1</kbd>, or <kbd>2</kbd> to select a key scheme and then press <kbd>Enter</kbd>.

Sui returns a message similar to the following (depending on the key scheme you selected) that includes the address and 12-word recovery phrase for the address:

```
Generated new key pair for address with scheme "ed25519" [0xb9c83a8b40d3263c9ba40d551514fbac1f8c12e98a4005a0dac072d3549c2442]
Secret Recovery Phrase : [cap wheat many line human lazy few solid bored proud speed grocery]
```

### Connect to a custom RPC endpoint

If you previously used `sui genesis` with the force option (`-f` or `--force`), your `client.yaml` file already includes 2 RPC endpoints: `localnet` at `http://0.0.0.0:9000` and `devnet` at `https://fullnode.devnet.sui.io:443`. You can view the defined environments with the `sui client envs` command and switch between them with the `sui client switch` command.

If you previously installed a Sui client that connected to a Sui network or created a local network, you can modify your existing `client.yaml` file to change the configured RPC endpoint. The `sui client` commands that relate to environments read from and write to the `client.yaml` file.

To check currently available environment aliases, run the following command: 

```sh
$ sui client envs
```

The command outputs the available environment aliases, with `(active)` denoting the currently active network.
```sh
localnet => http://0.0.0.0:9000 (active)
devnet => https://fullnode.devnet.sui.io:443
```

To add a new alias for a custom RPC endpoint, run the following command. Replace values in `<` `>` with values for your installation:

```sh
$ sui client new-env --alias <ALIAS> --rpc <RPC-SERVER-URL>
```

To switch the active network, run the following command:

```sh
$ sui client switch --env <ALIAS>
```

If you encounter an issue, delete the Sui configuration directory (`~/.sui/sui_config`) and reinstall the latest [Sui binaries](/guides/developer/getting-started/install-binaries.mdx).
>>>> sui/docs/content/guides/developer/sui-101/data-serving.mdx
---
title: Access Sui Data
description: Overview of the types of data access mechanisms available in Sui.
keywords: [ data types, data access, data access interfaces, json RPC, custom indexers, indexers, gRPC, graphql RPC, general purpose indexer ]
---

You can access Sui network data like [Transactions](/concepts/transactions.mdx), [Checkpoints](/concepts/cryptography/system/checkpoint-verification.mdx), [Objects](/concepts/object-model.mdx), [Events](/guides/developer/sui-101/using-events.mdx), and more through the available interfaces. You can use this data in your application workflows, to analyze network behavior across applications or protocols of interest, or to perform audits on parts or the whole of the network.

This document outlines the interfaces that are currently available to access the Sui network data, along with an overview of how that's gradually evolving. Refer to the following definitions for release stages mentioned in this document:

- **Alpha**: Experimental release that is subject to change and is not recommended for production use. You can use it for exploration in non-production environments.
- **Beta**: Somewhat stable release that is subject to change based on user feedback. You can use it for testing and production readiness in non-production environments. If you use it in production, do so at your own risk. Only entertain using after verifying the desired functional, performance, and other relevant characteristics in a non-production environment and if you are comfortable keeping your application regularly updated for any changes.
- **Generally available (GA)**: Fully stable release that you can use in production. Notifications for any breaking changes are made in advance.

## Latest data access interfaces

<div class="bg-sui-ghost-white">
![Future state data serving stack](../images/dataservingstack.png)
</div>

Primary interfaces to access Sui data include:

- [gRPC API](#grpc-api) replaces JSON-RPC on full nodes. If you already use JSON-RPC or are starting to utilize it as a dependency for your use case, note that it is **deprecated** and you need to migrate to gRPC or GraphQL RPC (see below).
- [General-purpose Indexer](#general-purpose-indexer) is a performant and scalable implementation of the [custom indexing framework](/concepts/custom-indexing-framework.mdx). It is currently available in beta. Use it to load network data at scale into a Postgres relational database.
- [GraphQL RPC](#graphql-rpc) includes a lightweight GraphQL RPC service that you can use to read data from the General-purpose Indexer's relational database. It is currently available in beta. You can use it as an alternative to gRPC, including for migration from JSON-RPC for an existing application. Refer to the [high-level timeline for GraphQL and General-purpose Indexer availability](#graphql-rpc).
- [Archival Store and Service](#archival-store-and-service) provides long-term storage and access to historical network data that might no longer be available on full nodes due to pruning. If using gRPC as your primary data access mechanism, you can query it using the gRPC `LedgerService` APIs by changing the endpoint from a full node to the Archival Service. If using GraphQL RPC, it's abstracted and you do not need to directly interact with it.

:::info
View the video below for a comparison of the latest and legacy Sui data stacks. 
<iframe width="560" height="315" src="https://www.youtube.com/embed/CL7H4QQSWd0?si=Mt2xo3HNfm2mbRtE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
:::

### gRPC API

[gRPC API](/concepts/grpc-overview.mdx) replaces the JSON-RPC on full nodes. JSON-RPC is **deprecated** and gRPC API is generally available. Apart from the message and request format changes between the 2, the gRPC API comes with a couple of key functional differences:

- Use streaming or subscription API endpoints to consume real-time streaming data in your application without having to poll for those records. This support replaces the deprecated WebSocket support in JSON-RPC.
- There is no implicit fallback on the [Sui Foundation-managed archival store for historical data](#archival-store-and-service). Full node operators, RPC providers, and data indexer operators are encouraged to run their own instance of a similar archival store that can be an explicit dependency to fetch historical data.

See [When to use gRPC vs GraphQL with General-purpose Indexer](#when-to-use-grpc-vs-graphql-with-general-purpose-indexer) for a comparison with GraphQL RPC.

**High-level timeline**

The target times indicated below are tentative and subject to updates based on project progress and your feedback.

| Tentative time | Milestone | Description |
| -------- | ------- | ------- |
| :heavy_check_mark: April 2025 | Beta release of initial set of polling-based APIs. | You can start validating the initial gRPC integration from your application and share feedback on the improvements you want to see. |
| :heavy_check_mark: July 2025 | Beta release of streaming APIs and the remaining set of polling-based APIs. | If your use case requires streaming low-latency data, this is an apt time to start validating that integration. Also, the functionality of the API coverage is complete at this point, so you can start migrating your application in non-production environments. |
| :heavy_check_mark: September-October 2025 | GA release of polling-based and streaming APIs. | Begin migration and cutover of your application in the production environment. **JSON-RPC is deprecated at this point and migration notice period starts.** |
| April 2026 | End of migration timeline. | **JSON-RPC is fully deactivated at this point.** This timeline assumes about 7 months of migration notice period. |

:::warning
The gRPC and GraphQL RPC APIs have replaced JSON-RPC. View the video below to learn more about the migration timeline and which API to use. 
<iframe width="560" height="315" src="https://www.youtube.com/embed/_Ke9y8svtW8?si=ADqYvGiKMhKp1ap4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
:::

### General-purpose Indexer

As mentioned, [General-purpose Indexer](/concepts/graphql-indexer.mdx) includes a performant and scalable implementation of the [custom indexing framework](/concepts/custom-indexing-framework.mdx). The underlying framework uses the remote checkpoint store and full node RPCs to ingest the data.

General-purpose Indexer is declarative in the sense that you can seamlessly configure it to load different kinds of Sui network data into Postgres relational tables in parallel. This improves the performance of the data ingestion into the Postgres-compatible database. In addition, you can configure pruning for different tables in the Postgres-compatible database, allowing you to tune it for the desired combination of performance and cost characteristics.

:::info

General-purpose Indexer is in beta, which is a somewhat stable release that is subject to change based on user feedback. You can use it for testing and production readiness in non-production environments.

:::

### GraphQL RPC

The [GraphQL RPC Service](/concepts/graphql-indexer.mdx) is a performant GraphQL RPC layer that reads data from the General-purpose Indexer's Postgres-compatible database, [Archival Store and Service](#archival-store-and-service), and a full node. GraphQL RPC is an alternative to gRPC API. If you are already using **deprecated** JSON-RPC in your application today, you have an option to migrate to GraphQL RPC by either self-operating the combined stack of General-purpose Indexer, Postgres-compatible database, and GraphQL RPC server, or by utilizing it as a service from an RPC provider or indexer operator.

GraphQL RPC Service is a lightweight server component that allows you to combine data from multiple tables in the Postgres-compatible database using GraphQL's expressive querying system, which is appealing to frontend developers.

See [When to use gRPC vs GraphQL with General-purpose Indexer](#when-to-use-grpc-vs-graphql-with-general-purpose-indexer) for a comparison with the gRPC API.

:::info

GraphQL RPC Server is in beta, which is a somewhat stable release that is subject to change based on user feedback. You can use it for testing and production readiness in non-production environments.

:::

**High-level timeline**

The target times indicated are tentative and subject to updates based on project progress and your feedback.

| Tentative time | Milestone | Description |
| -------- | ------- | ------- |
| :heavy_check_mark: September 2025 | Beta release of GraphQL RPC Server and General-purpose Indexer. | You can start validating the setup of General-purpose Indexer, along with testing the GraphQL RPC Server to access the indexed Sui data. You can also start migrating your application in the non-production environments, and share feedback on the improvements you want to see. |
| :heavy_check_mark: September-October 2025 | Deprecation of JSON-RPC. | **JSON-RPC will be deprecated at this point and migration notice period will start.** |
| December-January 2025 | GA release of GraphQL RPC Server and General-purpose Indexer. | Begin migration and cutover of your application in the production environment. |
| April 2026 | End of migration timeline. | **JSON-RPC is fully deactivated at this point.** This timeline assumes about 7 months of migration notice period. |

### Archival Store and Service

Long-term access to historical on-chain data is essential for developers, although full nodes enforce limited retention for scalability and performance. Use the [Archival Store and Service](/concepts/archival-store.mdx) to access historical on-chain data through a pluggable storage backend (like [Bigtable](https://cloud.google.com/bigtable)) and a [gRPC interface compatible with the `LedgerService` endpoint](/concepts/grpc-overview.mdx).

This infrastructure serves as the historical backbone for GraphQL RPC, gRPC-based apps, and data platforms, providing efficient point-lookups for old transactions, checkpoints, and object states, even after full nodes have pruned them.

You can:

- Query the archival store through gRPC-based archival service for missing data when using a full node
- Power GraphQL RPC queries that span unretained data
- Host the service yourself, use a provider, or rely on the public-good version (with rate limits)

Learn more about [Archival Store and Service](/concepts/archival-store.mdx).

### Custom indexer

If you need more control over the types, granularity, and retention period of the data that you need in your application, or if you have specific query patterns that are not served with gRPC or GraphQL RPC, then you can set up your own [custom indexer](/guides/developer/advanced/custom-indexer/build.mdx) or reach out to a [Data indexer operator](/references/awesome-sui.mdx#indexers--data-services) that might already have set one up.

If you set up your own indexer, you are responsible for its ongoing maintenance and the related infrastructure and operational costs. You can reduce your costs by implementing a pruning strategy for the relational database by taking into account the retention needs of your application.

:::info

Custom indexers are a good choice for app or protocol-specific logic and data layout.

:::

### When to use gRPC vs GraphQL with General-purpose Indexer

You can use the high-level criteria mentioned in the following table to determine whether gRPC API or GraphQL RPC with General-purpose Indexer would better serve your use case. It's not an exhaustive list and it's expected that either of the options could work suitably for some of the use cases.

| Dimension | gRPC API | GraphQL RPC with General-purpose Indexer |
| -------- | ------- | ------- |
| Type of application or data consumer. | Ideal for Web3 exchanges, DeFi market maker apps, other DeFi protocols or apps with ultra low-latency needs. | Ideal for webapp builders or builders with slightly relaxed latency needs. |
| Query patterns. | Okay to read data from different endpoints separately and combine on the client-side; faster serialization, parsing, and validation due to binary format. | Allows easier decoupling of the client with the ability to combine data from different tables in a single request; returns consistent data from different tables across similar checkpoints, including for paginated results. |
| Retention period requirements. | Default retention period is 2 weeks with actual configuration dependent on the full node operator and their needs and goals; see history-related note after the table. | Default retention period in Postgres database is 4 weeks with actual configuration depending on your needs or a RPC provider or data indexer operator's setup; see history-related note after the table. |
| Streaming needs. | Includes a streaming or subscription API before beta release. | Subscription API is planned but is available after GA. |
| Incremental costs. | Little to no incremental costs if already using full node JSON-RPC. | Somewhat significant incremental costs if already using full node JSON-RPC and if retention period and query patterns differences are insignificant. |

:::info

This table only mentions the default retention period for both options. The expectation is that it's reasonable for a full node operator, RPC provider, or data indexer operator to configure that to a few times higher without significantly impacting the performance. Also by default, the GraphQL RPC service can directly connect to the archival store and service for historical data beyond the retention period configured for the underlying Postgres database. Whereas in comparison, gRPC API doesn't have such direct connectivity to the archival store and service and you must directly connect to one from your application.

:::

Refer to the following articles outlining general differences between gRPC and GraphQL. Validate the accuracy and authenticity of the differences using your own experiments.

- https://stackoverflow.blog/2022/11/28/when-to-use-grpc-vs-graphql/
- https://blog.postman.com/grpc-vs-graphql/

## Legacy data access interfaces

### JSON-RPC

:::info

<ImportContent source="json-rpc-deprecation.mdx" mode="snippet" />

:::

Directly connect to [JSON-RPC](/references/sui-api.mdx) hosted on Sui [full nodes](guides/operator/sui-full-node.mdx) that are operated by [RPC providers](https://sui.io/developers#dev-tools) (filter by `RPC`) or [data indexer operators](https://github.com/sui-foundation/awesome-sui?tab=readme-ov-file#indexers--data-services).
  - The [Mainnet](https://fullnode.mainnet.sui.io:443), [Testnet](https://fullnode.testnet.sui.io:443), or [Devnet](https://fullnode.devnet.sui.io:443) load balancer URLs abstract the Sui Foundation-managed full nodes. Those are not recommended for production use.

You can get real-time or historical data using JSON-RPC. Retention period for historical data depends on the [pruning strategy](/guides/operator/data-management.mdx#sui-full-node-pruning-policies) that node operators implement, though the default configuration for all full nodes is to implicitly fall back on the [Archival Store](#archival-store-and-service) managed by the Sui Foundation.

:::caution

WebSocket-based JSON RPCs `suix_subscribeEvent` and `suix_subscribeTransaction` were deprecated in July 2024. Do not rely on those RPCs in your applications. Refer to [Future data access interfaces](#future-state-data-interfaces) to learn about the `gRPC subscriptions` alternative.

:::

## Related links

<RelatedLink to="/concepts/graphql-rpc" />
<RelatedLink to="/concepts/custom-indexing-framework" />
<RelatedLink to="/concepts/custom-indexer/pipeline-architecture" />
<RelatedLink to="/concepts/archival-store" />
<RelatedLink to="/guides/developer/advanced/custom-indexer" />
<RelatedLink to="/concepts/graphql-indexer" />
<RelatedLink href="/references/fullnode-protocol" label="Sui Full Node gRPC" desc="Generated documentation from the Sui gRPC schema." />
<RelatedLink href="/references/sui-api/sui-graphql/beta/reference" label="GraphQL Beta schema" desc="Schema documentation for GraphQL Beta." />
>>>> sui/docs/content/guides/developer/sui-101/local-network.mdx
---
title: Connect to a Local Network
description: Connect to a Sui local network using the Sui CLI. Use local networks to test your applications and prepare for launching them on Devnet or Testnet. 
keywords: [ local network, testnet, devnet, test application, deploy app locally, customize local network, configure local network, use local network, local network state, local faucet, using the local faucet, local sui faucet ]
---

Use a Sui local network to test your dApps against the latest changes to Sui and to prepare for the next Sui release to Devnet or Testnet. Sui CLI provides the `sui start` command to start a local network. There are several services that can be started when using `sui start`, such as an indexer, a faucet, or a local instance of the GraphQL service (including the web-based GraphiQL IDE). You can use the included faucet to get test SUI to use on the local network.

If you haven't already, you need to [install Sui CLI](/guides/developer/getting-started/sui-install.mdx) on your system.

## Start the local network

To start the local network, run the following command after you install Sui CLI.

```sh
$ RUST_LOG="off,sui_node=info" sui start --with-faucet --force-regenesis
```

This command:

- Calls the Sui CLI binary with 2 flags:
- `--with-faucet` to start a faucet service.
- `--force-regenesis` to generate a new genesis and not persist the local network state.
- Instructs Rust to set specific logging through the `RUST_LOG`=`off,sui_node=info` flags, which turns off logging for all components except `sui-node`. If you want to see more detailed logs, you can remove `RUST_LOG` from the command.

:::info
Each time you start the network by passing `--force-regenesis`, the local network starts from a random genesis with no previous data, and the local network is not persisted. If you'd like to persist data, skip passing the `--force-regenesis` flag. For more details, see the [Persist local network state](#persist-local-network-state) section. A temporary directory is created in `/tmp`, which might not work if the `/tmp` folder is mounted to `/tmpfs`. If this is the case, set `TMPDIR=./some_folder`.
:::

To customize your local Sui network, such as starting other services or changing default ports and hosts, include additional flags or options in the `sui start` command.

:::info
Options and flags like `with-indexer`, `with-graphql`, and related require you to have PostgreSQL/libpq installed. Check out the list of possible options below to find which is the default expected DB or how to pass a different DB.
:::

The following is a list of possible options and flags to pass to `sui start`:

```
    --network.config <CONFIG_DIR>            Config directory that will be used to store network config, node db, Keystore sui genesis -f --with-faucet generates a genesis config that can be used to start this process. Use with caution as the `-f` flag
                                             will overwrite the existing config directory. We can use any config dir that is generated by the `sui genesis`
    --force-regenesis                        A new genesis is created each time this flag is set, and state is not persisted between runs. Only use this flag when you want to start the network from scratch every time you run this command
    --with-graphql[=<WITH_GRAPHQL>]          Start a GraphQL server on localhost and port: 127.0.0.1:9125, or on the port provided. When providing a specific value, please use the = sign between the flag and value: `--with-graphql=6125`. Note that
                                             GraphQL requires a running indexer
    --with-faucet[=<WITH_FAUCET>]            Start a faucet with default host and port: 127.0.0.1:9123, or on the port provided. When providing a specific value, please use the = sign between the flag and value: `--with-faucet=6123`
    --with-indexer[=<WITH_INDEXER>]          Start an indexer with default host and port: 0.0.0.0:9124, or on the port provided. When providing a specific value, please use the = sign between the flag and value: `--with-indexer=6124`.                                          The indexer be started in writer mode and reader mode
    --fullnode-rpc-port <FULLNODE_RPC_PORT>  Port to start the Fullnode RPC server on. Default port is 9000 [default: 9000]
    --pg-port <PG_PORT>                      Port for the Indexer Postgres DB. Default port is 5432 [default: 5432]
    --pg-host <PG_HOST>                      Hostname for the Indexer Postgres DB. Default host is localhost [default: localhost]
    --pg-db-name <PG_DB_NAME>                DB name for the Indexer Postgres DB. Default DB name is sui_indexer [default: sui_indexer]
    --pg-user <PG_USER>                      DB username for the Indexer Postgres DB. Default username is postgres [default: postgres]
    --pg-password <PG_PASSWORD>              DB password for the Indexer Postgres DB. Default password is postgrespw [default: postgrespw]
    --epoch-duration-ms <EPOCH_DURATION_MS>  Set the epoch duration. Can only be used when `--force-regenesis` flag is passed or if there's no genesis config and one will be auto-generated. When this flag is not set but `--force-regenesis` is set, the
                                             epoch duration will be set to 60 seconds
    --no-full-node                           Start the network without a fullnode
-h, --help                                   Print help (see more with '--help')
```

Use `sui start --help` to see these options in your console.

### Persist local network state

By default, when using `sui start` the command uses an existing genesis and network configuration if the `~/.sui/sui_config` folder exists and includes a `genesis.blob` file. If the folder doesn't exist, it creates the folder and generates a new genesis configuration. If you pass `--network.config`, the command checks for the network config file and tries to load the genesis blob as per the network config file.

Whenever you stop and start the network without passing the `--force-regenesis` flag, all history is preserved and accessible.

:::info
To generate a custom genesis, use the `sui genesis` command and pass the desired custom values. For more information about possible flags and options, run `sui genesis --help`.
:::

### Access your local full node

Use the following command to retrieve the total transaction count from your local network:

```sh
$ curl --location --request POST 'http://127.0.0.1:9000' \
--header 'Content-Type: application/json' \
--data-raw '{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "sui_getTotalTransactionBlocks",
  "params": []
}'
```

If successful, the response resembles the following:

```json
{
	"jsonrpc": "2.0",
	"result": 168,
	"id": 1
}
```

## Connect the Sui CLI to your local network

You can use the Sui CLI with any Sui network. By default, it connects to Sui Devnet. To connect to your local network, create a new environment alias named `local` that sets the RPC URL the client uses to your local network.

```sh
$ sui client new-env --alias local --rpc http://127.0.0.1:9000
```

Next, use the following command to set the active environment to the new `local` environment you created.

```
sui client switch --env local
```

The command returns:

`Active environment switched to [local]`

You can check the current active environment with the following command:

```sh
$ sui client active-env
```

The command returns:

`local`

## Show the current active address

The Sui Client CLI uses the active address for command if you don't specify one. Use the following command to show the active address on your local network.

```
sui client active-address
```

The command returns an address, for example:

`0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de`

Use the active address to get test SUI to use on your local network. Use the `sui client addresses` command to see all of the addresses on your local network.

:::info

The address returned when you run the command is unique and does not match the one used in this example.

:::

## Use the local faucet {#use-the-local-faucet}

Transactions on your local network require SUI coins to pay for gas fees just like other networks. You can use the active address with the faucet.

Sui CLI provides the `sui client faucet` command to get coins from the faucet. In the most basic case, run `sui client faucet` and wait up to 60 seconds for the coins to reach your address. Use `sui client gas` to check for the new coins.

:::info

The `faucet` command uses the active address and the active network environment by default. If you need to pass in a different address or faucet server URL, check the `help` menu. If you're using a different network than a local network or the public ones (`fullnode.network.sui.io`), pass the URL to the faucet server.

:::

### Check the gas coin objects for the active address

After you get coins from the faucet, use the following command to view the coin objects for the address:

```sh
$ sui client gas
```

The response resembles the following, but with different IDs:

```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ gasCoinId                                                          â”‚ gasBalance â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0x1d790713c1c3441a307782597c088f11230c47e609af2cec97f393123ea4de45 â”‚ 200000000  â”‚
â”‚ 0x20c1d5ad2e8693953fca09fd2fec0fbc52a787e0a0f77725220d36a09a5b312d â”‚ 200000000  â”‚
â”‚ 0x236714566110f5624516faa0da215ad29f8daa611e8b651d1e972168207567b2 â”‚ 200000000  â”‚
â”‚ 0xc81f30256bb04ad84bc4a92017cffd7c1f98286e028fa504d8515ad72ddd1088 â”‚ 200000000  â”‚
â”‚ 0xf61c8b21b305cc8e062b3a37de8c3a37583e17f437a449a2ab42321d019aeeb4 â”‚ 200000000  â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

## Generate example data

Use the TypeScript SDK to add example data to your network. This requires to start a local network with an indexer and GraphQL: `sui start --force-regenesis --with-faucet --with-indexer --with-graphql`.
Then run the following command from the `sui` root folder:

```sh
$ pnpm --filter @mysten/sui test:e2e
```

For additional information about example data for testing, see [https://github.com/MystenLabs/ts-sdks/tree/main/packages/typescript#testing](https://github.com/MystenLabs/ts-sdks/tree/main/packages/typescript#testing).

## Monitor activity

Use a Sui network explorer to monitor your local network activity. You can build and run one locally or use the **Custom RPC URL** setting available on many online explorers to provide your local network's RPC URL (`http://127.0.0.1:9000` by default).

<ImportContent source="lists/sui-explorers.mdx" mode="snippet" />

## Troubleshooting

If you do not use [Node.js 18](https://nodejs.org/en/announcements/v18-release-announce), you might see the following message:

`Retrying requesting from faucet: Retry failed: fetch is not defined`

To resolve this, switch or update to Node.js 18 and then try again.

## Test with the Sui TypeScript SDK

The published version of the Sui TypeScript SDK might be an earlier version than the version of Sui you installed for your local network. To make sure you're using the latest version of the SDK, use the `experimental`-tagged version (for example, `0.0.0-experimental-20230317184920`) in the [Current Tags](https://www.npmjs.com/package/@mysten/sui?activeTab=versions) section of the Sui NPM registry.
>>>> sui/docs/content/guides/developer/sui-101/object-ownership.mdx
---
title: Object Ownership
description: On Sui, object ownership can be represented in different ways. Weigh the benefits of each to decide the best approach for your project.
keywords: [ shared objects, owned objects, object types, locked<t>, key, types of objects, shared, owned, address-owned ]
---

Objects on Sui can be versioned either through the fastpath or through consensus. The choice between these 2 paths affects your options for object ownership, as well as the performance and operational complexity of your application. Many applications can be built using a solution that either uses consensus objects or only fastpath objects, with trade-offs for each that need to be weighed.

Fastpath objects must be owned by a single address (or immutable). This makes it complicated to write some applications that require multiple parties or nodes to access the same object. Access to very hot fastpath objects needs to be coordinated off-chain. However, transactions that use the fastpath benefit from very low latency to finality.

Consensus objects can be owned by a single address (party objects) or globally accessible for read and writes by any transaction (shared objects). Transactions that access 1 or more consensus objects require consensus to sequence reads and writes to those objects. This makes version management simpler, especially for heavily accessed objects, but results in a slightly higher gas cost and latency.

Transactions that access multiple consensus objects, or particularly popular objects, might have increases in latency due to contention. However, the advantage of using consensus objects lies in the flexibility of allowing multiple addresses to access the same object in a coordinated manner.

To summarize, applications that are extremely sensitive to latency or gas costs, that do not need to handle complex multi-party transactions, or that already require an off-chain service could benefit from a design that only uses fastpath objects. Applications that require coordination between multiple parties typically benefit from using shared objects through consensus.

For more detailed information on the types of objects that Sui supports, see [Object Ownership](/concepts/object-ownership.mdx).

## Example: Escrow

The Escrow example demonstrates the trade-offs between consensus objects and fastpath objects by implementing the same application in both styles. Both styles of the example implement a service that enables a trustless swap of objects between 2 addresses (a "trade"), with the service holding those objects in escrow.

### `Locked<T>` and `Key`

[Code Sample](https://github.com/MystenLabs/sui/blob/93e6b4845a481300ed4a56ab4ac61c5ccb6aa008/examples/move/escrow/sources/lock.move)

Both implementations use a primitive for locking values, which offers the following interface:

```move
module escrow::lock {
    public fun lock<T: store>(obj: T, ctx: &mut TxContext): (Locked<T>, Key);
    public fun unlock<T: store>(locked: Locked<T>, key: Key): T
}
```

Any `T: store` can be locked to get a `Locked<T>` and a corresponding `Key`, and conversely, the locked value and its corresponding key can be consumed to get back the wrapped object.

The important property that this interface provides is that locked values cannot be modified except by unlocking them first (and later relocking them). Because unlocking consumes the key, tampering with a locked value can be detected by remembering the ID of the key that it was locked with. This prevents situations where a party in a swap changes the object they are offering to reduce its value.

### Address-owned objects (fastpath)

<details>
<summary>
`owned.move`
</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/owned.move" mode="code" />

</details>

The protocol for swapping through escrow implemented using address-owned objects starts with both parties locking their respective objects. 

```mermaid
flowchart TD
    SR[Locked&ltfa:fa-wrench S&gt, fa:fa-key key_s]
    BR[Locked&ltfa:fa-coins B&gt, fa:fa-key key_b]

    subgraph Seller
    a2(fa:fa-wrench S)--escrow::lock-->SR
    end

    subgraph Buyer
    a1(fa:fa-coins B)--escrow::lock-->BR
    end
```

This is used to prove that the object has not been tampered with after the swap has been agreed to. If either party doesn't want to proceed at this stage, they just unlock their object.

Assuming both parties are happy to continue, the next step requires both parties to swap the keys.

```mermaid
flowchart LR
    Buyer--fa:fa-key key_b-->Seller
    Seller--fa:fa-key key_s-->Buyer
```

A third party acts as custodian. The custodian holds objects that are waiting for their counterparts to arrive, and when they arrive, it matches them up to complete the swap.

<ImportContent source="examples/trading/contracts/escrow/sources/owned.move" mode="code" fun="create" noComments />

```mermaid
flowchart TB
    S["fa:fa-key key_s,
        Locked&ltfa:fa-wrench S&gt,
        exchange_key: fa:fa-key key_b,
        recipient: Buyer
    "]
    B["fa:fa-key key_b,
        Locked&ltfa:fa-coins B&gt,
        exchange_key: fa:fa-key key_s,
        recipient: Seller
    "]

    id1(Escrow&ltfa:fa-coins B&gt)-->Third_Party
    id2(Escrow&ltfa:fa-wrench S&gt)-->Third_Party
    subgraph Buyer
    direction TB
    B--create-->id1
    end

    subgraph Seller
    direction TB
    S--create-->id2
    end
```

The `create` function prepares the `Escrow` request and sends it to the `custodian`. The object being offered by this party is passed in, locked, with its key, and the object being requested is identified by the ID of the key it was locked with. While preparing the request, the offered object is unlocked while remembering the ID of its key.

Although the custodian is trusted to preserve liveness (to complete swaps if it owns both sides of a swap and to return objects if requested), all other correctness properties are maintained in Move: Even though the custodian owns both objects being swapped, the only valid action they are permitted to take is to match them up with their correct counterpart to finish the swap or to return them:

```mermaid
flowchart TB

    subgraph Third_Party
    direction TB
    id1(fa:fa-wrench S, fa:fa-coins B)
    id2(Escrow&ltfa:fa-coins B&gt, Escrow&ltfa:fa-wrench S&gt)
    id2--swap-->id1
    end

    Third_Party--fa:fa-wrench S-->Buyer
    Third_Party--fa:fa-coins B-->Seller
```

<ImportContent source="examples/trading/contracts/escrow/sources/owned.move" mode="code" fun="swap" />

The `swap` function checks that senders and recipients match and that each party wants the object that the other party is offering by comparing their respective key IDs. If the custodian tried to match together 2 unrelated escrow requests to swap, the transaction would not succeed.

### Shared objects (consensus)

<details>
<summary>
`shared.move`
</summary>

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" />

</details>

The protocol in the shared object case is less symmetric but still starts with the first party locking the object they want to swap. 
```mermaid
flowchart TB
    B["Locked&ltfa:fa-coins B&gt, fa:fa-key key_b"]
        
    subgraph Buyer
    direction TB
    a1(fa:fa-coins B)--escrow::lock-->B
    end
```

The second party can then view the object that was locked, and if they decide they want to swap with it, they indicate their interest by creating a swap request:

```mermaid
flowchart TB
    S["fa:fa-wrench S,
        exchange_key: fa:fa-key key_b,
        recipient: Buyer
    "]

    id1(Shared Object)-->id2(Escrow&ltfa:fa-wrench S&gt)

    subgraph Seller
    direction TB
    S--create-->id2
    end
```

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" fun="create" noComments />

This time the `create` request accepts the object being escrowed directly (not locked) and creates a shared `Escrow` object. The request remembers the address that sent it (who is allowed to reclaim the object if the swap hasn't already happened) and the intended recipient, who is then expected to continue the swap by providing the object they initially locked:

```mermaid
flowchart TB

    subgraph Buyer
    direction TB
    id1(Escrow&ltfa:fa-wrench S&gt,\n fa:fa-key key_b,\n Locked&ltfa:fa-coins B&gt)
    id2(fa:fa-wrench S)
    id1-->swap-->id2
    end

    swap--fa:fa-coins B-->Seller
```

<ImportContent source="examples/trading/contracts/escrow/sources/shared.move" mode="code" fun="swap" />


Even though the `Escrow` object is a shared object that is accessible by anyone, the Move interface ensures that only the original sender and the intended recipient can successfully interact with it. `swap` checks that the locked object matches the object that was requested when the `Escrow` was created (again, by comparing key IDs) and assumes that the intended recipient wants the escrowed object (if they did not, they would not have called `swap`).

Assuming all checks pass, the object held in `Escrow` is extracted, its wrapper is deleted, and it is returned to the first party. The locked object offered by the first party is also unlocked and sent to the second party, completing the swap.

### Comparison

This topic explores 2 ways to implement a swap between 2 objects. In both cases there is a point at which 1 party has made a request and the other has not responded. At this point, both parties might want to access the `Escrow` object: 1 to cancel the swap and the other to complete it.

In some cases, the protocol uses only address-owned objects but requires a custodian to act as an intermediary. This has the advantage of avoiding the costs and latencies of consensus altogether but involves more steps and requires trusting a third party for liveness.

In the other case, the object is in custody on-chain in a shared object. This requires consensus but involves fewer steps and no third party.
>>>> sui/docs/content/guides/developer/sui-101/sign-and-send-txn.mdx
---
title: Signing and Sending Transactions
description: Each transaction on Sui represents a call to a specific functionality that executes with inputs that define the result of the transaction. 
keywords: [ transactions, transaction inputs, smart contract functions, signatures, Ed25519 pure, ECDSA Secp256k1, ECDSA Secp256r1, Multisig, zkLogin ]
---

Transactions in Sui represent calls to specific functionality (like calling a smart contract function) that execute on inputs to define the result of the transaction.

Inputs can either be an object reference (either to an owned object, an immutable object, or a shared object) or an encoded value (for example, a vector of bytes used as an argument to a Move call). After a transaction is constructed, usually through using [programmable transaction blocks](/guides/developer/sui-101/building-ptb.mdx) (PTBs), the user signs the transaction and submits it to be executed on chain.

The signature is provided with the private key owned by the wallet, and its public key must be consistent with the transaction sender's Sui address.

Sui uses a `SuiKeyPair` to produce the signature, which commits to the Blake2b hash digest of the intent message (`intent || bcs bytes of tx_data`). The signature schemes currently supported are `Ed25519 Pure`, `ECDSA Secp256k1`, `ECDSA Secp256r1`, `Multisig`, and `zkLogin`.

You can instantiate `Ed25519 Pure`, `ECDSA Secp256k1`, and `ECDSA Secp256r1` using `SuiKeyPair` and use it to sign transactions. Note that this guide does not apply to `Multisig` and `zkLogin`, refer to their own pages ([Multisig](/concepts/cryptography/transaction-auth/multisig) and [zkLogin](https://docs.sui.io/concepts/cryptography/zklogin) respectively) for instructions.

With a signature and the transaction bytes, a transaction can be submitted to be executed.

## Workflow

The following high-level process describes the overall workflow for constructing, signing, and executing an on-chain transaction:

- Construct the transaction data by creating a `Transaction` where multiple transactions are chained. See [Building Programmable Transaction Blocks](/guides/developer/sui-101/building-ptb.mdx) for more information.
- The SDK's built-in gas estimation and coin selection picks the gas coin.
- Sign the transaction to generate a [signature](/concepts/cryptography/transaction-auth/signatures#user-signature).
- Submit the `Transaction` and its signature for on-chain execution.

:::info

If you want to use a specific gas coin, first find the gas coin object ID to be used to pay for gas and explicitly use that in the PTB. If there is no gas coin object, use the [splitCoin](./building-ptb#available-transactions) transaction to create a gas coin object. The split coin transaction should be the first transaction call in the PTB.

:::

## Examples

The following examples demonstrate how to sign and execute transactions using Rust, TypeScript, or the Sui CLI.

<Tabs groupId="code-language">

<TabItem value="ts-sdk" label="TypeScript">

There are various ways to instantiate a key pair and to derive its public key and Sui address using the Sui TypeScript SDK.

```tsx
import { fromHex } from '@mysten/bcs';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { type Keypair } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Secp256k1Keypair } from '@mysten/sui/keypairs/secp256k1';
import { Secp256r1Keypair } from '@mysten/sui/keypairs/secp256r1';
import { Transaction } from '@mysten/sui/transactions';

const kp_rand_0 = new Ed25519Keypair();
const kp_rand_1 = new Secp256k1Keypair();
const kp_rand_2 = new Secp256r1Keypair();

const kp_import_0 = Ed25519Keypair.fromSecretKey(
	fromHex('0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82'),
);
const kp_import_1 = Secp256k1Keypair.fromSecretKey(
	fromHex('0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82'),
);
const kp_import_2 = Secp256r1Keypair.fromSecretKey(
	fromHex('0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82'),
);

// $MNEMONICS refers to 12/15/18/21/24 words from the wordlist, for example, "retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire". Refer to [Keys and Addresses](/concepts/cryptography/transaction-auth/keys-addresses.mdx) for more.
const kp_derive_0 = Ed25519Keypair.deriveKeypair('$MNEMONICS');
const kp_derive_1 = Secp256k1Keypair.deriveKeypair('$MNEMONICS');
const kp_derive_2 = Secp256r1Keypair.deriveKeypair('$MNEMONICS');

const kp_derive_with_path_0 = Ed25519Keypair.deriveKeypair('$MNEMONICS', "m/44'/784'/1'/0'/0'");
const kp_derive_with_path_1 = Secp256k1Keypair.deriveKeypair('$MNEMONICS', "m/54'/784'/1'/0/0");
const kp_derive_with_path_2 = Secp256r1Keypair.deriveKeypair('$MNEMONICS', "m/74'/784'/1'/0/0");

// replace `kp_rand_0` with the variable names above.
const pk = kp_rand_0.getPublicKey();
const sender = pk.toSuiAddress();

// create an example transaction block.
const txb = new Transaction();
txb.setSender(sender);
txb.setGasPrice(5);
txb.setGasBudget(100);
const bytes = await txb.build();
const serializedSignature = (await keypair.signTransaction(bytes)).signature;

// verify the signature locally
expect(await keypair.getPublicKey().verifyTransaction(bytes, serializedSignature)).toEqual(true);

// define sui client for the desired network.
const client = new SuiClient({ url: getFullnodeUrl('testnet') });

// execute transaction.
let res = client.executeTransactionBlock({
	transactionBlock: bytes,
	signature: serializedSignature,
});
console.log(res);
```

</TabItem>

<TabItem value="rust" label="Rust">

The full code example below can be found under [crates/sui-sdk](https://github.com/MystenLabs/sui/blob/main/crates/sui-sdk/examples/sign_tx_guide.rs).

There are various ways to instantiate a `SuiKeyPair` and to derive its public key and Sui address using the Sui Rust SDK.

```rust
    // deterministically generate a key pair, testing only, do not use for mainnet, use the next section to randomly generate a key pair instead.
    let skp_determ_0 =
        SuiKeyPair::Ed25519(Ed25519KeyPair::generate(&mut StdRng::from_seed([0; 32])));
    let _skp_determ_1 =
        SuiKeyPair::Secp256k1(Secp256k1KeyPair::generate(&mut StdRng::from_seed([0; 32])));
    let _skp_determ_2 =
        SuiKeyPair::Secp256r1(Secp256r1KeyPair::generate(&mut StdRng::from_seed([0; 32])));

    // randomly generate a key pair.
    let _skp_rand_0 = SuiKeyPair::Ed25519(get_key_pair_from_rng(&mut rand::rngs::OsRng).1);
    let _skp_rand_1 = SuiKeyPair::Secp256k1(get_key_pair_from_rng(&mut rand::rngs::OsRng).1);
    let _skp_rand_2 = SuiKeyPair::Secp256r1(get_key_pair_from_rng(&mut rand::rngs::OsRng).1);

    // import a key pair from a base64 encoded 32-byte `private key`.
    let _skp_import_no_flag_0 = SuiKeyPair::Ed25519(Ed25519KeyPair::from_bytes(
        &Base64::decode("1GPhHHkVlF6GrCty2IuBkM+tj/e0jn64ksJ1pc8KPoI=")
            .map_err(|_| anyhow!("Invalid base64"))?,
    )?);
    let _skp_import_no_flag_1 = SuiKeyPair::Ed25519(Ed25519KeyPair::from_bytes(
        &Base64::decode("1GPhHHkVlF6GrCty2IuBkM+tj/e0jn64ksJ1pc8KPoI=")
            .map_err(|_| anyhow!("Invalid base64"))?,
    )?);
    let _skp_import_no_flag_2 = SuiKeyPair::Ed25519(Ed25519KeyPair::from_bytes(
        &Base64::decode("1GPhHHkVlF6GrCty2IuBkM+tj/e0jn64ksJ1pc8KPoI=")
            .map_err(|_| anyhow!("Invalid base64"))?,
    )?);

    // import a key pair from a base64 encoded 33-byte `flag || private key`. The signature scheme is determined by the flag.
    let _skp_import_with_flag_0 =
        SuiKeyPair::decode_base64("ANRj4Rx5FZRehqwrctiLgZDPrY/3tI5+uJLCdaXPCj6C")
            .map_err(|_| anyhow!("Invalid base64"))?;
    let _skp_import_with_flag_1 =
        SuiKeyPair::decode_base64("AdRj4Rx5FZRehqwrctiLgZDPrY/3tI5+uJLCdaXPCj6C")
            .map_err(|_| anyhow!("Invalid base64"))?;
    let _skp_import_with_flag_2 =
        SuiKeyPair::decode_base64("AtRj4Rx5FZRehqwrctiLgZDPrY/3tI5+uJLCdaXPCj6C")
            .map_err(|_| anyhow!("Invalid base64"))?;

    // replace `skp_determ_0` with the variable names above
    let pk = skp_determ_0.public();
    let sender = SuiAddress::from(&pk);
```

Next, sign transaction data constructed using an example programmable transaction block with default gas coin, gas budget, and gas price. See [Building Programmable Transaction Blocks](./building-ptb.mdx) for more information.

```rust
    // construct an example programmable transaction.
    let pt = {
        let mut builder = ProgrammableTransactionBuilder::new();
        builder.pay_sui(vec![sender], vec![1])?;
        builder.finish()
    };

    let gas_budget = 5_000_000;
    let gas_price = sui_client.read_api().get_reference_gas_price().await?;

    // create the transaction data that will be sent to the network.
    let tx_data = TransactionData::new_programmable(
        sender,
        vec![gas_coin.object_ref()],
        pt,
        gas_budget,
        gas_price,
    );
```

Commit a signature to the Blake2b hash digest of the intent message (`intent || bcs bytes of tx_data`).

```rust
    // derive the digest that the key pair should sign on, that is, the blake2b hash of `intent || tx_data`.
    let intent_msg = IntentMessage::new(Intent::sui_transaction(), tx_data);
    let raw_tx = bcs::to_bytes(&intent_msg).expect("bcs should not fail");
    let mut hasher = sui_types::crypto::DefaultHash::default();
    hasher.update(raw_tx.clone());
    let digest = hasher.finalize().digest;

    // use SuiKeyPair to sign the digest.
    let sui_sig = skp_determ_0.sign(&digest);

    // if you would like to verify the signature locally before submission, use this function. if it fails to verify locally, the transaction will fail to execute in Sui.
    let res = sui_sig.verify_secure(
        &intent_msg,
        sender,
        sui_types::crypto::SignatureScheme::ED25519,
    );
    assert!(res.is_ok());
```

Finally, submit the transaction with the signature.

```rust
    let transaction_response = sui_client
        .quorum_driver_api()
        .execute_transaction_block(
            sui_types::transaction::Transaction::from_generic_sig_data(
                intent_msg.value,
                Intent::sui_transaction(),
                vec![GenericSignature::Signature(sui_sig)],
            ),
            SuiTransactionBlockResponseOptions::default(),
            None,
        )
        .await?;
```

</TabItem>

<TabItem value="cli" label="Sui CLI">

When using the [Sui CLI](/references/cli.mdx) for the first time, it creates a local file in `~/.sui/keystore` on your machine with a list of private keys (encoded as Base64 encoded `flag || 32-byte-private-key`). You can use any key to sign transactions by specifying its address. Use `sui keytool list` to see a list of addresses.

There are 3 ways to initialize a key:

```sh
# generate randomly.
sui client new-address ed25519
sui client new-address secp256k1
sui client new-address secp256r1

# import the 32-byte private key to keystore.
sui keytool import "0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82" ed25519
sui keytool import "0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82" secp256k1
sui keytool import "0xd463e11c7915945e86ac2b72d88b8190cfad8ff7b48e7eb892c275a5cf0a3e82" secp256r1

# import the mnemonics (recovery phrase) with derivation path to keystore.
# $MNEMONICS refers to 12/15/18/21/24 words from the wordlist, for example, "retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire". Refer to [Keys and Addresses](/concepts/cryptography/transaction-auth/keys-addresses.mdx) for more.

sui keytool import "$MNEMONICS" ed25519
sui keytool import "$MNEMONICS" secp256k1
sui keytool import "$MNEMONICS" secp256r1
```

Create a transfer transaction in the CLI. Set the `$SUI_ADDRESS` to the one corresponding to the key pair used to sign. `$GAS_COIN_ID` refers to the object ID that is owned by the sender to be used as gas. `$GAS_BUDGET` refers to the budget used to execute transaction. Then sign with the private key corresponding to the sender address. `$MNEMONICS` refers to 12/15/18/21/24 words from the wordlist, for example, "retire skin goose will hurry this field stadium drastic label husband venture cruel toe wire". Refer to [Keys and Addresses](/concepts/cryptography/transaction-auth/keys-addresses.mdx) for more.

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client gas
```
```sh
$ sui client transfer-sui --to $SUI_ADDRESS --sui-coin-object-id $GAS_COIN_ID --gas-budget $GAS_BUDGET --serialize-unsigned-transaction
```
```sh
$ sui keytool sign --address $SUI_ADDRESS --data $TX_BYTES
```
```sh
$ sui client execute-signed-tx --tx-bytes $TX_BYTES --signatures $SERIALIZED_SIGNATURE
```

</TabItem>
</Tabs>

### Notes

1. This guide demonstrates how to sign with a single private key. Refer to [Multisig](/concepts/cryptography/transaction-auth/multisig.mdx) when it is preferred to set up more complex signing policies.
2. Similarly, native zkLogin does not follow the above steps, see [the docs](/concepts/cryptography/zklogin.mdx) to understand how to derive a zkLogin address and produce a zkLogin signature with an ephemeral key pair.
3. If you decide to implement your own signing mechanisms instead of using the previous tools, see the [Signatures](/concepts/cryptography/transaction-auth/signatures.mdx) doc on the accepted signature specifications for each scheme.
4. Flag is 1 byte that differentiates signature schemes. See supported schemes and its flag in [Signatures](/concepts/cryptography/transaction-auth/signatures.mdx).
5. The `execute_transaction_block` endpoint takes a list of signatures, so it should contain exactly 1 user signature, unless you are using sponsored transaction that a second signature for the gas object can be provided. See [Sponsored Transactions](/concepts/transactions/sponsored-transactions.mdx) for more information.
>>>> sui/docs/content/guides/developer/sui-101/simulating-refs.mdx
---
title: Simulating References
description: Use the borrow module in the Sui framework to include objects by reference in your programmable transaction blocks.
keywords: [ borrow module, sui framework, objects, immutable reference, mutable reference, Sui API, references, simulate a reference, simulate references ]
---

Everything on the Sui blockchain is an object. When you develop Move packages for the Sui network, you're typically manipulating or using on-chain objects in some way through functionality available in the Sui API. For most API functions, you provide an object by reference.

References are a key construct when programming in Move and on Sui. Most of the functionality available in the Sui API takes objects by reference.

There are 2 ways to use an object:

- **By value:** When you use an object by value, you have full control over that object. You can destroy it (if the functionality is available), wrap it (if it has the `store` ability), or transfer it to an address.
- **By reference:** When you use an object by reference, operations over that object are determined by the logic the module that defines the object provides because you are using a reference to its data rather than having ownership of the object itself. The restrictions of references allow you to develop smart contracts with a high level of security and safety around assets. There are 2 types of references:
  - Mutable reference (`&mut`): You can alter the object (according to the API) but you can't destroy or transfer it.
  - Immutable reference (`&`): Further restricts the set of operations and the guarantees or invariants over the referenced object. You have read-only access to the object's data.

Programmable transaction blocks (PTBs) do not currently allow the use of object references returned from one of its transaction commands. You can use input objects to the PTB, objects created by the PTB (like `MakeMoveVec`), or returned from a transaction command by value as references in subsequent transaction commands. If a transaction command returns a reference, however, you can't use that reference in any call, significantly limiting certain common patterns in Move.

## The borrow module

The Sui framework includes a [borrow](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/borrow.md) module that offers a solution to the reference problem. The module provides access to an object by value but builds a model that makes it impossible to destroy, transfer, or wrap the object retrieved. The borrow module exposes a `Referent` object that wraps another object (the object you want to reference). The module uses the hot potato pattern (through a `Borrow` instance) to allow retrieval of the wrapped object by value. Within the same PTB, the module then forces the object to be returned to the `Referent`. The `Borrow` instance guarantees that the object returned is the same that was retrieved.

As an example, consider the following module stub that exposes an object (`Asset`) and a function (`use_asset`) to use that object.

```rust
module a_module {
    struct Asset has key, store {
        â€¦ // some data
    }

    public fun use_asset(asset: &Asset) {
        â€¦. // some code
    }
}
```

The function `use_asset` takes an immutable reference to the asset (`&Asset`), which is a common pattern in an API definition.

Now consider another module that uses this asset.

```rust
module another_module {
    struct AssetManager has key {
        asset: Asset,
    }

    public fun get_asset(manager: &AssetManager): &Asset {
        &manager.asset
    }
}
```

This module creates an object (`AssetManager`) that references the object (`Asset`) created in the previous module (`a_module`).

You could then write a Move function that retrieves an object by reference and passes it to the `use_asset` function.

```rust
fun do_something(manager: &AssetManager) {
    let asset = another_module::get_asset(manager);
    a_module::use_asset(asset);
}
```

The 2 functions in `do_something` are not valid within a PTB, however, because PTBs do not support a reference returned by a function and passed to another function.

To make this operation valid within a PTB, you need to include functionality from the borrow module. Consequently, you could change the `another_module` code to the following:

```rust
module another_module {
    struct AssetManager has key {
        asset: Referent<Asset>,
    }

    public fun get_asset(manager: &mut AssetManager): (Asset, Borrow) {
        borrow::borrow(&mut manager.asset)
    }


    public fun return_asset(
        manager: &mut AssetManager,
        asset: Asset,
        b: Borrow) {
            borrow::put_back(&mut manager.asset, asset, b)
    }
}
```

Now the PTB can retrieve the asset, use it in a call to `use_asset`, and return the asset.

## Considerations

The `Borrow` object is the key to the guarantees the borrow module offers. The definition of `Borrow` is
`struct Borrow { ref: address, obj: ID }`
which makes it such that you cannot drop or save its instance anywhere, so it must be consumed in the same transaction that retrieves it (hot potato). Moreover, fields in the `Borrow` struct make sure that the object returned is for the same `Referent` and the object that was originally held by the `Referent` instance. In other words, there is no way to either keep the object retrieved or to swap it with another object in a different `Referent`.

:::caution

Using a `Referent` is a very explicit and intrusive change. That has to be taken into consideration when designing a solution.

:::

Support for references in a PTB is planned, which is a much more natural and proper pattern for APIs.

You must consider the implications of using the borrow module and whether you have a mechanism to later move to a more natural, reference pattern.

Finally, the `Referent` model forces the usage of a mutable reference and returns an object by value. Both have significant implications when designing an API. You must be careful in what logic your modules provide and how objects are exposed.

## Example

Extending the previous example, a PTB that calls `use_asset` is written as follows:

```rust
// initialize the PTB
const txb = new TransactionBlock();
// load the assetManager
const assetManager = txb.object(assetManagerId);
// retrieve the asset
const [asset, borrow] = txb.moveCall({
    target: "0xaddr1::another_module::get_asset",
    arguments: [ assetManager ],
});
// use the asset
txb.moveCall({
    target: "0xaddr2::a_module::use_asset",
    arguments: [ asset ],
});
// return the asset
txb.moveCall({
    target: "0xaddr1::another_module::return_asset",
    arguments: [ assetManager, asset, borrow ],
});
...
```
>>>> sui/docs/content/guides/developer/sui-101/sponsor-txn.mdx
---
title: Sponsored Transactions
description: Sponsored transactions are a primitive on the Sui blockchain that enable the execution of a transaction where you pay the gas fee for your users transactions.
keywords: [ sponsored, sponsor a transaction, sponsored transactions, pay for a transaction, app-specific sponsorship, wildcard sponsorship, sponsored transaction flow, sponsor an app, sponsor a transaction flow, pay for gas fee, pay another user's gas fee, pay another gas fee ]
---

A transaction on Sui takes a payment to execute. The payment, also known as gas, is a list of `0x2::coin::Coin<0x2::sui::Sui>` objects. Although gas is a critical piece in Sui tokenomics, it sometimes adds challenges when new Web3 users start to navigate on Sui.

Sponsored transactions are a primitive on the Sui blockchain that enable the execution of a transaction without a user paying the gas. Sponsored transactions can reduce the onboarding friction for users because the feature streamlines the process for end users. Using sponsored transactions, you can execute a transaction without requiring the user to pay it themselves. Instead, you can act as a sponsor of the transaction, offering your own payment gas objects for the transaction.

## Roles in sponsored transactions

In a sponsored transaction there are 3 roles: the user, the gas station, and the sponsor.

- The user is the entity who wants to execute a transaction. 
- The gas station is the entity that fulfills the sponsorship request for the user's transaction by providing the gas payment they own.
- The sponsor is entity that funds the gas station for its operations.

It's not uncommon for the gas station and the sponsor to be the same entity. For example, a Web3 gaming studio could run its own gas station to sponsor users with real free-to-play gaming experiences at its user acquisition stage. Because it's not always trivial to maintain a gas station for teams of any size, that gaming studio could also leverage third-party gas stations to sponsor transactions they want to promote. 

The remainder of this guide assumes the sponsor uses their own gas station. 

## Use cases

The following sections describe some common scenarios where sponsored transactions offer an improved user experience.

### App-specific sponsorship

In this scenario, the sponsor has a specific set of applications they want to sponsor.

- If the transaction is initialized by the user, the sponsor examines the transaction to make sure it's within the set of approved applications before agreeing to provide the gas payment. 
- If the transaction is proposed by the sponsor, the user must examine the transaction and decide if they want to execute it. Examples of this type of transaction might include a rewards claim transaction of a campaign or a "try it out" advertisement transaction.

### Wildcard sponsorship

In this scenario, the sponsor has few restrictions on the type of transactions the gas payment can be used for.

- If the sponsor is a gasless wallet, it might agree to sponsor any valid transactions proposed by its users.
- In the form of a reward or discount, the sponsor could offer the user a wildcard gas payment, expressly promising to execute any transactions with that gas payment.

A sponsored transaction is not restricted to these use cases. Essentially, a sponsored transaction is any transaction jointly made by the user and the sponsor. As long as the stakeholders can agree on the transaction details, then the number of possible ways to provide sponsored transactions is limited only by the imagination. Because at least 2 stakeholders are involved in a sponsored transaction, however, there are some [additional risks](#risk) that you should take steps to mitigate.


## Sponsored transaction flow

This section is mostly for developers who are interested in building a gas station or integrating with one.

The data structure of a transaction resembles the following:

```rust

pub struct SenderSignedTransaction {
    pub intent_message: IntentMessage<TransactionData>,
    /// A list of signatures signed by all transaction participants.
    /// 1. non participant signature must not be present.
    /// 2. signature order does not matter.
    pub tx_signatures: Vec<GenericSignature>,
}

pub struct TransactionDataV1 {  // <-- A variant of `TransactionData`
    pub kind: TransactionKind,  // <-- This is the actual transaction details
    pub sender: SuiAddress,
    pub gas_data: GasData,
    pub expiration: TransactionExpiration,
}

pub struct GasData {
    pub payment: Vec<ObjectRef>,
    pub owner: SuiAddress,
    pub price: u64,
    pub budget: u64,
}

```

A few details of note for the preceding code:

- `sender` in `TransactionDataV1` (a variant of `TransactionData`) is the user address.
- `gas_data` in `TransactionDataV1` is the gas payment.
- `GasData` allows a list of gas objects, but the same address must own them, namely the `owner` in `GasData` (the sponsor). When `owner` is equal to `sender`, then it is a regular or non-sponsored transaction.
- `tx_signatures` in `SenderSignedTransaction` is a list of signatures. For a sponsored transaction, the list needs to contain both signatures of the user and the sponsor in some order. The signatures are signed over the entire `TransactionData`, including `GasData`.

So, to construct a correct sponsored transaction, you must first build a `TransactionData` object. If you are neither the user or the sponsor, you pass the transaction to both parties to sign. If you're the sponsor, you sign the transaction and then pass it and the signature to the other party (in the form of `SenderSignedTransaction`) for them to sign. In practice, the latter is the more common scenario. 

There are 3 flows of sponsored transaction.

**User proposed transaction**

([swimlane link](https://swimlanes.io/d/wAcnOpA_h))

![](https://static.swimlanes.io/b090340af36c8a4af6c36d4479a4d04f.png)

**Sponsor proposed transaction**

([swimlane link](https://swimlanes.io/#ZZE9T8QwDIb3/ApvLIWBsQMSEh8DEkI6mInb+O6itk4VOxInxH8nqe76AVki+X392G+iXnuq4fYGdmNgCRHeYhiDkIP3iCzYqg9syuGg2WmstWZMDYjG1Ora9YCK8G0gn2LoPLt6rb/kQjXLQuwo1rBL/t65SCKLdkD5dJlWwzNKwS4SfY0+YsFt2I9zuTI/047mEuj67pKthjmlHj13ki+CD6EIA56gIfCslFfRHN8zIOgyoQJkB2G/pyhZsefNLKDAiKeBWDczC7YG++d97EQ5264ExB8YNUUyZtpjbmyP1Hbb+cX7H7g0PqW+fw0uf5KkZvAKLmE/deU4K9Iv))

![](https://static.swimlanes.io/d917884a263c494bb6127102d0f64840.png)


**Wildcard gas payment**


([swimlane link](https://static.swimlanes.io/ee3962b3ac3cc5d34f317cecdde125b0.png))

![](https://static.swimlanes.io/ee3962b3ac3cc5d34f317cecdde125b0.png)


## Risk considerations {#risk}

Because at least 2 stakeholders are involved in a sponsored transaction, you should take steps to mitigate risk.

### Client equivocation risk

Client equivocation happens when more than 1 legit transaction that shares at least 1 owned object (such as a gas coin object) at a certain version are submitted to the network simultaneously. On Sui, before a transaction is executed, owned objects in this transaction are locked on validators at specific versions. An honest validator only accepts 1 transaction and rejects others. Depending on the order validators receive these transactions, validators might accept different transactions. In the event of no single transaction getting accepted by at least 2/3rds of validators, the owned object is locked until end of the epoch.

Practically speaking, client equivocation is rare, mostly caused by buggy client software. After all, no one has incentives to lock their own objects. However, sponsored transactions come with counterparty risks. For example, a malicious user could equivocate the gas station's gas coin object by submitting another transaction that uses 1 owned object in the gas station signed transaction at the same version. Similarly, a Byzantine gas station could do the same to the user owned objects.

Although this risk might seem trivial, it is helpful to be aware of it. Your gas station should actively monitor user behavior and alert on anything abnormal. Whether you're a user taking advantage of sponsored transactions or a developer integrating with a gas station, consider your reputation to minimize the risk of client equivocation.

Both the user and the sponsor need to sign over the entire `TransactionData`, including `GasData` because otherwise a third party (such as a malicious full node) could snip the partially signed data and cause client equivocation and locking of owned objects. 

### Censorship risk

If you choose to submit the dual-signed transaction to the sponsor or gas station rather than a full node, the transaction might be subject to sponsor or gas station censorship. Namely, the sponsor might choose not to submit the transaction to the network or delay the submission. 

You can mitigate this risk by submitting the transaction directly to a full node.
>>>> sui/docs/content/guides/developer/sui-101/using-events.mdx
---
title: Using Events
description: Use events to notify on-chain assets of activity your smart contracts initiate and query events from other packages to trigger logic based on emitted events.
keywords: [ using events, notify events, notify assets, notify on-chain assets, activity events, events for activities, move events, events in move, query events, sui RPC, graphql, move, filter events, rust, typescript ]
---

The Sui network stores countless objects on chain where Move code can perform actions using those objects. Tracking this activity is often desired, for example, to discover how many times a module mints an NFT or to tally the amount of SUI in transactions that a smart contract generates.

To support activity monitoring, Move provides a structure to emit events on the Sui network. You can then leverage a custom indexer to process checkpoint data that includes events that have been emitted. See the [custom indexer](../advanced/custom-indexer.mdx) topic in the Advanced section to learn how to stream checkpoints and filter events continuously. 

If you don't want to run a custom indexer, you can poll the Sui network to query for emitted events instead. This approach typically includes a database to store the data retrieved from these calls. The [Poll events](#poll-events) section provides an example of using this method.

## Move event structure

An event object in Sui consists of the following attributes:

- `id`: JSON object containing the transaction digest ID and event sequence.
- `packageId`: The object ID of the package that emits the event.
- `transactionModule`: The module that performs the transaction.
- `sender`: The Sui network address that triggered the event.
- `type`: The type of event being emitted.
- `parsedJson`: JSON object describing the event.
- `bcs`: Binary canonical serialization value.
- `timestampMs`: Unix epoch timestamp in milliseconds.

## Emit events in Move

To create an event in your Move modules, add the `sui::event` dependency.

```move
use sui::event;
```

With the dependency added, you can use the `emit` function to trigger an event whenever the action you want to monitor fires. For example, the following code is part of an example application that enables the locking of objects. The `lock` function handles the locking of objects and emits an event whenever the function is called.

<ImportContent source="examples/trading/contracts/escrow/sources/lock.move" mode="code" fun="lock" noComments />

### Query events with RPC

The Sui RPC provides a [queryEvents](/sui-api-ref#suix_queryEvents) method to query on-chain packages and return available events. As an example, the following `curl` command queries the Deepbook package on Mainnet for a specific type of event:

```sh
$ curl -X POST https://fullnode.mainnet.sui.io:443 \
-H "Content-Type: application/json" \
-d '{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "suix_queryEvents",
  "params": [
    {
      "MoveModule": {
        "package": "0x158f2027f60c89bb91526d9bf08831d27f5a0fcb0f74e6698b9f0e1fb2be5d05",
        "module": "deepbook_utils",
        "type": "0xdee9::clob_v2::DepositAsset<0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>"
      }
    },
    null,
    3,
    false
  ]
}'
```

<details>
<summary>

A successful `curl` return

</summary>

```json
{
	"jsonrpc": "2.0",
	"result": {
		"data": [
			{
				"id": {
					"txDigest": "8NB8sXb4m9PJhCyLB7eVH4onqQWoFFzVUrqPoYUhcQe2",
					"eventSeq": "0"
				},
				"packageId": "0x158f2027f60c89bb91526d9bf08831d27f5a0fcb0f74e6698b9f0e1fb2be5d05",
				"transactionModule": "deepbook_utils",
				"sender": "0x8b35e67a519fffa11a9c74f169228ff1aa085f3a3d57710af08baab8c02211b9",
				"type": "0xdee9::clob_v2::WithdrawAsset<0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>",
				"parsedJson": {
					"owner": "0x704c8c0d8052be7b5ca7174222a8980fb2ad3cd640f4482f931deb6436902627",
					"pool_id": "0x7f526b1263c4b91b43c9e646419b5696f424de28dda3c1e6658cc0a54558baa7",
					"quantity": "6956"
				},
				"bcs": "2szz6igTRuGmD7YATo8BEg81VLaei4od62wehadwMXYJv63UzJE16USL9pHFYBAGbwNkDYLCk53d45eFj3tEZK1vDGqtXcqH5US",
				"timestampMs": "1691757698019"
			},
			{
				"id": {
					"txDigest": "8NB8sXb4m9PJhCyLB7eVH4onqQWoFFzVUrqPoYUhcQe2",
					"eventSeq": "1"
				},
				"packageId": "0x158f2027f60c89bb91526d9bf08831d27f5a0fcb0f74e6698b9f0e1fb2be5d05",
				"transactionModule": "deepbook_utils",
				"sender": "0x8b35e67a519fffa11a9c74f169228ff1aa085f3a3d57710af08baab8c02211b9",
				"type": "0xdee9::clob_v2::OrderFilled<0x2::sui::SUI, 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>",
				"parsedJson": {
					"base_asset_quantity_filled": "0",
					"base_asset_quantity_remaining": "1532800000000",
					"is_bid": false,
					"maker_address": "0x78a1ff467e9c15b56caa0dedfcfbdfe47c0c385f28b05fdc120b2de188cc8736",
					"maker_client_order_id": "1691757243084",
					"maker_rebates": "0",
					"order_id": "9223372036854839628",
					"original_quantity": "1614700000000",
					"pool_id": "0x7f526b1263c4b91b43c9e646419b5696f424de28dda3c1e6658cc0a54558baa7",
					"price": "605100",
					"taker_address": "0x704c8c0d8052be7b5ca7174222a8980fb2ad3cd640f4482f931deb6436902627",
					"taker_client_order_id": "20082022",
					"taker_commission": "0"
				},
				"bcs": "DcVGz85dWTLU4S33N7VYrhgbkm79ENhHVnp5kBfENEWEeMxHQuvsczg94teh6WHdYtwPqdEsPWdvSJ7ne5qiMxxn3kBm36KLyuuzHV1QdzF45GN8ZU1MDGU4XppiaqcMeRpPPiW8JpUDyeQoobKEV8fMqcyYpDq6KWtZ1WMoGvEDxFKDgFvW9Q7bt1JAzQehRkEKEDZ6dTwfiHw92QuFqczmZ5MKJLYzeysUsSw",
				"timestampMs": "1691757698019"
			},
			{
				"id": {
					"txDigest": "8b3byDuRojHXqmSz16PsyzfdXJEY5nZBGTM23gMsMAY8",
					"eventSeq": "0"
				},
				"packageId": "0x158f2027f60c89bb91526d9bf08831d27f5a0fcb0f74e6698b9f0e1fb2be5d05",
				"transactionModule": "deepbook_utils",
				"sender": "0x8b35e67a519fffa11a9c74f169228ff1aa085f3a3d57710af08baab8c02211b9",
				"type": "0xdee9::clob_v2::OrderFilled<0x2::sui::SUI, 0x5d4b302506645c37ff133b98c4b50a5ae14841659738d6d733d59d0d217a93bf::coin::COIN>",
				"parsedJson": {
					"base_asset_quantity_filled": "700000000",
					"base_asset_quantity_remaining": "0",
					"is_bid": false,
					"maker_address": "0x03b86e93d80b27763ee1fc2c37e285465dff835769de9462d9ad4ebcf46ac6df",
					"maker_client_order_id": "20082022",
					"maker_rebates": "634",
					"order_id": "9223372036854839643",
					"original_quantity": "1000000000",
					"pool_id": "0x7f526b1263c4b91b43c9e646419b5696f424de28dda3c1e6658cc0a54558baa7",
					"price": "604100",
					"taker_address": "0x704c8c0d8052be7b5ca7174222a8980fb2ad3cd640f4482f931deb6436902627",
					"taker_client_order_id": "20082022",
					"taker_commission": "1058"
				},
				"bcs": "DcVGz85dWTLU4S33N7VYrhgbkm79ENhHVnp5kBfENEWEjN45pa9U3AkNhxfTRZbaHTQLugLBXttE32hpJKRsbrZGdryXMPmNA8EpHJnVcnYMXZmWXkNXvY1XjEYnAKU4BnhyJ9BQuxRJDXLA4DEu5uWEpWjLPD2ZHuxqHCn7GpUxvxJjHkKjr9jVVfeR6sN2uRhUXkThEDjCekrqaqwidkyXNmTzmZG4fre3eoZ",
				"timestampMs": "1691758372427"
			}
		],
		"nextCursor": {
			"txDigest": "8b3byDuRojHXqmSz16PsyzfdXJEY5nZBGTM23gMsMAY8",
			"eventSeq": "0"
		},
		"hasNextPage": true
	},
	"id": 1
}
```

</details>

The TypeScript SDK provides a wrapper for the `suix_queryEvents` method: [`client.queryEvents`](https://sdk.mystenlabs.com/typedoc/classes/_mysten_sui.client.SuiClient.html#queryEvents).

<details>
<summary>

TypeScript SDK queryEvents example

</summary>

```ts
import { useCurrentAccount, useSignAndExecuteTransaction, useSuiClient } from "@mysten/dapp-kit";
import { Transaction } from "@mysten/sui/transactions";
import { Button, Flex, Heading } from "@radix-ui/themes";

export function Creategame({ onCreated }: { onCreated: (id: string) => void }) {
  const { mutateAsync: signAndExecute } = useSignAndExecuteTransaction();
  const currentAccount = useCurrentAccount();
  const client = useSuiClient();

  const executeMoveCall = async (method: "small" | "large") => {
    if (!currentAccount?.address) {
      console.error("No connected account found.");
      return;
    }

    try {
      const tx = new Transaction();

      tx.moveCall({
        arguments: [tx.pure.u64(method === "small" ? 0 : 1)],
        target: `<PACKAGE-ID>::<MODULE>::create_game`,
      });

      const txResult = await signAndExecute({
        transaction: tx,
      });

      await client.waitForTransaction({
        digest: txResult.digest
      });

      const eventsResult = await client.queryEvents({
        query: { Transaction: txResult.digest },
      });

      if (eventsResult.data.length > 0) {
        const firstEvent = eventsResult.data[0]?.parsedJson as { msg?: string };
        const result = firstEvent?.msg || "No events found for the given criteria.";
        onCreated(result);
      } else {
        onCreated("No events found for the given criteria.");
      }
    } catch (error) {
      console.error("Error creating game or querying events:", error);
    }
  };

  return (
    <>
      <Heading size="3">Game Start</Heading>
      <Flex direction="column" gap="2">
        <Flex direction="row" gap="2">
          <Button onClick={() => executeMoveCall("small")}>small</Button>
          <Button onClick={() => executeMoveCall("large")}>large</Button>
        </Flex>
      </Flex>
    </>
  );
}
```

The example displays the following JSON representation of the event. 

```json
{
  "id": {
    "txDigest": "46vSzYS9PaTWZDju2N8ECebAGLrXBdrP9NmvvydtDW2c",
    "eventSeq": "0"
  },
  "packageId": "<PACKAGE-ID>",
  "transactionModule": "<MODULE>",
  "sender": "<SENDER-ADDRESS>",
  "type": "<PACKAGE-ID>::<MODULE>::Result",
  "parsedJson": {
    "msg": "You Lose :("
  },
  "bcs": "DRUZAsJK2DLrBj27"
}
```
</details>


#### Filtering event queries

To filter the events returned from your queries, use the following data structures.

| Query             | Description                                              | JSON-RPC Parameter Example                                                                            |
| ----------------- | -------------------------------------------------------- | ----------------------------------------------------------------------------------------------------- |
| `All`             | All events                                               | `{"All": []}`                                                                                         |
| `Any`             | Events emitted from any of the given filter              | `{"Any": SuiEventFilter[]}`                                                                           |
| `Transaction`     | Events emitted from the specified transaction            | `{"Transaction":"DGUe2TXiJdN3FI6MH1FwghYbiHw+NKu8Nh579zdFtUk="}`                                      |
| `MoveModule`      | Events emitted from the specified Move module            | `{"MoveModule":{"package":"<PACKAGE-ID>", "module":"nft"}}`                                           |
| `MoveEventModule` | Events emitted, defined on the specified Move module.    | `{"MoveEventModule": {"package": "<DEFINING-PACKAGE-ID>", "module": "nft"}}`                          |
| `MoveEventType`   | Move struct name of the event                            | `{"MoveEventType":"::nft::MintNFTEvent"}`                                                             |                                                                   
| `Sender`          | Query by sender address                                  | `{"Sender":"0x008e9c621f4fdb210b873aab59a1e5bf32ddb1d33ee85eb069b348c234465106"}`                     |
| `TimeRange`       | Return events emitted in [start_time, end_time] interval | `{"TimeRange":{"startTime":1669039504014, "endTime":1669039604014}}`                                  | 

### Query events in Rust

The [Sui by Example](https://github.com/gdanezis/sui-by-example/blob/main/src/05_reading_events/bin/main.rs) repo on GitHub contains a code sample that demonstrates how to query events using the `query_events` function. The package that `PACKAGE_ID_CONST` points to exists on Mainnet, so you can test this code using Cargo. To do so, clone the `sui-by-example` repo locally and follow the [Example 05 directions](https://github.com/gdanezis/sui-by-example/tree/main/src/05_reading_events). 

```rust
use sui_sdk::{rpc_types::EventFilter, types::Identifier, SuiClientBuilder};

const PACKAGE_ID_CONST: &str = "0x279525274aa623ef31a25ad90e3b99f27c8dbbad636a6454918855c81d625abc";

#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    let sui_mainnet = SuiClientBuilder::default()
        .build("https://fullnode.mainnet.sui.io:443")
        .await?;

    let events = sui_mainnet
        .event_api()
        .query_events(
            EventFilter::MoveModule {
                package: PACKAGE_ID_CONST.parse()?,
                module: Identifier::new("dev_trophy")?,
            },
            None,
            None,
            false,
        )
        .await?;

    for event in events.data {
        println!("Event: {:?}", event.parsed_json);
    }

    Ok(())
}
```

### Query events with GraphQL

<BetaTag beta="true" slim="true"/>

You can use GraphQL to query events instead of JSON RPC. The following example queries are in the [`sui-graphql-rpc` crate](https://github.com/MystenLabs/sui/tree/main/crates/sui-graphql-rpc/examples/event_connection) in the Sui repo. 

<details>

<summary>

Event connection

</summary>

<ImportContent source="crates/sui-graphql-rpc/examples/event_connection/event_connection.graphql" mode="code" />

</details>

<details>

<summary>

Filter events by sender

</summary>

<ImportContent source="crates/sui-graphql-rpc/examples/event_connection/filter_by_sender.graphql" mode="code" />

</details>

The [TypeScript SDK](https://sdk.mystenlabs.com/typedoc/modules/_mysten_sui.graphql.html) provides functionality to interact with the Sui GraphQL service.

## Monitoring events

Firing events is not very useful in a vacuum. You also need the ability to respond to those events. There are 2 methods from which to choose when you need to monitor on-chain events:
- Incorporate a [custom indexer](/guides/developer/advanced/custom-indexer.mdx) to take advantage of Sui's micro-data ingestion framework.
- Poll the Sui network on a schedule to query events.

Using a custom indexer provides a near-real time monitoring of events, so is most useful when your project requires immediate reaction to the firing of events. Polling the network is most useful when the events you're monitoring don't fire often or the need to act on those events are not immediate. The following section provides a polling example.

### Poll events {#poll-events}

To monitor events, you need a database to store checkpoint data. The [Trustless Swap](/guides/developer/app-examples/trustless-swap.mdx) example uses a Prisma database to store checkpoint data from the Sui network. The database is populated from polling the network to retrieve emitted events. 

<details>

<summary>

`event-indexer.ts` from Trustless Swap

</summary>

<ImportContent source="examples/trading/api/indexer/event-indexer.ts" mode="code" noComments />

</details>

Trustless Swap incorporates handlers to process each event type that triggers. For the `locked` event, the handler in `locked-handler.ts` fires and updates the Prisma database accordingly.

<details>

<summary>

`locked-handler.ts` from Trustless Swap

</summary>

<ImportContent source="examples/trading/api/indexer/locked-handler.ts" mode="code" />

</details>

## Related links

<RelatedLink to="/guides/developer/advanced/custom-indexer.mdx" />
<RelatedLink href="https://move-book.com/programmability/events.html" label="Events" desc="The Move Book shows how to emit events in Move." />
<RelatedLink to="/guides/developer/app-examples/trustless-swap.mdx" />
>>>> sui/docs/content/guides/developer/sui-101/working-with-ptbs.mdx
---
title: Working with Programmable Transaction Blocks
description: Programmable transaction blocks (PTBs) are used to perform multiple commands in a single transaction.
keywords: [ ptbs, programmable transaction blocks, typescript SDK, how to use typescript SDK, typescript, transaction blocks, transactions as arguments, passing transactions ]
---

Programmable transaction blocks (PTBs) are key elements of the Sui ecosystem. Understanding PTBs and using them correctly are key fundamentals to creating efficient and cost-effective smart contracts. See [Programmable Transaction Blocks](../../../concepts/transactions/prog-txn-blocks.mdx) to learn about the structure of PTBs on Sui.

The topics in this section focus on effectively utilizing PTBs in your smart contracts.

<Cards>
<Card title="Building Programmable Transaction Blocks" href="/guides/developer/sui-101/building-ptb">
</Card>
<Card title="Coin Management" href="/guides/developer/sui-101/coin-mgt">
</Card>
<Card title="Simulating References" href="/guides/developer/sui-101/simulating-refs">
</Card>
</Cards>

>>>> sui/docs/content/guides/developer/zklogin-onboarding.mdx
---
title: zkLogin Onboarding
draft: true
---

Content coming soon
>>>> sui/docs/content/guides/operator.mdx
---
title: Operator Guides
description: Guides for operators on the Sui network. Whether you are running a full node for your dApp or operating as a validator on the Sui network, these guides help you set up your environment and operate your network.
keywords: [ validator, operator, full node, fullnode, operator guides, being an operator, being a node operator, running nodes ]
pagination_prev: null
---

Operator guides demonstrate how to run Full nodes on Sui, whether as a validator or operator of a full node to support your dApp, as well as how to integrate SUI into an exchange. 

## Sui Full Node Operators

<Cards>
<Card title="Sui Full Node Configuration" href="/guides/operator/sui-full-node">
</Card>
</Cards>

## Sui Validators

<Cards>
<Card title="Validator Configuration & Deployment" href="/guides/operator/validator/validator-config">
</Card>
<Card title="Validator Committee" href="/guides/operator/validator/validator-committee">
</Card>
<Card title="Validator Rewards" href="/guides/operator/validator/validator-rewards">
</Card>
<Card title="Validator Management" href="/guides/operator/validator/validator-tasks">
</Card>
<Card title="Validator Tools" href="/guides/operator/validator/validator-config">
</Card>
</Cards>

## Sui Full Node Operators and Validators

<Cards>
<Card title="Data Management" href="/guides/operator/data-management">
</Card>
<Card title="Genesis" href="/guides/operator/genesis">
</Card>
<Card title="Monitoring" href="/guides/operator/monitoring">
</Card>
<Card title="Snapshots" href="/guides/operator/snapshots">
</Card>
<Card title="Archives" href="/guides/operator/archives">
</Card>
</Cards>

## Exchange Integration Guide

<Cards>
<Card title="Exchange Integration Guide" href="/guides/operator/exchange-integration">
</Card>
</Cards>

## Sui Bridge Node Validators

<Cards>
<Card title="Sui Bridge Validator Node Configuration" href="/guides/operator/bridge-node-configuration">
</Card>
</Cards>

>>>> sui/docs/content/guides/operator/alerts.mdx
---
title: Sui Validator Alert Reference
description: A collection of the Prometheus Alertmanager rules that trigger alerts and warnings on Validator and Full nodes.
---

When running a Sui Validator node or Full node, you may want to configure alerting based off some or all of the following metrics.

## Alert reference 

The following sections cover the alert settings, but their details are meant to be customized in the following ways:

- Replace `$network` with your actual network label (for example, `mainnet`, `testnet`, and so on).
- Thresholds assume about 10,000 stake units â€” adjust for your own validator set size.
- Labels like `host` and `container` are stripped to be agnostic on infrastructure.

## High-priority chain health alerts (validator-specific)

These alerts should receive the most immediate attention from you or your team.

### Safe mode during reconfiguration

| Key          | Value                                            |
| ------------ | ------------------------------------------------ |
| **Name**     | `Safe Mode during Reconfiguration`               |
| **Summary**  | Epoch failed to advance; chain entered safe mode |
| **Duration** | `5m`                                             |

```sh
is_safe_mode{network="$network"} > 0.5 or absent(is_safe_mode{network="$network"})
```

### Consensus proposals failure

| Key          | Value                                       |
| ------------ | ------------------------------------------- |
| **Name**     | `Consensus Proposals Failure`               |
| **Summary**  | Less than 80% of stake is proposing consensus blocks |
| **Duration** | `5m`                                        |

```sh
sum(
  sum by (host) (current_voting_right{network="$network"})
  and
  sum by (host) (rate(consensus_proposed_blocks{network="$network"}[5m])) > 0
) < 8000
```

### Checkpoint execution rate is low

| Key          | Value                                                 |
| ------------ | ----------------------------------------------------- |
| **Name**     | `Checkpoint Execution Rate Is Low`                    |
| **Summary**  | Less than 80% of stake is executing checkpoints quickly enough |
| **Duration** | `5m`                                                  |

```sh
sum(
  sum by (host) (current_voting_right{network="$network"})
  and
  sum by (host) (rate(last_executed_checkpoint{network="$network"}[5m])) > 2
) < 8000
```

### Certificate execution latencies are high

| Key          | Value                                                                    |
| ------------ | ------------------------------------------------------------------------ |
| **Name**     | `Certificate execution latencies are high`                               |
| **Summary**  | Less than 80% of stake is handling shared-object tx certs with low enough latency |
| **Duration** | `5m`                                                                     |

```sh
sum(
  sum by (host) (current_voting_right{network="$network"})
  and
  histogram_quantile(0.95, sum by (le, host) (
    rate(validator_service_handle_certificate_consensus_latency_bucket{network="$network"}[5m])
  )) < 3
) < 8000
```

### Randomness DKG failure

| Key          | Value                                             |
| ------------ | ------------------------------------------------- |
| **Name**     | `RandomnessDkgFailure`                            |
| **Summary**  | Random beacon DKG has failed on one or more hosts |
| **Duration** | `5m`                                              |

```sh
epoch_random_beacon_dkg_failed{network="$network"} > 0 or absent(is_safe_mode{network="$network"})
```

### Validators not upgraded

| Key          | Value                                     |
| ------------ | ----------------------------------------- |
| **Name**     | `Mysten validators are not upgraded`      |
| **Summary**  | Validators are behind on protocol version |
| **Duration** | `1h`                                      |

```sh
min(sui_configured_max_protocol_version{network="$network", host=~"Mysten-.*"})
  < quantile(0.34, sui_configured_max_protocol_version{network="$network"})
```

## âš ï¸ Non-urgent and warning alerts

All alerts are important, but the following alerts and warnings can be addressed within a normal node maintenance workflow.

### Consensus sequencing p99 latency high

| Key          | Value                                                        |
| ------------ | ------------------------------------------------------------ |
| **Name**     | `Consensus sequencing p99 latencies are high`                |
| **Summary**  | Less than 80% of stake is sequencing tx certs with acceptable latency |
| **Duration** | `1m`                                                         |

```sh
sum(
  sum by (host) (current_voting_right{network="$network"})
  and
  histogram_quantile(0.95, sum by (le, host) (
    rate(sequencing_certificate_latency_bucket{network="$network", position="0", tx_type=~"shared_certificate|owned_certificate|soft_bundle"}[2m])
  )) < 2
) < 5000
```

### System invariant violations

| Key          | Value                                     |
| ------------ | ----------------------------------------- |
| **Name**     | `System Invariant Violations`             |
| **Summary**  | A system invariant violation was reported |
| **Duration** | `1m`                                      |

```sh
max(system_invariant_violations{network="$network"}) > 0
```

>>>> sui/docs/content/guides/operator/archives.mdx
---
title: Sui Archives
description: The archive is a historical record of all transactions on Sui. Enable archiving on your Full nodes as a best practice.
keywords: [ archive, archive data, full node archive, node archive, fallback, archival fallback ] 
---

A Sui archive is a history of all transaction data on Sui. In some cases, peer nodes may not catch up with all transactions and effects through synchronization if they lag behind the current epoch by more than the latest few epochs. In such cases, instead of relying on synchronization, peer nodes can fallback to downloading the relevant information from an archive.

:::info
Starting with the 1.51 release, the default archive bucket for mainnet switches to a requester pays model. See below for a configuration example
:::

## Set up archival fallback {#set-up-archival-fallback}

To enable your node to fallback to an archive in case of lag, add this to your `fullnode.yaml` file:

<Tabs groupId="object-store">
<TabItem value="mainnet" label="Mainnet">

```yaml
state-archive-read-config:
  - ingestion-url: "https://s3.us-west-2.amazonaws.com/mysten-mainnet-checkpoints"
    # How many objects to read ahead when catching up
    concurrency: 5
    remote-store-options:
      - ["aws_access_key_id", <YOUR_AWS_ACCESS_KEY_ID|PATH_TO_AWS_ACCESS_KEY>]
      - ["aws_secret_access_key", <AWS_SECRET_ACCESS_KEY|PATH_TO_AWS_SECRET_ACCESS_KEY>]
```

</TabItem>
<TabItem value="testnet" label="Testnet">

```yaml
state-archive-read-config:
  - ingestion-url: "https://checkpoints.testnet.sui.io"
    # How many objects to read ahead when catching up
    concurrency: 5
```

</TabItem>
</Tabs>


>>>> sui/docs/content/guides/operator/bridge-node-configuration.mdx
---
title: Sui Bridge Validator Node Configuration
sidebar_label: Sui Bridge Node Configuration
description: Correct configuration of your node ensures optimal performance and valid metrics data.
keywords: [ bridge validator node, bridge node, bridge, bridge committee, metric data, metrics, metadata, committee registration, waf, web application firewall, bridge client, bridgeclient, bridge node monitoring, build bridge node, run bridge node ]
---

Running a bridge validator node (bridge node) requires registering your node with the bridge committee. Correct configuration of your node ensures optimal performance and valid metrics data. Follow this topic to make sure your bridge node is set up properly.

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] Install `sui` and `sui-bridge-cli`.

<details className="nudge-details">

<summary>

Installation instructions 

</summary>

To set up and run a bridge node, you need to  You can install them using one of the following options: 

Install from tip of `main`:

```sh
$ cargo install --locked --git "https://github.com/MystenLabs/sui.git" sui sui-bridge-cli
```

Install with a commit sha:

```sh
$ cargo install --locked --git "https://github.com/MystenLabs/sui.git" --rev {SHA} sui sui-bridge-cli
```

</details>
</TabItem>
</Tabs>


## Committee registration

To join the network you must first register with the bridge validator committee.

### Prepare for metadata

The required metadata includes two things:

- `BridgeAuthorityKey`, an ECDSA key to sign messages. Because this is a hot key that is kept in memory, itâ€™s fine to use the following tool to generate one and write it to file.
- A REST API URL where the bridge node listens to and serves requests. Example: `https://bridge.example-sui-validator.io:443`. Make sure the port is correct and the URL does not contain any invalid characters, like quotes for example.

To create a `BridgeAuthorityKey`, run
```sh
$ sui-bridge-cli create-bridge-validator-key <PATH-TO-WRITE>
```
where `<PATH-TO-WRITE>` is the location to write the key pair to.

:::info

It's highly recommended you create a new key pair in a secure environment (for example, in the same machine where your node runs) to avoid key compromise.

:::

### Registration

After you have both authority key file and REST API URL ready, you can register them by using Sui CLI:

```sh
$ sui validator register-bridge-committee --bridge-authority-key-path <BRIDGE-AUTHORITY-KEY-PATH> --bridge-authority-url <BRIDGE-AUTHORITY-URL>
```

#### Offline signing {#offline-signing}

If you keep your validator account key in cold storage or you want to perform offline signing, use flags `--print-only` and `--validator-address` (with the value for the validator address). This prints serialized unsigned transaction bytes, then you can use your preferred signing process to produce signed bytes. 

Run the following command to execute it:

```sh
$ sui client execute-signed-tx
```

#### Update metadata (before committee is finalized)

Both key and URL are changeable **before the committee is finalized**. If you wish to update metadata, simply rerun `sui validator register-bridge-committee`.

#### View registered metadata

To double check you registered the correct metadata on chain, run

```sh
$ sui-bridge-cli view-bridge-registration --sui-rpc-url {SUI-FULLNODE-URL}
```

## Update metadata (after committee is finalized)

Use the following command to update bridge node URL:
```sh
$ sui validator update-bridge-committee-node-url
```
Refer to [offline signing section](#offline-signing) in this page for how to sign the transaction offline.

Authority key rotation is not supported yet.


## Bridge node

You have several options when configuring your bridge node for performance and metrics monitoring. Follow the instructions that follow to configure your node for best results in your environment.  

### Bridge node hardware requirements

Suggested hardware requirements:

- CPU: 6 physical cores
- Memory: 16GB
- Storage: 200GB
- Network: 100Mbps

### Web application firewall (WAF) protection for bridge node

To protect against distributed denial of service (DDoS) attacks and similar attacks intended to expend validator resources, you must provide rate limit protection for the bridge server. 

In addition to protection, this gives node operators fine-grained control over the rate of requests they receive, and observability into those requests.

The currently recommended rate limit is `50 requests/second per unique IP`.

#### Web application firewall (WAF) options

You can use a managed cloud service, for example:

- [Cloudflare WAF](https://www.cloudflare.com/en-ca/application-services/products/waf/)
- [AWS WAF](https://aws.amazon.com/waf/)
- [GCP Cloud Armor](https://cloud.google.com/security/products/armor)

It's also possible to use an open source load balancer, such as [HAProxy](https://www.haproxy.org/) for a practical, IP-based rate limit.

A shortened example HAProxy configuration looks like the following:

```
frontend http-in
    bind *:80
    # Define an ACL to count requests per IP and block if over limit
    acl too_many_requests src_http_req_rate() gt 50
    # Track the request rate per IP
    stick-table type ip size 1m expire 1m store http_req_rate(1s)
    # Check request rate and deny if the limit is exceeded
    http-request track-sc0 src
    http-request deny if too_many_requests

    default_backend bridgevalidator

backend bridgevalidator
    # Note the port needs to match the value in bridge node config, default is 9191
    server bridgevalidator 0.0.0.0:9191
```

If choosing to use an open source load balancing option, make sure to set up metrics collection and alerting on the service.

### Bridge node config

Use `sui-bridge-cli` command to create a template. If you want to run `BridgeClient` (see the following section), pass `--run-client` as a parameter.

```sh
$ sui-bridge-cli create-bridge-node-config-template {PATH}
$ sui-bridge-cli create-bridge-node-config-template --run-client {PATH}
```

The generated configuration includes the following parameters:

| Parameter | Description |
| --- | --- |
| `server-listen-port` | The port that bridge node listens to for handling requests. |
| `metrics-port` | Port to export Prometheus metrics. |
| `bridge-authority-key-path` | The path to the Bridge Validator key, generated from `sui-bridge-cli create-bridge-validator-key` command referenced previously. |
| `run-client` | Whether Bridge Client should be enabled in bridge node (more instructions follow). |
| `approved-governance-actions` | A list of governance actions that you want to support. |
| `sui:sui-rpc-url` | Sui RPC URL. |
| `sui:sui-bridge-chain-id` | `0` for Sui Mainnet, `1` for Sui Testnet. |
| `eth:eth-rpc-url` | Ethereum RPC URL. |
| `eth:eth-bridge-proxy-address` | The proxy address for Bridge Solidity contracts on Ethereum. |
| `eth:eth-bridge-chain-id` | `10` for Ethereum Mainnet, `11` for Sepolia Testnet. |
| `eth:eth-contracts-start-block-fallback` | The starting block BridgeNodes queries for from Ethereum FullNode. This number should be the block where Solidity contracts are deployed or slightly before. |
| `metrics:push-url` | The url of the remote Sui metrics pipeline (for example, `https://metrics-proxy.[testnet_OR_mainnet].sui.io:8443/publish/metrics`). See the [metrics push section](#metrics-push) that follows for more details. | 

With `run-client: true`, you can find these additional fields in the generated config:

| Parameter | Description |
| --- | --- |
| `db-path` | Path of BridgeClient database, for BridgeClient. |
| `sui:bridge-client-key-path` | The file path of Bridge Client key. This key can be generated with `sui-bridge-cli create-bridge-client-key` as previously shown. When `run-client` is true but you do not provide `sui:bridge-client-key-path`, it defaults to use the Bridge Validator key to submit transactions on Sui. This is not recommended for the sake of key separation. | 

### BridgeClient

`BridgeClient` orchestrates bridge transfer requests. It is **optional** to run for a `BridgeNode`. `BridgeClient` submits transaction on the Sui network. Thus when it's enabled, you need a Sui account key with enough SUI balance.

To enable `bridge_client` feature on a `BridgeNode`, set the following parameters in `BridgeNodeConfig`:

```yaml
run-client: true
db-path: <PATH-TO-DB>
sui:
    bridge-client-key-path: <PATH-TO-BRIDGE-CLIENT-KEY>
```

To create a `BridgeClient` key pair, run

```sh
$ sui-bridge-cli create-bridge-client-key <PATH_TO_BRIDGE_CLIENT_KEY>
```
This prints the newly created Sui Address. Then we need to fund this address with some SUI for operations.


### Build bridge node

Build or install bridge node in one of the following ways:

- Use `cargo install`.
    ```sh
    $ cargo install --locked --git "https://github.com/MystenLabs/sui.git" --branch {BRANCH-NAME} sui-bridge
    ```
    Or
    ```sh
    $ cargo install --locked --git "https://github.com/MystenLabs/sui.git" --rev {SHA-NAME} sui-bridge
    ```
- Compile from source code
    ```sh
    $ git clone https://github.com/MystenLabs/sui.git
    ```
    ```sh
    $ cd sui
    ```
    ```sh
    $ git fetch origin {BRANCH-NAME|SHA}
    ```
    ```sh
    $ git checkout {BRANCH-NAME|SHA}
    ```
    ```sh
    $ cargo build --release --bin sui-bridge
    ```
- Use `curl`/`wget` pre-built binaries (for Linux/AMD64 only).
    ```sh
    $ curl https://sui-releases.s3.us-east-1.amazonaws.com/{SHA}/sui-bridge -o sui-bridge
    ```
- Use pre-built Docker image. Pull from Docker Hub: `mysten/sui-tools:{SHA}`


### Run bridge node

Running bridge node is similar to running a Sui node using systemd or Ansible. The command to start the bridge node is:

```sh
$ RUST_LOG=info,sui_bridge=debug sui-bridge --config-path {BRIDGE-NODE-CONFIG-PATH}
```

### Ingress

Bridge node listens for TCP connections over port `9191` (or the preferred port in the configuration file). You must allow incoming connections for that port on the host that is running bridge node.

Test ingress with `curl` on a remote machine and expect a `200` response:

```sh
$ curl -v {YOUR_BRIDGE_URL}
```

### Bridge node monitoring

Use `uptime` to check if the node is running.

You can find a full list of bridge node metrics and their descriptions in the [`sui-bridge` crate](https://github.com/MystenLabs/sui/blob/main/crates/sui-bridge/src/metrics.rs).

#### When `run-client: false`

In this case bridge node runs as a passive observer and does not proactively poll on-chain activities. Important metrics to monitor in this case are the request handling metrics, such as:

- `bridge_requests_received`
- `bridge_requests_ok`
- `bridge_err_requests`
- `bridge_requests_inflight`
- `bridge_eth_rpc_queries`
- `bridge_eth_rpc_queries_latency`
- `bridge_signer_with_cache_hit`
- `bridge_signer_with_cache_miss`
- `bridge_sui_rpc_errors`

#### When `run-client: true`

In this case, Bridge Client is toggled on and syncs with blockchains proactively. The best metrics to track progress are:

- `bridge_last_synced_sui_checkpoints`
- `bridge_last_synced_eth_blocks`
- `bridge_last_finalized_eth_block`
- `bridge_sui_watcher_received_events`
- `bridge_eth_watcher_received_events`
- `bridge_sui_watcher_received_actions`
- `bridge_eth_watcher_received_actions`

`bridge_gas_coin_balance` is also a critical metric to track the balance of your client gas coin, and top up after it dips below a certain threshold.

### Metrics push {#metrics-push}

The Bridge Nodes can push metrics to the remote proxy for network-level observability.

To enable metrics push, set the following parameters in `BridgeNodeConfig`:

```yaml
metrics:
    push-url: https://metrics-proxy.[testnet|mainnet].sui.io:8443/publish/metrics
```

The proxy authenticates pushed metrics by using the metrics key pair. It is similar to `sui-node` pushing metrics with `NetworkKey`. Unlike `NetworkKey`, the bridge node metrics key is not recorded on chain and can be ephemeral. The metrics key is loaded from the `metrics-key-pair` field in `BridgeNodeConfig` if provided, otherwise a new key pair is generated on the fly. The proxy queries node public keys periodically by hitting the metrics public API key of each node.

When bridge node starts, it might log this line once:

```
unable to push metrics: error sending request for url (xyz); new client will be created
```

This is okay to ignore as long as it does not persist. Otherwise, try:

```sh
$ curl -i  {your-bridge-node-url-on-chain}/metrics_pub_key
```

and make sure the public key is correctly returned.

>>>> sui/docs/content/guides/operator/data-management.mdx
---
title: Data Management
description: A high-level description of data management on the Sui network that you can use to optimize your Sui full node configuration. 
keywords: [ data management, run data management, what is data management, full node data, full node data management, rpc, pruning, data pruning, pruning policies, object pruning, object history ]
---

Managing the data on your Sui full node is critical to ensuring a healthy Sui network. This topic provides a high-level description of data management on Sui Full nodes that you can use to optimize your full node configuration. For more information about Sui full nodes, such as pruning policies and archival settings, see [Run a Sui Full Node](./sui-full-node.mdx).

## Basic Sui full node functionality

The minimal version of a Sui full node executes all of the transactions Sui validators commit. Sui full nodes also orchestrate the submitting of new transactions to the system:

![Basic Sui full node functionality](./images/fn-basic-functionality.png "A diagram that shows the operations of a basic Sui full node.")

The preceding image shows how data flows through a full node:

1. **`State sync` protocol:** A Sui full node performs the following to achieve state synchronization:
   - Retrieves the information about the committed checkpoints via the p2p gossip-like protocol.
   - Executes the transactions locally to verify that effects match the effects certified by the quorum of the validators.
   - Updates the local state with the latest object values accordingly.
2. **RPCs:** A Sui full node exposes Sui RPC endpoints for querying the latest state of the system, including both the latest state metadata (such as, `sui_getProtocolConfig`), and the latest state object data (`sui_getObject)`.
3. **Transaction submission:** Each Sui full node orchestrates transaction submission to the quorum of the Sui validators, and, optionally if configured, locally executes the finalized transactions (called fast path execution), which circumvents the wait for checkpoint synchronization.

## Sui full node data and RPC types

A Sui full node stores multiple categories of data in its permanent store.

:::info

The per-epoch Sui store is beyond the scope of this topic. Sui uses the per-epoch store (resets at the start of each epoch) internally for authority and consensus operations.

:::

Sui full nodes store the following types of data:

1. **Transactions with associated effects and events:** Sui uses a unique transaction digest to retrieve information about a transaction, including its effects and emitted events. Sui full nodes don't require the historic transaction information for basic full node operations. To conserve drive space, you can enable pruning to remove this historical data.
2. **Checkpoints:** Sui groups committed transactions in checkpoints, and then uses those checkpoints to achieve state synchronization. Checkpoints keep transaction digests that contain additional integrity metadata.
Sui Full nodes don't require data from checkpoints to  execute and submit transactions, so you can configure pruning for this data as well.
3. **Objects:** Transactions that mutate objects create new object versions. Each object has a unique pair of `(objectId, version)` used to identify the object. Sui full nodes don't require historic object versions to  execute and submit transactions, so you can configure your full node to also prune this data. 
4. **Indexing information:** A full node default configuration is to post-process the committed transactions: it indexes the committed information to enable efficient aggregation and filtering queries. For example, the indexing can be useful for retrieving all the historic transactions of a given sender, or finding all the objects owned by an address. 

Sui full nodes support more than 40 RPC types that includes the following categories:

* **General metadata**, such as `sui_getProtocolConfig` and `sui_getChainIdentier`. These requests don't depend on additional indexing and don't require historic data to process.
* **Direct lookups**, such as `sui_getObject`, `sui_getEvents`. These requests don't depend on additional indexing, but require historic data in some cases, such as `sui_tryGetPastObject` and `sui_getTransactionBlock`.
* **Accumulation and filtering queries**,such as `suix_getOwnedObjects` and `suix_getCoins`. These requests depend on additional indexing, and require historic data in some cases, such as `suix_queryTransactionBlocks`.

:::info

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::

## Sui archival data

A Sui archive instance stores the full Sui transaction history since genesis in a database agnostic format. This includes information about transactions (with client authentication), effects, events, and checkpoints. As such, archival storage can be used for data auditing and for replaying historic transactions.

A full node that starts from scratch can replay (and thus re-verify) transactions that occurred since Sui genesis from the given archive via [configuring archival fallback](./archives.mdx#set-up-archival-fallback) in the `fullnode.yaml` configuration file to point to the cloud bucket that stores the archive.

A Sui full node that fails to retrieve checkpoints from its peers via state sync protocol falls back to downloading the missing checkpoints from its pre-configured archive. This fallback enables a full node to catch up with the rest of the system regardless of the pruning policies of its peers.

## Sui node pruning policies

As described previously, sustainable disk usage requires Sui nodes (validators and full nodes) to prune the information about historic object versions as well as historic transactions with the corresponding effects and events, including old checkpoint data.

Both transaction and object pruners run in the background. The logical deletion of entries from RocksDB ultimately triggers the physical compaction of data on disk, which is governed by RocksDB background jobs: the pruning effect on disk usage is not immediate and might take multiple days.

To learn more about object pruning policies, see [Object pruning](#object-pruning). You can configure the pruner in two modes:
* **aggressive pruning** (`num-epochs-to-retain: 0`): Sui prunes old object versions as soon as possible. This mode should only be used when the node does not serve read queries.
* **epoch-based pruning** (`num-epochs-to-retain: X`): Sui prunes old object versions after X epochs.

:::tip 
Keeping some history (5 epochs) provides better RPC performance on full nodes as it allows more lookups to happen from local disk rather than from remote storage.
:::

To learn more about transaction pruning policies, see [Transaction pruning](#transaction-pruning). To configure transaction pruning, specify the `num-epochs-to-retain-for-checkpoints: X` config option. The checkpoints, including their transactions, effects and events are pruned up to X epochs ago. We suggest setting transaction pruning to 2 epochs.

## Object pruning {#object-pruning}

Sui adds new object versions to the database as part of transaction execution. This makes previous versions ready for 
garbage collection. However, without pruning, this can result in database performance degradation and requires large 
amounts of storage space. Sui identifies the objects that are eligible for pruning in each checkpoint, and then performs
the pruning in the background.

You can enable pruning for a Sui node by adding the `authority-store-pruning-config` config to `fullnode.yaml` file:
```yaml
authority-store-pruning-config:
  # Number of epoch dbs to keep 
  # Not relevant for object pruning
  num-latest-epoch-dbs-to-retain: 3
  # The amount of time, in seconds, between running the object pruning task.
  # Not relevant for object pruning
  epoch-db-pruning-period-secs: 3600
  # Number of epochs to wait before performing object pruning.
  # When set to 0, Sui prunes old object versions as soon
  # as possible. This is also called *aggressive pruning*, and results in the most effective
  # garbage collection method with the lowest disk usage possible. 
  # This is the recommended setting for Sui Validator nodes since older object versions aren't
  # necessary to execute transactions.
  # When set to 1, Sui prunes only object versions from transaction checkpoints
  # previous to the current epoch. In general, when set to N (where N >= 1), Sui prunes  
  # only object versions from checkpoints up to `current - N` epoch. 
  # It is therefore possible to have multiple versions of an object present 
  # in the database. This setting is recommended for Sui Full nodes as they might need to serve 
  # RPC requests that require looking up objects by ID and Version (rather than just latest
  # version). However, if your full node does not serve RPC requests you should then also enable.
  # aggressive pruning.
  num-epochs-to-retain: 1
  # Advanced setting: Maximum number of checkpoints to prune in a batch. The default
  # settings are appropriate for most use cases.
  max-checkpoints-in-batch: 10
  # Advanced setting: Maximum number of transactions in one batch of pruning run. The default
  # settings are appropriate for most use cases.
  max-transactions-in-batch: 1000
```
## Transaction pruning {#transaction-pruning}

Transaction pruning removes previous transactions and effects from the database.
Sui periodically creates checkpoints. Each checkpoint contains the transactions that occurred during the checkpoint and their associated effects.

Sui performs transaction pruning in the background after checkpoints complete.

You can enable transaction pruning for your full node or validator node by adding  `num-epochs-to-retain-for-checkpoints`
to the `authority-store-pruning-config` config for the node:

```yaml
authority-store-pruning-config:
  num-latest-epoch-dbs-to-retain: 3
  epoch-db-pruning-period-secs: 3600
  num-epochs-to-retain: 0
  max-checkpoints-in-batch: 10
  max-transactions-in-batch: 1000
  # Number of epochs to wait before performing transaction pruning.
  # When this is N (where N >= 2), Sui prunes transactions and effects from 
  # checkpoints up to the `current - N` epoch. Sui never prunes transactions and effects from the current and
  # immediately prior epoch. N = 2 is a recommended setting for Sui Validator nodes and Sui Full nodes that don't 
  # serve RPC requests.
  num-epochs-to-retain-for-checkpoints: 2
  # Ensures that individual database files periodically go through the compaction process.
  # This helps reclaim disk space and avoid fragmentation issues
  periodic-compaction-threshold-days: 1
```

:::info

If you prune transactions, archival nodes can help ensure lagging peer nodes don't lose any information. For more information, see [Sui Archives](./archives.mdx).

:::


## Pruning policy examples

Use the examples in this section to configure your Sui full node. You can copy the examples, and then, optionally, modify the values as appropriate for your environment. 

### Validator and State Sync full node

This configuration keeps disk usage to a minimum. It is suitable for validators and state sync full nodes that do not serve read traffic. Full nodes with this configuration cannot answer queries that require indexing or historic data.

```yaml
# Do not generate or maintain indexing of Sui data on the node
enable-index-processing: false

authority-store-pruning-config:
  # Prune obsolete object versions immediately.
  num-epochs-to-retain: 0
  # Prune historic transactions of the past epochs
  num-epochs-to-retain-for-checkpoints: 2
```

### Full node with indexing but limited object history

This setup manages secondary indexing in addition to the latest state, but prunes historical data after a few epochs. A full node with this configuration:

- Answers RPC queries that require indexing, like `suix_getBalance()`.
- Answers RPC queries that require historic transactions via a fallback to retrieve the data from a remote key-value store: `sui_getTransactionBlock()`.

```yaml
authority-store-pruning-config:
  # Retain 5 epochs of object versions for better RPC performance
  num-epochs-to-retain: 5
  # Prune historic transactions of the past epochs
  num-epochs-to-retain-for-checkpoints: 2
```

### Full node with full object history but pruned transaction history

This configuration manages the full object history while still pruning historic transactions. A full node with this configuration can answer all historic and indexing queries (using the transaction query fallback for transactional data), including the ones that require historic objects such as the `showBalanceChanges` filter of `sui_getTransactionBlock()`.

The main caveat is that the current setup enables **transaction pruner** to go ahead of **object pruner**. The object pruner might not be able to properly clean up the objects modified by the transactions that have been already pruned. You should closely monitor the disk space growth on a full node with this configuration.

In addition to the regular (pruned) snapshots, Mysten Labs also maintains special RocksDB snapshots with full history of object versions available for the operators using this configuration.

```yaml
authority-store-pruning-config:
  # No pruning of object versions with u64::max for num of epochs.
  # Set a lower value for a smaller objects history.
  num-epochs-to-retain: 18446744073709551615
  # Prune historic transactions of the past epochs
  num-epochs-to-retain-for-checkpoints: 2
```

>>>> sui/docs/content/guides/operator/exchange-integration.mdx
---
title: Sui Exchange Integration Guide
description: Learn the primary tasks necessary to integrate SUI, the token native to the Sui network, into a cryptocurrency exchange.
keywords: [ integrate sui, integrate with SUI token, sui tokens, SUI, integrate sui into exchange, cryptocurrency exchange, decentralized exchange, dex, integrate with dex, sui balance transfer, staking functions, track balance, checkpoints, staking functions ]
---

This topic describes how to integrate SUI, the token native to the Sui network, into a cryptocurrency exchange. The specific requirements and processes to implement an integration vary between exchanges. Rather than provide a step-by-step guide, this topic provides information about the primary tasks necessary to complete an integration. After the guidance about how to configure an integration, you can also find information and code samples related to staking on the Sui network.

## Requirements to configure a SUI integration

The requirements to configure a SUI integration include:
 - A Sui full node. You can operate your own Sui full node or use a full node from a node operator.
 - Suggested hardware requirements to run a Sui full node:
    - CPU: 8 physical cores / 16 vCPUs
    - RAM: 128 GB
    - Storage (SSD): 4 TB NVMe drive

For best results, run Sui full nodes on Linux. Sui supports the Ubuntu and Debian distributions. You can also run a full node on macOS.

## Configure a Sui full node

You can set up and configure a [Sui full node](./sui-full-node.mdx) using Docker or directly from source code in the Sui GitHub repository.

## Set up Sui addresses

Sui addresses do not require on-chain initialization, you can spend from an address if it corresponds to your private key. You can derive a 32-byte Sui address by hashing the signature scheme flag byte concatenated with public key bytes `flag || pubkey` using the [BLAKE2b](https://www.blake2.net/) (256 bits output) hashing function.

Currently, Sui address supports these signature schemes: pure Ed25519, Secp256k1, Secp256r1 and multisig. The corresponding flag bytes are 0x00, 0x01, 0x02, 0x03 respectively.

The following code sample demonstrates how to derive a Sui address in Rust:

```rust
let flag = 0x00; // 0x00 = ED25519, 0x01 = Secp256k1, 0x02 = Secp256r1, 0x03 = multiSig
// Hash the [flag, public key] bytearray using Blake2b
let mut hasher = DefaultHash::default();
hasher.update([flag]);
hasher.update(pk);
let arr = hasher.finalize();
let sui_address_string = hex::encode(arr);
```

## Displaying addresses

Sui supports both addresses with and without a `0x` prefix. Sui recommends that you always include the `0x` prefix in API calls and when you display user addresses.

## Track balance changes for an address

You can track balance changes by calling `sui_getBalance` at predefined intervals. This call returns the total balance for an address. The total includes any coin or token type, but this document focuses on SUI. You can track changes in the total balance for an address between subsequent `sui_getBalance` requests.

The following bash example demonstrates how to use `sui_getBalance` for address `0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3`. If you use a network other than Devnet, replace the value for `rpc` with the URL to the appropriate full node.

```sh
rpc="https://fullnode.devnet.sui.io:443"
address="0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3"
data="{\"jsonrpc\": \"2.0\", \"method\": \"sui_getBalance\", \"id\": 1, \"params\": [\"$address\"]}"
curl -X POST -H 'Content-type: application/json' --data-raw "$data" $rpc
```

The response is a JSON object that includes the `totalBalance` for the address:
```json
{
  "jsonrpc":"2.0",
  "result":{
     "coinType":"0x2::sui::SUI",
     "coinObjectCount":40,
     "totalBalance":10000000000,
     "lockedBalance":{

     }
  },
  "id":1
}
```

The following example demonstrates using `sui_getBalance` in Rust:
```rust
use std::str::FromStr;
use sui_sdk::types::base_types::SuiAddress;
use sui_sdk::{SuiClient, SuiClientBuilder};


#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
   let sui = SuiClientBuilder::default().build(
      "https://fullnode.devnet.sui.io:443",
   ).await.unwrap();
   let address = SuiAddress::from_str("0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3")?;
   let objects = sui.read_api().get_balance(address).await?;
   println!("{:?}", objects);
   Ok(())
}
```

## Use events to track balance changes for an address

You can also track the balance for an address by subscribing to all of the events emitted from it. Use a filter to include only the events related to SUI coins, such as when the address acquires a coin or pays for a gas fee.
The following example demonstrates how to filter events for an address using bash and cURL:

```sh
rpc="https://fullnode.devnet.sui.io:443"
address="0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3"
data="{\"jsonrpc\": \"2.0\", \"id\":1, \"method\": \"sui_getEvents\", \"params\": [{\"Recipient\": {\"AddressOwner\": \"0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3\"}}, null, null, true ]}"
curl -X POST -H 'Content-type: application/json' --data-raw "$data" $rpc
```

The response can include a large number of events. Add pagination to the response using the `nextCursor` key in the request. You can determine the corresponding `txDigest` and `eventSeq` from the `id` field of a transaction.

You can replace the first `null` in the `params` array with a `txDigest` value to paginate from a specific point. The second `null` is an integer that defines how many results (up to 1000) to return and the `true` means ascending order. You can use the `nextCursor` so the response starts from a desired point.

The `id` field of any transaction looks like:

```sh
"id": {
    "txDigest": "GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2",
    "eventSeq": 6019
}
```

With this data, create a `nextCursor` as follows:

```sh
nextCursor : {"txDigest": "GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2","eventSeq": 6019}
```

## Blocks vs checkpoints

Sui is a DAG-based blockchain and uses checkpoints for node synchronization and global transaction ordering. Checkpoints differ from blocks in the following ways:
 - Sui creates checkpoints and adds finalized transactions. Note that transactions are finalized even before they are included in a checkpoint
 - Checkpoints do not fork, roll back, or reorganize.
 - Sui creates about four checkpoints every second. Find the most up-to-date statistic on the [Sui public dashboard](https://metrics.sui.io/public-dashboards/4ceb11cc210d4025b122294586961169).

### Checkpoint API operations

Sui Checkpoint API operations include:
 - [`sui_getCheckpoint`](/sui-api-ref#sui_getCheckpoint): Retrieves the specified checkpoint.
 - [`sui_getLatestCheckpointSequenceNumber`](/sui-api-ref#sui_getLatestCheckpointSequenceNumber): Retrieves the sequence number of the most recently executed checkpoint.
 - [`sui_getCheckpoints`](/sui-api-ref#sui_getCheckpoints): Retrieves a paginated list of checkpoints that occurred during the specified interval. Pending a future release.

## SUI balance transfer

To transfer a specific amount of SUI between addresses, you need a SUI token object with that specific value. In Sui, everything is an object, including SUI tokens. The amount of SUI in each SUI token object varies. For example, an address could own 3 SUI tokens with different values: one of 0.1 SUI, a second of 1.0 SUI, and a third with 0.005 SUI. The total balance for the address equals the sum of the values of the individual SUI token objects, in this case, 1.105 SUI.

You can merge and split SUI token objects to create token objects with specific values. To create a SUI token worth .6 SUI, split the token worth 1 SUI into two token objects worth .6 SUI and .4 SUI.

To transfer a specific amount of SUI, you need a SUI token worth that specific amount. To get a SUI token with that specific value, you might need to split or merge existing SUI tokens. Sui supports several methods to accomplish this, including some that do not require you to manually split or merge coins.

## Sui API operations for transfers

Sui supports the following API operations related to transferring SUI between addresses:

 - [`sui_transferObject`](/sui-api-ref#sui_transferObject): Because SUI tokens are objects, you can transfer SUI tokens just like any other object. This method requires a gas token, and is useful in niche cases only.

 - [`sui_payAllSui`](/sui-api-ref#sui_payAllSui): This method accepts an array of SUI token IDs. It merges all existing tokens into one, deducts the gas fee, then sends the merged token to the recipient address.

   The method is especially useful if you want to transfer all SUI from an address. To merge together all coins for an address, set the recipient as the same address. This is a native Sui method and does not produce additional on-chain transaction objects for the internal merge operation.

 - [`sui_paySui`](/sui-api-ref#sui_paySui): This operation accepts an array of SUI token IDs, an array of amounts, and an array of recipient addresses.

   The amounts and recipients array map one to one. Even if you use only one recipient address, you must include it for each amount in the amount array.

   The operation merges all of the tokens provided into one token object and settles the gas fees. It then splits the token according to the amounts in the amounts array and sends the first token to the first recipient, the second token to the second recipient, and so on. Any remaining SUI on the token stays in the source address.

   The benefits of this method include: no gas fees for merging or splitting tokens, and the abstracted token merge and split. The `sui_paySui` operation is a native function, so the merge and split operations are not considered Sui transactions. The gas fees for them match typical transactions on Sui.You can use this operation to split coins in your own address by setting the recipient as your own address. Note that the total value of the input coins must be greater than the total value of the amounts to send.

 - [`sui_pay`](/sui-api-ref#sui_pay): This method is similar to sui_paySui, but it accepts any kind of coin or token instead of only SUI. You must include a gas token, and all of the coins or tokens must be the same type.

 - [`sui_transferSui`](/sui-api-ref#sui_transferSui): This method accepts only one SUI token object and an amount to send to the recipient. It uses the same token for gas fees, so the amount to transfer must be strictly less than the value of the SUI token used.

## Signing transactions

Refer to [Sui Signatures](/concepts/cryptography/transaction-auth/signatures.mdx) for more details on signature validity requirements.

## SUI staking

The Sui blockchain uses a Delegated Proof-of-Stake mechanism (DPoS). This allows SUI token holders to stake their SUI tokens to any validator of their choice. When someone stakes their SUI tokens, it means those tokens are locked for the entire epoch. Users can withdraw their stake at any time, but new staking requests become active only at the start of the next epoch.

SUI holders who stake their tokens to validators earn rewards for helping secure the Sui network. Sui determines rewards for staking based on stake rewards on the network, and distributes them at the end of each epoch.

The total voting power in the Sui Network is always 10,000. The voting power of each individual validator is similar to basis points. For example, a voting power of 101 = 1.01%. Sui's quorum threshold (number of votes needed to confirm a transaction) is 6,667 (which is greater than 2/3). The voting power for a single validator is capped at 1,000 (10%) regardless of how much stake the validator has.

## Staking functions

Sui supports the following API operations related to staking. You can find the source code in the [sui_system](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-system/sources/sui_system.move) module.

 - `request_add_stake`: Add user stake to a validator's staking pool.

   ```move
   public fun request_add_stake(
      self: &mut SuiSystemState,
      stake: Coin<SUI>,
      validator_address: address,
      ctx: &mut TxContext,
   ) {
      validator_set::request_add_stake(
         &mut self.validators,
         validator_address,
         coin::into_balance(stake),
         option::none(),
         ctx,
      );
   }
   ```

 - `request_add_stake_mul_coin`: Add user stake to a validator's staking pool using multiple coins.

   ```move
   public fun request_add_stake_mul_coin(
      self: &mut SuiSystemState,
      delegate_stakes: vector<Coin<SUI>>,
      stake_amount: option::Option<u64>,
      validator_address: address,
      ctx: &mut TxContext,
   ) {
      let balance = extract_coin_balance(delegate_stakes, stake_amount, ctx);
      validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::none(), ctx);
   }
   ```

 - `request_add_stake_with_locked_coin`: Add user stake to a validator's staking pool using a locked SUI coin.

   ```move
   public fun request_add_stake_with_locked_coin(
      self: &mut SuiSystemState,
      stake: LockedCoin<SUI>,
      validator_address: address,
      ctx: &mut TxContext,
   ) {
      let (balance, lock) = locked_coin::into_balance(stake);
      validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::some(lock), ctx);
   }
   ```

 - `request_withdraw_stake`: Withdraw some portion of a user stake from a validator's staking pool.

   ```move
   public fun request_withdraw_stake(
      self: &mut SuiSystemState,
      delegation: &mut Delegation,
      staked_sui: &mut StakedSui,
      principal_withdraw_amount: u64,
      ctx: &mut TxContext,
   ) {
      validator_set::request_withdraw_stake(
         &mut self.validators,
         delegation,
         staked_sui,
         principal_withdraw_amount,
         ctx,
      );
   }
   ```
>>>> sui/docs/content/guides/operator/genesis.mdx
---
title: Genesis
description: Genesis refers to the state of the Sui blockchain when it was initially launched.
keywords: [ sui genesis, blockchain genesis, initial blockchain state, initial state, genesis checkpoint, genesis.blob ]
---

Genesis is the initial state of the Sui blockchain. To launch a network, the initial committee of validators collaborate by providing their validator information (public keys, network addresses, and so on) to a shared workspace. After all of the initial validators have contributed their information, Sui generates the initial, unsigned genesis checkpoint (checkpoint with sequence number 0) and each validator provides their signature. Sui aggregates these signatures to form a certificate on the genesis checkpoint. Sui bundles this checkpoint, as well as the initial objects, together into a single genesis.blob file that is used to initialize the state when running the `sui-node` binary for both validators and Full nodes.

## Genesis blob locations

The `genesis.blob` files for each network are in the [sui-genesis](https://github.com/mystenlabs/sui-genesis) repository.

See [Sui Full Node](./sui-full-node.mdx#set-up-from-source) for how to get the genesis.blob file for each network.

>>>> sui/docs/content/guides/operator/indexer-stack-setup.mdx
---
title: GraphQL and General-Purpose Indexer
description: Setup instructions for running the indexer, consistent store, and GraphQL in production.
keywords: [indexer, consistent store, graphql, setup, dex]
---

<ImportContent source="indexer-graphql.mdx" mode="snippet" />

See [GraphQL and General-Purpose Indexer](/concepts/graphql-indexer.mdx) for more information on the stack.

## Indexer setup

The indexer consists of multiple pipelines that each read, transform, and write checkpoint data to a table. Multiple instances of the indexer can run in parallel, each configured by its own TOML file.

#### Hardware requirements

- **CPU:** 8 cores
- **Memory:** 16GB

### Run command

Run an indexer instance using this command for each of the configuration files that follow:

```sh
$ sui-indexer-alt indexer \
    --config <CONFIG_FILE> \
    --database-url <DATABASE_URL> \
    --remote-store-url <REMOTE_STORE_URL>
```

| CLI param            | Description                                                                                                                          |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `<CONFIG_FILE>`      | Path to indexer configuration file.                                                                                                  |
| `<DATABASE_URL>`     | Postgres database connection string.                                                                                                 |
| `<REMOTE_STORE_URL>` | URL of a checkpoint bucket to index from, one of multiple possible [data sources](/concepts/custom-indexing-framework#data-sources). |

Example:

```sh
$ sui-indexer-alt indexer \
    --config misc.toml \
    --database-url postgres://username:password@localhost:5432/database \
    --remote-store-url https://checkpoints.mainnet.sui.io
```

### Run config recommendations {#indexer-run-config}

We recommend using the TOML files below which are grouped by pipeline speed. All pipelines in an instance are limited by the slowest pipeline in that instance so these files each contain pipelines that run at approximately the same speed.

<table>
	<thead>
		<tr>
			<th>Config TOML</th>
			<th>Description</th>
			<th>Pipelines</th>
			<th>Backfill time</th>
			<th>Data retention</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>`events.toml`</td>
			<td>Lightweight event tables.</td>
			<td>
				<ul className="pl-4">
					<li>`ev_emit_mod`</li>
					<li>`ev_struct_inst`</li>
				</ul>
			</td>
			<td>1-2 days</td>
			<td>90 days</td>
		</tr>
		<tr>
			<td colspan={5}>
				<details>
					<summary>`events.toml`</summary>
					<ImportContent source="examples/prod-config/events.toml" mode="code" />
				</details>
			</td>
		</tr>
		<tr>
			<td>`misc.toml`</td>
			<td>Lightweight miscellaneous tables.</td>
			<td>
				<ul className="pl-4">
					<li>`cp_sequence_numbers`</li>
					<li>`tx_balance_changes`</li>
					<li>`tx_digests`</li>
					<li>`kv_epoch_ends`</li>
					<li>`kv_epoch_starts`</li>
					<li>`kv_feature_flags`</li>
					<li>`kv_packages`</li>
					<li>`kv_protocol_configs`</li>
					<li>`sum_displays`</li>
				</ul>
			</td>
			<td>2-4 days</td>
			<td>90 days</td>
		</tr>
		<tr>
			<td colspan={5}>
				<details>
					<summary>`misc.toml`</summary>
					<ImportContent source="examples/prod-config/misc.toml" mode="code" />
				</details>
			</td>
		</tr>
		<tr>
			<td>`obj_versions.toml`</td>
			<td>Heavyweight object versions table containing data since genesis.</td>
			<td>`obj_versions`</td>
			<td>10-14 days</td>
			<td>unpruned</td>
		</tr>
		<tr>
			<td colspan={5}>
				<details>
					<summary>`obj_versions.toml`</summary>
					<ImportContent source="examples/prod-config/obj_versions.toml" mode="code" />
				</details>
			</td>
		</tr>
		<tr>
			<td>`tx_affected_addresses.toml`</td>
			<td>Midweight transaction table.</td>
			<td>`tx_affected_addresses`</td>
			<td>1-2 days</td>
			<td>90 days</td>
		</tr>
		<tr>
			<td colspan={5}>
				<details>
					<summary>`tx_affected_addresses.toml`</summary>
					<ImportContent source="examples/prod-config/tx_affected_addresses.toml" mode="code" />
				</details>
			</td>
		</tr>
		<tr>
			<td>`tx_affected_objects.toml`</td>
			<td>Midweight transaction table.</td>
			<td>`tx_affected_objects`</td>
			<td>1-2 days</td>
			<td>90 days</td>
		</tr>
		<tr>
			<td colspan={5}>
				<details>
					<summary>`tx_affected_objects.toml`</summary>
					<ImportContent source="examples/prod-config/tx_affected_objects.toml" mode="code" />
				</details>
			</td>
		</tr>
		<tr>
			<td>`tx_calls.toml`</td>
			<td>Midweight transaction table.</td>
			<td>`tx_calls`</td>
			<td>1-2 days</td>
			<td>90 days</td>
		</tr>
		<tr>
			<td colspan={5}>
				<details>
					<summary>`tx_calls.toml`</summary>
					<ImportContent source="examples/prod-config/tx_calls.toml" mode="code" />
				</details>
			</td>
		</tr>
		<tr>
			<td>`tx_kinds.toml`</td>
			<td>Midweight transaction table.</td>
			<td>`tx_kinds`</td>
			<td>1-2 days</td>
			<td>90 days</td>
		</tr>
		<tr>
			<td colspan={5}>
				<details>
					<summary>`tx_kinds.toml`</summary>
					<ImportContent source="examples/prod-config/tx_kinds.toml" mode="code" />
				</details>
			</td>
		</tr>
	</tbody>
</table>

## Consistent store setup

All consistent store pipelines run in the same instance based on a single configuration file. Like the indexer, the pipelines run in parallel and throughput is limited by the slowest pipeline.

#### Hardware requirements

- **CPU:** 8 cores
- **Memory:** 32GB

### Restore command

Restores one or more pipelines from checkpoint data in a GCS bucket.

```sh
$ sui-indexer-alt-consistent-store restore \
    --azure <AZURE_BUCKET> \
    --database-path <DATABASE_PATH> \
    --gcs <GCS_BUCKET> \
    --http <HTTP_ENDPOINT> \
    --object-file-concurrency <OBJECT_FILE_CONCURRENCY> \
    --pipeline <PIPELINE_NAME> \
    --remote-store-url <REMOTE_STORE_URL> \
    --s3 <S3_BUCKET>
```

| CLI parameter               | Description                                                                                                                               |
| --------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- |
| `<AZURE_BUCKET>` \*         | Name or URL of Azure bucket containing [managed snapshots](https://docs.sui.io/guides/operator/snapshots#mysten-labs-managed-snapshots).  |
| `<DATABASE_PATH>`           | Path to RocksDB database.                                                                                                                 |
| `<GCS_ACCOUNT>` \*          | Name or URL of GCS bucket containing [managed snapshots](https://docs.sui.io/guides/operator/snapshots#mysten-labs-managed-snapshots).    |
| `<HTTP_ENDPOINT>` \*        | URL of formal snapshot API.                                                                                                               |
| `<OBJECT_FILE_CONCURRENCY>` | Path to indexer configuration file.                                                                                                       |
| `<PIPELINE_NAME>`           | Name of pipeline to restore. Can be set multiple times; once per pipeline.                                                                |
| `<REMOTE_STORE_URL>`        | URL of a checkpoint bucket to index from, one of multiple possible [data sources](/concepts/custom-indexing-framework#data-sources).      |
| `<S3_BUCKET>` \*            | Name or URL of AWS S3 bucket containing [managed snapshots](https://docs.sui.io/guides/operator/snapshots#mysten-labs-managed-snapshots). |

\* Must specify one of `<AZURE_BUCKET>`, `<GCS_ACCOUNT>`, `<HTTP_ENDPOINT>`, or `<S3_BUCKET>`.

Example:

```sh
$ sui-indexer-alt-consistent-store restore \
    --database-path /path/to/rocksdb \
    --http https://formal-snapshot.mainnet.sui.io \
    --object-file-concurrency 5 \
    --pipeline balances \
    --pipeline object_by_owner \
    --pipeline object_by_type \
    --remote-store-url https://checkpoints.mainnet.sui.io
```

### Run command

Run a consistent store instance using this command for the configuration file that follows:

```sh
$ sui-indexer-alt-consistent-store run \
    --config <CONFIG_FILE> \
    --database-path <DATABASE_PATH> \
    --remote-store-url <REMOTE_STORE_URL>
```

| CLI param            | Description                                                                                                                          |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| `<CONFIG_FILE>`      | Path to consistent store configuration file.                                                                                         |
| `<DATABASE_PATH>`    | Path to RocksDB database.                                                                                                            |
| `<REMOTE_STORE_URL>` | URL of a checkpoint bucket to index from, one of multiple possible [data sources](/concepts/custom-indexing-framework#data-sources). |

Example:

```sh
$ sui-indexer-alt-consistent-store run \
    --config consistent-store.toml \
    --database-path /path/to/rocksdb \
    --remote-store-url https://checkpoints.mainnet.sui.io
```

### Run config recommendations

<table>
	<thead>
		<tr>
			<th>Config TOML</th>
			<th>Description</th>
			<th>Pipelines</th>
			<th>Backfill time</th>
			<th>Data retention</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>`consistent-store.toml`</td>
			<td>Consistent store API configuration and event tables.</td>
			<td>
				<ul className="pl-4">
					<li>`balances`</li>
					<li>`object-by-owner`</li>
					<li>`object-by-type`</li>
				</ul>
			</td>
			<td>1-2 hours</td>
			<td>Unpruned</td>
		</tr>
	</tbody>
</table>

<details>
	<summary>`consistent-store.toml`</summary>
	<ImportContent source="examples/prod-config/consistent-store.toml" mode="code" />
</details>

## Related links

<RelatedLink to="/concepts/graphql-indexer" />
<RelatedLink to="/concepts/graphql-rpc" />
<RelatedLink to="/concepts/custom-indexing-framework" />
<RelatedLink to="/concepts/custom-indexer/pipeline-architecture" />
<RelatedLink to="/concepts/archival-store" />
<RelatedLink to="/guides/developer/advanced/custom-indexer" />
<RelatedLink
	href="https://github.com/MystenLabs/sui/tree/main/crates/sui-indexer-alt"
	label="Sui Indexer Alt"
	desc="The `sui-indexer-alt` crate in the Sui repo."
/>
<RelatedLink
	href="https://github.com/MystenLabs/mvr/tree/main/crates/mvr-indexer"
	label="Move Registry"
	desc="The indexer that the Move Registry (MVR) implements."
/>
<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/crates/indexer"
	label="DeepBook Indexer"
	desc="The indexer that DeepBook implements."
/>
<RelatedLink
	href="/references/sui-api/sui-graphql/beta/reference"
	label="GraphQL Beta schema"
	desc="Schema documentation for GraphQL Beta"
/>

>>>> sui/docs/content/guides/operator/monitoring.mdx
---
title: Sui Node Monitoring
description: Monitor Sui node metrics to ensure the health and performance of your node.
keywords: [ localhost:9184/metrics, no monitoring, node metrics, view metrics, monitor production. ]
---

:::info

These instructions are for advanced users. If you just need a local development environment, you should instead follow the instructions in [Create a Local Sui Network](/guides/developer/sui-101/local-network.mdx) to create a local full node, validators, and faucet.

:::

Nodes expose on `localhost:9184/metrics` by default.

You can view the metrics in the metrics UI, or you can use a tool like `curl` to get the metrics in a format that is easy to parse.

```sh
$ curl -s http://localhost:9184/metrics | grep -E 'sui_validator|sui_fullnode'
```

## Production monitoring

For production monitoring, [Prometheus](https://prometheus.io/) and [Grafana](https://grafana.com/) are recommended.

You can use Grafana Agent, Grafana Alloy, or another tool to scrape the metrics from your node.


>>>> sui/docs/content/guides/operator/observability.mdx
---
title: Logging, Tracing, Metrics, and Observability
sidebar_label: Observability
draft: true
---

Good observability capabilities are key to the development and growth of Sui. This is made more challenging by the distributed and asynchronous nature of Sui, with multiple client and validator processes distributed over a potentially global network.

The observability stack in Sui is based on the [Tokio tracing](https://tokio.rs/blog/2019-08-tracing) library. The rest of this document highlights specific aspects of achieving good observability through structured logging and metrics in Sui.

:::info

The output here is largely for the consumption of Sui operators, administrators, and developers. The content of logs and traces do not represent the authoritative, certified output of validators and are subject to potentially byzantine behavior.

:::

## Contexts, scopes, and tracing transaction flow {#context-scope-trace}

In a distributed and asynchronous system like Sui, one cannot rely on looking at individual logs over time in a single thread. To solve this problem, use the approach of structured logging. Structured logging offers a way to tie together logs, events, and blocks of functionality across threads and process boundaries.

### Spans and events {#spans-and-events}

In the [Tokio tracing](https://tokio.rs/blog/2019-08-tracing) library, structured logging is implemented using [spans and events](https://docs.rs/tracing/0.1.31/tracing/index.html#core-concepts).
Spans cover a whole block of functionality - like one function call, a future or asynchronous task, etc. They can be nested, and key-value pairs in spans give context to events or logs inside the function.

- spans and their key-value pairs add essential context to enclosed logs, such as a transaction ID.
- spans also track time spent in different sections of code, enabling distributed tracing functionality.
- individual logs can also add key-value pairs to aid in parsing, filtering and aggregation.

Here is a list of context information of interest:

- TX Digest
- Object references/ID, when applicable
- Address
- Certificate digest, if applicable
- For Client HTTP endpoint: route, method, status
- Epoch
- Host information, for both clients and validators

In the digest, `process_tx` is a span that covers handling the initial transaction request, and "Checked locks" is a single log message within the transaction handling method in the validator.

Every log message that occurs within the span inherits the key-value properties defined in the span, including the `tx_digest` and any other fields that are added. Log messages can set their own keys and values. The fact that logs inherit the span properties allows you to trace, for example, the flow of a transaction across thread and process boundaries.

## Key-value pairs schema {#key-value-pairs-schema}

Spans capture not a single event but an entire block of time; so start, end, duration, etc. can be captured and analyzed for tracing, performance analysis, and so on.

### Tags - keys {#tags-keys}

The idea is that every event and span would get tagged with key-value pairs. Events that log within any context or nested contexts would also inherit the context-level tags.

These tags represent _fields_ that can be analyzed and filtered by. For example, one could filter out broadcasts and see the errors for all instances where the bad stake exceeded a certain amount, but not enough for an error.

## Logging levels {#logging-levels}

This is always tricky, to balance the right amount of verbosity especially by default -- while keeping in mind this is a high performance system.

| Level | Type of Messages                                                                                           |
| ----- | ---------------------------------------------------------------------------------------------------------- |
| Error | Process-level faults (not transaction-level errors, there could be a ton of those)                         |
| Warn  | Unusual or byzantine activity                                                                              |
| Info  | High level aggregate stats, major events related to data sync, epoch changes.                              |
| Debug | High level tracing for individual transactions, eg Gateway/client side -> validator -> Move execution etc. |
| Trace | Extremely detailed tracing for individual transactions                                                     |
|       |                                                                                                            |

Going from information to debug results in a much larger spew of messages.

Use the `RUST_LOG` environment variable to set both the overall logging level as well as the level for individual components. Filtering down to specific spans or tags within spans is even possible.

For more details, see the [EnvFilter](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html) topic.

## Metrics {#metrics}

Sui includes Prometheus-based metrics:

- `rpc_requests_by_route` and related for RPC Server API metrics and latencies (see `rpc-server.rs`)
- Validator transaction metrics (see `AuthorityMetrics` in `authority.rs`)

## Viewing logs, traces, metrics {#viewing-logs-traces-metrics}

The tracing architecture is based on the idea of [subscribers](https://github.com/tokio-rs/tracing#project-layout) which can be plugged into the tracing library to process and forward output to different sinks for viewing. Multiple subscribers can be active at the same time.

You can feed JSON logs, for example, through a local sidecar log forwarder such as [Vector](https://vector.dev), and then onwards to destinations such as ElasticSearch.

The use of a log and metrics aggregator such as Vector allows for easy reconfiguration without interrupting the validator server, as well as offloading observability traffic.

Metrics: served with a Prometheus scrape endpoint, by default at `<host>:9184/metrics`.

### Stdout (default) {#stdout-default}

By default, logs (but not spans) are formatted for human readability and output to stdout, with key-value tags at the end of every line.

You can configure `RUST_LOG` for custom logging output, including filtering - see the [Logging levels](#logging-levels) section earlier in this topic.

### Tracing and span output {#tracing-and-span-output}

To generate detailed span start and end logs, define the `SUI_JSON_SPAN_LOGS` environment variable. This causes all output to be in JSON format, which is not as human-readable, so it is not enabled by default.

You can send this output to a tool or service for indexing, alerts, aggregation, and analysis.

The following example output shows certificate processing in the authority with span logging. Note the `START` and `END` annotations, and notice how `DB_UPDATE_STATE` which is nested is embedded within `PROCESS_CERT`. Also notice `elapsed_milliseconds`, which logs the duration of each span.

```sh
{"v":0,"name":"sui","msg":"[PROCESS_CERT - START]","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.241421Z","target":"sui_core::authority_server","line":67,"file":"sui_core/src/authority_server.rs","tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493"}
{"v":0,"name":"sui","msg":"[PROCESS_CERT - EVENT] Read inputs for transaction from DB","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.246688Z","target":"sui_core::authority","line":393,"file":"sui_core/src/authority.rs","num_inputs":2,"tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493"}
{"v":0,"name":"sui","msg":"[PROCESS_CERT - EVENT] Finished execution of transaction with status Success { gas_used: 18 }","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.246759Z","target":"sui_core::authority","line":409,"file":"sui_core/src/authority.rs","gas_used":18,"tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493"}
{"v":0,"name":"sui","msg":"[DB_UPDATE_STATE - START]","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.247888Z","target":"sui_core::authority","line":430,"file":"sui_core/src/authority.rs","tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493"}
{"v":0,"name":"sui","msg":"[DB_UPDATE_STATE - END]","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.248114Z","target":"sui_core::authority","line":430,"file":"sui_core/src/authority.rs","tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493","elapsed_milliseconds":0}
{"v":0,"name":"sui","msg":"[PROCESS_CERT - END]","level":20,"hostname":"Evan-MLbook.lan","pid":51425,"time":"2022-03-08T22:48:11.248688Z","target":"sui_core::authority_server","line":67,"file":"sui_core/src/authority_server.rs","tx_digest":"t#d1385064287c2ad67e4019dd118d487a39ca91a40e0fd8e678dbc32e112a1493","elapsed_milliseconds":2}
```

### Jaeger (seeing distributed traces) {#jaeger}

To see nested spans visualized with [Jaeger](https://www.jaegertracing.io), do the following:

1.  Run this to get a local Jaeger container:

```sh
$ docker run -d -p6831:6831/udp -p6832:6832/udp -p16686:16686 jaegertracing/all-in-one:latest
```

1.  Run Sui like this (trace enables the most detailed spans):

```sh
$ SUI_TRACING_ENABLE=1 RUST_LOG="info,sui_core=trace" ./sui start
```

1.  Run some transfers with Sui CLI client, or run the benchmarking tool.
1.  Browse to `http://localhost:16686/` and select Sui as the service.

:::info

Separate spans (that are not nested) are not connected as a single trace for now.

:::

### Live async inspection / Tokio Console {#tokio-console}

[Tokio-console](https://github.com/tokio-rs/console) is an awesome CLI tool designed to analyze and help debug Rust apps using Tokio, in real time. ðŸŽ‰ It relies on a special subscriber.

1.  Build Sui using a special flag: `RUSTFLAGS="--cfg tokio_unstable" cargo build`.
1.  Start Sui with `SUI_TOKIO_CONSOLE` set to 1.
1.  Clone the console repo and `cargo run` to launch the console.

:::tip

Adding Tokio-console support might significantly slow down Sui validators/gateways.

:::

### Memory profiling {#memory-profiling}

Sui uses the [jemalloc memory allocator](https://jemalloc.net/) by default on most platforms, and there is code that enables automatic memory profiling using jemalloc's sampling profiler, which is very lightweight and designed for production use. The profiling code spits out profiles at most every 5 minutes, and only when total memory has increased by a default 20%. Profiling files are named `jeprof.<TIMESTAMP>.<memorysize>MB.prof` so that it is easy to
correlate to metrics and incidents, for ease of debugging.

For the memory profiling to work, you need to set the environment variable `_RJEM_MALLOC_CONF=prof:true`. If you use the [Docker image](https://hub.docker.com/r/mysten/sui-node) they are set automatically.

Running some allocator-based heap profilers such as [Bytehound](https://github.com/koute/bytehound) will essentially disable automatic jemalloc profiling, because they interfere with or don't implement `jemalloc_ctl` stats APIs.

To view the profile files, one needs to do the following, on the same platform as where the profiles were gathered:

1.  Install `libunwind`, the `dot` utility from graphviz, and jeprof. On Debian: `apt-get install libjemalloc-dev libunwind-dev graphviz`.
1.  Build with debug symbols: `cargo build --profile bench-profiling`
1.  cd to `$SUI_REPO/target/bench-profiling`
1.  Run `jeprof --svg sui-node jeprof.xxyyzz.heap` - select the heap profile based on
    timestamp and memory size in the filename.

:::tip

With automatic memory profiling, it is no longer necessary to configure environment variables beyond those previously listed. It is possible to configure custom profiling options:

- [Heap Profiling](https://github.com/jemalloc/jemalloc/wiki/Use-Case%3A-Heap-Profiling)
- [heap profiling with jemallocator](https://gist.github.com/ordian/928dc2bd45022cddd547528f64db9174)

For example, set `_RJEM_MALLOC_CONF` to:
`prof:true,lg_prof_interval:24,lg_prof_sample:19`

The preceding setting means: turn on profiling, sample every 2^19 or 512KB bytes allocated, and dump out the profile every 2^24 or 16MB of memory allocated. However, the automatic profiling is designed to produce files that are better named and at less intervals, so overriding the default configuration is not usually recommended.

:::

>>>> sui/docs/content/guides/operator/snapshots.mdx
---
title: Database Snapshots
description: Database snapshots of the Sui network enable full node operators a way to bootstrap a full node without having to execute all the transactions that occurred after genesis.
keywords: [ node snapshots, database snapshots, full node snapshots, formal snapshots, rocksdb, rocksdb snapshot, restoring a node, restoring a full node, restoring from snapshot, managed snapshots, enabling snapshots ]
---

Database snapshots provide a point-in-time view of a database's store. In Sui, the database snapshot captures a running database's view of the Sui network from a particular node at the end of an epoch. While validators can enable snapshots, they are typically most valuable for full node operators.

Snapshots of the Sui network enable full node operators a way to bootstrap a full node without having to execute all the transactions that occurred after genesis. You can upload snapshots to remote object stores like S3, Google Cloud Storage, Azure Blob Storage, and similar services. These services typically run the export process in the background so there is no degradation in performance for your full node. With snapshots stored in the cloud, you're more easily able to recover quickly from catastrophic failures in your system or hardware.

To maintain a healthy Sui network, Sui encourages the Sui community to bring up additional snapshots to ensure stronger data availability across the network.

## Supported snapshot types

Sui supports two types of snapshots:

- **RocksDB snapshots** are a point-in-time view of a database store. This means that the snapshot keeps the state of the system at the moment it generates the snapshot, including non-pruned data, additional indices, and other data.
- **Formal snapshots** are database agnostic with a minimalistic format. In other words, they contain only the data necessary to restore a node to a valid state at the specified epoch. Consequently, they have a much smaller storage footprint and are generally faster to restore from when compared to database snapshots. Formal snapshots are also supported natively by the Sui protocol. In this context, you can cryptographically verify the contents of the formal snapshot against a commitment from the committee at the epoch you are restoring to. This verification happens automatically and by default during a formal snapshot restore (unless explicitly bypassed). 

:::info

Formal snapshots are not suitable for use if you are running an RPC node that does any historical data lookups. For more information on node data management, see [Data Management](./data-management.mdx).

:::

You can configure a full node snapshot to generate a state snapshot at the end of each epoch.
A single full node can generate RocksDB snapshots, formal snapshots, or both.

## Formal snapshots

Formal snapshots provide a mechanism for a node to restore to a canonical state (the state of a full pruned and compacted node at the end of an epoch) at some prior point in time without having to execute all the transactions that have occurred since genesis. Unlike existing database snapshots, these formal snapshots have the following properties:

1. **Minimalism:** Formal snapshots currently contain only the end of epoch live object set (the set of all object versions eligible for use as input objects for future transactions). Sui syncs all other critical chain information from the chain or derives it. Thus, formal snapshots contain only the necessary data required for a node to startup at epoch boundary and participate in the network.
1. **Agnosticism:** Formal snapshots are by nature agnostic to the underlying database choice or implementation of the protocol. As the live object set is protocol defined, so is the formal snapshot.
1. **Verifiability:** Formal snapshots have first-class support in the core Sui protocol. As such, they must be trustless/verifiable by the node operator upon download. To support this, the protocol signs a commitment to the live object state at end of epoch, which formal snapshots are checked against at restore time. If this verification fails, the node state is moved back to the state before the snapshot restore attempt.

Because these snapshots do not contain indexes, they are most immediately useful for validators and state sync Full nodes (SSFNs). You can upload snapshots to remote object stores like S3, Google Cloud Storage, Azure Blob Storage, and similar services. These services typically run the export process in the background so there is no degradation in performance for your full node. With snapshots stored in the cloud, you can recover from catastrophic failures in your system or hardware more efficiently.

## Restoring a full node using snapshots

### Restoring using RocksDB snapshots

To restore from a RocksDB snapshot, follow these steps:

1. Download the snapshot for the epoch you want to restore to your local disk. There is one snapshot per epoch in s3 bucket.
1. Place the snapshot into the directory that the `db-path` value points to in your fullnode.yaml file. For example, if the `db-path` value points to `/opt/sui/db/authorities_db/full_node_db` and you want to restore from epoch 10, then copy the snapshot to the directory with this command:

   You can use the AWS CLI (provided you have credentials to associate with the download):
   `aws s3 cp s3://<BUCKET_NAME>/epoch_10 /opt/sui/db/authorities_db/full_node_db/live --recursive --request-payer requester`.

1. When using `aws s3 cp` (or `gsutil cp`) the database is copied to the location you pass to `--path`, in a directory named `epoch_[NUM]`. Rename the `epoch_[NUM]` directory to `live/` under your node's `db_path`, for example `cp -r /tmp/epoch_[NUM] /opt/sui/db/authorities_db/full_node_db/live`.
1. Make sure you update the ownership of the downloaded directory to the sui user (whichever linux user you run `sui-node` as)
   `sudo chown -R sui:sui  /opt/sui/db/authorities_db/full_node_db/live`.
1. Start the Sui node.

:::info

When you restore a full node from a snapshot, write it to the path `/opt/sui/db/authorities_db/full_node_db/live`. When restoring a validator node, you can shorten the database destination to `/opt/sui/db/authorities_db/live`. Check the `db_path` field of your full node or Validator configs to confirm the path location.

:::

### Restoring using formal snapshots

To restore using a formal snapshot, use the `sui-tool` binary. You can download `sui-tool` along with other `sui` binaries.
See [Install Sui](/guides/developer/getting-started/sui-install.mdx) for more details.

The following steps can be used to restore a node from a formal snapshot:

1. If it's running, stop the node.
2. Run the command:
   ```
   sui-tool download-formal-snapshot --latest --genesis "<PATH-TO-GENESIS-BLOB>" \
        --network <NETWORK> --snapshot-bucket <BUCKET-NAME> --snapshot-bucket-type <TYPE> \
        --path <PATH-TO-NODE-DB> --num-parallel-downloads 50 --no-sign-request
   ```
   - `--epoch`: The epoch that you want to download. Mysten Labs hosted buckets will only keep the last 90 epochs, you can check the most recent epoch on sui explorers like [suivision](https://suivision.xyz/) or [suiscan](https://suiscan.xyz/).
   - `--latest`: Rather than explicitly passing a epoch via `--epoch`, you can pass the `--latest` flag, which will automatically select the latest snapshot`
   - `--genesis`: The path to the location of the network's `genesis.blob`.
   - `--network`: Network to download snapshot for. Defaults to `mainnet`.
   - `--path`: Path to snapshot directory on local filesystem.
   - `--no-sign-request`: If set, `--snapshot-bucket` and `--snapshot-bucket-type` are ignored, and Cloudflare R2 is used.
   - `--snapshot-bucket`: Source snapshot bucket name, eg `mysten-mainnet-snapshots`. This cannot be used with `--no-sign-request`.
   - `--snapshot-bucket-type`: Snapshot bucket type. GCS and S3 currently supported. This cannot be used with `--no-sign-request`.

   The following environment variables are used if `--no-sign-request` is not set:
   * *AWS*: `AWS_SNAPSHOT_ACCESS_KEY_ID`, `AWS_SNAPSHOT_SECRET_ACCESS_KEY`, `AWS_SNAPSHOT_REGION`
   * *GCS*: `GCS_SNAPSHOT_SERVICE_ACCOUNT_FILE_PATH`
   * *AZURE*: `AZURE_SNAPSHOT_STORAGE_ACCOUNT`, `AZURE_SNAPSHOT_STORAGE_ACCESS_KEY`


## Mysten Labs managed snapshots

Mysten Labs hosts two tiers of snapshot storage access. **High throughput, Requester Pays enabled buckets**, and **free, permissionless buckets**.

**High throughput, Requester Pays enabled buckets:**
* GCS and S3 are both setup with requester pays. This means that you'll need to provide a set of valid AWS/GCP credentials when downloading from these buckets.
[Requester Pays](https://cloud.google.com/storage/docs/requester-pays) means you are charged for the egress costs of pulling the snapshot data.
* If you are looking for the best download speeds, we recommend using the S3 buckets with [transfer acceleration](https://aws.amazon.com/s3/transfer-acceleration/) enabled.

**Free, permissionless buckets:**
* These are currently hosted on Cloudflare R2, currently only in North America, but we plan on adding more regions soon.
* Since the bucket is open to the internet, there's no need to provide any cloud credentials.
* The free buckets (eg. `sui-tool download-formal-snapshot --no-sign-request`) are now only available for _formal_ snapshots. You must use one of the requester pays (S3 or GCS) buckets if downloading a db snapshot

### Bucket names

**S3**

Testnet: `s3://mysten-testnet-snapshots/`, `s3://mysten-testnet-formal/`

Mainnet: `s3://mysten-mainnet-snapshots/`,  `s3://mysten-mainnet-formal/`

**GCS**

Testnet: `gs://mysten-testnet-snapshots/`, `gs://mysten-testnet-formal/`

Mainnet: `gs://mysten-mainnet-snapshots/`,  `gs://mysten-mainnet-formal/`

![Mysten Managed Snapshots](./images/mysten-cloud-snapshots.png "A diagram that shows the current architecture of Mysten snapshot availability")

## Enabling snapshots

Full nodes do not take snapshots by default. To enable this feature you must apply specific configs to your full node.

Follow these steps to change the configs for a full node:

1. Stop your node, if it's running.
2. Open your `fullnode.yaml` config file and apply config updates as the following sections show.
3. Save the `fullnode.yaml` file and restart the node.

### Enabling DB snapshots

Add an entry to the config file for `db-checkpoint-config`. Using Amazon's S3 service as an example:
   ```yaml
   db-checkpoint-config:
     perform-db-checkpoints-at-epoch-end: true
     perform-index-db-checkpoints-at-epoch-end: true
     object-store-config:
       object-store: "S3"
       bucket: "<BUCKET-NAME>"
       aws-access-key-id: â€œ<ACCESS-KEY>â€
       aws-secret-access-key: â€œ<SHARED-KEY>â€
       aws-region: "<BUCKET-REGION>"
       object-store-connection-limit: 20
   ```
   - `object-store`: The remote object store to upload snapshots. Set as Amazon's `S3` service in the example.
   - `bucket`: The S3 bucket name to store the snapshots.
   - `aws-access-key-id` and `aws-secret-access-key`: AWS authentication information with write access to the bucket.
   - `aws-region`: Region where bucket exists.
   - `object-store-connection-limit`: Number of simultaneous connections to the object store.

### Enabling formal snapshots

 Add an entry to the config file for `state-snapshot-write-config`. Using Amazon's S3 service as an example:
   ```yaml
   state-snapshot-write-config:
     object-store-config:
       object-store: "S3"
       bucket: "<BUCKET-NAME>"
       aws-access-key-id: â€œ<ACCESS-KEY>â€
       aws-secret-access-key: â€œ<SHARED-KEY>â€
       aws-region: "<BUCKET-REGION>"
       object-store-connection-limit: 200
   ```
   The configuration settings shown in the example are specific to AWS S3, but GCS, Azure Storage, and Cloudflare R2 are all supported.


>>>> sui/docs/content/guides/operator/sui-full-node.mdx
---
title: Sui Full Node Configuration
description: Operate a Sui full node to validate blockchain activities, like transactions, checkpoints, and epoch changes.  
keywords: [ fullnode configuration, full node configuration, sui full nodes, state synchronization, state sync, full node architecture, node hardware requirements, node software requirements, grpc, starting a full node, running a full node ]
---

:::info

These instructions are for advanced users. If you just need a local development environment, you should instead follow the instructions in [Create a Local Sui Network](/guides/developer/sui-101/local-network.mdx) to create a local full node, validators, and faucet.

:::

Sui full nodes validate blockchain activities, including transactions, checkpoints, and epoch changes. Each full node stores and services the queries for the blockchain state and history.

This role enables validators to focus on servicing and processing transactions. When a validator commits a new set of transactions (or a block of transactions), the validator pushes that block to all connected full nodes that then service the queries from clients.

## Features 

Sui full nodes:
- Track and verify the state of the blockchain, independently and locally.
- Serve read requests from clients.

## State synchronization 
Sui full nodes sync with validators to receive new transactions on the network.

A transaction requires a few round trips to 2f+1 validators to form a transaction certificate (TxCert).

This synchronization process includes:

1. Following 2f+1 validators and listening for newly committed transactions.
1. Making sure that 2f+1 validators recognize the transaction and that it reaches finality.
1. Executing the transaction locally and updating the local DB.

This synchronization process requires listening to at a minimum `2f+1` validators to ensure that a full node has properly processed all new transactions. Sui will improve the synchronization process with the introduction of checkpoints and the ability to synchronize with other full nodes.

## Architecture 

A Sui full node is essentially a read-only view of the network state. Unlike validator nodes, full nodes cannot sign transactions, although they can validate the integrity of the chain by re-executing transactions that a quorum of validators previously committed.

Today, a Sui full node has the potential to maintain the full history of the chain. That will change with gRPC and as JSON-RPC gets phased out.

Validator nodes store only the latest transactions on the frontier of the object graph (for example, transactions with >0 unspent output objects).

## Full node setup 

Follow the instructions here to run your own Sui full node. Sui full nodes run using the `sui-node` binary.

### Hardware requirements 

Suggested minimum hardware to run a Sui full node:

- CPUs: 8 physical cores / 16 vCPUs
- RAM: 128 GB
- Storage (SSD): 4 TB NVMe drive

### Software requirements 

Sui recommends running Sui full nodes on Linux. Sui supports the Ubuntu and Debian distributions. You can run a Sui full node on macOS,
but this is only recommended for development and not for production use.

Make sure to [update Rust](https://doc.rust-lang.org/book/ch01-01-installation.html#updating-and-uninstalling).

Use the following command to install additional Linux dependencies.

```sh
$ sudo apt-get update \
&& sudo apt-get install -y --no-install-recommends \
tzdata \
libprotobuf-dev \
ca-certificates \
build-essential \
libssl-dev \
libclang-dev \
libpq-dev \
pkg-config \
openssl \
protobuf-compiler \
git \
clang \
cmake
```

### Considerations to enable gRPC

You must enable gRPC support on your full nodes. JSON-RPC is **deprecated**. Refer to [Sui's data serving roadmap](/guides/developer/sui-101/data-serving.mdx#grpc-api) for guidance on the overall transition plan.

To serve the [gRPC API](/concepts/grpc-overview.mdx), you must enable it on your full node by indexing gRPC-specific data. During the initial gRPC indexing phase, your full node may not be able to handle other traffic, including the [**deprecated** JSON-RPC](/references/sui-api.mdx) requests. Plan your rollout carefully (such as using the `rolling upgrade` mechanism), and communicate any downtime to your customers and partners in advance. The time required to sync gRPC indexes depends on your full node's hardware and software configuration.

Enable gRPC indexing on your full node by adding the following entry to the `fullnode.yaml` configuration:

```sh

rpc:
  enable-indexing: true

```

Running gRPC alongside JSON-RPC increases your full nodeâ€™s storage usage. You can reclaim this storage by disabling JSON-RPC after all your client applications have migrated from JSON-RPC. All applications must gradually migrate to gRPC or [GraphQL RPC](/concepts/graphql-indexer.mdx). You can also run gRPC and JSON-RPC on separate nodes to optimize resource usage and provide a performant and resilient RPC experience to client applications. Add the following to the `fullnode.yaml` configuration of your full node to selectively disable JSON-RPC on it:

```sh

enable-index-processing: false

```

You can configure the retention window for the gRPC index on your full node by adding the following to its `fullnode.yaml` configuration:

```sh

authority-store-pruning-config:
  num-epochs-to-retain: 14
  num-epochs-to-retain-for-checkpoints: 14

```

Adjust the gRPC data retention period based on your full nodeâ€™s resource profile and whether you've disabled JSON-RPC or not. In any case, test the longer retention period for performance and scalability before using gRPC in your application or offering it to other developers.

## Running a full node {#running-a-full-node}

Instructions for building, installing, or downloading the `sui-node` binary are available at [Sui Install](/guides/developer/getting-started/sui-install.mdx). 
These install instructions are specific to the `sui` CLI, but apply to the `sui-node` binary as well.

There are many ways to run a Sui full node (bare metal, virtual machine, Kubernetes StatefulSet, and so on), and the solution that you choose depends on your specific needs as well as the infrastructure that you have available.

There are some specific considerations to keep in mind when running a Sui full node that apply to all environments:

* [Genesis](./genesis.mdx): You must download the genesis blob for the network that you want to connect to, and make it available to the `sui-node`.
* [Data Storage](./data-management.mdx): Sui full nodes _can_ require a significant amount of disk space to store the blockchain history. If you plan to use your full node to serve RPC requests, you must also plan for the storage of index files, which requires a significant amount of disk space.
* [Monitoring](./monitoring.mdx): Sui full nodes expose metrics about the node's health and the state of the Sui network.
* [Updates](./updates.mdx): Sui full nodes must be updated to the latest version to remain in sync with the network.
* [Archival Fallback](./archives.mdx): The archival fallback allows you to sync checkpoints from any point in the chain's history. The network `seed-peers` below only keep a few epochs of history.


### Using Docker Compose 

There's a guide in the Sui repository on running a full node via [Docker Compose](https://github.com/MystenLabs/sui/tree/main/docker/fullnode#readme). 
This alone is not suitable for a production environment, but can be used to get a full node up and running quickly on a virtual machine or local machine for development purposes.
Refer to [Running a full node](#running-a-full-node) for instructions relevant to production use cases.


### Setting up a full node

When you are ready to run `sui-node` in your production environment, you can set up your full node by completing the following steps:

1. Make a copy of the [full node YAML template](https://github.com/MystenLabs/sui/blob/main/crates/sui-config/data/fullnode-template.yaml):
    ```sh
    $ cp crates/sui-config/data/fullnode-template.yaml fullnode.yaml
    ```
1. Download the genesis blob for the network to use:
    - [Devnet genesis blob](https://github.com/MystenLabs/sui-genesis/raw/main/devnet/genesis.blob):
        ```sh
        $ curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/devnet/genesis.blob
        ```
    - [Testnet genesis blob](https://github.com/MystenLabs/sui-genesis/raw/main/testnet/genesis.blob):
        ```sh
        $ curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/testnet/genesis.blob
        ```
    - [Mainnet genesis blob](https://github.com/MystenLabs/sui-genesis/raw/main/mainnet/genesis.blob):
        ```sh
        $ curl -fLJO https://github.com/MystenLabs/sui-genesis/raw/main/mainnet/genesis.blob
        ```
1. For Testnet or Mainnet: Edit the `fullnode.yaml` file to include peer nodes for state synchronization. Append the following to the end of the current configuration:

    <Tabs groupId="network">

    <TabItem label="Mainnet" value="mainnet">

    ```sh
    p2p-config:
      seed-peers:
        - address: /dns/mel-00.mainnet.sui.io/udp/8084
          peer-id: d32b55bdf1737ec415df8c88b3bf91e194b59ee3127e3f38ea46fd88ba2e7849
        - address: /dns/ewr-00.mainnet.sui.io/udp/8084
          peer-id: c7bf6cb93ca8fdda655c47ebb85ace28e6931464564332bf63e27e90199c50ee
        - address: /dns/ewr-01.mainnet.sui.io/udp/8084
          peer-id: 3227f8a05f0faa1a197c075d31135a366a1c6f3d4872cb8af66c14dea3e0eb66
        - address: /dns/lhr-00.mainnet.sui.io/udp/8084
          peer-id: c619a5e0f8f36eac45118c1f8bda28f0f508e2839042781f1d4a9818043f732c
        - address: /dns/sui-mainnet-ssfn-1.nodeinfra.com/udp/8084
          peer-id: 0c52ca8d2b9f51be4a50eb44ace863c05aadc940a7bd15d4d3f498deb81d7fc6
        - address: /dns/sui-mainnet-ssfn-2.nodeinfra.com/udp/8084
          peer-id: 1dbc28c105aa7eb9d1d3ac07ae663ea638d91f2b99c076a52bbded296bd3ed5c
        - address: /dns/sui-mainnet-ssfn-ashburn-na.overclock.run/udp/8084
          peer-id: 5ff8461ab527a8f241767b268c7aaf24d0312c7b923913dd3c11ee67ef181e45
        - address: /dns/sui-mainnet-ssfn-dallas-na.overclock.run/udp/8084
          peer-id: e1a4f40d66f1c89559a195352ba9ff84aec28abab1d3aa1c491901a252acefa6
        - address: /dns/ssn01.mainnet.sui.rpcpool.com/udp/8084
          peer-id: fadb7ccb0b7fc99223419176e707f5122fef4ea686eb8e80d1778588bf5a0bcd
        - address: /dns/ssn02.mainnet.sui.rpcpool.com/udp/8084
          peer-id: 13783584a90025b87d4604f1991252221e5fd88cab40001642f4b00111ae9b7e
    ```

    </TabItem>
    <TabItem label="Testnet" value="testnet">

    ```sh
    p2p-config:
      seed-peers:
        - address: /dns/yto-tnt-ssfn-01.testnet.sui.io/udp/8084
          peer-id: 2ed53564d5581ded9b6773970ac2f1c84d39f9edf01308ff5a1ffe09b1add7b3
        - address: /dns/yto-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: 6563732e5ab33b4ae09c73a98fd37499b71b8f03c27b5cc51acc26934974aff2
        - address: /dns/nrt-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: 23a1f7cd901b6277cbedaa986b3fc183f171d800cabba863d48f698f518967e1
        - address: /dns/ewr-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: df8a8d128051c249e224f95fcc463f518a0ebed8986bbdcc11ed751181fecd38
        - address: /dns/lax-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: f9a72a0a6c17eed09c27898eab389add704777c03e135846da2428f516a0c11d
        - address: /dns/lhr-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: 9393d6056bb9c9d8475a3cf3525c747257f17c6a698a7062cbbd1875bc6ef71e
        - address: /dns/mel-tnt-ssfn-00.testnet.sui.io/udp/8084
          peer-id: c88742f46e66a11cb8c84aca488065661401ef66f726cb9afeb8a5786d83456e
    ```

    </TabItem>

    </Tabs>
1. Optional: Set up the [Archival Fallback](./archives.mdx), which allows you to sync checkpoints if you fall behind the network's `seed-peers`.
1. Optional: Skip this step to accept the default paths to resources. Edit the `fullnode.yaml` file to use custom paths.
1. Update the `db-path` field with the path to the full node database.
    `db-path: "/db-files/sui-fullnode"`
1. Update the `genesis-file-location` with the path to genesis.blob.
    ```sh
    genesis:
        genesis-file-location: "/sui-fullnode/genesis.blob"
    ```

### Starting your full node {#starting-a-full-node}

You should not start syncing your full node from the start of the genesis. This will take a very long time and consume a lot of resources (including likely filling up your disk).

Instead, start your full node from a recent snapshot. You can find details on how to obtain a snapshot from the [Sui Snapshots guide](./snapshots.mdx).

Now that you have your full node config file set up, and you've obtained a snapshot, you can start your full node by running the `sui-node` binary with your `fullnode.yaml` configuration file:

```sh
$ sui-node --config-path fullnode.yaml
```

It's a good idea to use something like systemd to manage your full node in a production environment.

### Troubleshooting 
If you receive a `cannot find -lpq` error, you are missing the `libpq` library. Use `sudo apt-get install libpq-dev` to install on Linux, or `brew install libpq` on MacOS. After you install on MacOS, create a Homebrew link using `brew link --force libpq`. For further context, reference the [issue on Stack Overflow](https://stackoverflow.com/questions/70313347/ld-library-not-found-for-lpq-when-build-rust-in-macos?rq=1).

If you receive the following error:

```sh
panicked at error binding to 0.0.0.0:9184: error creating server listener: Address already in use (os error 98)
```

Then update the metrics address in your `fullnode.yaml` file to use port `9180`.

```sh
metrics-address: "0.0.0.0:9180"
```

>>>> sui/docs/content/guides/operator/updates.mdx
---
title: Updating a Full Node
description: Update your Sui full node to the latest version to remain in sync with the network.
keywords: [ update a full node, update full node, update node, sui release schedule, release schedule, release process, how to update node, when should nodes be updated, when are updates released ]
---

## Sui release process

Each Sui network is deployed on a consistent schedule. There are extenuating circumstances that might delay releases occasionally, but these delays are rare and communicated through [official channels](#communication).

- `devnet`: Deployed every week on Mondays.
- `testnet`: Deployed every week on Tuesdays.
- `mainnet`: Deployed every two weeks on Wednesdays.

:::info

For additional details, see each network's [release schedule and configuration](https://sui.io/networkinfo).

:::

Whenever Sui releases a new version, you must update your full node with the release to ensure compatibility with the network it connects to. For example, if you use Sui Testnet you should install the version of Sui running on Sui Testnet.

Any release that contains a protocol change will need to be followed before the protocol upgrade takes place (when enough stake within the validator set upgrades, the new protocol version is enacted in the next epoch).
If you do not update your full node, you will not be able to connect to the network after the protocol upgrade takes place.

## Communication

Releases are announced on [Sui Discord server](https://discord.com/invite/sui) and [node-operators](https://groups.google.com/a/groups.sui.io/g/node-operators) Google group.

### Discord channels
- `devnet`: [`#devnet-updates`](https://discord.com/channels/916379725201563759/1004638487078772736)
- `testnet`: [`#tn-validator-announcements`](https://discord.com/channels/916379725201563759/1003660994381353101), [`#testnet-updates`](https://discord.com/channels/916379725201563759/1095151359642304612), â and [`#node-announcements`](https://discord.com/channels/916379725201563759/1002231298888306718) channels.
- `mainnet`: [`â #mn-validator-announcements`](https://discord.com/channels/916379725201563759/1093852827627040768), [`#mainnet-updates`](https://discord.com/channels/916379725201563759/1103082453792464906), and [`#node-announcements`](https://discord.com/channels/916379725201563759/1002231298888306718) channels.

## Update your full node 

You can track the latest version of Sui on the [Sui Releases](https://github.com/MystenLabs/sui/releases) page on GitHub.
The schedule for each network is available in the [Network Release Schedule](https://sui.io/networkinfo) page.

It is reasonable to have to shut down your full node to perform an update, whether that be a rolling restart in Kubernetes, or a systemctl stop on a Linux machine to replace the sui-node binary.

>>>> sui/docs/content/guides/operator/validator-index.mdx
---
title: Sui Validators
description: Guides for validator nodes on the Sui network. 
keywords: [ validator, validator configuration, validator committee, validator rewards, validator management, validator tools ]
pagination_prev: null
---

## Sui Validators

<Cards>
<Card title="Validator Configuration & Deployment" href="/guides/operator/validator/validator-config">
</Card>
<Card title="Validator Committee" href="/guides/operator/validator/validator-committee">
</Card>
<Card title="Validator Rewards" href="/guides/operator/validator/validator-rewards">
</Card>
<Card title="Validator Management" href="/guides/operator/validator/validator-tasks">
</Card>
<Card title="Validator Tools" href="/guides/operator/validator/validator-config">
</Card>
</Cards>
>>>> sui/docs/content/guides/operator/validator/node-tools.mdx
---
title: Validator Node Tools
description: Use the Sui CLI to interact with a full node's validator commands. 
keywords: [ sui cli, full node, delegator, validator, operation cap, report validators, join a committee, leave a committee, report a validator, proof of possession, generate proof of possession ]
sidebar_position: 5
sidebar_label: Tools
---

This guide focuses on using the Sui CLI `validator` commands. 

:::info

This tool supports only pending validators and active validators.

:::

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] Complete all [Sui installation prerequisites](/guides/developer/getting-started/sui-install.mdx#prerequisites).

- [x] Build the `sui` binary, which you need for the genesis ceremony. You can do this on any computer.

<details className="nudge-details">

<summary>

View `sui` binary installation details.

</summary>

    1. Clone the git repo:

           `$ git clone git@github.com:MystenLabs/sui.git && cd sui`

    2. Check out the commit to use for Testnet:

           `$ git checkout testnet`

    3. Build `sui` binary

           `$ cargo build --bin sui`

    4. Remember the path to your binary:

           `$ export SUI_BINARY="$(pwd)/target/debug/sui"`

</details>

- [x] Set up your Sui account and CLI environment. 

<details className="nudge-details">

<summary>

View Sui account and CLI environment instructions.

</summary>

    - If this is the first time running this program, it asks you to provide a Sui full node server URL and a meaningful environment alias. It also generates a random key pair in `sui.keystore` and a config `client.yaml`. Swap in your validator account key if you already have one.

       By default, the `client.yaml` and `sui.keystore` files are located in `~/.sui/sui_config`. For more information, refer to the [Sui client CLI tutorial](/references/cli/client.mdx).

       ```sh
       $ sui client
       ```

    - If you already set it up, just make sure:
      - `rpc` is correct in `client.yaml`. 
      - `active_address` is correct in `client.yaml`.
      - `sui.keystore` contains your account key pair.

</details>

- [x] Test your network connection and configuration by displaying your validator information:

```sh
$ sui validator display-metadata
```

</TabItem>
</Tabs>

## Using Sui CLI 
Use the Sui CLI to perform validator tasks.
### Print help information

```sh
$ sui validator --help
```

### Become a validator or join committee

To become a validator candidate, first run:

```sh
$ sui validator make-validator-info <name> <description> <image-url> <project-url> <host-name> <gas_price>
```

This generates a `validator.info` file and key pair files. The output of this command includes:
  1. Four [key pair files](./validator-tasks.mdx#key-management). **Set their permissions with the minimal visibility (`chmod 600`, for example) and store them securely**. They are needed when running the validator node.
    a. If you follow this guide thoroughly, this key pair is actually copied from your `sui.keystore` file.
  2. `validator.info` file that contains your validator information. Double check all information is correct.

Then run:

```sh
$ sui validator become-candidate path/to/validator.info
```

This submits an on-chain transaction for you to become a validator candidate. The parameter is the file path to the `validator.info` file generated in the previous step. **Make sure the transaction succeeds (printed in the output).**

At this point, you are validator candidate and can start to accept self-staking and delegated staking. 

If you haven't already, start a full node now to catch up with the network. When you officially join the committee but are not fully up-to-date, you cannot make meaningful contributions to the network and might be subject to peer reporting. This imposes the risk of reduced staking rewards for you and your delegator.

Then, you must acquire 30M SUI and stake it to the validator staking pool. You can add Sui to the validator staking pool with the command:

```sh
$ sui client call --package 0x3 --module sui_system --function request_add_stake --args 0x5 {sui_object_id} {validator_address}
```

This creates a stake object (of type `0x3::staking_pool::StakedSui`). This object can be withdrawn with the following command:

```sh
$ sui client call --package 0x3 --module sui_system --function request_withdraw_stake --args 0x5 {stake_object_id}
```

:::tip 

You cannot withdraw non-activated stake from an inactive validator. If that is the case, you should be able to withdraw after the next epoch change when the stake becomes active. 

:::

After you have staked enough, run:

```sh
$ sui validator join-committee
```

Joining the committee makes you a pending validator. A pending validator becomes active and joins the committee starting from the next epoch.


### Leave committee

To leave the committee, run:

```sh
$ sui validator leave-committee
```

You are removed from the committee starting from the next epoch.

### Proof of possession: Generate the payload

Serialize the payload that is used to generate proof of possession. This allows the signer to take the payload offline for an authority protocol BLS key pair to sign.

```sh
$ sui validator serialize-payload-pop --account-address $ACCOUNT_ADDRESS --protocol-public-key $BLS_PUBKEY
```

```sh
Serialized payload: $PAYLOAD_TO_SIGN
```

### Display validator metadata

Display metadata about your local validator:

```sh
$ sui validator display-metadata
```

Display metadata about another validator via validator address

```sh
$ sui validator display-metadata <validator-address>
```

### Update validator metadata

Run the following to see how to update validator metadata. Read description carefully about when the change takes effect.

```sh
$ sui validator update-metadata --help
```

You can update the following on-chain metadata:
- Name
- Description
- Image URL
- Project URL
- Network address
- P2P address
- Primary address
- Worker address
- Protocol public key
- Network public key
- Worker public key

:::info 
Only the first 4 metadata listed above take effect immediately. Others are changed only after the next epoch. For those, restart the validator program immediately after the next epoch, with the new key files and updated `validator.yaml` config. 

Particularly, make sure the new address is not behind a firewall.
:::

Run the following to see how to update each metadata.

```sh
$ sui validator update-metadata --help
```

### Operation Cap

Operation Cap allows a validator to authorize another account to perform certain actions on behalf of this validator. [Learn more about Operation Cap](./validator-tasks.mdx#operation-cap).

The Operation Cap holder (either the validator itself or the delegatee) updates its gas price and reports validator peers with the Operation Cap.

### Update gas price

If the account itself is a validator and holds the Operation Cap, update the gas price with:

```sh
$ sui validator update-gas-price <gas-price>
```

If the account is a delegatee:

```sh
$ sui validator update-gas-price --operation-cap-id <operation-cap-id> <gas-price>
```

### Report validators

If the account itself is a validator and holds the Operation Cap, report validators peers with:

```sh
$ sui validator report-validator <reportee-address>
```

Add the `--undo-report false` argument if it intends to undo an existing report.

Similarly, if the account is a delegatee, add the `--operation-cap-id <operation-cap-id>` option to the command.

If the account is a delegatee, run:

```sh
$ sui validator update-gas-price --operation-cap-id <operation-cap-id> <gas-price>
```

>>>> sui/docs/content/guides/operator/validator/validator-committee.mdx
---
title: Validator Node Committee
description: Sui has a committee of validators to verify on-chain transactions. Epochs, quorums, transactions, certificates, and consensus are touch points for this committee.
keywords: [ sui validator node, validator committee, epochs, quorums, write requests, transactions, certificates, consensus, verify on-chain, verify transactions on-chain, validator nodes ]
sidebar_position: 2
sidebar_label: Committee

---

A set of independent validators participate on the Sui network, each running its own instance of the Sui software on a separate machine (or a sharded cluster of machines the same entity operates). Each validator handles read and write requests sent by clients, verifying transactions and updating on-chain information.

To learn how to set up and run a Sui validator node, including how staking and rewards work, see [Sui Validator Node Configuration](./validator-config.mdx).

> **Important Update**: Sui is implementing SIP-39 to significantly lower the barrier to entry for validators. The minimum stake requirement will soon change from 30M SUI to a voting power-based threshold, reducing the required SUI to around 3M. If you're interested in becoming a validator, please [fill out this form](https://docs.google.com/forms/d/e/1FAIpQLSf6ZngRJ6Q5RdEiBfnbpUq4Htj8ShL58I6JRkmRTwTVSzeNtQ/viewform) to join validator communications.

Sui uses Delegated Proof-of-Stake (DPoS) to determine which validators operate the network and their voting power. Validators are incentivized to participate in good faith via a share of transaction fees, staking rewards, and slashing stake and staking rewards in case of misbehavior.

## Epochs 

Operation of the Sui network is temporally partitioned into non-overlapping, approximate fixed-duration (~24-hour) epochs. During a particular epoch, the set of validators participating in the network and their voting power is fixed. At an epoch boundary, reconfiguration might occur and can change the set of validators participating in the network and their voting power. Conceptually, reconfiguration starts a new instance of the Sui protocol with the previous epoch's final state as [genesis](../genesis.mdx) and the new set of validators as the operators. Besides validator set changes, tokenomics operations such as staking/un-staking, and distribution of staking rewards are also processed at epoch boundaries.

## Quorums 

A quorum is a set of validators whose combined voting power is greater than two-thirds (>2/3) of the total during a particular epoch. For example, in a Sui instance operated by four validators that all have the same voting power, any group containing three validators is a quorum.

The quorum size of >2/3 ensures Byzantine fault tolerance (BFT). A validator commits a transaction (durably store the transaction and update its internal state with the effects of the transaction) only if it is accompanied by cryptographic signatures from a quorum. Sui calls the combination of the transaction and the quorum signatures on its bytes a *certificate*. The policy of committing only certificates ensures Byzantine fault tolerance: if >2/3 of the validators faithfully follow the protocol, they are guaranteed to eventually agree on both the set of committed certificates and their effects.

## Write requests 

A validator can handle two types of write requests: transactions and certificates. At a high level, a client:

- Communicates a transaction to a quorum of validators to collect the signatures required to form a certificate.
- Submits a certificate to a validator to commit state changes on that validator.

### Transactions 

When a validator receives a transaction from a client, it first performs transaction validity checks (validity of the sender's signature). If the checks pass, the validator locks all owned-objects and signs the transaction bytes, then returns the signature to the client. The client repeats this process with multiple validators until it has collected signatures on its transaction from a quorum, thereby forming a certificate.

The process of collecting validator signatures on a transaction into a certificate and the process of submitting certificates can be performed in parallel. The client can simultaneously multicast transactions/certificates to an arbitrary number of validators. Alternatively, a client can outsource either or both of these tasks to a third-party service provider. This provider must be trusted for liveness (it can refuse to form a certificate), but not for safety (it cannot change the effects of the transaction, and does not need the user's secret key).

### Certificates / certified transactions {#certificates}

After the client forms a certificate, it submits it to the validators, which perform certificate validity checks. These checks ensure the signers are validators in the current epoch, and the signatures are cryptographically valid. If the checks pass, the validators execute the transaction inside the certificate. Execution of a transaction either succeeds and commits all of its effects or aborts and has no effect other than debiting the transaction's gas input. Some reasons a transaction might abort include an explicit abort instruction, a runtime error such as division by zero, or exceeding the maximum gas budget. Whether it succeeds or aborts, the validator durably stores the certificate indexed by the hash of its inner transaction.

If a client collects a quorum of signatures on the effects of the transaction, then the client has a promise of finality. This means that transaction effects persist on the shared database and are actually committed and visible to everyone by the end of the epoch. This does not mean that the latency is a full epoch, because you can use the effects certificate to convince anyone of the transactions finality, as well as to access the effects and issue new transactions. As with transactions, you can parallelize the process of sharing a certificate with validators and (if desired) outsource to a third-party service provider.

## The role of consensus

Sui uses a high-throughput DAG-based consensus engine implementing the Mysticeti algorithm to sequence certified transactions. Consensus produces a series of commits. In each commit, there is a sequence of certified transactions.

The order of transactions in consensus output determines the relative order they can operate on each shared object. Note that executions of transactions touching different shared objects are parallelized on multiple cores.

If total execution cost of transactions in a consensus commit is over a threshold, transactions can be cancelled post consensus to avoid overloading the system.

>>>> sui/docs/content/guides/operator/validator/validator-config.mdx
---
title: Validator Deployment & Configuration
description: Learn how to set up, configure, and manage a Sui validator node.
keywords: [ sui validator node, validator nodes, validator node configuration, configure validator node, set up validator node, manage validator ]
sidebar_position: 1
sidebar_label: Deployment & Configuration
---

Validators on Sui run specialized validator nodes that can execute more tasks than full nodes. Validators are used for staking, gas price reference, and tallying rules.

## Validator requirements

To run a Sui validator, you must set up and configure a Sui validator node. Specific steps you must take include:

1. Install and configure Sui.
2. Configure port and protocol settings.
3. Configure key management.
4. Configure storage.
5. Update software.
6. Execute on-chain commands to interact with the network.
7. Update the gas price survey.
8. Report to other validators.

### Hardware requirements

Suggested minimum hardware specifications to run a Sui validator node:

- CPU: 24 physical cores (or 48 virtual cores)
- Memory: 128 GB
- Storage: 4 TB NVME
- Network: 1 Gbps

<ImportContent source="staking-pool-reqs.mdx" mode="snippet" />

To set up staking on your validator node:

1. Call `request_add_validator_candidate` to become a candidate. This creates the on-chain validator information and initializes a staking pool for delegators to contribute to.

2. Acquire 30M SUI by staking to the validator staking pool created in the previous step. Call the `request_add_stake` with the address of the validator (this is not the same as the staking pool ID).

3. Call `request_add_validator` to have the validator become a pending validator. At the next epoch, it joins the validator set. Before the next epoch, you should stand up the validator so that when the epoch changes, it can participate.

[Learn more about validator staking rewards](./validator-rewards.mdx).

## Deployment

You can deploy Sui node in a number of ways.

1. Use pre-built container images available in [Docker Hub](https://hub.docker.com/r/mysten/sui-node/tags).

2. Use pre-built `linux/amd64` binaries available in S3 that you can fetch using one of the following methods:

```sh
$ wget https://releases.sui.io/$SUI_SHA/sui-node
```

```sh
$ curl https://releases.sui.io/$SUI_SHA/sui-node -o sui-node
```

Or, to build directly from source:

```sh
$ git clone https://github.com/MystenLabs/sui.git && cd sui
$ git checkout [SHA|BRANCH|TAG]
$ cargo build --release --bin sui-node
```

For more information on deploying a validator, refer to the [Sui for Node Operators](https://github.com/MystenLabs/sui/blob/main/nre/sui_for_node_operators.md) guide.

## Configuration

Configuration guides are available for the following deployment options:

- [Systemd](https://github.com/MystenLabs/sui/blob/main/nre/systemd/README.md)
- [Ansible](https://github.com/MystenLabs/sui/blob/main/nre/ansible/README.md)
- [Docker Compose](https://github.com/MystenLabs/sui/blob/main/nre/docker/README.md)

`sui-node` runs with a single configuration file provided as an argument, for example:

```sh 
$ ./sui-node --config-path /opt/sui/config/validator.yaml
```

For more information on configuring a validator, refer to the [Sui for Node Operators](https://github.com/MystenLabs/sui/blob/main/nre/sui_for_node_operators.md) guide.

See [Validator](https://github.com/MystenLabs/sui/blob/main/nre/config/validator.yaml) for configuration templates.

## Connectivity

`sui-node` uses the following ports by default:

| protocol/port | reachability     | purpose                           |
| ------------- | ---------------- | --------------------------------- |
| TCP/8080      | Inbound          | Validator/transaction interface   |
| TCP/8081      | Inbound/outbound | Consensus interface               |
| UDP/8084      | Inbound/outbound | Peer-to-peer state sync interface |
| TCP/8443      | Outbound         | Metrics pushing                   |
| TCP/9184      | Localhost        | Metrics scraping                  |

To run a validator successfully, it is critical that ports 8080-8084 are open as outlined, including the specific protocol (TCP/UDP).

## Network buffer

Load testing Sui validator networks suggests that the default Linux network buffer sizes are too small.
It is recommend to increase them using one of the following two methods:

### Option 1: With `/etc/sysctl.d/`

Add these settings to a new `sysctl` file specifically for `sui-node` or append to an existing file. Modifications made in this way persist across system restarts.

Create a new `sysctl` file for the `sui-node`:

```sh
$ sudo nano /etc/sysctl.d/100-sui-node.conf
```

Add these lines to the file, overwriting existing settings if necessary:

```sh 
net.core.rmem_max = 104857600
net.core.wmem_max = 104857600
net.ipv4.tcp_rmem = 8192 262144 104857600
net.ipv4.tcp_wmem = 8192 262144 104857600
```

Apply the settings immediately, before the next restart:

```sh
$ sudo sysctl --system
```

### Option 2: With `sysctl` command

These modifications do not persist across system restarts. Therefore, run the commands each time the host restarts.

```sh
$ sudo sysctl -w net.core.wmem_max=104857600
$ sudo sysctl -w net.core.rmem_max=104857600
$ sudo sysctl -w net.ipv4.tcp_rmem="8192 262144 104857600"
$ sudo sysctl -w net.ipv4.tcp_wmem="8192 262144 104857600"
```

### Verification

To verify that the system settings have successfully been updated, check the output of the following command:

```sh
$ sudo sysctl -a | egrep [rw]mem
```

>>>> sui/docs/content/guides/operator/validator/validator-rewards.mdx
---
title: Validator Node Rewards
description: Learn how validator user and staker rewards are calculated and distributed. 
keywords: [ manage staking, manage gas price reference, tally rules, validator tally rules, validator staking, validator consensus, validator voting power, user staking and rewards, slashing, tallying ]
sidebar_position: 3
sidebar_label: Rewards
---

The total voting power on Sui is always 10,000, regardless of the amount staked. Therefore, the quorum threshold is 6,667. There is no limit to the amount of SUI users can stake with a validator. Each validator has consensus voting power proportional to SUI in its staking pool, with one exception: the voting power of an individual validator is capped at 1,000 (10% of the total). If a validator accumulates more than 10% of total stake, the validator's voting power remains fixed at 10%, and the remaining voting power is spread across the rest of the validator set.

## User staking and rewards

When users stake SUI tokens, the tokens are wrapped into `StakedSUI` objects. A userâ€™s share of the staking pool is calculated using the timestamp of their `StakedSUI` object, which records when the deposit occurred, along with the change in exchange rates between the deposit epoch and the withdrawal epoch.  

Each staking pool maintains a time series of its exchange rates. This data allows the system to determine the correct withdrawal amount for any staker in the pool.

### Find the exchange rate 

Each epoch change emits a `0x2::validator_set::ValidatorEpochInfo` event per validator with the exchange rate information. You can use the Events API to query events.

### Rewards 

A stake deposit request goes into a pending state immediately in the staking pool as soon as it is made. Sui Wallet reflects any pending stake deposit requests for the user's account. However, pending stake deposit requests do not take effect until the end of the epoch during which the request is made.

A withdrawal (un-stake) request is processed immediately as soon as it is received. The staker obtains the originally deposited SUI together with all accrued stake rewards up to the previous epoch boundary, meaning they do not include stake rewards for the current epoch.

Users can't withdraw a portion of their active stake. They must withdraw all staked SUI at the same time. Users can, however, stake using multiple `StakedSui` objects by splitting their SUI into multiple coins. They can then perform a partial withdrawal from a validator by un-staking only some of the `StakedSUI` objects.

### Withdrawals 

Stake withdrawals are processed immediately with the exchange rate prevailing at the previous epoch's exchange rate. Withdrawals do not have to wait for the current epoch to close. Withdrawals include both the original stake the user deposited and all the stake rewards accumulated up to the previous epoch. Stakers do not earn the rewards accruing to their stake during the epoch at which they withdraw. Since there is no way to know how many stake rewards will be accumulated during the current epoch until the epoch closes, these cannot be included in the withdrawal. Hence, any user can withdraw their stake immediately and receive:

$$
SUI withdrawn at E' = ( SUI deposited at E ) * ( Exchange Rate at E'-1 / Exchange Rate at E )
$$

## Staker rewards 

Within a given validator staking pool, all stakers receive the same proportion of rewards through the pool's exchange rate appreciation. Because validators earn commissions over the stake they manage, they receive additional `StakedSUI` objects at the end of each epoch in proportion to the amount of commissions their staking pool earns.

Staking rewards are funded by transaction gas fees collected during the current epoch and by stake subsidies released at the end of the epoch.

$$
StakeRewards = StakeSubsidies + GasFees
$$

Stake subsidies are intended to subsidize the network during its early phases and are funded by a 10% allocation of SUI tokens. After this allocation depletes, the entirety of stake rewards will be made up of gas fees collected through regular network operations.

Stake rewards are made up of gas fees and stake subsidies. The total amount distributed throughout each epoch is determined as follows:

- **Stake subsidies:** The amount distributed in each epoch is determined prior to the beginning of the epoch according to a predefined schedule.
- **Gas fees:** Each epoch's amount depends on the total gas fees collected throughout the epoch. Each Sui transaction pays gas fees depending on two variables, the amount of executed gas units and the gas price:

$$
_GasFee = GasPrice _ GasUnits
$$

The total amount of gas fees collected corresponds to the sum of gas fees across all transactions processed in the epoch. During regular market conditions, the vast majority of transactions should have a `GasPrice` equal to the `ReferenceGasPrice`.

## Reference gas price 

Sui is designed such that end-users can expect the gas price to be stable and predictable during regular network operations. This is achieved by having validators set the network's reference gas price at the beginning of each epoch.

Operationally this is achieved through a gas price survey that occurs as follows:

- During each epoch E, each validator submits what they think the optimal reference gas price should be for the next epoch E+1.
- At the epoch boundary, when Sui transitions from epoch E to epoch E+1, the network observes the gas price quotes across the validator set and sets the 2/3 percentile weighted by stake as the epoch's reference gas price. Hence the reference gas price is constant throughout each epoch and is only updated when the epoch changes.

For example, assume that there are seven validators with equal stake, and the price quotes they submit are `{15, 1, 4, 2, 8, 3, 23}`. The protocol sets the reference gas price at 8.

In practice, the process for submitting a gas price quote for the Gas Price Survey is a straightforward one. Each validator owns an object that contains their quote for the reference gas price. To change their response, they must update the value in that object.

For example, to set the price quote for the next epoch to 42, run:

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client call --package <PACKAGE-ID> --module sui_system --function request_set_gas_price --args 0x5 \"42\" --gas-budget <GAS-AMOUNT>
```

Importantly, the gas object's value persists across epochs so that a validator who does not update and submit a new quote uses the same quote from the previous epoch. Hence, a validator seeking to optimize its own operations should update its quote every epoch in response to changes in network operations and market conditions.

## Validator slashing and tallying rule 

Sui is designed to encourage and enforce community monitoring of the validator set. This is done through the tallying rule by which each validator monitors and scores every other validator in order to ensure that everyone is operating efficiently and in the network's best interest. Validators that receive a low score can be penalized with slashed stake rewards.

The protocol only computes the global tallying rule score at the epoch boundary and so relies on validators monitoring actively and changing their individual scores whenever they detect changes in other validator behavior. In general, the tallying rule default option should always be a score of one for all validators and only be changed to zero upon determining bad operations. In practice, the tallying rule consists of a set of objects each validator owns that default to scores of one and thus a validator will generally be passive and only update the object corresponding to another validator's score whenever needed.

For example, to report a validator whose Sui address is `0x44840a79dd5cf1f5efeff1379f5eece04c72db13512a2e31e8750f5176285446` as bad or non-performant, run:

```sh
$ sui client call --package <PACKAGE-ID> --module sui_system --function report_validator --args 0x5 0x44840a79dd5cf1f5efeff1379f5eece04c72db13512a2e31e8750f5176285446 --gas-budget <GAS-AMOUNT>
```

The tallying rule should be implemented through a social equilibrium. The validator set should actively monitor itself and if one validator is clearly non-performant, then the other validators should score that validator with a 0 and slash its rewards. Community members can launch public dashboards tracking validator performance and that can be used as further signal into a validator's operations. There is no limit on the number of validators that can receive a 0 tallying score in an epoch.

>>>> sui/docs/content/guides/operator/validator/validator-tasks.mdx
---
title: Validator Node Management
description: As a validator on Sui, there are some processes you need to perform to ensure your nodes are always optimized.
keywords: [ run sui validator, sui validator tasks, running a validator node, running validator, deploy validator node, configure validator node, node storage, node metrics, node logs, node dashboards, state sync, node updates, joining the validator set, leaving the validator set, private security fixes ]
sidebar_position: 4
sidebar_label: Management
---

As a validator on Sui, there are some processes you need to perform to ensure your nodes are always optimized.

## Storage management

All `sui-node` related data is stored by default under `/opt/sui/db/`. This is specified in the `sui-node` configuration file.

```sh
$ cat /opt/sui/config/validator.yaml | grep db-path
```

```
  db-path: /opt/sui/db/authorities_db
  db-path: /opt/sui/db/consensus_db
```

Ensure that you have an appropriately sized disk mounted for the database to write to.

- To check the size of the local `sui-node` databases:

```sh
$ du -sh /opt/sui/db/
$ du -sh /opt/sui/db/authorities_db
$ du -sh /opt/sui/db/consensus_db
```

- To delete the local `sui-node` databases:

```sh
$ sudo systemctl stop sui-node
$ sudo rm -rf /opt/sui/db/authorities_db /opt/sui/db/consensus_db
```

## Key management

The following keys are used by `sui-node`:

| Key          | Scheme   | Purpose                         |
| ------------ | -------- | ------------------------------- |
| `protocol.key` | bls12381 | Transactions                    |
| `account.key`  | ed25519  | Controls assets for staking     |
| `network.key`  | ed25519  | State sync                      |
| `worker.key`   | ed25519  | Consensus (to be migrated)      |

These are configured in the [`sui-node` configuration file](./validator-config.mdx).

## Metrics

`sui-node` exposes metrics via a local HTTP interface. These can be scraped for use in a central monitoring system, as well as viewed directly from the node.

- View all metrics:

```sh
$ curl -s http://localhost:9184/metrics
```

- Search for a particular metric:

```sh
$ curl http://localhost:9184/metrics | grep <METRIC>
```

`sui-node` also pushes metrics to a central Sui metrics proxy.

## Logs

Logs are controlled using the `RUST_LOG` environment variable.

The `RUST_LOG_JSON=1` environment variable can optionally be set to enable logging in JSON structured format.

Depending on your deployment method, these are configured in the following places:

- [Ansible](https://github.com/MystenLabs/sui/blob/main/nre/ansible/roles/sui-node/files/sui-node.service)
- [Native systemd](https://github.com/MystenLabs/sui/blob/main/nre/systemd/sui-node.service)
- [Docker Compose](https://github.com/MystenLabs/sui/blob/main/nre/docker/docker-compose.yaml)

To view and follow the `sui-node` logs:

```sh
$ journalctl -u sui-node -f
```

To search for a particular match:

```sh
$ journalctl -u sui-node -g <SEARCH_TERM>
```

- If you are using Docker Compose, look at the [examples in the README](https://github.com/MystenLabs/sui/blob/main/nre/docker/README.md#logs).

It is possible to change the logging configuration while a node is running using the admin interface.

To view the currently configured logging values:

```sh
$ curl localhost:1337/logging
```

To change the currently configured logging values:

```sh
$ curl localhost:1337/logging -d "info"
```

## Dashboards

Public dashboard for network-wide visibility:

- [Sui Testnet Validators](https://metrics.sui.io/public-dashboards/9b841d63c9bf43fe8acec4f0fa991f5e)

## Software updates

When an update is required to the `sui-node` software, the following process can be used. Follow the relevant Systemd or Docker Compose run book depending on your deployment type. It is highly unlikely that you want to restart with a clean database.

- [Systemd](https://github.com/MystenLabs/sui/blob/main/nre/systemd/README.md#updates)
- [Docker Compose](https://github.com/MystenLabs/sui/blob/main/nre/docker/README.md#updates)

## State sync

Checkpoints in Sui contain the permanent history of the network. They are comparable to blocks in other blockchains with one big difference being that they are lagging instead of leading. All transactions are final and executed prior to being included in a checkpoint.

These checkpoints are synchronized between validators and full nodes via a dedicated peer-to-peer state sync interface.

Inter-validator state sync is always permitted, however there are controls available to limit what full nodes are allowed to sync from a specific validator.

The default and recommended `max-concurrent-connections: 0` configuration does not affect inter-validator state sync, but restricts all full nodes from syncing. The [`sui-node` configuration](./validator-config.mdx) can be modified to allow a known full node to sync from a validator:

```sh
p2p-config:
  anemo-config:
    max-concurrent-connections: 0
  seed-peers:
    - address: <multiaddr>  # The p2p address of the full node
      peer-id: <peer-id>    # hex encoded network public key of the node
    - address: ...          # another permitted peer
      peer-id: ...
```

## Chain operations

The following chain operations are executed using the `sui` CLI. This binary is built and provided as a release similar to `sui-node`, for example:

```sh
$ wget https://releases.sui.io/$SUI_SHA/sui
$ chmod +x sui
```

```sh
$ curl https://releases.sui.io/$SUI_SHA/sui -o sui
$ chmod +x sui
```

It is recommended and often required that the `sui` binary release/version matches that of the deployed network.

### Updating on-chain metadata

You can leverage the [validator tool](https://github.com/MystenLabs/sui/blob/main/nre/validator_tool.md) to perform a majority of the following tasks.

An active/pending validator can update its on-chain metadata by submitting a transaction. Some metadata changes take effect immediately, including:

- Name
- Description
- Image URL
- Project URL

Other metadata (keys, addresses, and so on) only come into effect at the next epoch.

To update metadata, a validator makes a `MoveCall` transaction that interacts with the system object. For example:

1. To update `name` to `new_validator_name`, use the Sui Client CLI to call `sui_system::update_validator_name`:

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client call --package 0x3 --module sui_system --function update_validator_name --args 0x5 \"new_validator_name\" --gas-budget 10000
```

2. To update the p2p address starting from next epoch to `/ip4/192.168.1.1`, use the Sui Client CLI to call `sui_system::update_validator_next_epoch_p2p_address`:

```sh
$ sui client call --package 0x3 --module sui_system --function update_validator_next_epoch_p2p_address --args 0x5 "[4, 192, 168, 1, 1]" --gas-budget 10000
```

See the [full list of metadata update functions](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-system/sources/sui_system.move#L267-L444).

### Operation Cap

To avoid touching account keys too often and allowing them to be stored off-line, validators can delegate the operation ability to another address. This address can then update the reference gas price and tallying rule on behalf of the validator.

Upon creating a validator, a `UnverifiedValidatorOperationCap` is created and transferred to the validator address. The holder of this `Cap` object (short for "Capability") therefore could perform operational actions for this validator. To authorize another address to conduct these operations, a validator transfers the object to another address that they control. 

The transfer can be done by using Sui Client CLI: `sui client transfer`.

To rotate the delegatee address or revoke the authorization, the current holder of `Cap` transfers it to another address. In the event of compromised or lost keys, the validator could create a new `Cap` object to invalidate the incumbent one. 

This is done by calling `sui_system::rotate_operation_cap`:

```sh
$ sui client call --package 0x3 --module sui_system --function rotate_operation_cap --args 0x5 --gas-budget 10000
```

By default, the new `Cap` object is transferred to the validator address, which then could be transferred to the new delegatee address. At this point, the old `Cap` becomes invalidated and no longer represents eligibility.

To get the current valid `Cap` object's ID of a validator, use the Sui Client CLI `sui client objects` command after setting the holder as the active address.

### Updating the gas price survey quote

To update the gas price survey quote of a validator, which is used to calculate the reference gas price at the end of the epoch, the sender needs to hold a valid [`UnverifiedValidatorOperationCap`](#operation-cap). The sender could be the validator itself or a trusted delegatee. 

To do so, call `sui_system::request_set_gas_price`:

```sh
$ sui client call --package 0x3 --module sui_system --function request_set_gas_price --args 0x5 {cap_object_id} {new_gas_price} --gas-budget 10000
```

### Reporting/un-reporting validators

To report a validator or undo an existing report, the sender needs to hold a valid [`UnverifiedValidatorOperationCap`](#operation-cap). The sender could be the validator itself or a trusted delegatee. 

To do so, call `sui_system::report_validator/undo_report_validator`:

```sh
$ sui client call --package 0x3 --module sui_system --function report_validator/undo_report_validator --args 0x5 {cap_object_id} {reportee_address} --gas-budget 10000
```

After a validator is reported by `2f + 1` other validators by voting power, their staking rewards are slashed.

### Joining the validator set

For a Sui address to join the validator set, they need to first sign up as a validator candidate by calling `sui_system::request_add_validator_candidate` with their metadata and initial configs:

```sh
$ sui client call --package 0x3 --module sui_system --function request_add_validator_candidate --args 0x5 {protocol_pubkey_bytes} {network_pubkey_bytes} {worker_pubkey_bytes} {proof_of_possession} {name} {description} {image_url} {project_url} {net_address} {p2p_address} {primary_address} {worker_address} {gas_price} {commission_rate} --gas-budget 10000
```

After an address becomes a validator candidate, any address (including the candidate address itself) can start staking with the candidate's staking pool. After a candidate's staking pool has accumulated at least `sui_system::MIN_VALIDATOR_JOINING_STAKE` amount of stake, the candidate can call `sui_system::request_add_validator` to officially add themselves to next epoch's active validator set:

```sh
$ sui client call --package 0x3 --module sui_system --function request_add_validator --args 0x5 --gas-budget 10000000
```

### Leaving the validator set

To leave the validator set starting next epoch, the sender needs to be an active validator in the current epoch and should call `sui_system::request_remove_validator`:

```sh
$ sui client call --package 0x3 --module sui_system --function request_remove_validator --args 0x5 --gas-budget 10000
```

After the validator is removed at the next epoch change, the staking pool becomes inactive and stakes can only be withdrawn from an inactive pool.

## Private security fixes

There might be instances where urgent security fixes need to be rolled out before publicly announcing its presence (issues affecting liveliness, invariants such as SUI supply, governance, and so on). To not be actively exploited, Mysten Labs releases signed security binaries incorporating such fixes with a delay in publishing the source code until a large percentage of our validators have patched the vulnerability.

This release process is different and you should expect that announcements of the directory for such binaries are out of band.
[View the public key used to verify these binaries](https://sui-private.s3.us-west-2.amazonaws.com/sui_security_release.pem)

There is also a script available that downloads all the necessary signed binaries and Docker artifacts incorporating the security fixes.

- Usage: `./download_private.sh <directory-name>`

You can also download and verify specific binaries that might not be included by the above script using the `download_and_verify_private_binary.sh` script.

- Usage: `./download_and_verify_private_binary.sh <directory-name> <binary-name>`

>>>> sui/docs/content/guides/suiplay0x1.mdx
---
title: SuiPlay0X1 Development Guide for Game Developers
description: Learn how to build games for the SuiPlayX01 handheld gaming device.
keywords: [ suiplayx01, handheld console, console gaming, Web3 gaming, gamefi ]
pagination_prev: null
---

This guide provides an overview and recommendations for game developers building for the [SuiPlay0X1](https://www.suiplay0x1.com/) handheld gaming device. The SuiPlay0X1 is a first-of-its-kind handheld gaming console for Web3. It supports a wide range of PC games, as well as new AAA titles developed using Sui technology. 

Unlike traditional gaming where assets are locked within individual games, Web3 gaming enables true digital ownership through blockchain wallets. Players can own, trade, and transfer their in-game assets across different games and platforms. On the SuiPlay0X1, wallet integration is central to delivering this enhanced gaming experience.

<ImportContent source="suiplay.mdx" mode="snippet" />

<Cards>
<Card title="Integration" href="/guides/suiplay0x1/integration">
</Card>
<Card title="Migration Strategies" href="/guides/suiplay0x1/migration-strategies">
</Card>
<Card title="Wallet Integration" href="/guides/suiplay0x1/wallet-integration">
</Card>
<Card title="Best Practices" href="/guides/suiplay0x1/best-practices">
</Card>
</Cards>
>>>> sui/docs/content/guides/suiplay0x1/best-practices.mdx
---
title: Best Practices
description: Adhere to best practices when developing for SuiPlay0X1.
keywords: [ SuiPlay0X1, beamable, shinami, data management, handling transactions, on-chain storage, off-chain storage ]
---

<ImportContent source="suiplay.mdx" mode="snippet" />

There are some best practices to consider when developing for SuiPlay0X1. 

## Handling transactions

Avoid frequent micro-transactions: If players are using their self-custody wallets and transactions require explicit player signatures, then you should avoid frequent micro-transactions, particularly during gameplay. Signing a transaction requires popping up an on-device visual element or an off-device browser dialog to approve, breaking the gameplay flow. This is not a concern if you are managing custodial wallets on behalf of the player. See [Wallet Integration Options](./wallet-integration.mdx) for more information on available wallet integrations.

Many on-chain actions do not require explicit user approval. For example, dropping rewards to a user, incrementing their currency, and so on. The game can be handle these whenever appropriate, even silently in the background during gameplay.

## Managing gas

If using a third-party wallet service ([Beamable](https://beamable.com/), [Shinami](https://www.shinami.com/)), leverage gas sponsorship for custodial implementations to abstract from users. Consider tradeoffs between aggregated and individual wallets and batch transactions whenever possible to reduce gas costs.

## Data management

Proper data management design can augment the user experience.

### On-chain versus off-chain storage

Consider where best to store your data:

- **On-chain:** Assets and currencies that can be traded or sold.  
- **Off-chain:** Game state, progress, and so on using traditional game servers.

While you can store any information on-chain, consider whether itâ€™s important to your game for that data to exist there. If not, leverage traditional game server backends, which makes data syncing and updating easier.

### Session start protocol

Always check wallet state at session beginning and don't cache wallet data between sessions as assets can change externally.

## Related links

<RelatedLink href="https://github.com/playtron-os/playtron-sdk" label="Playtron GameOS SDK" desc="The official Playtron OS SDK repository on GitHub." />
<RelatedLink href="https://sdk.mystenlabs.com/dapp-kit" label="Sui dApp Kit documentation" desc="The Sui dApp Kit is a set of React components, hooks, and utilities to help you build a dApp for the Sui ecosystem." />
<RelatedLink href="https://discord.gg/suiplay" label="SuiPlay0X1 Discord" desc="Follow announcements and connect with the community on the Discord channel for SuiPlay0X1." />
<RelatedLink to="/guides/suiplay0x1/wallet-integration.mdx" />

>>>> sui/docs/content/guides/suiplay0x1/integration.mdx
---
title: SDK Integrations
description: Integrate with SuiPlay0X1 using the Playtron GameOS SDK. 
keywords: [ playtron, playtron gameOS, gameOS SDK, C++, C#, node.js, dApp kit, sui dApp kit, self-custody wallets, playtron wallets, gaming, suiplay0x1 ]
---

<ImportContent source="suiplay.mdx" mode="snippet" />

Your integration options depend on the environments you expect your users to interact with your game. 

## On device integration

For on-device game integration, you need the [Playtron GameOS SDK](https://github.com/playtron-os/playtron-sdk). The SDK provides access to OS-level features, such as environment detection, remote PACT attestation, virtual keyboard and browser utilities, and Sui wallet integration.

The Playtron GameOS SDK repository contains the installation and initialization steps to begin development. The repository also contains examples on how to use the SDK in C++, C#, and Node.js environments. The .dll build files needed to compile the C++ code are provided. For the C# and Node.js examples, you can install the necessary dependencies from the respective package manager.

The Playtron GameOS SDK provides automatic wallet access with the following benefits:

- Users already have a Playtron wallet through their Playtron account.
- No additional wallet setup required on-device.
- Games can immediately access wallet functions through the SDK.

## Off-device integration

For off-device integration, use the [Sui dApp Kit](https://sdk.mystenlabs.com/dapp-kit). By integrating the Sui dApp Kit, your game can continue to use the Playtron zkLogin wallet when not running directly on the SuiPlay0X1 device. This is useful if your game is available on the web, desktop, or mobile devices.

The Sui dApp Kit documentation site (linked in the previous paragraph), provides the installation instructions for the SDK. With the SDK integrated into your gaming project, you can enable Playtron zkLogin wallet as a connection option.
 
The dApp Kit runs in TypeScript, meaning your game needs TypeScript processing to integrate with this SDK. If your game is a web-based game, or you navigate users to a browser to perform Web3 transactions on your associated website, this should not be an issue. 

If you're unable to run TypeScript, you can always support sending assets from your wallet to the Playtron wallet. Users can also access their Playtron wallet address via the [companion web application](https://wallet.playtron.one). Finally, you can support sending assets from your game on a different platform. For example, the user can use your PC client to transfer assets to their Playtron wallet, then continue playing on-device.

### Supported wallet types

* **Playtron wallet:** Seamless continuation from on-device sessions.  
* **Self-custody options:** Support for any wallet available through the Sui dApp Kit (such as [Slush wallet](https://slush.app/), [Phantom](https://phantom.com/), [Backpack](https://backpack.app/)) to include future wallet integrations.

## Related links

<RelatedLink href="https://github.com/playtron-os/playtron-sdk" label="Playtron GameOS SDK" desc="The official Playtron OS SDK repository on GitHub." />
<RelatedLink href="https://sdk.mystenlabs.com/dapp-kit" label="Sui dApp Kit documentation" desc="The Sui dApp Kit is a set of React components, hooks, and utilities to help you build a dApp for the Sui ecosystem." />
<RelatedLink href="https://discord.gg/suiplay" label="SuiPlay0X1 Discord" desc="Follow announcements and connect with the community on the Discord channel for SuiPlay0X1." />
<RelatedLink href="https://wallet.playtron.one" label="Companion web application" desc="Support linking the Playtron wallet to other self-custody wallets using Sui Link, enabling read-access of associated wallets while on the device." />
<RelatedLink href="https://docs.enoki.mystenlabs.com/enoki-connect" label="Enoki Connect" desc="With Enoki Connect, users can use their dApp-specific accounts across different dApps, enabling a more unified and consistent experience." />

>>>> sui/docs/content/guides/suiplay0x1/migration-strategies.mdx
---
title: Broader Sui Ecosystem Support
description: SuiPlay0X1 is part of the Sui gaming ecosystem. Users can migrate accounts between on-device and off-device versions of a game. 
keywords: [ suiplayx01, playtron, sui dApp kit, off-device users, on-device users, sui gaming, on-device gaming, off-device gaming, playtron wallet, off-device play, on-device play, dApp kit, migrate off-device to on-device, migrate on-device to off-device ]
---

<ImportContent source="suiplay.mdx" mode="snippet" />

The SuiPlay0X1 is one part of a larger ecosystem of Sui gaming. Users might play your game for the first time on the device, and later decide to continue playing your game on PC. Or, they might have already played your game before on PC with their own mnemonic wallet and want to continue playing on the device.

As a result, itâ€™s important to consider the different possible migration flows for your game both for new users and existing ones.

## On-device â‡’ off-device

If a user starts playing your game on-device first, and you have added support using dApp Kit, then their Playtron wallet is their primary wallet. Off-device play is automatically supported with the same wallet.

**Automatic transition**

- Integrate Sui dApp Kit in your off-device version.
- Enable Playtron wallet as connection option.
- Users can seamlessly continue with same wallet across platforms.

:::info

The Playtron wallet is portable and can connect to any dApp using the Sui dApp Kit.

:::

**Asset management**

- All assets remain accessible across platforms.
- No manual transfer required.
- Users can connect their Playtron wallet to marketplaces, DeFi protocols, and other dApps that support Playtron wallet.

## Off-device â‡’ on-device

If a user starts playing your game off-device first, their primary wallet depends on what wallet architecture you choose in your game design (custodial, self-custody, or game-specific zkLogin). Depending on what kind of wallet interactions your game requires during gameplay, you have different options for supporting cross-device gameplay. To learn more about wallet options, see [Wallet Integration Options](./migration-strategies.mdx).

### Read-only asset access

If your game only needs to read the list of assets from a wallet during gameplay (for example, to determine if a user owns an NFT to grant them status in game), then users can link their Playtron wallet to their existing self-custody wallet.

Examples where read-only is adequate:

- Soulbound assets, such as a proof of attendance protocol (POAP).
- An NFT representing membership access. 
- An NFT representing an unlocked skin that canâ€™t be transacted on while playing the game (but can be traded separately on a third-party NFT marketplace).

Users login to the Playtron wallet via the companion web site ([https://wallet.playtron.one](https://wallet.playtron.one)) to link their Playtron wallet to their existing wallet. This works for tying the Playtron wallet to self-custody wallets. This doesn't work for tying to custodial wallets, but that shouldn't be necessary as your game's backend can track users' assets across devices (such as through a user ID or Steam/EGS login).

If you are using a game-specific zkLogin wallet, a properly configured [Enoki Connect](https://docs.enoki.mystenlabs.com/enoki-connect) can link your game-specific zkLogin wallet with the Playtron wallet.  

Games can read from the linked wallet and act based on contents. There are no transaction capabilities with linked assets, however.

### Full asset access

If your game requires the user to sign or approve transactions to act on assets in their wallet during gameplay, users need to transfer their assets from their existing self-custody wallet to their Playtron zkLogin wallet. Examples where you might need full asset access include:

- Tokens that represent game currency and users can spend during the course of gameplay.
- NFTs that can be traded from inside your game that require signed transactions.

For self-custody and game-specific zkLogin wallets, users must transfer assets from original self-custody wallets to Playtron wallets. For custodial wallets, there is no need as your game backend can track the userâ€™s assets across devices (such as through a user ID or Steam/EGS login).

Transfer enables full transaction capabilities on-device. The companion web app provides user-friendly transfer flows  

:::tip

If you are using a game-specific zkLogin wallet, to use the companion web app requires Enoki Connect support.

:::

## Related links

<RelatedLink href="https://github.com/playtron-os/playtron-sdk" label="Playtron GameOS SDK" desc="The official Playtron OS SDK repository on GitHub." />
<RelatedLink href="https://sdk.mystenlabs.com/dapp-kit" label="Sui dApp Kit documentation" desc="The Sui dApp Kit is a set of React components, hooks, and utilities to help you build a dApp for the Sui ecosystem." />
<RelatedLink href="https://discord.gg/suiplay" label="SuiPlay0X1 Discord" desc="Follow announcements and connect with the community on the Discord channel for SuiPlay0X1." />
<RelatedLink href="https://wallet.playtron.one" label="Companion web application" desc="Support linking the Playtron wallet to other self-custodied wallets using Sui Link, enabling read-access of associated wallets while on the device." />
<RelatedLink href="https://docs.enoki.mystenlabs.com/enoki-connect" label="Enoki Connect" desc="With Enoki Connect, users can use their dApp-specific accounts across different dApps, enabling a more unified and consistent experience." />

>>>> sui/docs/content/guides/suiplay0x1/wallet-integration.mdx
---
title: Wallet Integration Options
description: SuiPlay0X1 supports integration with several wallet solutions, including self-custodial wallets, zkLogin wallets, Playtron wallets, and custodial wallets.
keywords: [ self-custodial wallets, zkLogin wallets, Playtron wallets, custodial wallets, wallet integrations, integrate with a wallet, suiplay0x1, integrate wallet with suiplay0x1, integrate with suiplay0x1, SuiLink, SuiLink, enoki, soulbound, nfts  ]
---

<ImportContent source="suiplay.mdx" mode="snippet" />

You have several options for what wallet you develop for on the SuiPlay0X1. There are some concepts to keep in mind when deciding which wallets to target.

- [Self-custodial wallets](#self-custodial-wallets): Users control their private keys and own their assets directly.
- [zkLogin wallets](#zkLogin-wallets): Traditional zkLogin wallets (or [Enoki](https://enoki.mystenlabs.com/) wallets) are a unique wallet type to Sui. zkLogin wallets are tied to a Web2 auth provider (such as Google OAuth). The user authenticates with their traditional auth provider, which associates a wallet to their social account by utilizing zero knowledge proofs. This grants them access to their zkLogin wallet through an ephemeral key pair that does not correlate auth provider user metadata with their on-chain attributed address. If the ephemeral key pair resides on the client side, the zkLogin wallet is self-custodial.
- [Playtron zkLogin wallet](#playtron-zkLogin-wallet): The Playtron zkLogin wallet is a special zkLogin wallet tied to the user's Playtron credentials. Every user who has a SuiPlay0X1 device has a Playtron login, and therefore possess an associated Playtron zkLogin wallet.
- [Custodial wallets](#custodial-wallets): Developers manage wallets on behalf of users (similar to traditional gaming databases) except on chain. Users don't need to create or bring a wallet, or to even understand what a wallet is. This smooths out the initial experience, but you still need to confront this issue downstream for users to actually benefit from the Web3 aspects of your game.

### Self-custodial wallets {#self-custodial-wallets}

With self-custodial wallets, users control their private keys and own their assets directly. Users that already own a wallet are typically familiar with wallet functionality and seed phrase security and storage. For users new to Web3, you must guide them through the process of obtaining a wallet and educating them on proper seed phrase management.

With self-custodial wallets, the usual payment flow has users pay their own gas fees, which reduces your costs but requires users to fund their wallets to pay for transactions. You can change this flow through the use of [sponsored transactions](https://docs.sui.io/concepts/transactions/sponsored-transactions) where you pay gas fees on behalf of your users. This can reduce friction for users (especially new-to-Web3 users) because you can make the wallet onboarding experience considerably less involved for users. You must consider the long-term financial impact for your project, however, and make sure the sponsored transactions you offer are sustainable for your goals. 
 
Self-custodial wallets have the most portability in terms of being able to interact with other applications on chain.

### zkLogin wallets {#zkLogin-wallets}

zkLogin wallets are a unique wallet type to Sui. These wallets provide familiar login methods from Web2 authorization providers (such as Google, Facebook, or Twitch OAuth). The user authenticates with their chosen provider, then zkLogin attaches on-chain wallet credentials to that account.

The zkLogin wallet uses an ephemeral key pair that does not correlate user metadata from authorization providers to on-chain wallets. Ephemeral key pairs are kept on the client side, making zkLogin wallets self-custodial. This eliminates the need for your users to write down seed phrases or otherwise securely store private keys.

In their simplest form, zkLogin wallets are siloed to the app that creates them. Users essentially create a new wallet for each application that supports zkLogin. This model is intentional to prevent users from having to remember passports for each wallet instance, and to match their expectations for Web2. If your intent is to keep your users in your game without the need to connect their wallet to another application, the simple zkLogin is a good choice.

[Enoki by Mysten Labs](https://enoki.mystenlabs.com/) is a SaaS solution that allows you to access zkLogin, sponsored transactions, and more using an API key for a monthly fiat subscription. Use Enoki for zkLogin functionality enables Enoki Connect access. Enoki Connect enables portability for your embedded zkLogin wallet where other applications can choose to allow users to connect via your game wallet. See the [Enoki Connect documentation](https://docs.enoki.mystenlabs.com/enoki-connect) for more details.

### Playtron zkLogin wallet {#playtron-zkLogin-wallet}

The Playtron wallet is a type of zkLogin wallet that offers a few unique features:
- Direct integrations with the GameOS running on the SuiPlay0X1, which enables users to sign transactions seamlessly on the device.
- Support for Enoki Connect out of the box, making it portable across dApps.

A companion web application is in development to support linking the Playtron wallet to other self-custody wallets using SuiLink, enabling read-access of associated wallets while on the device.

### Custodial wallets {#custodial-wallets}

With custodial wallets, you manage wallets on behalf of your users. The experience is similar to traditional gaming databases, except on chain. Custodial wallets eliminate the need for a user to create or bring a wallet, or to even understand what a wallet is. This greatly reduces onboarding friction, but you still need to educate users downstream for them to actually benefit from the Web3 aspects of your game.

Custodial wallets can either be aggregated or individual. In the aggregated case, all user assets are pooled together in a single wallet, and the game uses an off-chain database to track which assets belong to which individuals. Transferring assets between players does not result in any on-chain activity, only a database update. For example, if player A sells a sword to player B, you capture the object swap in a database rather than performing an on-chain transaction.

:::info

Aggregated custodial wallets can obfuscate some on-chain metrics, which can be an issue if you want external verification of your game's on-chain activity through third parties or Sui network explorers. For example, if you launch a token for your game, potential investors can't assess how many active players your dApp has if your game uses an aggregated wallet.

:::

In the individual case, each user gets their own custodial wallet that you manage as the game developer. Transferring assets between players results in on-chain activity and you pay the gas fee costs.

Users can't interact with other third-party dApps on chain (such as NFT marketplaces) using custodial wallets.

:::tip 

Be careful when selecting a third-party custodial wallet provider as this might have downstream risks if the wallet vendor goes out of business.

:::

## Selecting the optimal wallet integration

The best wallet to select for your dApp depends on the goals of your project. There is usually not a single, best solution, but some choices are better than others when weighing the tradeoffs between different approaches.

## Requirements

While the wallet strategy is left to you as the developer, there are some requirements for working with the SuiPlay0X1:

### On-device

Games that run on the SuiPlay0X1 device must support the Playtron zkLogin wallet as the default option.  

You can't require users to sign transactions off-device for gameplay while playing on the SuiPlay0X1.  

There is no guarantee that players have access to their other self-custody wallets or can access a non-Playtron zkLogin wallet.

### Off-device 

Off-device games that run on different platforms (like Windows PC) must use the Sui [dApp Kit](https://sdk.mystenlabs.com/dapp-kit) to enable cross-platform play with the same wallet.

## Wallet strategies

The following strategies offer some recommendations on how to best address the relevant scenarios' needs.

### Option 1: Playtron zkLogin wallet plus dApp Kit combo (Recommended)

- On-device, the game uses the Playtron wallet as default.
- Off-device, the game uses dAppKit to enable the user to use the Playtron wallet, or bring their own self-custody wallet through a web portal.
- If the user has initially played off-device with their own self-custody wallet, they can use our [companion app](https://wallet.playtron.one) to link their wallet to their Playtron wallet. If playing the game requires:
  - Only read access: The game can run on-device and read linked self-custody wallets, functioning normally. 
  - Transacting: Users can transfer assets from their self-custody wallet to their Playtron wallet, facilitated by the companion app.

**Benefits**

- Users maintain control of their private keys enforcing true ownership.
- Seamless transition between on-device and off-device gameplay.
- Enhanced security and user sovereignty.
- On-device, the wallet experience is seamless and familiar to traditional gamers.
- Users who have existing wallets can still use them off-device.

On the SuiPlay0X1 device, use the Playtron wallet as default. Off-device, users can continue with their Playtron wallet (assuming you have integrated the dApp Kit SDK).

### Option 2: Custodial wallets with per-user allocation

- Create individual custodial wallets for each user (not shared wallets).
- Manage these wallets on behalf of the user (typically through some third-party service like [Beamable](https://beamable.com/)).
- Support transfer of assets out of the custodial wallet to a self-custody wallet using the dApp Kit SDK.

**Tradeoffs**

- Balances driving on-chain active wallet metrics with UX and obfuscating wallet mechanics from users.  
- Asset transfers between users still incur gas costs, which you pay for.  
- No wallet recovery mechanisms - relies on you or backend provider.  
- Ultimately, you canâ€™t avoid users having a wallet if you want them to experience Web3 benefits. The Playtron ecosystem provides this as the game OS shows user assets and the companion app always serves game-centric wallet needs. If you use a custodial wallet, you must consider how to show users their assets, teach them how to transfer assets, and other needs that Playtron provides out of the box.

### Option 3: Game-specific zkLogin wallets with Playtron wallet transfer support

This option is effectively a special case of the recommended approach. If your game uses a game-specific zkLogin wallet, you still need to support using the Playtron wallet on the device.

- Use game-specific zkLogin wallets as the primary wallet when playing off-device.
- If new users start on-device, use the Playtron zkLogin wallet.  
- If users have initially played the game off-device using your game-specific zkLogin wallet, they can use our companion app to link their wallet and transfer assets from that wallet to their Playtron zkLogin wallet to continue playing on-device. See [Cross-Platform Migration Strategies](./migration-strategies.mdx) to learn more.
  - Connecting your zkLogin wallet to the companion app requires you to upgrade your wallet to Enoki Connect (see the [Enoki Connect section](#enoki-connect) that follows).  
  - After users connect their wallet to the companion app, they can link their game-specific zkLogin wallet to the Playtron wallet. If your game requires read-only access, then this link should be sufficient. If your game requires full asset access, on the other hand, players need to transfer assets from their game-specific wallet to the Playtron wallet.

**Tradeoffs**

- Provides on-chain wallet activity per user, while still maintaining simple UX and obfuscating wallet mechanics from the user.
- Unlike custodial wallets, users still need to pay for gas. You can always [sponsor transactions](https://docs.sui.io/concepts/transactions/sponsored-transactions) instead to assume this responsibility.
- In essence, the wallet is self-custodied by users in this scenario as you do not have access to the private keys. Users do not need to record or protect seed phrases, however. 
- Ultimately, you canâ€™t avoid users having a wallet if you want them to experience Web3 benefits. The Playtron ecosystem provides this as the game OS shows user assets and the companion app always serves game-centric wallet needs. If you use a custodial wallet, you must consider how to show users their assets, teach them how to transfer assets, and other needs that Playtron provides out of the box.

## Enoki Connect (optional) {#enoki-connect}

As a reminder, standard game-specific zkLogin and Enoki wallets are app-specific and non-portable. Users must transfer assets to third-party wallets to use external dApps. This provides a simpler implementation, but isolated user experience.

With Enoki Connect, you can upgrade your game-specific zkLogin wallet to make it portable across the Sui ecosystem.

- Users can connect their game wallet directly to marketplaces and other dApps. 
- External dApps must manually add your game's wallet to their supported wallet list, which requires you to reach out or develop a business relationship. dApps must individually enable your game-specific wallet to have it appear in the list of connectable wallets on their sites.
- Requires additional implementation work to upgrade an existing game-specific zkLogin or Enoki wallet.

### Recommended hybrid approach

Use dApp Kit to support self-custody wallet (either Playtron wallet on-device or Slush wallet off-device) as your primary or default wallet option. This provides immediate ecosystem portability without requiring other dApps to support you.Optionally, offer Enoki Connect as a secondary choice for users who prefer game-specific wallets or are unable to set up a self-custody wallet off-device.

:::tip

Enoki Connect is not required for SuiPlay integration. In other words, your game wallet doesn't need to use Enoki Connect unless you want the additional benefits. The Playtron wallet uses Enoki Connect, which allows it to connect to third-party dApps if they enable support for the wallet.

:::

## SuiLink

[SuiLink](https://www.suilink.io/) is a Mysten Labs product that connects wallets across chains to support use cases such as cross chain wallet verification, asset ownership verification, and asset distributions across chains. 

The [Playtron companion wallet app](https://wallet.playtron.one/) utilizes this technology to enable linking wallets that could contain soulbound assets in their other Sui mnemonic or zkLogin wallets, or their Solana or Ethereum wallets. This offers an improved user experience as users wonâ€™t need to transfer over all of their assets to their Playtron wallet to get the benefits these assets attribute to them.

:::info 

You can prove ownership of another wallet or asset and link it to your Playtron wallet (thereby allowing the game to read those assets), but you can't transact with these assets. For operations that require transactions to occur from the Playtron wallet, assets need to be transferred.

:::

### How to integrate with SuiLink

Provided a SuiLink connection (already established for SuiPlay0X1 users onboarded in the Playtron wallet app) you can query a userâ€™s SuiLink objects to validate that they own a specific asset. You can achieve this with the following query using the dApp Kit SDK:

```ts
   const ethSolSuiLinks = suiClient.getOwnedObjects({
     owner: suiAddress,
     filter: {
       Package: SUILINK_PACKAGE_ID_ETH_SOL,
     },
     options: {
       showContent: true,
       showType: true,
     },
   });

   const suiSuiLinks = suiClient.getOwnedObjects({
     owner: suiAddress,
     filter: {
       Package: SUILINK_PACKAGE_ID_SUI,
     },
     options: {
       showContent: true,
       showType: true,
     },
   });
```

The `SUILINK_PACKAGE_ID_ETH_SOL` and `SUILINK_PACKAGE_ID_SUI` have the following package IDs:

| Network | `SUILINK_PACKAGE_ID_ETH_SOL` | `SUILINK_PACKAGE_ID_SUI` |
| :---- | :---- | :---- |
| Testnet | `0x0025bafa2e6afa511c19bd4e95626c897e798fde629b4782fe061bdc8bd65c8a` | `0x0025bafa2e6afa511c19bd4e95626c897e798fde629b4782fe061bdc8bd65c8a` |
| Mainnet | `0xf857fa9df5811e6df2a0240a1029d365db24b5026896776ddd1c3c70803bccd3` | `0x73f5ab2461c5993408fff21354fa9831d4f4a66cc81382419ec29e3c80c384b5` |

A SuiLink NFT contains information about the chain its linking in its type and contains the address of the linked account in its fields. 

Reference fields:

```json
{
  id: {
    id: "0xcafe"
  }
  network_address: "0xdecaf"
  timestamp_ms: "1751541273947"
}
```

Reference types:

```json
// Sui to Sui SuiLink (Mainnet)
0xf857fa9df5811e6df2a0240a1029d365db24b5026896776ddd1c3c70803bccd3::suilink::SuiLink<0x73f5ab2461c5993408fff21354fa9831d4f4a66cc81382419ec29e3c80c384b5::sui::Sui>

// Sui to Ethereum SuiLink (Testnet)
0x0025bafa2e6afa511c19bd4e95626c897e798fde629b4782fe061bdc8bd65c8a::suilink::SuiLink<0x0025bafa2e6afa511c19bd4e95626c897e798fde629b4782fe061bdc8bd65c8a::ethereum::Ethereum>

// Sui to Solana SuiLink (Testnet)
0x0025bafa2e6afa511c19bd4e95626c897e798fde629b4782fe061bdc8bd65c8a::suilink::SuiLink<0x0025bafa2e6afa511c19bd4e95626c897e798fde629b4782fe061bdc8bd65c8a::solana::Solana>
```

After obtaining the SuiLink NFTs, the game can use the corresponding read API (such as [Alchemy](https://www.alchemy.com/)) to read the assets the user holds in the linked chain and wallet. If the target asset is found in the linked wallet, the game can attribute the benefit to the user from the userâ€™s Playtron wallet.

## Related links

<RelatedLink href="https://github.com/playtron-os/playtron-sdk" label="Playtron GameOS SDK" desc="The official Playtron OS SDK repository on GitHub." />
<RelatedLink href="https://sdk.mystenlabs.com/dapp-kit" label="Sui dApp Kit documentation" desc="The Sui dApp Kit is a set of React components, hooks, and utilities to help you build a dApp for the Sui ecosystem." />
<RelatedLink href="https://discord.gg/suiplay" label="SuiPlay0X1 Discord" desc="Follow announcements and connect with the community on the Discord channel for SuiPlay0X1." />
<RelatedLink href="https://wallet.playtron.one" label="Companion web application" desc="Support linking the Playtron wallet to other self-custody wallets using SuiLink, enabling read-access of associated wallets while on the device." />
<RelatedLink href="https://docs.enoki.mystenlabs.com/enoki-connect" label="Enoki Connect" desc="With Enoki Connect, users can use their dApp-specific accounts across different dApps, enabling a more unified and consistent experience." />

>>>> sui/docs/content/references.mdx
---
title: References Overview
sidebar_label: Overview
description: Refer to the Sui reference documentation for low-level details about different features and architectures. 
keywords: [ sui rpc, move, sui cli, reference docs, api reference, cli reference, sui IDE support, move IDE support, sui SDKs, software development kits ]
---

Already familiar with Sui? Use these valuable resources to continue your development journey.

## Sui RPC

Reference the Sui framework and Sui RPC documentation for details of the code that powers the Sui blockchain. 

<Cards>

<Card title="GraphQL for Sui RPC" href="/references/sui-graphql"/>
<Card title="JSON-RPC" href="/references/sui-api">
Use GraphQL for the Sui RPC for new projects. Use the JSON-RPC reference for legacy projects that have not migrated to GraphQL yet.
</Card>
</Cards>

## Move

Move powers smart contract logic for the Sui blockchain. Use these resources to learn Move or refresh your memory.

<Cards>
<Card title="Sui framework" href="/references/framework"/>
<Card title="The Move Book" href="https://move-book.com/">
The Move Book is a comprehensive guide to the Move programming language on the Sui blockchain.
</Card>
<Card title="The Move Reference" href="https://move-book.com/reference/">
The Move Reference documents the architecture and syntax of the Move programming language.
</Card>
</Cards>

## Sui CLI

Interact directly with Sui networks and its features using the Sui command line interface (CLI). The CLI is divided into separate base commands that target a specific set of features.

<Cards>
<Card title="Sui Client CLI" href="/references/cli/client">
Create a client on a Sui network to generate addresses, access networks, and more with the Sui Client CLI.
</Card>
<Card title="Sui Client PTB CLI" href="/references/cli/ptb">
Build, preview, and execute programmable transaction blocks directly from your terminal with the Sui Client PTB CLI.
</Card>
<Card title="Sui Move CLI" href="/references/cli/move">
Access Sui Move functions on chain using the Sui Move CLI.
</Card>

<Card title="Sui Replay CLI" href="/references/cli/replay">
Access Sui Move functions on chain using the Sui Move CLI.
</Card>
</Cards>

## Sui IDE support

Use the [Move](https://marketplace.visualstudio.com/items?itemName=mysten.move) and [Move Trace Debugger](https://marketplace.visualstudio.com/items?itemName=mysten.move-trace-debug) extensions for VSCode to quickly navigate and edit your Move codebase, and debug execution traces.

<Cards>
<Card title="Move" href="/references/ide/move"/>
<Card title="Move Trace Debugger" href="/references/ide/debugger"/>
</Cards>



## Sui software development kits

Official software development kits (SDKs) available for Sui include the TypeScript SDK and Rust SDK.

<Cards>
<Card title="Sui TypeScript SDK" href="https://sdk.mystenlabs.com/typescript">
The Sui TypeScript SDK has its own microsite. Click this box to go there.
</Card>
<Card title="Sui Rust SDK" href="/references/rust-sdk"/>
</Cards>

>>>> sui/docs/content/references/cli.mdx
---
title: Sui CLI
description: Sui provides command line tools to interact with the network, its features, and the Move programming language. Individual command groups are referred to as Sui Client CLI, Sui Keytool CLI, Sui Move CLI, and Sui Validator CLI.
keywords: [ Sui Client CLI, Sui Keytool CLI, Sui Move CLI, Sui Validator CLI, sui cli, update cli, sui cli commands, sui client PTB CLI, sui PTB CLI ] 
pagination_prev: null
---

Sui provides a command line interface (CLI) tool to interact with the Sui network, its features, and the Move programming language. The complete suite of tools is called the Sui CLI, with commands grouped together by feature. Each group of commands is commonly referred to by its top-level command: Sui Client CLI, Sui Keytool CLI, Sui Move CLI, and Sui Validator CLI.

<ImportContent source="cli-check-install.mdx" mode="snippet" />

## Update CLI

The recommended way to manage Sui CLI installations and versions is via `suiup`: https://github.com/mystenLabs/suiup.

:::info

The `tracing` feature is important as it adds Move test coverage and debugger support in the Sui CLI. Unless it is enabled you will not be able to use these two features.

:::

## Sui CLI commands

There are a number of top-level commands available, but the five most useful to users are the following. Use the `help` flag for the commands that are not documented yet. For example, `sui validator --help`.

- **[Sui Client CLI](./cli/client.mdx):** Use the `sui client` commands to interact with the Sui network.
- **[Sui Client PTB CLI](./cli/ptb.mdx):** Use the `sui client ptb` command to build and execute PTBs.
- **[Sui Keytool CLI](./cli/keytool.mdx):** Use the `sui keytool` commands to access cryptography utilities.
- **[Sui Move CLI](./cli/move.mdx):** Use the `sui move` commands to work with the Move programming language.
- **[Sui Replay CLI](./cli/replay.mdx):** Use the `sui client replay` command to replay a transaction and generate transaction traces for the Move Debugger and trace analysis tools.
- **[Sui Validator CLI](./cli/validator.mdx):** Use the `sui validator` commands to access tools useful for Sui validators.

>>>> sui/docs/content/references/cli/cheatsheet.mdx
---
title: Sui CLI Cheat Sheet
description: Use this cheat sheet to learn common Sui CLI commands.
keywords: [ sui cli, common sui cli commands, cli cheat sheet, quick reference ]
---

The cheat sheet highlights common Sui CLI commands.

:::tip

<a href="/doc/sui-cli-cheatsheet.pdf" target="_blank" rel="noreferrer">Download sheet as PDF</a>

:::

## Addresses & aliases

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client active-address`</td>
			<td class="w-1/3">Get the active address</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client addresses`</td>
			<td class="w-1/3">List the addresses, their aliases, and the active address</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client new-address ed25519`</td>
			<td class="w-1/3">Create a new address with ED25519 scheme</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client new-address ed25519 MY_ALIAS`</td>
			<td class="w-1/3">Create a new address with ED25519 scheme and alias</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client switch --address ADDRESS`</td>
			<td class="w-1/3">Make this the active address (accepts also an alias)</td>
		</tr>
		<tr> 	
			<td class="w-2/3">`sui keytool convert PRIVATE_KEY`</td>
			<td class="w-1/3">Convert private key in Hex or Base64 to new format (Bech32 encoded 33 byte flag || private key starting with "suiprivkey")</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui keytool generate ed25519`</td>
			<td class="w-1/3">Generate a new keypair with ED25519 scheme and save it to file</td>
		</tr>
		<tr> 	
      <td class="w-2/3">`sui keytool import INPUT KEY_SCHEME`</td>
			<td class="w-1/3">Add a new key to Sui CLI Keystore using either the input mnemonic phrase or a Bech32 encoded 33-byte flag || privkey starting with "suiprivkey"</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui keytool update-alias OLD_ALIAS NEW_ALIAS`</td>
			<td class="w-1/3">Update the alias of an address</td>
		</tr>
	</tbody>
</table>

## Faucet & gas

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client faucet`</td>
			<td class="w-1/3">Get a SUI coin from the faucet associated with the active network</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client faucet --address ADDRESS`</td>
			<td class="w-1/3">Get a SUI coin for the address (accepts also an alias)</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client faucet --url CUSTOM_FAUCET_URL`</td>
			<td class="w-1/3">Get a SUI coin from custom faucet</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client gas`</td>
			<td class="w-1/3">List the gas coins for the active address</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client gas ADDRESS`</td>
			<td class="w-1/3">List the gas coins for the given address (accepts also an alias)</td>
		</tr>
	</tbody>
</table>

## Network command description

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client active-env`</td>
			<td class="w-1/3">Get the active environment</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client envs`</td>
			<td class="w-1/3">List defined environments</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client new-env --rpc URL --alias ALIAS`</td>
			<td class="w-1/3">Create a new environment with URL and alias</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client switch --env ENV_ALIAS`</td>
			<td class="w-1/3">Switch to the given environment</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui genesis`</td>
			<td class="w-1/3">Bootstrap and initialize a new Sui network</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui start`</td>
			<td class="w-1/3">Start the local Sui network</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui-faucet`</td>
			<td class="w-1/3">Start a local faucet. Note this is a different binary</td>
		</tr>
	</tbody>
</table>

## Create, build, and test a Move project

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui move build`</td>
			<td class="w-1/3">Build the Move project in the current directory</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move build --path PATH`</td>
			<td class="w-1/3">Build the Move project from the given path</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move migrate PATH`</td>
			<td class="w-1/3">Migrate to Move 2024 for the package at provided path</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move new PROJECT_NAME`</td>
			<td class="w-1/3">Create a new Move project in the given folder</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move test`</td>
			<td class="w-1/3">Test the Move project in the current directory</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui move test --trace`</td>
			<td class="w-1/3">Create an execution trace for the Move tests in the current directory. Use with the [Move Trace Debugger](https://marketplace.visualstudio.com/items?itemName=mysten.move-trace-debug) extension.</td>
		</tr>
	</tbody>
</table>

## Executing transactions

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client call \`<br/>&nbsp;&nbsp;`--package PACKAGE \`<br/>&nbsp;&nbsp;`--module MODULE \`<br/>&nbsp;&nbsp;`--function FUNCTION`</td>
			<td class="w-1/3">Call a Move package</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client merge-coin \`<br/>&nbsp;&nbsp;`--primary-coin COIN_ID \`<br/>&nbsp;&nbsp;`--coin-to-merge COIN_ID`</td>
			<td class="w-1/3">Merge two coins</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client split-coin \`<br/>&nbsp;&nbsp;`--coin-id COIN_ID \`<br/>&nbsp;&nbsp;`--amounts 1000`</td>
			<td class="w-1/3">Split a coin into two coins: one with 1000 MIST and the rest</td>
		</tr>
		<tr>
			<td class="w-2/3">
				`sui client pay-sui \`<br/>&nbsp;&nbsp;`--input-coins COIN_ID \`<br/>&nbsp;&nbsp;`--recipients ADDRESS \`<br/>&nbsp;&nbsp;`--amounts 100000000`
			</td>
			<td class="w-1/3">Transfer 0.1 SUI to an address and use the same coin for gas</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client transfer-sui \`<br/>&nbsp;&nbsp;`--sui-coin-object-id COIN_ID \`<br/>&nbsp;&nbsp;`--to ADDRESS`</td>
			<td class="w-1/3">Transfer SUI object to an address and use the same coin for gas</td>
		</tr>
	</tbody>
</table>

## Programmable transaction blocks (PTBs)

<table class="w-100">
	<thead>
		<tr>
			<td>Command</td>
			<td>Description</td>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="w-2/3">`sui client ptb --move-call p::m::f "<type>" args`</td>
			<td class="w-1/3">Call a Move function from a package and module</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client ptb --make-move-vec "<u64>" "[1000,2000]"`</td>
			<td class="w-1/3">Make a Move vector with two elements of type u64</td>
		</tr>
		<tr>
			<td class="w-2/3">
				`sui client ptb \`<br/>&nbsp;&nbsp;`--split-coins gas "[1000]" \`<br/>&nbsp;&nbsp;`--assign new_coins \`<br/>&nbsp;&nbsp;`--transfer-objects
				"[new_coins]" ADDRESS`
			</td>
			<td class="w-1/3">Split a gas coin and transfer it to address</td>
		</tr>
		<tr>
			<td class="w-2/3">`sui client ptb --transfer-objects "[object_id]" ADDRESS`</td>
			<td class="w-1/3">
				Transfer an object to an address. Note that you can pass multiple objects in the array
			</td>
		</tr>
		<tr>
			<td class="w-2/3">
				`sui client ptb \`<br/>&nbsp;&nbsp;`--move-call sui::tx_context::sender \`<br/>&nbsp;&nbsp;`--assign sender \`<br/>&nbsp;&nbsp;`--publish "." \`<br/>&nbsp;&nbsp;`--assign
				upgrade_cap \`<br/>&nbsp;&nbsp;`--transfer-objects "[upgrade_cap]" sender`
			</td>
			<td class="w-1/3">Publish a Move package, and transfer the upgrade capability to sender</td>
		</tr>
	</tbody>
</table>

>>>> sui/docs/content/references/cli/client.mdx
---
title: Sui Client CLI
description: The Sui Client CLI provides command-level access to interact with the Sui network.
keywords: [ sui cli, sui client cli, sui client cli, sui client, sui cli help, sui cli reference, sui cli commands, cli commands, cli reference ]
---

The Sui CLI `client` command provides command-level access to interact with the Sui network. Typical uses for `sui client` include publishing Move smart contracts, getting the information of an object, executing transactions, or managing addresses.

<ImportContent source="cli-check-install.mdx" mode="snippet" />

## Commands

```sh
$ sui client --help
```

<ImportContent source="console-output/sui-client-help.mdx" mode="snippet" />

## JSON output

Append the `--json` flag to commands to format responses in JSON instead of the more human-friendly default Sui CLI output. This can be useful for extremely large datasets, for example, as those results can have a troublesome display on smaller screens. In these cases, the `--json` flag is useful.

## Examples

The following examples demonstrate some of the most often used commands.

### List available network environments

Use the `sui client envs` command to find the network environments set up in the CLI. The information for these environments is also stored in the client.yaml file in the Sui configuration directory (`~/.sui/sui_config`).

```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ alias  â”‚ url                                â”‚ active â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ devnet â”‚ https://fullnode.devnet.sui.io:443 â”‚ *  	   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Create network environment

Use `client new-env` to add details for a new network environment. This example creates an environment pointer to Sui Mainnet. Setting the `alias` value makes referencing the environment less prone to typographical errors. After running this command, Sui updates your client.yaml file in `~/.sui/sui_config` with the new information.

```
$ sui client new-env --alias=mainnet --rpc https://fullnode.mainnet.sui.io:443

Added new Sui env [mainnet] to config.
```

### Set current environment

Use the `sui client switch` command to change the current network. This example switches the current network to `mainnet`.

```sh
$ sui client switch --env mainnet
```
```sh
Active environment switched to [mainnet]
```

If you run `sui client envs` after this command, you see the asterisk in the `active` column on the `mainnet` row of the table.

### Get current active address

Use the `sui client active-address` command to reveal the current address. The CLI uses the current active address to execute address-specific CLI commands (like `sui client objects`) when you don't provide them with a Sui address value.

```sh
$ sui client active-address
```
```sh
0x514692f08249c3e9951234ce29074695840422564bff85e424b56de462913e0d
```

### Request a SUI coin from faucet

If you use one of the standard public RPCs (for example, `fullnode.devnet.sui.io:443`), you can use the `faucet` command to request gas coins. If you use a custom faucet service, then pass in the URL to the faucet using the `--url` option.
The `faucet` command works for a local network, as well. If you start your network with a custom faucet port, include the `--url` option.

```sh
$ sui client faucet
```
```sh
Request successful. It can take up to 1 minute to get the coin. Run sui client gas to check your gas coins.
```

### Get objects owned by an address

Use `sui client objects` to list summary information about the objects the current active address owns. You can provide a Sui address value to the command to list objects for a particular address. This example lists objects for the current active address.

```sh
$ sui client objects 0x36df11369cf00ecf0be68d6ba965b0abe2e883bc5245911e3a29ebfa0aaf6b69
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
| â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ objectId   â”‚  0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f  â”‚ â”‚
â”‚ â”‚ version	   â”‚  33363559                                                        	  â”‚ â”‚
â”‚ â”‚ digest 	   â”‚  IY7/qsIJhliQL0uxwSzNYu0SMcn5AMsqQklSGngn1V0=                    	  â”‚ â”‚
â”‚ â”‚ objectType â”‚  0x0000..0002::coin::Coin                                        	  â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ objectId   â”‚  0xfffe59fb6f78b1ced7f6537e69a205cc45d105270857bfd66332f9a627a38ae0  â”‚ â”‚
â”‚ â”‚ version	   â”‚  33370864                                                            â”‚ â”‚
â”‚ â”‚ digest     â”‚  b+tKChvujbCk/UCm8L+lflyb6Vjt7beB+uz6+ahUHmM=                    	  â”‚ â”‚
â”‚ â”‚ objectType â”‚  0x0000..0002::coin::Coin                                        	  â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Get complete object information

Use `sui client object <OBJECT-ID>` to list object information for the ID you provide. This example displays the information for a Coin object.

```sh
$ sui client object 0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ objectId  	  â”‚  0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f                                             	  â”‚
â”‚ version   	  â”‚  33363559                                                                                                       	  â”‚
â”‚ digest    	  â”‚  3FzvXJVVVcXb9H6dEXdARaY9EmxXyyNFduet3X4eYV4x                                                                   	  â”‚
â”‚ objType   	  â”‚  0x2::coin::Coin<0x2::sui::SUI>                                                                                 	  â”‚
â”‚ ownerType 	  â”‚  AddressOwner                                                                                                   	  â”‚
â”‚ prevTx    	  â”‚  ES2RQThjRE5u8rwiUEnhcnMoLA3cHeEGYJ8Pq98tmyAc                                                                   	  â”‚
â”‚ storageRebate â”‚  988000                                                                                                         	  â”‚
â”‚ content   	  â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚           	  â”‚ â”‚ dataType      	  â”‚  moveObject                                                                            	    â”‚ â”‚
â”‚           	  â”‚ â”‚ type          	  â”‚  0x2::coin::Coin<0x2::sui::SUI>                                                       	    â”‚ â”‚
â”‚           	  â”‚ â”‚ hasPublicTransfer â”‚  true                                                                                    	  â”‚ â”‚
â”‚           	  â”‚ â”‚ fields        	  â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ â”‚
â”‚           	  â”‚ â”‚               	  â”‚ â”‚ balance â”‚  530076676                                                                	  â”‚ â”‚ â”‚
â”‚           	  â”‚ â”‚               	  â”‚ â”‚ id  	  â”‚ â•­â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ â”‚ â”‚
â”‚           	  â”‚ â”‚               	  â”‚ â”‚     	  â”‚ â”‚ id â”‚  0xfffbb30ccb631f15f6cd36700589fc9c31cb04af28a95f3ed26d62daf3acb57f  â”‚ â”‚ â”‚ â”‚
â”‚           	  â”‚ â”‚               	  â”‚ â”‚     	  â”‚ â•°â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚ â”‚ â”‚
â”‚           	  â”‚ â”‚               	  â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚ â”‚
â”‚           	  â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Get dynamic fields of an object

Use the `sui client dynamic-field <DYNAMIC-FIELD-ID>` command to list the details of the dynamic field with the ID you provide.

```sh
$ sui client dynamic-field 0x5
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ hasNextPage â”‚  false                                                                                	  â”‚
â”‚ nextCursor  â”‚  0x5b890eaf2abcfa2ab90b77b8e6f3d5d8609586c3e583baf3dccd5af17edf48d1                   	  â”‚
â”‚ data     	  â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚         	  â”‚ â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚ name   	   â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â•®                                                	  â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚        	   â”‚ â”‚ type  â”‚  u64  â”‚                                                	  â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚        	   â”‚ â”‚ value â”‚  2	 â”‚                                                	    â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚        	   â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â•¯                                                	  â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚ bcsName	   â”‚  LQM2cdzDY3                                                      	  â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚ type   	   â”‚  DynamicField                                                    	  â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚ objectType â”‚  0x3::sui_system_state_inner::SuiSystemStateInnerV2              	  â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚ objectId   â”‚  0x5b890eaf2abcfa2ab90b77b8e6f3d5d8609586c3e583baf3dccd5af17edf48d1  â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚ version	   â”‚  112                                                             	  â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â”‚ digest 	   â”‚  HMrm1KNKjq3GfB1cWTRdvRo8gk7auhgvoZXaVoyEHqUR                    	  â”‚ â”‚ â”‚
â”‚         	  â”‚ â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚ â”‚
â”‚         	  â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Send SUI or objects

In this example, let's see how to transfer SUI or transfer an object from one address to another. First of all, there two main commands for sending SUI or transferring objects: `pay` and `transfer`.
Both `pay` and `transfer` have a few sister commands: `pay-sui`, `pay-all-sui`, `transfer-sui`.

The differences between these commands are:
- commands that end in `-sui` deal with Sui's native coin, and they use the input coints to pay for gas and for transferring SUI or the object.
- `pay-` commands typically deal with coins and handle gas smashing for you, whereas `transfer` commands can handle the transfer of any object that has public transfer, meaning any object that has the `store` ability.
- `pay` commands allow you to send coins to multiple recipients, whereas `transfer` commands only accept one recipient.
- `pay-all-sui` is a special case of `pay-sui` that offers a way to transfer the entire balance after smashing.
- `transfer-sui` is a legacy command and has been entirely superseded by `pay-sui` or `pay-all-sui` depending on whether an amount is specified or not.

Assume you have two addresses:

```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ alias             â”‚ address                                                            â”‚ active address â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ hungry-spodumene  â”‚ 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea â”‚ *              â”‚
â”‚ eloquent-amber    â”‚ 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 â”‚                â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
````

Address `hungry-spodumene` has a few coins:

```sh
$ sui client gas hungry-spodumene
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ gasCoinId                                                          â”‚ mistBalance (MIST) â”‚ suiBalance (SUI) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0x205972830acd8264a38b9a1776a1b72a1ae626fa23a4d1f12249349ce3b83c06 â”‚ 200000000000       â”‚ 200.00           â”‚
â”‚ 0x56d76420a5bc7d356e3930e6a2ddc61cbbc0c87ea5c5f3cc3ac5952b4d52be5a â”‚ 200000000000       â”‚ 200.00           â”‚
â”‚ 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 â”‚ 200000000000       â”‚ 200.00           â”‚
â”‚ 0xe373de9bdbd3dbd4f5f707f144c83af74a181cdb3903a953ee366f48e33865c7 â”‚ 200000000000       â”‚ 200.00           â”‚
â”‚ 0xf7adb6aeb18eb409c03fe88cc31711b61a65333e0fdd88c1815d4ec75f713f31 â”‚ 200000000000       â”‚ 200.00           â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

You want to send 0.5 SUI to `eloquent-amber`. Given that you have a few gas coins, you can use `pay`. If only one gas coin exists, then you need to use `transfer-sui` or `pay-sui`, or you would need to split the coin first to have another coin to use for paying gas. In this case, let's use the `pay-sui` command as you do not need to provide a separate gas coin to be used for the gas fees. In the command below, you set the recipient to be `eloquent-amber`, which coin to use to transfer SUI from, and the amount of SUI to transfer.

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client pay-sui --recipients eloquent-amber --input-coins 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 --amounts 500000000 --gas-budget 5000000
```

The result is:

```sh
Transaction Digest: AsWkciVhLHeCmqVipjjyAA7Hv5y87pFjHS59K8m4zBJV
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Data                                                                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                   â”‚
â”‚ Gas Owner: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                â”‚
â”‚ Gas Budget: 5000000 MIST                                                                                     â”‚
â”‚ Gas Price: 1000 MIST                                                                                         â”‚
â”‚ Gas Payment:                                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                                         â”‚
â”‚  â”‚ ID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                                    â”‚
â”‚  â”‚ Version: 2                                                                                                â”‚
â”‚  â”‚ Digest: 9MEH7kr1YkBDx7pdUPCDnVb3FtPz9UZVeWmCot5Dhxqr                                                      â”‚
â”‚  â””â”€â”€                                                                                                         â”‚
â”‚                                                                                                              â”‚
â”‚ Transaction Kind: Programmable                                                                               â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ Input Objects                                                                                            â”‚ â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ â”‚ 0   Pure Arg: Type: address, Value: "0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976" â”‚ â”‚
â”‚ â”‚ 1   Pure Arg: Type: u64, Value: "500000000"                                                              â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                                                                     â”‚
â”‚ â”‚ Commands             â”‚                                                                                     â”‚
â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                                                                     â”‚
â”‚ â”‚ 0  SplitCoins:       â”‚                                                                                     â”‚
â”‚ â”‚  â”Œ                   â”‚                                                                                     â”‚
â”‚ â”‚  â”‚ Coin: GasCoin     â”‚                                                                                     â”‚
â”‚ â”‚  â”‚ Amounts:          â”‚                                                                                     â”‚
â”‚ â”‚  â”‚   Input  1        â”‚                                                                                     â”‚
â”‚ â”‚  â””                   â”‚                                                                                     â”‚
â”‚ â”‚                      â”‚                                                                                     â”‚
â”‚ â”‚ 1  TransferObjects:  â”‚                                                                                     â”‚
â”‚ â”‚  â”Œ                   â”‚                                                                                     â”‚
â”‚ â”‚  â”‚ Arguments:        â”‚                                                                                     â”‚
â”‚ â”‚  â”‚   Result 0        â”‚                                                                                     â”‚
â”‚ â”‚  â”‚ Address: Input  0 â”‚                                                                                     â”‚
â”‚ â”‚  â””                   â”‚                                                                                     â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                                                                     â”‚
â”‚                                                                                                              â”‚
â”‚ Signatures:                                                                                                  â”‚
â”‚    eZc/iFO3i4Y8Le92zu9q75jILs+yg0sSXd1yPV9Dta+knH99VfkSCnzNQG1KbXSvY24wexmVtiuU6NkfudbiAQ==                  â”‚
â”‚                                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: AsWkciVhLHeCmqVipjjyAA7Hv5y87pFjHS59K8m4zBJV                                              â”‚
â”‚ Status: Success                                                                                   â”‚
â”‚ Executed Epoch: 0                                                                                 â”‚
â”‚                                                                                                   â”‚
â”‚ Created Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 )  â”‚
â”‚  â”‚ Version: 3                                                                                     â”‚
â”‚  â”‚ Digest: Fq3maqq3pShgKw58Ssm8cS2j1pspfhanedVK2MMxfQWQ                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Mutated Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  â”‚
â”‚  â”‚ Version: 3                                                                                     â”‚
â”‚  â”‚ Digest: GFB9mpxTP4z6CCShTbvD58FYxtu9G4mnxN3JtFeRupM3                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Object:                                                                                       â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                         â”‚
â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  â”‚
â”‚  â”‚ Version: 3                                                                                     â”‚
â”‚  â”‚ Digest: GFB9mpxTP4z6CCShTbvD58FYxtu9G4mnxN3JtFeRupM3                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Cost Summary:                                                                                 â”‚
â”‚    Storage Cost: 1976000 MIST                                                                     â”‚
â”‚    Computation Cost: 1000000 MIST                                                                 â”‚
â”‚    Storage Rebate: 978120 MIST                                                                    â”‚
â”‚    Non-refundable Storage Fee: 9880 MIST                                                          â”‚
â”‚                                                                                                   â”‚
â”‚ Transaction Dependencies:                                                                         â”‚
â”‚    GThyjtRFysBgVppXDc9iduNPzB2bLteXBnJcBEYXz4vG                                                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ No transaction block events â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Created Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241                  â”‚
â”‚  â”‚ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 ) â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    â”‚
â”‚  â”‚ Version: 3                                                                                    â”‚
â”‚  â”‚ Digest: Fq3maqq3pShgKw58Ssm8cS2j1pspfhanedVK2MMxfQWQ                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â”‚ Mutated Objects:                                                                                 â”‚
â”‚  â”Œâ”€â”€                                                                                             â”‚
â”‚  â”‚ ObjectID: 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52                  â”‚
â”‚  â”‚ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                    â”‚
â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea ) â”‚
â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    â”‚
â”‚  â”‚ Version: 3                                                                                    â”‚
â”‚  â”‚ Digest: GFB9mpxTP4z6CCShTbvD58FYxtu9G4mnxN3JtFeRupM3                                          â”‚
â”‚  â””â”€â”€                                                                                             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Balance Changes                                                                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  â”‚
â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
â”‚  â”‚ Amount: -501997880                                                                             â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ Owner: Account Address ( 0x3d78abc33ccd173c521b4f9e78b21ea2c989960b631732c539efaa38bda30976 )  â”‚
â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
â”‚  â”‚ Amount: 500000000                                                                              â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

```

Check the gas for the sender and the recipient's coins using `sui client gas <address>`. The sender now has 199.49 SUI for that gas coin that was used. 0.5 SUI was transferred, and the remaining 0.01 SUI paid the gas fees.
```sh
$ sui client gas
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ gasCoinId                                                          â”‚ mistBalance (MIST) â”‚ suiBalance (SUI) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0x205972830acd8264a38b9a1776a1b72a1ae626fa23a4d1f12249349ce3b83c06 â”‚ 200000000000       â”‚ 200.00           â”‚
â”‚ 0x56d76420a5bc7d356e3930e6a2ddc61cbbc0c87ea5c5f3cc3ac5952b4d52be5a â”‚ 200000000000       â”‚ 200.00           â”‚
â”‚ 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 â”‚ 199498002120       â”‚ 199.49           â”‚
â”‚ 0xe373de9bdbd3dbd4f5f707f144c83af74a181cdb3903a953ee366f48e33865c7 â”‚ 200000000000       â”‚ 200.00           â”‚
â”‚ 0xf7adb6aeb18eb409c03fe88cc31711b61a65333e0fdd88c1815d4ec75f713f31 â”‚ 200000000000       â”‚ 200.00           â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```
```sh
$ sui client gas eloquent-amber
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ gasCoinId                                                          â”‚ mistBalance (MIST) â”‚ suiBalance (SUI) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241 â”‚ 500000000          â”‚ 0.50             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

If you want to transfer the whole object, you can use `sui client pay-all-sui` or `sui client transfer-sui` (without passing the amount):
```sh
$ sui client pay-sui --recipient eloquent-amber --input-coins 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 --gas-budget 5000000
```
or
```sh
$ sui client transfer-sui --to eloquent-amber --sui-coin-object-id 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 --gas-budget 5000000
```

Then check the gas for `eloquent-amber` again:
```sh
$ sui client gas eloquent-amber
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ gasCoinId                                                          â”‚ mistBalance (MIST) â”‚ suiBalance (SUI) â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0xa031d3f8fd53b5f9885172e1c6bd8b770b25e42371c9ee215c6d4b21b2b73241 â”‚ 500000000          â”‚ 0.50             â”‚
â”‚ 0xc9b447fff18f13fa035e028534b8344d5fc8a8760248fad10155e78f44dc3a52 â”‚ 199496992240       â”‚ 199.49           â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```


### Replay a transaction

Client commands to replay transactions have been deprecated in favor of the `sui replay` command. Learn about replaying a transaction and how it can be used for debugging or profiling in the [Transaction Replay](./replay.mdx), [Debugging Transactions](../ide/debugger.mdx), and [Transaction Trace Analysis](./trace-analysis.mdx) guides.

## Publish a Move package

One of the main uses of the `sui client` command is to publish smart contracts on the Sui network. This example switches the current environment to Devnet, then builds, tests, and publishes one of the existing Move examples available in the Sui repository: [sui/examples/move](https://github.com/MystenLabs/sui/tree/main/examples/move)

This example also makes use of `sui move` commands. To learn more about those commands, see [Sui Move CLI](./move.mdx).

1. Open a terminal or console to the root of your local Sui repository and navigate to the `move_tutorial` example.
    ```sh
    $ cd examples/move/first_package
    ```
1. Switch to Devnet network. This command uses an alias, so the `devnet` value might be different for you, depending on the alias name set in your configuration (use `sui client envs` for a list of your defined networks and their aliases).
    ```sh
    $ sui client switch --env devnet
    ```
1. Use `sui move build` to build the package. You must run this command at the same level as the package manifest file ([Move.toml](https://move-book.com/concepts/manifest.html)).
    ```sh
    $ sui move build
    ```
    The console responds with the status of the build.
    ```sh
    INCLUDING DEPENDENCY Sui
    INCLUDING DEPENDENCY MoveStdlib
    BUILDING first_package
    ```
1. Use `sui move test` to run the unit tests.
    ```sh
    $ sui move test
    ```
    The console responds with updates of its progress.
    ```sh
    INCLUDING DEPENDENCY Sui
    INCLUDING DEPENDENCY MoveStdlib
    BUILDING first_package
    Running Move unit tests
    [ PASS    ] 0x0::example::test_module_init
    [ PASS    ] 0x0::example::test_sword_transactions
    Test result: OK. Total tests: 2; passed: 2; failed: 0
     ```
1. Use the `sui client verify-bytecode-meter` to check if the module passes the bytecode meter.
    ```sh
    $ sui client verify-bytecode-meter
    ```
    The console responds with the maximum allowed values, as well as the amount the package uses.
    ```sh
    Running bytecode verifier for 1 modules
    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
    â”‚ Module passes metering check. â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚        â”‚ Module     â”‚ Function   â”‚
    â”‚ Max    â”‚ 16000000   â”‚ 16000000   â”‚
    â”‚ Used   â”‚ 4565       â”‚ 4565       â”‚
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
    ```
1. Use `sui client gas` to verify that the active address has a gas coin for paying gas.
    ```sh
    $ sui client gas
    ```
    In the case of this example, the console responds with the information that the address is coinless.
    ```sh
    No gas coins are owned by this address
    ```
1. If you need coins, use `sui client faucet` (not available for Mainnet). For more information on getting gas tokens, see [Get Sui Tokens](/guides/developer/getting-started/get-coins.mdx).
    ```sh
    $ sui client faucet
    ```
1. Use `sui client gas` to verify the current active address received the coins.
    ```sh
    $ sui client gas
    ```
    ```sh
    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
    â”‚ gasCoinId                                                          â”‚ gasBalance  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8 â”‚ 10000000000 â”‚
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
    ```
1. Use `sui client publish` to publish the package, being sure to set an appropriate value for the `gas-budget` flag if you're using an older version of Sui. The console responds with the details of the publish. You can use `sui client object <OBJECT-ID>` to check the details of any of the objects from the process.
    ```sh
    $ sui client publish --gas-budget 100000000 .
    ```
    ```sh
     Transaction Digest: ABPd7v8BxLkcyHvX8Jt1SbneQRwzE9WzcEoptT2RDNVF
    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
    â”‚ Transaction Data                                                                                             â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                   â”‚
    â”‚ Gas Owner: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                                â”‚
    â”‚ Gas Budget: 5000000000 MIST                                                                                  â”‚
    â”‚ Gas Price: 1000 MIST                                                                                         â”‚
    â”‚ Gas Payment:                                                                                                 â”‚
    â”‚  â”Œâ”€â”€                                                                                                         â”‚
    â”‚  â”‚ ID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                                    â”‚
    â”‚  â”‚ Version: 2                                                                                                â”‚
    â”‚  â”‚ Digest: GZQwvpxLeTciVboEWeC8EZ2KYYU9o6XoBtW6LrA5Si1h                                                      â”‚
    â”‚  â””â”€â”€                                                                                                         â”‚
    â”‚                                                                                                              â”‚
    â”‚ Transaction Kind: Programmable                                                                               â”‚
    â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
    â”‚ â”‚ Input Objects                                                                                            â”‚ â”‚
    â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
    â”‚ â”‚ 0   Pure Arg: Type: address, Value: "0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea" â”‚ â”‚
    â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
    â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®                                  â”‚
    â”‚ â”‚ Commands                                                                â”‚                                  â”‚
    â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                                  â”‚
    â”‚ â”‚ 0  Publish:                                                             â”‚                                  â”‚
    â”‚ â”‚  â”Œ                                                                      â”‚                                  â”‚
    â”‚ â”‚  â”‚ Dependencies:                                                        â”‚                                  â”‚
    â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000001 â”‚                                  â”‚
    â”‚ â”‚  â”‚   0x0000000000000000000000000000000000000000000000000000000000000002 â”‚                                  â”‚
    â”‚ â”‚  â””                                                                      â”‚                                  â”‚
    â”‚ â”‚                                                                         â”‚                                  â”‚
    â”‚ â”‚ 1  TransferObjects:                                                     â”‚                                  â”‚
    â”‚ â”‚  â”Œ                                                                      â”‚                                  â”‚
    â”‚ â”‚  â”‚ Arguments:                                                           â”‚                                  â”‚
    â”‚ â”‚  â”‚   Result 0                                                           â”‚                                  â”‚
    â”‚ â”‚  â”‚ Address: Input  0                                                    â”‚                                  â”‚
    â”‚ â”‚  â””                                                                      â”‚                                  â”‚
    â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯                                  â”‚
    â”‚                                                                                                              â”‚
    â”‚ Signatures:                                                                                                  â”‚
    â”‚    x437h/JxDAba2zkx4a2kEfz6iaXQ08T7+inyP5YkbmlSB5K7IYasM6onckjYDB19FNM1ZNqXm1z13VyTmDHXCw==                  â”‚
    â”‚                                                                                                              â”‚
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
    â”‚ Transaction Effects                                                                               â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Digest: ABPd7v8BxLkcyHvX8Jt1SbneQRwzE9WzcEoptT2RDNVF                                              â”‚
    â”‚ Status: Success                                                                                   â”‚
    â”‚ Executed Epoch: 0                                                                                 â”‚
    â”‚                                                                                                   â”‚
    â”‚ Created Objects:                                                                                  â”‚
    â”‚  â”Œâ”€â”€                                                                                              â”‚
    â”‚  â”‚ ID: 0x569828cc4e134ccccd7408def18b80af1465ac791fd4ef40483f6b16e2f00d95                         â”‚
    â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  â”‚
    â”‚  â”‚ Version: 3                                                                                     â”‚
    â”‚  â”‚ Digest: 4iD7ZhsFS9iFuszqxBSEL6xZdcnWG76WGgU4D5PH1PeL                                           â”‚
    â”‚  â””â”€â”€                                                                                              â”‚
    â”‚  â”Œâ”€â”€                                                                                              â”‚
    â”‚  â”‚ ID: 0xde670ae990c8f20fd53e9f597a0da056bdb634175176602658e9da2c2ec9cb93                         â”‚
    â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  â”‚
    â”‚  â”‚ Version: 3                                                                                     â”‚
    â”‚  â”‚ Digest: AV27tn7ePXhdDyDV9TCkSQZA3mkMei9DV63AmB4DEjGN                                           â”‚
    â”‚  â””â”€â”€                                                                                              â”‚
    â”‚  â”Œâ”€â”€                                                                                              â”‚
    â”‚  â”‚ ID: 0xe1d9d66b7a19b27ebda338a52593cd10e728f666f34ecd30a7cc2ad3fed186da                         â”‚
    â”‚  â”‚ Owner: Immutable                                                                               â”‚
    â”‚  â”‚ Version: 1                                                                                     â”‚
    â”‚  â”‚ Digest: 4bzxMQgcSZoKzppNiRtQwAWDBvCgjr18gQi2H8Yk1tQZ                                           â”‚
    â”‚  â””â”€â”€                                                                                              â”‚
    â”‚ Mutated Objects:                                                                                  â”‚
    â”‚  â”Œâ”€â”€                                                                                              â”‚
    â”‚  â”‚ ID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                         â”‚
    â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  â”‚
    â”‚  â”‚ Version: 3                                                                                     â”‚
    â”‚  â”‚ Digest: 46rvdbXkw5qqsBYbUGChzgFatJAYPmarPmFHgRRJiiU9                                           â”‚
    â”‚  â””â”€â”€                                                                                              â”‚
    â”‚ Gas Object:                                                                                       â”‚
    â”‚  â”Œâ”€â”€                                                                                              â”‚
    â”‚  â”‚ ID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                         â”‚
    â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  â”‚
    â”‚  â”‚ Version: 3                                                                                     â”‚
    â”‚  â”‚ Digest: 46rvdbXkw5qqsBYbUGChzgFatJAYPmarPmFHgRRJiiU9                                           â”‚
    â”‚  â””â”€â”€                                                                                              â”‚
    â”‚ Gas Cost Summary:                                                                                 â”‚
    â”‚    Storage Cost: 9978800                                                                          â”‚
    â”‚    Computation Cost: 1000000                                                                      â”‚
    â”‚    Storage Rebate: 978120                                                                         â”‚
    â”‚    Non-refundable Storage Fee: 9880                                                               â”‚
    â”‚                                                                                                   â”‚
    â”‚ Transaction Dependencies:                                                                         â”‚
    â”‚    891Qjq6qDZ6SzAJiAg3CEaHobXrpDL5bAy2o45ZJPTuB                                                   â”‚
    â”‚    ESHcS3y3VCuaCVmWkKDx3EXX3icfPtj4bHhk86gaGWdo                                                   â”‚
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
    â”‚ No transaction block events â”‚
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
    â”‚ Object Changes                                                                                     â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ Created Objects:                                                                                   â”‚
    â”‚  â”Œâ”€â”€                                                                                               â”‚
    â”‚  â”‚ ObjectID: 0x569828cc4e134ccccd7408def18b80af1465ac791fd4ef40483f6b16e2f00d95                    â”‚
    â”‚  â”‚ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                      â”‚
    â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )   â”‚
    â”‚  â”‚ ObjectType: 0xe1d9d66b7a19b27ebda338a52593cd10e728f666f34ecd30a7cc2ad3fed186da::example::Forge  â”‚
    â”‚  â”‚ Version: 3                                                                                      â”‚
    â”‚  â”‚ Digest: 4iD7ZhsFS9iFuszqxBSEL6xZdcnWG76WGgU4D5PH1PeL                                            â”‚
    â”‚  â””â”€â”€                                                                                               â”‚
    â”‚  â”Œâ”€â”€                                                                                               â”‚
    â”‚  â”‚ ObjectID: 0xde670ae990c8f20fd53e9f597a0da056bdb634175176602658e9da2c2ec9cb93                    â”‚
    â”‚  â”‚ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                      â”‚
    â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )   â”‚
    â”‚  â”‚ ObjectType: 0x2::package::UpgradeCap                                                            â”‚
    â”‚  â”‚ Version: 3                                                                                      â”‚
    â”‚  â”‚ Digest: AV27tn7ePXhdDyDV9TCkSQZA3mkMei9DV63AmB4DEjGN                                            â”‚
    â”‚  â””â”€â”€                                                                                               â”‚
    â”‚ Mutated Objects:                                                                                   â”‚
    â”‚  â”Œâ”€â”€                                                                                               â”‚
    â”‚  â”‚ ObjectID: 0x01b2795ba5800c8f7cb7d7c56abe19e24c656ed6764f3ccc5e66da3de52402a8                    â”‚
    â”‚  â”‚ Sender: 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea                      â”‚
    â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )   â”‚
    â”‚  â”‚ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                      â”‚
    â”‚  â”‚ Version: 3                                                                                      â”‚
    â”‚  â”‚ Digest: 46rvdbXkw5qqsBYbUGChzgFatJAYPmarPmFHgRRJiiU9                                            â”‚
    â”‚  â””â”€â”€                                                                                               â”‚
    â”‚ Published Objects:                                                                                 â”‚
    â”‚  â”Œâ”€â”€                                                                                               â”‚
    â”‚  â”‚ PackageID: 0xe1d9d66b7a19b27ebda338a52593cd10e728f666f34ecd30a7cc2ad3fed186da                   â”‚
    â”‚  â”‚ Version: 1                                                                                      â”‚
    â”‚  â”‚ Digest: 4bzxMQgcSZoKzppNiRtQwAWDBvCgjr18gQi2H8Yk1tQZ                                            â”‚
    â”‚  â”‚ Modules: example                                                                                â”‚
    â”‚  â””â”€â”€                                                                                               â”‚
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
    â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
    â”‚ Balance Changes                                                                                   â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  â”Œâ”€â”€                                                                                              â”‚
    â”‚  â”‚ Owner: Account Address ( 0x0fe375fff0ee40d20c54a7f2478b9b5c7eaa3625b7611f9661ec5faefb4a6fea )  â”‚
    â”‚  â”‚ CoinType: 0x2::sui::SUI                                                                        â”‚
    â”‚  â”‚ Amount: -10000680                                                                              â”‚
    â”‚  â””â”€â”€                                                                                              â”‚
    â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
    ```

## Help

Each command has its own help section. For example:

```sh
$ sui client call --help
```

<ImportContent source="console-output/sui-client-call-help.mdx" mode="snippet" />

>>>> sui/docs/content/references/cli/keytool.mdx
---
title: Sui Keytool CLI
description: The Sui Keytool CLI has commands for managing and generating addresses, working with private keys, signatures, or zkLogin. 
keywords: [ Keytool cli, Keytool reference, Keytool, sui Keytool, Keytool help, how to use Keytool, key tool ]
---

The Sui CLI `keytool` command provides several command-level access for the management and generation of addresses, as well as working with private keys, signatures, or zkLogin. For example, a user could export a private key from the Sui Wallet and import it into the local Sui CLI wallet using the `sui keytool import [...]` command.

<ImportContent source="cli-check-install.mdx" mode="snippet" />

## Commands

```sh
$ sui keytool --help
```

<ImportContent source="console-output/sui-keytool-help.mdx" mode="snippet" />

## JSON output

Append the `--json` flag to commands to format responses in JSON instead of the more human friendly default Sui CLI output. This can be useful for extremely large datasets, for example, as those results can have a troublesome display on smaller screens. In these cases, the `--json` flag is useful. 

## Examples

The following examples demonstrate some of the most often used commands. 

### List the key pairs in the local wallet

Use the `sui keytool list` command to output all the Sui addresses that exist in the `~/.sui/sui_config/sui.keystore` file in a readable format. 


```sh
$ sui keytool list
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ suiAddress      â”‚  0x3047f142a84297a42a65fb0a8c7a716d9d1b0bd0413d6bfa5ddfec45df175235  â”‚ â”‚
â”‚ â”‚ publicBase64Key â”‚  AHsXwcxaWNaNtCIIszwu7V2G6HO8aNM1598w/8y0zI5q                        â”‚ â”‚
â”‚ â”‚ keyScheme       â”‚  ed25519                                                             â”‚ â”‚
â”‚ â”‚ flag            â”‚  0                                                                   â”‚ â”‚
â”‚ â”‚ peerId          â”‚  7b17c1cc5a58d68db42208b33c2eed5d86e873bc68d335e7df30ffccb4cc8e6a    â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•® â”‚
â”‚ â”‚ suiAddress      â”‚  0x514692f08249c3e9957799ce29074695840422564bff85e424b56de462913e0d  â”‚ â”‚
â”‚ â”‚ publicBase64Key â”‚  AKJCGi8R8TslhYdO2OHIjI6rbr+to1eR+vlOjigLY6SX                        â”‚ â”‚
â”‚ â”‚ keyScheme       â”‚  ed25519                                                             â”‚ â”‚
â”‚ â”‚ flag            â”‚  0                                                                   â”‚ â”‚
â”‚ â”‚ peerId          â”‚  a2421a2f11f13b2585874ed8e1c88c8eab6ebfada35791faf94e8e280b63a497    â”‚ â”‚
â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯ â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Generate a new key pair and store it in a file

To generate a new key pair with the `ed25519` scheme, use the `sui keytool generate ed25519` command. For other schemes, see `sui keytool generate â€“help`. The key pair file is saved to the current directory with its filename being the address. The content of the file is a Base64 encoded string of 33-byte `flag || privkey`. 

```sh
$ sui keytool generate ed25519
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ suiAddress      â”‚  0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25               â”‚
â”‚ publicBase64Key â”‚  AKTAGf9iv0JqeLXXlsr4PUzBXb9VY8lK7xiZMS50GSu6                                     â”‚
â”‚ keyScheme       â”‚  ed25519                                                                          â”‚
â”‚ flag            â”‚  0                                                                                â”‚
â”‚ mnemonic        â”‚  cushion price ability recall payment embody kid media rude mosquito chalk broom  â”‚
â”‚ peerId          â”‚  a4c019ff62bf426a78b5d796caf83d4cc15dbf5563c94aef1899312e74192bba                 â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Show the key pair data from a file

Use `sui keytool show [filename]` to show the key pair data that is stored in a file. For example, the previous command generated a file named `0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25.key`. 

```sh
$ sui keytool show 0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25.key
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ suiAddress      â”‚  0x5d8aa70f17d9343813d3ba6a59ecf5e8a23ffb487938e860999a722989eaef25  â”‚
â”‚ publicBase64Key â”‚  AC+AKTAGf9iv0JqeLXXlsr4PUzBXb9VY8lK7xiZMS50GSu6                     â”‚
â”‚ keyScheme       â”‚  ed25519                                                             â”‚
â”‚ flag            â”‚  0                                                                   â”‚
â”‚ peerId          â”‚  a4c019ff62bf426a78b5d796caf83d4cc15dbf5563c94aef1899312e74192bba    â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

### Sign a transaction

```sh
$ sui keytool sign --data AAABACBRRpLwgknD6ZV3mc4pB0aVhAQiVkv/heQktW3kYpE+DQEBAQABAAAwR/FCqEKXpCpl+wqMenFtnRsL0EE9a/pd3+xF3xdSNQEaEUeErlBmGWxz3Bh+9BZh2mzayodzsri7xIZNDHRA3wIAAAAAAAAAILsR2d1FIZ5+ADDYZtJ2e9CWlpAxsGd4Y2rZrjlyTUF1MEfxQqhCl6QqZfsKjHpxbZ0bC9BBPWv6Xd/sRd8XUjXoAwAAAAAAAICWmAAAAAAAAA== --address 0x3047f142a84297a42a65fb0a8c7a716d9d1b0bd0413d6bfa5ddfec45df175235
```
```sh
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ suiAddress   â”‚ 0x3047f142a84297a42a65fb0a8c7a716d9d1b0bd0413d6bfa5ddfec45df175235                                                                                               â”‚
â”‚ rawTxData    â”‚ AAABACBRRpLwgknD6ZV3mc4pB0aVhAQiVkv/heQktW3kYpE+DQEBAQABAAAwR/FCqEKXpCpl+wqMenFtnRsL0EE9a/pd3+xF3xdSNQEaEUeErlBmGWxz3Bh+9BZh2mzayodzsri7xIZNDHRA3wIAAAAAAAAAILsR â”‚
â”‚              â”‚ 2d1FIZ5+ADDYZtJ2e9CWlpAxsGd4Y2rZrjlyTUF1MEfxQqhCl6QqZfsKjHpxbZ0bC9BBPWv6Xd/sRd8XUjXoAwAAAAAAAICWmAAAAAAAAA==                                                     â”‚
â”‚ intent       â”‚ â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â•®                                                                                                                                                â”‚
â”‚              â”‚ â”‚ scope   â”‚  0  â”‚                                                                                                                                                â”‚
â”‚              â”‚ â”‚ version â”‚  0  â”‚                                                                                                                                                â”‚
â”‚              â”‚ â”‚ app_id  â”‚  0  â”‚                                                                                                                                                â”‚
â”‚              â”‚ â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â•¯                                                                                                                                                â”‚
â”‚ rawIntentMsg â”‚ AAAAAAABACBRRpLwgknD6ZV3mc4pB0aVhAQiVkv/heQktW3kYpE+DQEBAQABAAAwR/FCqEKXpCpl+wqMenFtnRsL0EE9a/pd3+xF3xdSNQEaEUeErlBmGWxz3Bh+9BZh2mzayodzsri7xIZNDHRA3wIAAAAAAAAA â”‚
â”‚              â”‚ ILsR2d1FIZ5+ADDYZtJ2e9CWlpAxsGd4Y2rZrjlyTUF1MEfxQqhCl6QqZfsKjHpxbZ0bC9BBPWv6Xd/sRd8XUjXoAwAAAAAAAICWmAAAAAAAAA==                                                 â”‚
â”‚ digest       â”‚ +B8Cbr16HfOVT50DoN/QF8HB0+oznm8KAYy8Rm+TQFo=                                                                                                                     â”‚
â”‚ suiSignature â”‚ ANucBEl9TIE0uv+w965DvOjlfDUll7NUtIpJgRhPc3D3y3EtZ4cvaNbm8i5pc7TNIov/qI0FhzIYf2J6PbqoNQ57F8HMWljWjbQiCLM8Lu1dhuhzvGjTNeffMP/MtMyOag==                             â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
 ```

## Help

Each command has its own help section. For example:

```sh
$ sui keytool sign --help
```

<ImportContent source="console-output/sui-keytool-sign-help.mdx" mode="snippet" />

>>>> sui/docs/content/references/cli/move.mdx
---
title: Sui Move CLI
description: The Sui CLI move command provides commands for working with Move source code directly from a terminal or console.
keywords: [ sui move, sui move help, move, move reference, move commands, sui move commands, use move cli, cli move, create a move project, interact with move project, move project, move project cli ]
---

The Sui CLI `move` command provides several commands for working with Move source code. A typical usage of `sui move` is to compile and test the Move code, or to generate a new Move project by using `sui move new project_name`, which creates the needed directories and the `Move.toml` file.

<ImportContent source="cli-check-install.mdx" mode="snippet" />

## Commands

```sh
$ sui move --help
```

<ImportContent source="console-output/sui-move-help.mdx" mode="snippet" />

## Examples

The following examples demonstrate some of the most often used commands.

### Create a new Move project

To create a new Move project that automatically adds the necessary dependencies in a `Move.toml` file, run `sui move new [<PROJECT-NAME>]`.

```sh
$ sui move new smart_contract_test
```
```sh
$ ls -l smart_contract_test
```
```sh
Move.toml
Sources
```
Display the contents of Move.toml file.

```sh
$ cat smart_contract_test/Move.toml
```

```sh
[package]
name = "smart_contract_test"
version = "0.0.1"

[dependencies]
Sui = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }

[addresses]
smart_contract_test = "0x0"
```

### Build a Move project

Use `sui move build` at the root of your Move project to build the package.

```sh
$ sui move build
```
```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING smart_contract_test
```

### Run tests in a Move project

Use `sui move test` to run the tests in a Move package.

```sh
$ sui move test
```
```sh
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING smart_contract_test
Running Move unit tests
Test result: OK. Total tests: 0; passed: 0; failed: 0
```

### Get test coverage for a module


:::caution

This command currently only works on debug builds of the CLI.  Please build the CLI from source to use it.

:::


This example uses [`first_package`](https://github.com/MystenLabs/sui/tree/main/examples/move/first_package) Move package.

To get a summary of the test coverage, you must first run the `sui move test --coverage` command, and then the `sui move coverage summary --test` to get a summary of the test coverage in the example project.

```sh
$ sui move test --coverage
```
```sh
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING first_package
Running Move unit tests
[ PASS    ] 0x0::example::test_module_init
[ PASS    ] 0x0::example::test_sword_transactions
Test result: OK. Total tests: 2; passed: 2; failed: 0

$ sui move coverage summary --test
+-------------------------+
| Move Coverage Summary   |
+-------------------------+
Module 0000000000000000000000000000000000000000000000000000000000000000::example
>>> % Module coverage: 92.81
+-------------------------+
| % Move Coverage: 92.81  |
+-------------------------+
```

## Help

Each command has its own help section. For example:

```sh
$ sui move build --help
```

<ImportContent source="console-output/sui-move-build-help.mdx" mode="snippet" />

>>>> sui/docs/content/references/cli/ptb.mdx
---
title: Sui Client PTB CLI
description: The Sui Client PTB CLI enables a user to construct a PTB and execute it from the command line or a file.
keywords: [ client ptb, sui client ptb, programmable transaction block, ptbs, sui cli ptbs, sui ptb cli, ptb cli, execute ptb from cli, execute ptb from file, ptb help ]
---

The `client ptb` command allows you to specify the transactions for execution in a programmable transaction block (PTB) directly from your CLI or through bash scripts.

:::warning

The examples in this document were tested using a `bash` shell environment. Your experience might vary depending on how your shell interprets the input values (for example, zsh requires quotes around passed values in brackets: "[]"; whereas bash accepts them without quotes). On Windows, you might need to add even more quotes around arguments passed (for example, `--assign "forge @<FORGE-ID>"`).

:::

## Commands

The following list itemizes all the available args for the `sui client ptb` command. Use the `--help` for a long help version that includes some examples on how to use this command.

```sh
$ sui client ptb --help
```

<ImportContent source="console-output/sui-client-ptb-help.mdx" mode="snippet" />

## Design philosophy and concepts

The main philosophy behind the CLI PTB support is to enable a user to build and execute a PTB from the command line. Bash scripts can be used to construct and execute the PTB just as you would do from the command line, providing great flexibility when it comes to automating different tasks.

Besides using existing [traditional PTB](/concepts/transactions/prog-txn-blocks/) related concepts, we introduce a few new and important concepts for this command.

:::warning

All the following examples were tested using a `bash` shell environment and your experience may vary depending on how your shell interprets the input values (e.g., zsh requires to pass values in brackets by adding quotes around it: "[]"; bash accepts them without quotes).

:::

### Types

Sometimes, CLI PTBs require that you specify the type of a value or variable. For instance, in the following example you must provide the `<u64>` type when calling the `0x1::option::is_none` function.

```sh
$ sui client ptb \
--assign my_variable none \
--move-call 0x1::option::is_none "<u64>" my_variable \
--gas-budget 50000000
```

To pass in multiple types, delimit them with a comma:

```sh
...
--move-call package::module::function "<u64,u8,u256>" \
...
```

### Strings

CLI PTBs support string literals as inputs, which will be encoded as pure values that can be used as inputs to `vector<u8>`, `std::ascii::String` and `std::string::String` parameters. The following example previews a transaction block that passes the string `"Hello, world"` to a function `m::f` in a package `$PKG` (its ID is held in an environment variable).

```sh
$ sui client ptb --move-call "$PKG::m::f" '"Hello, world"' --gas-budget 10000000 --preview
```

:::warning

Double-quoted string literals tend to also be valid syntax for shells (like `bash`), so when inputting PTBs on the command-line, remember to wrap the entire string in single-quotes so that its double-quotes are interpreted literally, as in the previous example.

:::

### Addresses and Object IDs

<ImportContent source="address-prefix.mdx" mode="snippet" />

Here are some examples for `transfer-objects` and `gas-coin`:

```sh
$ sui client ptb --transfer-objects "[ARRAY_OF_OBJECTS]" @0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331 --gas-coin @0x00002819ee07a66e53800495ccf5eeade8a02054a2e0827546c70e4b226f0495
```

### Vectors

CLI PTBs support vectors of serializable types as input (which includes all the primitive types, `ID`s, and `Option`s). Vectors are represented as a comma-separated list of values in square brackets prefixed with `vector`.

```sh
$ sui client ptb --move-call "$PKG::m::f" vector[1, 2, 3]
```

Example above illustrates a vector of integer values. Depending on the type of the vector, you can pass any supported type:

```sh
--move-call package::module::function vector[@0x1, @0x2, @0x3] # vector<address>
--move-call package::module::function vector[none, none]       # vector<Option<T>>
--move-call package::module::function vector["1", "2", "3"]    # vector<String>
```

### Option

Options are represented as `none` or `some(value)`. The value can be any supported primitive type, `ID`, or `Option`.

```sh
$ sui client ptb --move-call "0x1::option::destroy_some" some(2)
```

For `none`, you can use the `none` keyword. For `some`, you can use the `some` keyword followed by the value.

```sh
$ sui client ptb --move-call "0x1::option::destroy_none" none
```

### Addresses

### Assign

Use the `--assign` argument to bind values to variables. There are two ways you can use it:

- assign a value to a variable
- assign a variable to the result of the previous command

Let's look at the first case where you assign a value to a variable. You want to check if some variable's value is `none`. Call the `0x1::option::is_none` function from the Move standard library, and pass in the variable name:

```sh
$ sui client ptb \
--assign my_variable none \
--move-call 0x1::option::is_none "<u64>" my_variable \
--gas-budget 50000000
```

:::tip

CLI PTB uses name resolution for common packages like `sui`, `std`, `deepbook`, so you can use them directly instead of their addresses: `0x2`, `0x1`, or `0xdee9`.

:::

In the second case, if a previous command outputs some result, you can bound it to a variable for later access. Let's see an example where you want a new coin with 1000 MIST, which you can achieve by using the `split-coins` command. After you do that, you want to transfer the new coin to another address. Without the `--assign` argument, you couldn't instruct the CLI to transfer that new coin object as you would not have a way to refer to it.

```sh
$ sui client ptb \
--split-coins gas "[1000]" \
--assign coin \
--transfer-objects "[coin]" @recipient_address \
--gas-budget 50000000
```

:::tip

If you build a complex PTB, use the `--preview` flag to display the PTB transaction list instead of executing it.

:::

## Examples

The following examples demonstrate how to use the `client ptb` command.

:::tip

When a PTB is executed, the output contains all the relevant information (transaction data, gas cost, effects, object changes, and so on). Use `--summary` to get a short summary when you do not need all the data. For complex PTBs, you can use `--preview` to display the PTB transaction list instead of executing it.

:::

### Move call

When needing to execute a Move call, use the `--move-call` transaction to call a specific function from a package. The CLI PTB supports name resolution for common packages like `sui`, `std`, `deepbook`, so you can use both `0x1::option::is_none` as well as `std::option::is_none` for passing the function name.

```sh
--assign A none
--move-call std::option::is_none "<u64>" A
```

To call a specific function from a specific package, you can use the following call:

```sh
--move-call PACKAGE_ADDR::MODULE::FUNCTION "<TYPE>" FUNC_ARG1 FUNC_ARG2 ...
```

### Publish

Publishing a package is one of the most important commands you need when working with Sui. While the CLI has a standalone `publish` command, PTBs also support publishing and upgrading packages. One main difference is that with `sui client ptb`, you must explicitly transfer the `UpgradeCap` object that is returned when creating a package, or destroy it with a call to [`make_immutable`](/concepts/sui-move-concepts/packages.mdx). Here is an example on how to publish a Move project on chain using the `sui client ptb` command. It makes a call to the `sui::tx_context::sender` to acquire the sender and assigns the result of that call to the `sender` variable, and then calls the publish command. The result of `publish` is bounded to `upgrade_cap` variable, and then this object is transferred to the sender.

```sh
$ sui client ptb \
--move-call sui::tx_context::sender \
--assign sender \
--publish "." \
--assign upgrade_cap \
--transfer-objects "[upgrade_cap]" sender \
--gas-budget 100000000
```

### Split, destroy, and merge coins

The following example showcases how to split a gas coin into multiple coins, make a move call to destroy one or more of the new coins, and finally merge the coins that were not destroyed back into the gas coin. It also showcases how to use framework name resolution (for example, `sui::coin` instead of `0x2::coin`) and how to refer to different values in an array using the `.` syntax.

```sh
# Split off from gas
--split-coins gas "[0,1,2,3]"
--assign coins
--move-call sui::coin::destroy_zero<sui::sui::SUI> coins.0
# Can further split a split coin (and through variable bindings/result accesses)
--split-coins coins.1 "[0,0]"
--assign zcoins
# Destroy both new coins
--move-call sui::coin::destroy_zero<sui::sui::SUI> zcoins.0
--move-call sui::coin::destroy_zero<sui::sui::SUI> zcoins.1
# Can merge the split coins back
--merge-coins gas "[coins.1, coins.2, coins.3]"
--gas-budget 10000000
```

### Transfer objects

This example creates three new coins from gas and transfers them to a different address.

```sh
--assign to_address @0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331 \
--split-coins gas "[1,2,3]" \
--assign s \
--transfer-objects "[s.0, s.1, s.2]" to_address \
--gas-budget 10000000
```

:::info

You can also pass an alias (without the '@') instead of an address.

:::

## Reserved words

You cannot use the following words for variable names:

- `address`
- `bool`
- `vector`
- `some`
- `none`
- `gas`
- `u8`
- `u16`
- `u32`
- `u64`
- `u128`
- `u256`

## JSON output

Append the `--json` flag to commands to format responses in JSON instead of the more human-friendly default Sui CLI output. This can be useful for extremely large datasets, for example, as those results can have a troublesome display on smaller screens. In these cases, the `--json` flag is useful.

>>>> sui/docs/content/references/cli/replay.mdx
---
title: Sui Replay CLI
description: Use the Sui CLI to replay a given transaction to view its effects.
---

Replay is a tool that allows you to replay a given transaction to check and analyze the transaction effects. In a nutshell, the replay tool will locally execute the transaction and compare its effects to the effects that exist on chain.

Using the replay tool, you can pass the `--trace` flag to generate execution traces for a transaction that can be used with the Move debugger. For more information about the Move debugger, see the [Move Debugger](../ide/debugger.mdx) page. You can run different [analyses on the transaction traces](./trace-analysis.mdx) such as [gas profiling](./trace-analysis.mdx#profiling-a-transaction).

## Usage

The main command for replaying a transaction follows. For all available flags and arguments, run `sui replay --help`.

```sh
$ sui replay --digest <digest>
```

After running this command, the tool generates a directory corresponding to the digest in `<cur_directory>/.replay/<digest>`, unless you set the `--output-dir` flag. The output directory is **not** automatically overwritten if you attempt to replay the same transaction more than once. If you want to overwrite this directory, include the `--overwrite` flag.


After successfully running the previous command, your console provides a response similar to the following:
```
Successfully replayed transaction

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: 5sbk5UYpQv1i84zkSBSWmowAmPTxw71U7Bb1gbiW5w4y                                              â”‚
â”‚ Status: Success                                                                                   â”‚
â”‚ Executed Epoch: 816                                                                               â”‚
â”‚ Mutated Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x03ff4587a65631bb43648a204588789e95c556eb3f577a0bbca49f0c70724fb6                         â”‚
â”‚  â”‚ Owner: Account Address ( 0xdae936b5ac98927cf44e9270dd3a045d04d17dd167f744e619d3ba79207f7068 )  â”‚
â”‚  â”‚ Version: 524747425                                                                             â”‚
â”‚  â”‚ Digest: 5a6zqDPxZi1iPYE4QCGGd9D2WN9fMzZGgAq4LQvYDKsH                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x1e67adaf36d79a3f9e37dde8a8ea24122d4360b537cbaed29612c06267a5d23b                         â”‚
â”‚  â”‚ Owner: Object ID: ( 0xe83c2da3f26cedac7ced3652dbfae0df591aeb51818d45fb33e91364d551d0cd )       â”‚
â”‚  â”‚ Version: 524747425                                                                             â”‚
â”‚  â”‚ Digest: 7CXwfqNEnXVHHDuFMxNQvpF7TqSDo65RkMh3byXX3qtW                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x4044f18055b2eafa176865303c1d8aa257d2d750e4a003c24e86e2fab2151d4b                         â”‚
â”‚  â”‚ Owner: Object ID: ( 0xa676f00193c93b812da927baf1e51bd408c2a32b14104df6c1af2b0e874f33ad )       â”‚
â”‚  â”‚ Version: 524747425                                                                             â”‚
â”‚  â”‚ Digest: B5qvW4VTQXHotjJ9becki57bnD45fcJvWN8gTzWViVN4                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x8ece4cb6de126eb5c7a375f90c221bdc16c81ad8f6f894af08e0b6c25fb50a45                         â”‚
â”‚  â”‚ Owner: Shared( 414117256 )                                                                     â”‚
â”‚  â”‚ Version: 524747425                                                                             â”‚
â”‚  â”‚ Digest: 68jzyz67fHfS3xczermH8FUmDXg82pJ75t8SWLkq5W3G                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xd7aaa813f0ee8b63ea5a1ea85849a74f8d48210358b53d0de710de29566d6247                         â”‚
â”‚  â”‚ Owner: Object ID: ( 0xa30645bc6016097b9182a25eb57a50522a1c08216416b21be8fef564aeb6e0fe )       â”‚
â”‚  â”‚ Version: 524747425                                                                             â”‚
â”‚  â”‚ Digest: A57sAtSpBT6nmUMqbas5w6Kh6a7guhTgZTxM1JeQavy1                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Shared Objects:                                                                                   â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x8ece4cb6de126eb5c7a375f90c221bdc16c81ad8f6f894af08e0b6c25fb50a45                         â”‚
â”‚  â”‚ Version: 524747424                                                                             â”‚
â”‚  â”‚ Digest: AHtPqe2Spt5N1ba5QiBtnkj3yBNTNV27av8FSKgbaS21                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Deleted Objects:                                                                                  â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xf2a44b7b1de81c8fbf11635411fa7cd2cdc8ae64b48dae13928d4d91066cf13b                         â”‚
â”‚  â”‚ Version: 524747425                                                                             â”‚
â”‚  â”‚ Digest: 7gyGAp71YXQRoxmFBaHxofQXAipvgHyBKPyxmdSJxyvz                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0xfe02a0286e87e702c6c9ccd87c3392033bdaf571aeed2f48982591e8ea5f21f5                         â”‚
â”‚  â”‚ Version: 524747425                                                                             â”‚
â”‚  â”‚ Digest: 7gyGAp71YXQRoxmFBaHxofQXAipvgHyBKPyxmdSJxyvz                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Object:                                                                                       â”‚
â”‚  â”Œâ”€â”€                                                                                              â”‚
â”‚  â”‚ ID: 0x03ff4587a65631bb43648a204588789e95c556eb3f577a0bbca49f0c70724fb6                         â”‚
â”‚  â”‚ Owner: Account Address ( 0xdae936b5ac98927cf44e9270dd3a045d04d17dd167f744e619d3ba79207f7068 )  â”‚
â”‚  â”‚ Version: 524747425                                                                             â”‚
â”‚  â”‚ Digest: 5a6zqDPxZi1iPYE4QCGGd9D2WN9fMzZGgAq4LQvYDKsH                                           â”‚
â”‚  â””â”€â”€                                                                                              â”‚
â”‚ Gas Cost Summary:                                                                                 â”‚
â”‚    Storage Cost: 11187200 MIST                                                                    â”‚
â”‚    Computation Cost: 1000000 MIST                                                                 â”‚
â”‚    Storage Rebate: 13031568 MIST                                                                  â”‚
â”‚    Non-refundable Storage Fee: 131632 MIST                                                        â”‚
â”‚                                                                                                   â”‚
â”‚ Transaction Dependencies:                                                                         â”‚
â”‚    jTwsncjYXYtioZqfTZSpjLUaxWrNT2vyhSgjP3P9XGG                                                    â”‚
â”‚    36GM8UKe7M71qQkSY468vnxcApxFuMErx4M8vF5fQdLs                                                   â”‚
â”‚    4h5punxCyApywJVsWaux7Ym7mf7tzBECjp2avZTaLdue                                                   â”‚
â”‚    BvfZzvfVD8SYPAx6De3CVFrgrxdSVgEACqxtvBtiHm7R                                                   â”‚
â”‚    D3AKQmh6WsSv74cGeXpdE5cg3TdRHcptapPd2ySBQdFX                                                   â”‚
â”‚    D7LMC2Jzf9LH2FmeW4WW2qbHDgEBCfduDhFH3Y2LpQAH                                                   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
Transaction Gas Report for 5sbk5UYpQv1i84zkSBSWmowAmPTxw71U7Bb1gbiW5w4y

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Gas Info                   â”‚          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Computation Cost           â”‚ 1000000  â”‚
â”‚ Storage Cost               â”‚ 11187200 â”‚
â”‚ Storage Rebate             â”‚ 13031568 â”‚
â”‚ Non-Refundable Storage Fee â”‚ 131632   â”‚
â”‚ Gas Used                   â”‚ 947      â”‚
â”‚ Gas Budget                 â”‚ 3089992  â”‚
â”‚ Gas Price                  â”‚ 1000     â”‚
â”‚ Reference Gas Price        â”‚ 1000     â”‚
â”‚ Storage Gas Price          â”‚ 76       â”‚
â”‚ Rebate Rate                â”‚ 9900     â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Object ID                                                          â”‚ Bytes â”‚ Old Rebate â”‚ New Rebate â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 0x03ff4587a65631bb43648a204588789e95c556eb3f577a0bbca49f0c70724fb6 â”‚ 130   â”‚ 988000     â”‚ 988000     â”‚
â”‚ 0x1e67adaf36d79a3f9e37dde8a8ea24122d4360b537cbaed29612c06267a5d23b â”‚ 461   â”‚ 3503600    â”‚ 3503600    â”‚
â”‚ 0x4044f18055b2eafa176865303c1d8aa257d2d750e4a003c24e86e2fab2151d4b â”‚ 398   â”‚ 3024800    â”‚ 3024800    â”‚
â”‚ 0x8ece4cb6de126eb5c7a375f90c221bdc16c81ad8f6f894af08e0b6c25fb50a45 â”‚ 175   â”‚ 1330000    â”‚ 1330000    â”‚
â”‚ 0xd7aaa813f0ee8b63ea5a1ea85849a74f8d48210358b53d0de710de29566d6247 â”‚ 308   â”‚ 2340800    â”‚ 2340800    â”‚
â”‚ 0xf2a44b7b1de81c8fbf11635411fa7cd2cdc8ae64b48dae13928d4d91066cf13b â”‚ 0     â”‚ 988000     â”‚ 0          â”‚
â”‚ 0xfe02a0286e87e702c6c9ccd87c3392033bdaf571aeed2f48982591e8ea5f21f5 â”‚ 0     â”‚ 988000     â”‚ 0          â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
````

The response above provides the transaction effects information, gas report, and a more detailed list of the each object's size and cost. For more information about
the gas cost, please refer to the [gas in sui](../../concepts/tokenomics/gas-in-sui.mdx) page.

You can replay multiple transactions at once by using the `--digests-path` flag to specify a location of a file containing multiple transaction digests, one per line. By default, the entire batch is replayed regardless of the success or failure of an individual transaction execution. You can use the `--terminate-early` flag to terminate batch execution if an error occurs when replaying one of the transactions.

You can provide default values for the replay tool flags by specifying them in the `~/.sui/sui_config/replay.toml` file. You need to specify them in the `[flags]` section (the only section currently supported) using their "long" names with initial dashes (`--`) removed. For example, you can disable showing transaction effects with `show-effects = false` but not with `e = false`. Here is a complete example of a config file:
```toml
[flags]
show-effects = false
overwrite = true
```
>>>> sui/docs/content/references/cli/trace-analysis.mdx
---
title: Sui Trace Analysis
description: Use the Sui CLI to analyze transaction traces.
---

[Replaying a transaction](./replay.mdx) generates a trace file that contains detailed information about the execution of the transaction, such as gas usage, functions called, instructions executed, and more. Use the Sui CLI to analyze a trace file and extract useful insights.

:::info

Currently, only gas profile analysis is supported for transactions traced with the replay command. Support for additional analyses is planned.

:::

### Profile a transaction

Use the `sui analyze-trace -p <PATH_TO_TRACE_FILE> gas-profile` command to analyze a trace for a transaction and produce a gas profile. 

The command outputs a profile to the current working directory in the format `gas_profile_{TRACE_FILE_NAME}.json`. You can also supply an optional `--output/-o` flag to the `analyze-trace` command to specify a different output directory for the profile. Use [speedscope](https://www.speedscope.app/) to display the profile that was generated.

To install speedscope, run:

```sh
$ npm install -g speedscope
```

Then, to open a profile in speedscope, run:

```sh
$ speedscope <PATH/PROFILE-OUTPUT-FILE>
```

When viewing the profile in speedscope, there are three different views available: Timer Order, Left Heavy, and Sandwich. 

In each view, a bar's vertical width corresponds to the percentage of gas consumption incurred by the function. Hover your mouse over a bar or click a bar to see the computation units accrued by the function invocation. 

The transaction's total computation and storage units are multiplied by the gas price to determine the total gas cost of the transaction based on a tier system.

**Time Order** shows the call stack of function invocations from left to right in the order of invocation, while **Left Heavy** combines repeated sequences of nested invocations into a single combined call stack. 

**Left Heavy** displays these sequences from left to right by total incurred gas consumption per combined call stack. This is useful to quickly observe the total gas consumption over all calls when there have been hundreds of repeated calls to the same function.

In both views, click the top section and drag to zoom in or out over different sections of the profile.

**Sandwich** view shows a list of discrete values that correspond to gas consumption per function. The **Total** value shows the gas cost incurred in all functions called by the function. **Self** shows the gas cost for only the given function.

Observing a transaction's gas consumption provides insight into the expected gas cost of a package. During package development, you can [run a local network](/guides/developer/sui-101/local-network.mdx) and publish your package locally. Then, create a transaction that calls your package and run the profiler on that transaction to see a breakdown of the gas cost.

>>>> sui/docs/content/references/cli/validator.mdx
---
title: Sui Validator CLI
description: The Sui Validator CLI is used to access the validator features of the Sui network. 
keywords: [ sui validator cli, sui validator, sui cli validator, interact with validator from cli, validator cli, validator commands ]
---

The Sui CLI `validator` command provides command-level access to validator features of the Sui network.

## Commands

```sh
$ sui validator --help
```

```sh
Usage: sui validator [OPTIONS] [COMMAND]

Commands:
  make-validator-info          	 
  become-candidate             	 
  join-committee               	 
  leave-committee              	 
  display-metadata             	 
  update-metadata              	 
  update-gas-price              	Update gas price that is used to calculate Reference Gas Price
  report-validator              	Report or un-report a validator
  serialize-payload-pop         	Serialize the payload that is used to generate Proof of Possession. This is useful to take the payload offline for an Authority protocol
                                    	key pair to sign
  display-gas-price-update-raw-txn  Print out the serialized data of a transaction that sets the gas price quote for a validator
  help                          	Print this message or the help of the given subcommand(s)

Options:
  	--client.config <CONFIG>  Sets the file storing the state of our user accounts (an empty one will be created if missing)
  	--json                	Return command outputs in json format
  -y, --yes                	 
  -h, --help                	Print help
```

## Examples

The following examples demonstrate some of the most often used commands. 

### Update gas price for next epoch

```sh
$ sui validator  update-gas-price 500
```


<details>
  <summary>
  Toggle output
  </summary>

```sh
----- Transaction Digest ----
A8z83EqjmgwRNFV6sme6A5tTTTQPjiLgiW76neyvhLud

----- Transaction Data ----
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Data                                                                                                                                                                                                                                                                                                                                                                                                                   	 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sender: 0xf...3d9                                                                                                                                                                                                                                                                                                                                                         	                                                         â”‚
â”‚ Gas Owner: 0xf...3d9                                                                                                                                                                                                                                                                                                                                                      	                                                         â”‚
â”‚ Gas Budget: 200000000 MIST                                                                                                                                                                                                                                                                                                                                                                                                         	 â”‚
â”‚ Gas Price: 1000 MIST                                                                                                                                                                                                                                                                                                                                                                                                               	 â”‚
â”‚ Gas Payment:                                                                                                                                                                                                                                                                                                                                                                                                                       	 â”‚
â”‚  â”Œâ”€â”€                                                                                                                                                                                                                                                                                                                                                                                                                               	 â”‚
â”‚  â”‚ ID: 0x8...19e                                                                                                                                                                                                                                                                                                                                                          	                                                         â”‚
â”‚  â”‚ Version: 1                                                                                                                                                                                                                                                                                                                                                                                                                      	 â”‚
â”‚  â”‚ Digest: 8UEiGYe3KL3S6JPs8uP2sbbx7sMCtzi8yJJ6SyTe9V1x                                                                                                                                                                                                                                                                                                                                                                            	 â”‚
â”‚  â””â”€â”€                                                                                                                                                                                                                                                                                                                                                                                                                               	 â”‚
â”‚                                                                                                                                                                                                                                                                                                                                                                                                                                    	 â”‚
â”‚ Transaction Kind : Programmable                                                                                                                                                                                                                                                                                                                                                                                                    	 â”‚
â”‚ Inputs: [Object(SharedObject { object_id: 0x0...005, initial_shared_version: SequenceNumber(1), mutable: true }), Object(ImmOrOwnedObject { object_id: 0x4...dbe, version: SequenceNumber(1), digest: o#82z9UUX9iD2Mq9zvciD56kmmDYqjF3iwaFadi3Mk16eJ }), Pure(SuiPureValue { value_type: Some(U64), value: "500" })]                                                                                                                   â”‚
â”‚ Commands: [                                                                                                                                                                                                                                                                                                                                                                                                                        	 â”‚
â”‚   MoveCall(0x0...003::sui_system::request_set_gas_price(Input(0),Input(1),Input(2))),                                                                                                                                                                                                                                                                                     	                                                         â”‚
â”‚ ]                                                                                                                                                                                                                                                                                                                                                                                                                                  	 â”‚
â”‚                                                                                                                                                                                                                                                                                                                                                                                                                                    	 â”‚
â”‚                                                                                                                                                                                                                                                                                                                                                                                                                                    	 â”‚
â”‚ Signatures:                                                                                                                                                                                                                                                                                                                                                                                                                        	 â”‚
â”‚	j2FE7GNkHm9+ey0zTQrgfaTXJgGu1vYWmivrVxbUfP56vIrxMFA4XxqEyw7Q8pM1FR+JDPgCsE1kgZRGH6TZDg==                                                                                                                                                                                                                                                                                                                                        	 â”‚
â”‚                                                                                                                                                                                                                                                                                                                                                                                                                                    	 â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
----- Transaction Effects ----
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                           	â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: A8z83EqjmgwRNFV6sme6A5tTTTQPjiLgiW76neyvhLud                                          	â”‚
â”‚ Status: Success                                                                               	â”‚
â”‚ Executed Epoch: 5                                                                             	â”‚
â”‚                                                                                               	â”‚
â”‚ Mutated Objects:                                                                              	â”‚
â”‚  â”Œâ”€â”€                                                                                          	â”‚
â”‚  â”‚ ID: 0x0...005                     	                                                            â”‚
â”‚  â”‚ Owner: Shared                                                                              	â”‚
â”‚  â”‚ Version: 16                                                                                	â”‚
â”‚  â”‚ Digest: ER2L6MxrqKNAsaRd9pWdMwvLzXG3ocGQnytnP9s5QLeh                                       	â”‚
â”‚  â””â”€â”€                                                                                          	â”‚
â”‚  â”Œâ”€â”€                                                                                          	â”‚
â”‚  â”‚ ID: 0x4...dbe                     	                                                            â”‚
â”‚  â”‚ Owner: Account Address ( 0xf45...3d9 )                                                         â”‚
â”‚  â”‚ Version: 16                                                                                	â”‚
â”‚  â”‚ Digest: 4yDkecsKPe8SnacWdECmq1yVDt7MzvpXCxbRGs74PGaB                                       	â”‚
â”‚  â””â”€â”€                                                                                          	â”‚
â”‚  â”Œâ”€â”€                                                                                          	â”‚
â”‚  â”‚ ID: 0x5...8d1                     	                                                            â”‚
â”‚  â”‚ Owner: Object ID: ( 0x000...005 )   	                                                        â”‚
â”‚  â”‚ Version: 16                                                                                	â”‚
â”‚  â”‚ Digest: BBu5zHWWX7nnb1XcFu5VLVnKZEU6AqRRarDDjEeBtqWy                                       	â”‚
â”‚  â””â”€â”€                                                                                          	â”‚
â”‚  â”Œâ”€â”€                                                                                          	â”‚
â”‚  â”‚ ID: 0x8...19e                     	                                                            â”‚
â”‚  â”‚ Owner: Account Address ( 0xf45...3d9 )                                                         â”‚
â”‚  â”‚ Version: 16                                                                                	â”‚
â”‚  â”‚ Digest: 4WQp6FYctutMFzf6f2EX68xut71AMubewJ6c7GxpzX7e                                       	â”‚
â”‚  â””â”€â”€                                                                                          	â”‚
â”‚                                                                                               	â”‚
â”‚ Shared Objects:                                                                               	â”‚
â”‚  â”Œâ”€â”€                                                                                          	â”‚
â”‚  â”‚ ID: 0x0...005                     	                                                            â”‚ 
â”‚  â”‚ Version: 15                                                                                	â”‚
â”‚  â”‚ Digest: 6vdobiuiDQpJguDxVbbMNW5ddRqEFkP67C3FWrAVYYuZ                                       	â”‚
â”‚  â””â”€â”€                                                                                          	â”‚
â”‚                                                                                               	â”‚
â”‚ Gas Object:                                                                                   	â”‚
â”‚  â”Œâ”€â”€                                                                                          	â”‚
â”‚  â”‚ ID: 0x8...19e                     	                                                            â”‚
â”‚  â”‚ Owner: Account Address ( 0xf45...3d9 )                                                         â”‚
â”‚  â”‚ Version: 16                                                                                	â”‚
â”‚  â”‚ Digest: 4WQp6FYctutMFzf6f2EX68xut71AMubewJ6c7GxpzX7e                                       	â”‚
â”‚  â””â”€â”€                                                                                          	â”‚
â”‚                                                                                               	â”‚
â”‚ Gas Cost Summary:                                                                             	â”‚
â”‚	Storage Cost: 31479200                                                                     	    â”‚
â”‚	Computation Cost: 1000000                                                                  	    â”‚
â”‚	Storage Rebate: 0                                                                          	    â”‚
â”‚	Non-refundable Storage Fee: 0                                                              	    â”‚
â”‚                                                                                               	â”‚
â”‚ Transaction Dependencies:                                                                     	â”‚
â”‚	2gqHgPZbjTkDWM9GnVuWU5kT9z2SWN2ggwK3ryxf8aUX                                               	    â”‚
â”‚	EmW6DhJWRACNZAvupiTNVacZFLoZxbNJ88mrKVv9DeiJ                                               	    â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

</details>


### Set gas price for the next epoch

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui validator request_set_gas_price --args 0x5 \"42\" --gas-budget GAS-BUDGET-AMOUNT>
```

### Display the validator information

```sh
$ sui validator display-metadata 0x3...de5
```


<details>
  <summary>
  Toggle output
  </summary>

```sh
0x3...de5's valdiator status: Active
SuiValidatorSummary {
	sui_address: 0x3...de5,
	protocol_pubkey_bytes: [
    	167,
    	93,
    	42,
    	177,
    	79,
    	244,
    	192,
    	168,
    	26,
    	242,
    	55,
    	119,
    	232,
    	131,
    	191,
    	112,
    	92,
    	219,
    	204,
    	109,
    	234,
    	107,
    	124,
    	116,
    	79,
    	200,
    	221,
    	159,
    	185,
    	142,
    	173,
    	161,
    	122,
    	214,
    	113,
    	183,
    	240,
    	124,
    	205,
    	8,
    	157,
    	110,
    	31,
    	85,
    	16,
    	106,
    	16,
    	34,
    	9,
    	254,
    	125,
    	36,
    	83,
    	125,
    	35,
    	231,
    	245,
    	203,
    	204,
    	43,
    	137,
    	70,
    	229,
    	201,
    	64,
    	157,
    	189,
    	203,
    	220,
    	222,
    	1,
    	121,
    	138,
    	139,
    	41,
    	108,
    	106,
    	57,
    	116,
    	212,
    	208,
    	249,
    	215,
    	18,
    	22,
    	237,
    	214,
    	179,
    	71,
    	192,
    	93,
    	89,
    	255,
    	51,
    	56,
    	158,
	],
	network_pubkey_bytes: [
    	118,
    	14,
    	165,
    	223,
    	145,
    	150,
    	130,
    	74,
    	212,
    	160,
    	218,
    	170,
    	134,
    	2,
    	206,
    	72,
    	228,
    	87,
    	35,
    	114,
    	40,
    	217,
    	206,
    	35,
    	29,
    	194,
    	81,
    	61,
    	186,
    	215,
    	56,
    	215,
	],
	worker_pubkey_bytes: [
    	84,
    	171,
    	204,
    	100,
    	81,
    	92,
    	16,
    	207,
    	151,
    	167,
    	70,
    	138,
    	104,
    	92,
    	100,
    	75,
    	53,
    	47,
    	212,
    	209,
    	92,
    	2,
    	109,
    	120,
    	66,
    	146,
    	180,
    	116,
    	144,
    	22,
    	139,
    	57,
	],
	proof_of_possession_bytes: [
    	137,
    	134,
    	236,
    	79,
    	232,
    	146,
    	206,
    	45,
    	136,
    	245,
    	8,
    	42,
    	114,
    	154,
    	128,
    	148,
    	60,
    	137,
    	214,
    	92,
    	177,
    	46,
    	118,
    	246,
    	37,
    	159,
    	183,
    	233,
    	122,
    	49,
    	121,
    	227,
    	136,
    	76,
    	48,
    	122,
    	119,
    	187,
    	194,
    	169,
    	114,
    	7,
    	16,
    	225,
    	104,
    	211,
    	100,
    	198,
	],
	name: "Staked",
	description: "The leading provider of staking infrastructure",
	image_url: "https://avatars.githubusercontent.com/u/38704373",
	project_url: "https://staked.us/",
	net_address: "/dns/sui-mainnet.prod-eks-eu-west-1.staked.cloud/tcp/8080/http",
	p2p_address: "/dns/sui-mainnet-udp.prod-eks-eu-west-1.staked.cloud/udp/8084",
	primary_address: "/dns/sui-mainnet-udp.prod-eks-eu-west-1.staked.cloud/udp/8081",
	worker_address: "/dns/sui-mainnet-udp.prod-eks-eu-west-1.staked.cloud/udp/8082",
	next_epoch_protocol_pubkey_bytes: None,
	next_epoch_proof_of_possession: None,
	next_epoch_network_pubkey_bytes: None,
	next_epoch_worker_pubkey_bytes: None,
	next_epoch_net_address: None,
	next_epoch_p2p_address: None,
	next_epoch_primary_address: None,
	next_epoch_worker_address: None,
	voting_power: 53,
	operation_cap_id: 0x4...217,
	gas_price: 1000,
	commission_rate: 1000,
	next_epoch_stake: 42223548570491465,
	next_epoch_gas_price: 1000,
	next_epoch_commission_rate: 1000,
	staking_pool_id: 0xc...932,
	staking_pool_activation_epoch: Some(
    	0,
	),
	staking_pool_deactivation_epoch: None,
	staking_pool_sui_balance: 42926894529549497,
	rewards_pool: 1047712965206377,
	pool_token_balance: 41704322845739375,
	pending_stake: 0,
	pending_total_sui_withdraw: 703345959058032,
	pending_pool_token_withdraw: 683314441220777,
	exchange_rates_id: 0x5...65d,
	exchange_rates_size: 231,
```
</details>

### Report a bad / non-performant validator

```sh
$ sui validator report-validator  0xf...3d9
```


<details>
  <summary>
  Toggle output
  </summary>


```sh
----- Transaction Digest ----
8jVYrpuRBmdSLP37MsQGRqUqE3kE2m8XiSS4TG4aJwXf

----- Transaction Data ----
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Data                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Sender: 0xf...3d9                                                                                                                                                                                                                                                                                                                                                                                                                             	                                                         â”‚
â”‚ Gas Owner: 0xf...3d9                                                                                                                                                                                                                                                                                                                                                                                                                          	                                                         â”‚
â”‚ Gas Budget: 200000000 MIST                                                                                                                                                                                                                                                                                                                                                                                                                                                                             	 â”‚
â”‚ Gas Price: 1000 MIST                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   	 â”‚
â”‚ Gas Payment:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           	 â”‚
â”‚  â”Œâ”€â”€                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   	 â”‚
â”‚  â”‚ ID: 0x8...19e                                                                                                                                                                                                                                                                                                                                                                                                                              	                                                         â”‚
â”‚  â”‚ Version: 16                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         	 â”‚
â”‚  â”‚ Digest: 4WQp6FYctutMFzf6f2EX68xut71AMubewJ6c7GxpzX7e                                                                                                                                                                                                                                                                                                                                                                                                                                                	 â”‚
â”‚  â””â”€â”€                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   	 â”‚
â”‚                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 â”‚
â”‚ Transaction Kind : Programmable                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 â”‚
â”‚ Inputs: [Object(SharedObject { object_id: 0x0...005, initial_shared_version: SequenceNumber(1), mutable: true }), Object(ImmOrOwnedObject { object_id: 0x4...dbe, version: SequenceNumber(16), digest: o#4yDkecsKPe8SnacWdECmq1yVDt7MzvpXCxbRGs74PGaB }), Pure(SuiPureValue { value_type: Some(Address), value: "0xf...3d9" })]                                                                                                                                                                            â”‚
â”‚ Commands: [                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            	 â”‚
â”‚   MoveCall(0x0...003::sui_system::report_validator(Input(0),Input(1),Input(2))),                                                                                                                                                                                                                                                                                                                                                              	                                                         â”‚
â”‚ ]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      	 â”‚
â”‚                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 â”‚
â”‚                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 â”‚
â”‚ Signatures:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            	 â”‚
â”‚	7lJ9ezA1qjGk7nyFCESgLlg/tkVSy46dDkRgJzwgWP3qA+kAjJV8YVWFjJf2r6aLgWgCZCKnka9bkcp1V5jBAA==                                                                                                                                                                                                                                                                                                                                                                                                            	 â”‚
â”‚                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        	 â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
----- Transaction Effects ----
â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚ Transaction Effects                                                                                                                                                                                                                                                                              	   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Digest: 8jVYrpuRBmdSLP37MsQGRqUqE3kE2m8XiSS4TG4aJwXf                                                                                                                                                                                                                                             	   â”‚
â”‚ Status: Failure { error: "MoveAbort(MoveLocation { module: ModuleId { address: 0000000000000000000000000000000000000000000000000000000000000003, name: Identifier(\"sui_system_state_inner\") }, function: 16, instruction: 12, function_name: Some(\"report_validator_impl\") }, 3) in command 0" } â”‚
â”‚ Executed Epoch: 8                                                                                                                                                                                                                                                                                	   â”‚
â”‚                                                                                                                                                                                                                                                                                                  	   â”‚
â”‚ Mutated Objects:                                                                                                                                                                                                                                                                                 	   â”‚
â”‚  â”Œâ”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚  â”‚ ID: 0x0...005                                                                                                                                                                                                                        	                                                           â”‚
â”‚  â”‚ Owner: Shared                                                                                                                                                                                                                                                                                 	   â”‚
â”‚  â”‚ Version: 25                                                                                                                                                                                                                                                                                   	   â”‚
â”‚  â”‚ Digest: 5N5zyTyFCqAkyz44FGrpr6cYdXcwk4eUCHKzyAZqehMB                                                                                                                                                                                                                                          	   â”‚
â”‚  â””â”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚  â”Œâ”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚  â”‚ ID: 0x4...dbe                                                                                                                                                                                                                        	                                                           â”‚
â”‚  â”‚ Owner: Account Address ( 0xf...3d9 )                                                                                                                                                                                                 	                                                           â”‚
â”‚  â”‚ Version: 25                                                                                                                                                                                                                                                                                       â”‚
â”‚  â”‚ Digest: HCEr5bcJhKo5jfRx2gsXxGSkpcq6tm8nFGSxxwoPpkNz                                                                                                                                                                                                                                          	   â”‚
â”‚  â””â”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚  â”Œâ”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚  â”‚ ID: 0x8...19e                                                                                                                                                                                                                        	                                                           â”‚
â”‚  â”‚ Owner: Account Address ( 0xf...3d9 )                                                                                                                                                                                                 	                                                           â”‚
â”‚  â”‚ Version: 25                                                                                                                                                                                                                                                                                   	   â”‚
â”‚  â”‚ Digest: BTzMmVABwEKXoiLsTZ79Li97Eo6HPtNtWTvib8Eq1yrH                                                                                                                                                                                                                                          	   â”‚
â”‚  â””â”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚                                                                                                                                                                                                                                                                                                  	   â”‚
â”‚ Shared Objects:                                                                                                                                                                                                                                                                                  	   â”‚
â”‚  â”Œâ”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚  â”‚ ID: 0x0...005                                                                                                                                                                                                                        	                                                      	   â”‚
â”‚  â”‚ Version: 24                                                                                                                                                                                                                                                                                   	   â”‚
â”‚  â”‚ Digest: BiS4pKAX3KGXbJrk4oZijy6ggKHDZJd9qPUDWxLEoNR1                                                                                                                                                                                                                                          	   â”‚
â”‚  â””â”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚                                                                                                                                                                                                                                                                                                  	   â”‚
â”‚ Gas Object:                                                                                                                                                                                                                                                                                      	   â”‚
â”‚  â”Œâ”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚  â”‚ ID: 0x8...19e                                                                                                                                                                                                                        	                                                      	   â”‚
â”‚  â”‚ Owner: Account Address ( 0xf...3d9 )                                                                                                                                                                                                 	                                                      	   â”‚
â”‚  â”‚ Version: 25                                                                                                                                                                                                                                                                                   	   â”‚
â”‚  â”‚ Digest: BTzMmVABwEKXoiLsTZ79Li97Eo6HPtNtWTvib8Eq1yrH                                                                                                                                                                                                                                          	   â”‚
â”‚  â””â”€â”€                                                                                                                                                                                                                                                                                             	   â”‚
â”‚                                                                                                                                                                                                                                                                                                  	   â”‚
â”‚ Gas Cost Summary:                                                                                                                                                                                                                                                                                	   â”‚
â”‚	Storage Cost: 4195200                                                                                                                                                                                                                                                                         	   â”‚
â”‚	Computation Cost: 1000000                                                                                                                                                                                                                                                                     	   â”‚
â”‚	Storage Rebate: 31164408                                                                                                                                                                                                                                                                      	   â”‚
â”‚	Non-refundable Storage Fee: 314792                                                                                                                                                                                                                                                            	   â”‚
â”‚                                                                                                                                                                                                                                                                                                  	   â”‚
â”‚ Transaction Dependencies:                                                                                                                                                                                                                                                                        	   â”‚
â”‚	2gqHgPZbjTkDWM9GnVuWU5kT9z2SWN2ggwK3ryxf8aUX                                                                                                                                                                                                                                                  	   â”‚
â”‚	A8z83EqjmgwRNFV6sme6A5tTTTQPjiLgiW76neyvhLud                                                                                                                                                                                                                                                  	   â”‚
â”‚	B8p4pVC5pzFQRVpZ73nZfAWMt7sL4iH4x4AbDviYWuzF                                                                                                                                                                                                                                                  	   â”‚
â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
```

</details>


## Help

Each command has its own help section. For example `sui validator report-validator --help` will display the following prompt:

```sh
$ sui validator report-validator --help
```
```sh
Report or un-report a validator

Usage: sui validator report-validator [OPTIONS] <reportee-address>

Arguments:
  <reportee-address>  The Sui Address of the validator is being reported or un-reported

Options:
  	--operation-cap-id <operation-cap-id>  Optional when sender is reporter validator itself and it holds the Cap object. Required when sender is not the reporter validator itself.
                                         	Validator's OperationCap ID can be found by using the `display-metadata` subcommand
  	--undo-report <undo-report>        	If true, undo an existing report [possible values: true, false]
  	--gas-budget <gas-budget>          	Gas budget for this transaction
  	--json                             	Return command outputs in json format
  -h, --help                             	Print help
```

>>>> sui/docs/content/references/contribute/code-of-conduct.mdx
---
title: Sui Contributor Covenant Code of Conduct
sidebar_label: Code of Conduct
slug: /code-of-conduct
description: All contributions to Sui must adhere to the Contributor Code of Conduct. 
keywords: [ code of conduct, contribute to sui, open source contributions, contributing to sui, contribution guidelines, how to contribute ]
---

Sui, as an open source project, encourages free discussion rooted in respect.
We endeavor to always be mindful of others' perspectives and ask all
fellow contributors to do the same. We welcome you to the Sui platform
and ask you to help us grow it with relevant, on-point contributions.

## Our pledge {#our-pledge}

We, as members, contributors, and leaders, pledge to make participation in our
community a harassment-free experience for everyone, regardless of age, body
size, visible or invisible disability, ethnicity, sex characteristics, gender
identity and expression, level of experience, education, socio-economic status,
nationality, personal appearance, race, caste, color, religion, or sexual
identity and orientation.

We pledge to act and interact in ways that contribute to an open, welcoming,
diverse, inclusive, and healthy community.

## Our standards {#our-standards}

Examples of behavior that contributes to a positive environment for our
community include:

- Demonstrating empathy and kindness toward other people
- Being respectful of differing opinions, viewpoints, and experiences
- Giving and gracefully accepting constructive feedback
- Accepting responsibility and apologizing to those affected by our mistakes,
  and learning from the experience
- Focusing on what is best, not just for us as individuals, but for the overall
  community

Examples of unacceptable behavior include:

- The use of sexualized language or imagery, and sexual attention or advances of
  any kind
- Trolling, insulting or derogatory comments, and personal or political attacks
- Public or private harassment
- Publishing others' private information, such as a physical or email address,
  without their explicit permission
- Other conduct which could reasonably be considered inappropriate in a
  professional setting

## Enforcement responsibilities {#enforcement-responsibilities}

Community leaders are responsible for clarifying and enforcing our standards of
acceptable behavior and will take appropriate and fair corrective action in
response to any behavior that they deem inappropriate, threatening, offensive,
or harmful.

Community leaders have the right and responsibility to remove, edit, or reject
comments, commits, code, wiki edits, issues, and other contributions that are
not aligned to this Code of Conduct, and will communicate reasons for moderation
decisions when appropriate.

## Scope {#scope}

This Code of Conduct applies within all community spaces, and also applies when
an individual is officially representing the community in public spaces.
Examples of representing our community include using an official e-mail address,
posting via an official social media account, or acting as an appointed
representative at an online or offline event.

## Enforcement {#enforcement}

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported to the community leaders responsible for enforcement.

All complaints will be reviewed and investigated promptly and fairly.

All community leaders are obligated to respect the privacy and security of the
reporter of any incident.

## Enforcement guidelines {#enforcement-guidelines}

Community leaders will follow these Community Impact Guidelines in determining
the consequences for any action they deem in violation of this Code of Conduct:

### 1. Correction {#correction}

**Community Impact**: Use of inappropriate language or other behavior deemed
unprofessional or unwelcome in the community.

**Consequence**: A private, written warning from community leaders, providing
clarity around the nature of the violation and an explanation of why the
behavior was inappropriate. A public apology may be requested.

### 2. Warning {#warning}

**Community Impact**: A violation through a single incident or series of
actions.

**Consequence**: A warning with consequences for continued behavior. No
interaction with the people involved, including unsolicited interaction with
those enforcing the Code of Conduct, for a specified period of time. This
includes avoiding interactions in community spaces as well as external channels
like social media. Violating these terms may lead to a temporary or permanent
ban.

### 3. Temporary ban {#temporary-ban}

**Community Impact**: A serious violation of community standards, including
sustained inappropriate behavior.

**Consequence**: A temporary ban from any sort of interaction or public
communication with the community for a specified period of time. No public or
private interaction with the people involved, including unsolicited interaction
with those enforcing the Code of Conduct, is allowed during this period.
Violating these terms may lead to a permanent ban.

### 4. Permanent ban {#permanent-ban}

**Community Impact**: Demonstrating a pattern of violation of community
standards, including sustained inappropriate behavior, harassment of an
individual, or aggression toward or disparagement of classes of individuals.

**Consequence**: A permanent ban from any sort of public interaction within the
community.

## Attribution {#attribution}

This Code of Conduct is adapted from the [Contributor Covenant][homepage],
version 2.1, available at
[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].

Community Impact Guidelines were inspired by
[Mozilla's code of conduct enforcement ladder][Mozilla CoC].

For answers to common questions about this code of conduct, see the FAQ at
[https://www.contributor-covenant.org/faq][FAQ]. Translations are available at
[https://www.contributor-covenant.org/translations][translations].

[homepage]: https://www.contributor-covenant.org
[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html
[Mozilla CoC]: https://github.com/mozilla/diversity
[FAQ]: https://www.contributor-covenant.org/faq
[translations]: https://www.contributor-covenant.org/translations

>>>> sui/docs/content/references/contribute/contribute-to-sui-repos.mdx
---
title: Contribute to Sui Repositories
slug: /contribute-to-sui-repos
description: Sui repositories are open source and welcome community contributions. 
keywords: [ contribute to sui, open source contributions, contributing to sui, contribution guidelines, how to contribute, open an issue, contribute via SIP, sui improvement proposal  ]
---

This page describes how to contribute to Sui, and provides additional information about participating in the Sui community.

## Join the community {#join-the-community}

To connect with the Sui community, join our [Discord](https://discord.gg/sui).

## Open issues {#open-issues}

To report an issue with Sui, [create an issue](https://github.com/MystenLabs/sui/issues/new/choose) in the GitHub repo. Click **Get started** to open a template for the type of issue to create.

## Fork Sui to contribute {#fork-sui-contribute}

To contribute to Sui source code or documentation, you need only a GitHub account. You can commit updates and then submit a PR directly from the Github website, or create a fork of the repo to your local environment and use your favorite tools to make changes. Always submit PRs to the `main` branch.

See [Sui Environment Setup](./sui-environment.mdx) for instructions on forking the Sui repository, if necessary.

## Contribute via the Sui Improvement Proposal (SIP) process {#SIP}

The Sui Network is an open source, decentralized, and permissionless protocol that welcomes community contributions. If you have an idea regarding a core protocol upgrade, the best way to make your voice heard is via submitting a Sui Improvement Proposal (SIP). For more information on SIPs, see [Contribute to Sui through SIPs](https://blog.sui.io/sui-improvement-proposals-sips/).


>>>> sui/docs/content/references/contribute/contribution-process.mdx
---
title: Contribute to Sui Documentation
sidebar_label: Docs Contribution
description: Help the Sui community through documentation contributions. Whether its to fix errors or add new content, the entire Sui community benefits from your contributions.
keywords: [ contribute docs, style guide compliance, add new docs page, change existing docs page ]
pagination_prev: null
---

The Sui documentation is open source and thrives on community contributions. Whether youâ€™re fixing a typo, clarifying explanations, or adding entirely new content, your work benefits the whole community. This page explains how to contribute to the documentation using either GitHubâ€™s web editor or your local development environment.

## Follow the style guide

All documentation changes must follow the [Sui style guide](./style-guide.mdx). Reviewers will provide feedback to ensure consistency in tone and quality. Donâ€™t be discouraged if your pull request (PR) receives multiple review comments, as this process helps maintain clarity and uniformity across all docs. After your PR is merged, future updates may refine your content further.

When writing, keep these key principles in mind:

- Use active voice.  
- Write in present tense.  
- Be clear and concise. Use only as many words as needed.  

## GitHub web editor

If youâ€™re new to Git or prefer a simpler workflow, you can make small edits directly in GitHubâ€™s web interface.

- **Add a new page**  
  1. Go to the `docs/content` directory.  
  1. Open the relevant subdirectory.  
  1. Click **Add file** â†’ **Create new file**.  
  1. Write your content and commit your changes.  

- **Edit an existing page**  
  1. From the documentation website, you can use the "Edit this page" link at the bottom of each documentation page.
  1. From GitHub, navigate to the file you want to update. Click the **pencil icon** in the top-right.  
  1. Make your edits and commit them.  

## Set up a local environment {#local-environment}

Cloning the documentation locally is recommended when you are creating larger, more significant changes to the docs. See [Sui Environment Setup](./sui-environment.mdx) for instructions on forking and cloning the Sui repository. Documentation is located in the `docs/content` directory.

1. **Install dependencies**  
   - If you use [Visual Studio Code](https://code.visualstudio.com/), install the [Prettier extension](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode) to keep formatting consistent.  
1. **Make your changes**  
   - Edit or add files in the `docs/content` directory.  
   - Stage and commit changes:  
     ```bash
     git add .
     git commit -m "Describe your changes"
     git push
     ```  
1. **Preview locally**  
   - Navigate to the `docs/site` directory.  
   - Install dependencies (If you donâ€™t have `pnpm` installed, see the [pnpm installation guide](https://pnpm.io/installation)):  
     ```bash
     pnpm install
     ```  
   - Start the local dev server:  
     ```bash
     pnpm start
     ```  
   - Open `http://localhost:3000` to verify your updates.  


## Review process {#review-process}

When your changes are ready:  

1. Submit a PR to the `main` branch of the Sui repository.  
1. A [Vercel](https://vercel.com) preview will be generated so you can verify your changes. The preview is what you can expect to see online after your changes have been merged.
1. Reviewers will provide feedback. Itâ€™s your responsibility to update your PR based on their comments. Multiple reviewers might give input.  
1. After at least one reviewer approves your PR, it gets merged into `main`, and your contribution goes live. Changes are reflected on the live website within 5-10 minutes after the PR has merged into `main`. 

>>>> sui/docs/content/references/contribute/localize-sui-docs.mdx
---
title: Localize Sui Documentation
slug: /localize-sui-docs
description: The Sui documentation can be translated into any language using Crowdin.
keywords: [ translate docs, translate documentation, translate, crowdin, localize, localization, docs localization, docs translations ]
---

The Sui documentation can be localized (translated) into any language of your choosing. The localization platform utilized is Crowdin. For more information regarding the localization process please see [here](https://support.crowdin.com/crowdin-intro/).

>>>> sui/docs/content/references/contribute/mdx-components.mdx
---
title: MDX Components
description: Extensions to the Sui docs rendering engine.
---

The Sui developer documentation uses the MarkdownX (`.mdx`) format for all pages. MDX allows [JSX within Markdown content](https://mdxjs.com/). The site uses Docusaurus, an open-source framework that provides built-in features like admonitions and Mermaid diagrams. It also utilizes community plugins and custom components the documentation team developed. While none of these features are required in a contribution, you may include them if they enhance the readerâ€™s experience.

## Custom frontmatter

The frontmatter at the top of every documentation page provides additional context for the page, including a description that appears in the page's link preview, keywords for optimized search results, and other optional, format-related components.

Include the following components on every page:

```
---
title: Title of Page
description: 1-2 sentences summarizing the page's content.
keywords: [ words, for, search, results ]
---
```

### Optional frontmatter 

#### `beta`

Adds an admonition box to the top of the page to inform readers of the feature or topic's beta status.  

**Options:**  
- `true` â†’ Standard beta box.  
- `devnet`, `testnet`, `mainnet` â†’ Displays environments where the feature is available.  

**Example:**

```yaml
---
title: Page title
description: A page of information describing a beta feature.
beta: devnet, testnet
---
```

#### `effort`

Used for end-to-end tutorials. Adds an admonition box at the top indicating the effort required to complete the tutorial.

**Options:** 

- `small`
- `medium`
- `large`

**Example:**

```yaml
---
title: A Guide
description: A guide on how to do this thing in Sui.
effort: medium
---
```

## `UnsafeLink`

Use `UnsafeLink` to skip the Docusaurus link checker for a URL.

This is **necessary** for pages that the Docusaurus build auto-generates, as they are generated after the link checker runs and thus will result in a build error.

:::info
In local development, the setting `onBrokenMarkdownLinks: "warn"` remains at `"warn"`, but in production the build process still throws a build error.
:::

**Example:**

```jsx
<UnsafeLink href="link/to/path">Link title</UnsafeLink>
```

## Custom admonition boxes

Beyond the Docusaurus defaults (`info`, `note`, `warning`, `danger`), there is another custom admonition box for checkpoints.

Use checkpoints in end-to-end guides to validate user progress.

**Example:**

```
:::checkpoint

Run your app and make sure you can:
- Create an NFT.
- Initiate a trade.

:::
```

## Tabs

Use `<Tabs>` and `<TabItem>` to segment content that achieves the same goal but for different operating systems, programming languages, or developer environments. 

Docusaurus automatically imports the `<Tabs>` and `<TabItem>` components into every documentation page. You do not need to import them manually. 

The docs use a few custom scripts to properly render and style the `<Tabs>` component. These scripts let you use `<Tabs>` with [`{@include:}` snippets](#snippets-include) without breaking the page's formatting.

When using multiple instances of `<Tabs>` within a page, use `groupId` to persist selections across sections. The name of each `<TabItem>` across `<Tabs>` components using `groupId` must match for the tabs to function properly.

To create a tabbed section:

1. Add the `<Tabs>` element where you want the tabbed content to go. Include the optional `groupId` property if there are other `Tabs` with the same selections.

1. Add a `<TabItem>` element for each section of content as a child of the `Tabs` element. Each `TabItem` needs both `value` and `label` property values. If you're using `groupId` in the parent `Tabs`, make sure the `value` remains consistent across `TabItem`s in other `Tabs` with the same `groupId` value. Doing so makes the `TabItem`s that are intended to show the same type of information become active across all relevant `Tabs`. This behavior persists across pages and sessions.  


1. Close each `</TabItem>` and the parent `</Tabs>`.

**Example:**

```md
<Tabs groupId="operating-systems">

  <TabItem value="linux" label="Linux">

    Linux-only content.

  </TabItem>

  <TabItem value="macos" label="macOS">

    macOS-only content.

  </TabItem>

  <TabItem value="windows" label="Windows">

    Windows-only content.

  </TabItem>

</Tabs>
```

:::info
You must add empty newlines between content, opening, and closing tags. Without them, the component fails to render properly.
:::

## `<ImportContent>`

Use the `<ImportContent>` component to inject code or markdown into a page.

### Snippet mode

Reusable Markdown content stored in `docs/content/snippets`. Snippets can be reusable sentences, paragraphs, admonition boxes, `<Tabs>`, or pieces of code. 

Tables of data, technology requirements, and other information relevant to more than one topic or audience are good candidates to create as snippets (especially if the information is likely to change).

Snippets help reduce maintenance and avoid forcing readers off-page for important information.  

#### How to use snippets

1. Set the `source` argument to the file path in the `snippets` folder. Do not include the `snippet` directory.
1. Set the `mode` argument to `snippet`. 

`<ImportContent source="file.mdx" mode="snippet" />`

#### Prerequisite snippets

For guides and tutorials that have prerequisite requirements, the prerequisite tab format should be used.

If a guide or tutorial uses the following prerequisites: 

```
- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install).

- [x] Set up your Sui account and CLI environment. 

- [x] Obtain test tokens. 
```

Then a reusable snippet can be used:

```jsx
<ImportContent source="prerequisites.mdx" mode="snippet" />
```

For guides and tutorials that have their own unique prerequisites, the following `Tabs` component with the `className="tabsHeadingCentered--small"` styling should be used:

```
<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] Unique prerequisite.

</TabItem>
</Tabs>
```

### Code mode

Inject code directly into a documentation file using a custom plugin that supports filtering and syntax highlighting.

In an active repo, source code changes frequently. If you copy and paste that source code in a document, then the two sources can diverge quickly and drastically. If the code you inject is tested, this directive ensures the code in your document is also tested.

Use `<ImportContent />` to keep docs synchronized with live source code, as it prevents divergence between the docs and repo code. 

#### Considerations

The effective use of `<ImportContent />` often requires code comments in the source file. You might need to balance the granularity of your documentation with the amount of comment chatter your documentation efforts might create.

When including sections of code, understand that the code might change from what you reference during document creation to what a reader eventually consumes. Assume other processes will update the accompanying content, but be mindful of the possibility of changing code when considering the level of detail in your instruction. You can take comfort in the knowledge that the code is always valid, though.


#### Referencing files within the Sui monorepo 

Reference files via their relative path:

#### Referencing files from other repos 

If several code files located in another repo need to be referenced across multiple documentation pages, the Sui documentation team may have added it as a **submodule** of the Sui repo. Submodules are a GitHub feature that creates symlinks across repositories. 

Current submodules within the Sui docs include:

- [TS SDK](https://github.com/MystenLabs/ts-sdks): `/docs/submodules/ts-sdks`

- [DeepBook](https://github.com/MystenLabs/deepbookv3): `/docs/submodules/deepbookv3`

The Sui documentation team decides whether to add submodules. Community contributions should not attempt to add submodules.

#### How to use

1. Set the `source` argument to the relative path of the file. Do not include the `sui` root. 
1. Set the `mode` argument to `code`.
1. Include options as needed.

To include an entire file of code: 

```
<ImportContent source="examples/move/hero/sources/example.move" mode="code" />
```

To include specific components or sections, use the following arguments in the component:  

- Module: `module="MODULE::NAME"`
- Function: `fun="FUNCTION_NAME,ANOTHER_FUNCTION"`
- Struct: `struct="STRUCT_NAME,ANOTHER_STRUCT"`
- Trait: `trait="TRAIT_NAME,ANOTHER_TRAIT"`
- Variables: `var="variableName,anotherVariable"`
- Move import: `dep="LIBRARY::NAME"`
- React component: `component="ComponentName"`
- Type declaration: `type="TypeName"`
- Enum declaration: `enumeration="EnumName"`

**Example:**  
```
<ImportContent source="examples/move/example.source" mode="code" fun="buy_sword" />
```

#### Include nonlinear parts of code

:::info

Consider restructuring your document before using this approach. This feature is useful in some situations, but it increases the comment chatter in the source file.

:::

If you don't want to include a section of code, but instead focus on the code around it in a single doc instance, you can pause the injection with a source code comment in the form `// docs::#ID-pause`. A second comment in the form `// docs::#ID-resume` continues the injection.

1. In your document, set the `tag` value to the name. The build process replaces this line with the referenced code, so place where the code should appear.
    ```ts
    <ImportContent source="examples/foo/bar.move" mode="code" tag="tagName" />
    ```
1. In the source file, add a comment where the section should begin in the form `// docs::#Tag`.
    ```ts 
    // docs::#tagString 
    import lib from "library"; 
    ...
    ```
1. In the source file, add a comment where the injection should pause and where it should resume. Optionally, append a colon and replacement text to the pause directive. The replacement text displays in the document instead of the code.
    ```ts 
    // docs::#tagString 
    import lib from "library"; 
    ... 

    // docs::#tagString-pause:TODO 
    const Advanced = () => {}; 
    // docs::#tagString-resume
    ```
1. In the source file, add a comment where the injection should end.
    ```ts 
    // docs::#tagString 
    import lib from "library"; 
    ... 

    // docs::#tagString-pause:
    // TODO 
    const Advanced = () => {};
    ... 

    // docs::#tagString-resume 
    return book; 

    // docs::/#tagString 
    ...
    ```

The final result in the document from these steps is:

```ts 
import lib from "library"; 
...

// TODO 
return book;
```

### Additional options 

You can also add additional strings to the end of the inject statement to highlight specific lines, remove titles, etc:

- `noComments` â†’ Strip comments  
- `noTests` â†’ Strip tests  
- `noTitle` â†’ Remove code block title  
- `singleSpace` â†’ Normalize spacing  
- `highlight` â†’ Highlight a specific line using a unique word in the line you want highlighted (ex. `highlight="variable_name"`)

**Example:**  

```
<ImportContent source="examples/move/example.source" mode="code" module="example::example" noComments noTests />
```

## `RelatedLink`

Each page should have a _Related links_ section at the bottom. Use the `RelatedLink` component to itemize each link under this heading. The `## Related links` heading remains in markdown format for ease of ToC inclusion.

There are two basic forms to the component. 

1. `<RelatedLink to="/guides/path/to/page" />`
    Internal pages just need a `to` value that is relative to the site root. The label and description are pulled from that pages frontmatter.

1. `<RelatedLink href="https://url/to/page" label="Hyperlink label" desc="Description of link." />`
    Links external to the site need an `href`, `label`, and `desc` values.

**Example:**

```
...

## Related links

<RelatedLink to="/guides/path/to/page" />
<RelatedLink href="https://url/to/page" label="Hyperlink label" desc="Description of link." />
<RelatedLink href="https://url/to/page" label="Hyperlink label" desc="Description of link." />
```

## Collapsible components: Details and summary 

Use `<details>` and `<summary>` to create collapsible content. This is useful for reducing page length by placing long code files, command output, or other large text blocks inside `<details>`, making the page easier to scroll.

Add an empty newline above and below the content, opening, and closing tags.

**Example:**

```html
<details>

  <summary>Example</summary>

  Collapsible details go here.

</details>
``` 

## Using step headings

Prefer ordered lists for processes; keep each step to one instruction. However, if a step needs multiple sub-instructions or lots of context, use step headings (headings with step/substep) to group content. 

Avoid lists where Step 1 spans pages and switch to step headings instead. Step headings make long guides easier to resume and navigate via the ToC.

### How to use step headings

To create step headings, add a `step` or `substep` suffix to the usual heading levels. 

For instance, to create a level 2 heading, write `##step Buy peanuts`, which is the same as typing `## Step 1: Buy peanuts`.

The feature supports one level of `nesting` using the `substep` suffix in the same manner. Don't forget to use the proper number of hashes in relation to the parent step. Continuing the example, you might have `###substep Buy Cracker Jacks`, which would be the same as typing `### Step 1.1: Buy Cracker Jacks`.

##step Buy peanuts

Buy me some peanuts.

###substep Buy Cracker Jacks

And Cracker Jacks.

##step Come back

I don't care if I ever come back.

## Mermaid graphs

Mermaid graphs are text-based [Mermaid.js](https://mermaid.js.org) diagrams. Mermaid has native support in Docusaurus. The Docusaurus implementation determines support for newer graph types, which might not render correctly. 

### How to use

To create a mermaid graph, place the code inside tick fencing with `mermaid` defined as the language. You do not need to import anything into your document. 

```mermaid
flowchart LR
    CC(CLI Client) --> ClientService
    RC(Rest Client) --> ClientService
    RPCC(RPC Client) --> ClientService
    ClientService --> AuthorityAggregator
    AuthorityAggregator --> AC1[AuthorityClient] & AC2[AuthorityClient]
    subgraph Authority1
    AS[AuthorityState]
    end
    subgraph Authority2
    AS2[AuthorityState]
    end
    AC1 <==>|Network TCP| Authority1
    AC2 <==>|Network TCP| Authority2
```

<!----- not currently used

## YouTube player with thumbnail carousel

Use `YTCarousel` to display multiple videos.  

**Example:**
```jsx
import YTCarousel from "@site/src/components/YTCarousel";

<YTCarousel ids={["dQw4w9WgXcQ","EwTZ2xpQwpA","1TewCPi92ro"]}/>
```

----->

>>>> sui/docs/content/references/contribute/style-guide.mdx
---
title: Style Guide
slug: /style-guide
description: All contributions to the Sui documentation must adhere to the style guide.
keywords: [ style guide, documentation style, accessibility of docs, formatting of docs, capitalization, grammar, tense, headings, lists, tables, word choice ]
---

This document defines the styles, vocabulary usage, and content formatting for Sui documentation. Entries are in alphabetical order. A style guide is never finished; expect continued iterations to add additional styles, additional information to existing styles, and infrequently a change to an existing style.

## Editorial considerations {#editorial-considerations}

- **Use simple words and concise sentences.**  
  Prefer plain, direct language over complex or academic phrasing. Short sentences improve readability and are easier to localize.  

- **Avoid redefining common words.**  
  Do not give familiar words new or unexpected meanings (for example, do not use "object" to mean something other than its standard technical or everyday sense). This prevents confusion, especially for new readers.  

- **Use technical terms with care.**  
  Introduce technical terms only when necessary. Define them clearly the first time, and use them consistently throughout the documentation.  

- **Avoid jargon and slang.**  
  Do not assume readers understand informal expressions, company-specific shorthand, or unnecessary buzzwords. Use precise terms instead.  

- **Prefer active, descriptive phrasing.**  
  Instead of vague phrases like, "do the thing," explain the action explicitly: "Deploy the contract" or "Restart the node."  

- **Write for a global audience.**  
  Keep in mind that many readers are non-native English speakers. Favor clarity over cleverness, and avoid idioms or culturally specific references.  

---

## Spelling and grammar 

#### Spelling {#spelling}

Use US English spelling in source content.

#### Avoid Latin abbreviations {#latin-abbreviations}

Because many languages are not Latin-based, avoid using Latin abbreviations (e.g., i.e., etc., et. al, and so on). Prefer ex. or complete phrases like "for example", "and so on", and similar.

#### Grammar {#grammar}

##### Active voice {#active-voice}

Use active voice whenever possible. Active voice is direct, clear, and uses fewer words. Passive voice is often less clear, awkward, and uses more words.

> âœ… **Active:** She installed the software.

> âŒ **Passive:** The software was installed by her.

##### Person {#person}

- First person â†’ I or we 

- Second person â†’ you 

- Third person â†’ he, she, they, it, product names

Use **second person** ("you"). **Do not** use first or third person ("I" or "we").

> âœ… You can view the transaction history in the Sui Explorer.

> âŒ We can view the transaction history in the Sui Explorer.

##### Present tense {#present-tense}

Use present tense whenever possible. Reserve future tense only for events that will happen at a specific future time, such as a scheduled product release.

Do not use future tense when describing product behavior or writing task instructions. From the reader's perspective, actions occur in the present as they follow the steps.  

> **Example: Present tense**
>
> Click **Save** to save the updated file.  
> When you click **Save**, your device writes the changes to disk.  
> To save a file after you modify it, click **Save**.  

> **Example: Future tense (avoid)**
>
> Your changes will be saved when you click **Save**.  
> When you click **Save**, the file will be written to disk.  

Although technically correct, the future tense creates distance between the user and the action. It also makes the text harder to understand for ESL readers and more difficult to localize. In reality, the action happens immediately when the user clicks **Save**.

##### Punctuation

1. Sentences

    - Use a period at the end of a complete sentence. 

    - Use a single space after a period (never two).  

2. Lists

    - Full sentences in lists: End each item with a period.  

    - Fragments or single words in lists: Do not use periods.  

    - Mixed lists: Avoid mixing fragments and full sentences. Rewrite for consistency.  

3. Parentheses

    - If the entire sentence is inside parentheses, place the period inside.  

    - If the parentheses are part of a sentence, place the period outside.  

    - Never place a period before the closing parenthesis.  

4. Abbreviations

    - Keep the period as part of an abbreviation. However, [do not use Latin abbreviations](#latin-abbreviations). 

5. Headings and titles

    - Do not use periods after headings, subheadings, or titles (unless the title ends in an abbreviation).  

6. Numbers and decimals

    - Do not add an extra period after a decimal number.  

##### Parentheses 

Use parentheses to add clarifying or supplemental information that is not essential to the main sentence.

Avoid overusing parentheses. If the information is important, integrate it into the sentence instead of isolating it.

#### Avoid using (s) for plurals

Use â€œ(s)â€ only if required for legal, contractual, or regulatory text where precision demands explicit acknowledgment of both singular and plural forms. Otherwise, use the plural form without parentheses. 

##### Oxford (serial) commas {#oxford-serial-commas}

Do use serial commas.

> âœ… You must install Cargo, Rust, Docker, and the Sui CLI to create a Sui node.

> âŒ You must install Cargo, Rust, Docker and the Sui CLI to create a Sui node.

##### Numbers {#numbers}

Do not write out numbers when referring to a number of items; always use the numerical value. 

> The folder contains 24 files.
> One folder contains 7 files, and the other contains 24 files.
> At least 20 pieces of candy fell off the table.

Do write out numbers when they are grammatically part of the sentence.

> One can always include extra documentation to support the theory.
> The client checks if the checkpoint is the last one of the epoch.

##### Quotation marks 

Do not use quotation marks, except for the single exception "Hello, World!".

##### Ampersands

Do not use ampersands (`&`) in content to replace `and` as the word is more accessible and less error-prone for some programmatic use cases. If you absolutely must include an ampersand in content, escape it using `&amp;`.

##### Exclamations

Do not use exclamation marks. If you'd like to express excitement, such as:

> Congratulations! You've finished the tutorial.

Use the confetti emoji instead:

> Congratulations, you've finished the tutorial. ðŸŽ‰ 

--- 

## Terminology and vocabulary

For consistency, the Sui documentation must use the following terms and phrases with the indicated capitalization (unless sentence structure determines otherwise). This list is not exhaustive and will be updated over time. 

|     **Category**       |             **Words and terms**               |    **Notes**   |
| ---------------------- |---------------------------------------------- | -------------- |
| **Always capitalized** | [Proper nouns](#proper-nouns), [product names](#product-names), names of example dApps (Coin Flip, Blackjack, etc), Archival Store and Service, Archival Store, Archival Service, Coin Registry, Currency Standard, DeepBook Indexer, DeepBookV3, Devnet, GraphQL RPC, General-purpose Indexer, ID, Localnet, Kiosk (when referring to the standard), Mainnet, Mysticeti, One-Time Witness, Operation Cap, Sui, Sui CLI, Sui Client PTB CLI, Sui Closed-Loop Token / Closed-Loop Token, Sui dApp Kit, Sui Explorer, SuiJSON, Sui Keystore, Sui Keytool, SuiLink, Sui Object Display, SuiPlay0X1, SUI, SUI token, Testnet, Wallet Standard, Web2, Web3, zkSend SDK | Use capitalization consistently for branding and product-specific references |
| **Always lowercase**   | casual history, casual order, certificate, dApp, epoch, equivocation, eventual consistency, finality, gas, genesis, kiosk (when referring to an instance), object, oracle, recovery passphrase (mnemonic), smart contract, soulbound, Sui framework, Sui object, total order, transaction, transfer, validator, wallet | Use lowercase when referring to general concepts rather than branded terms   |
| **Never hyphenated**   | key pair, layer 1, open source, use case                  | Keep these words separate, no hyphen                                         |
| **Always hyphenated**  | burn-only (currency supplies), depth-first search, multi-writer objects, off-chain, off-device, on-chain, on-device, One-Time Witness, peer-to-peer, proof-of-stake, single-writer objects  | Maintain hyphen for clarity and correctness  |
| **Word preference**    | Use "might" in place of "may"                 | The word may has a secondary definition that implies permission rather than possibility. |
| **Word preference**    | Do not start sentences with "Please note" or "Note"              | It can be argued that any sentence could be prefaced with these words. |
| **Word preference**    | Use "through" in place of "via"                 | Indicates a more direct action. | 
| **Word preference**    | Use "because" in place of "since"                 | More direct. | 
| **Word preference**   | Use "basic" in place of "simple"    | Frustrating for user if something is not simple but is described as such. |



### Nodes

When referencing nodes (full, archival, validator, and so on), use:

- Lowercase _full node_ when referring to the conceptual role in the network.
    â€œEvery RPC provider must enable gRPC on their full node.â€
- Capitalize _Sui Full Node_ when referring to the official software binary/package that Sui distributes.
    â€œDownload and run the Sui Full Node from GitHub to connect to Mainnet.â€

### Proper nouns {#proper-nouns}

Capitalize proper nouns throughout.

Proper nouns include:

- Names of people: Bob Ross

- Named places: San Francisco, Union Station

- Products and services: Slack, Google Play

- Trademarks: Coca-Cola

- Book titles: The Move Book

- Standards or technologies: Local Area Network (LAN)

### Product names {#product-names}

Product names are proper nouns. Capitalize all words of a product name. When referring to a product, use only the product name without "the". When referring specifically to a Sui wallet, use Sui Wallet or Ethos Wallet and not just wallet. Users likely have multiple wallets, and we want to make it clear which wallet. Use wallet generically when referring to the concept of a wallet.

> There are several types of wallets to choose from.

> Never share the recovery passphrase for your wallet with anyone.

> The Sui network supports the following wallets:
> - Sui Wallet
> - Ethos Wallet
> - Coinbase Wallet

### Acronyms and abbreviations

#### Acronyms {#acronyms}

Spell out a term or phrase on first use in a topic, followed by the acronym in parentheses. Then use the acronym for subsequent mentions.

> Example: You can mint non-fungible tokens (NFTs) using your Sui Wallet. To view an NFT after you mint it, click the NFTs tab of your wallet.

##### Terms that should always be used as acronyms 

- CLI  
- SDK

#### Abbreviations 

Abbreviations for words should not be used. Write out the full word for clarity.

> âœ… Open the tab for more information.

> âŒ Open the tab for more info.

--- 

## Capitalization {#capitalization}

#### Title capitalization {#title-capitalization}

For title capitalization, follow these guidelines:

- Do not capitalize short conjunctions and prepositions (a, an, and, but, for, in, or, so, to, with, yet), unless they are the first or last word.

- Capitalize all other words (including 'Is' and 'Be' as they are verbs).

- Capitalize the word after a hyphen.

- Match casing for commands or special terms, such as cURL or dApp.

- Match the casing for API elements and programming language keywords.

#### Section heading capitalization 

Use sentence capitalization for section headings, table cells or headers, list items, captions, alt text, and error messages.

#### Body text capitalization 

##### Do:

Always capitalize the first word of a new sentence.

Always capitalize proper nouns and product names. See [words to always capitalize](#word-list) for the exhaustive list of capitalized terms. 

##### Do not:

Do not use all uppercase for emphasis; use bold instead.

> Example: IMPORTANT vs **Important**

Do not use bicapitalization or internal capitalization unless it is part of a brand.

> Examples: YouTube or DreamWorks.

Do not capitalize the spelled-out form of an acronym unless it's a proper noun.

> Example: HyperText Markup Language (HTML).

---

## Body text styling 

#### Bold text 

Use bold for UI elements that appear on the screen, such as buttons, menu items, field labels, and commands.  

> Example: Click **Save** to store your changes.  

Use bold sparingly for emphasis and only when necessary for clarity. Avoid overusing bold for general emphasis in body text.  

#### Keyboard button text

Use the `<kbd>` tags around text that corresponds to a physical button on the keyboard.

<Tabs>
<TabItem value="example" label="Example" default>

Press <kbd>0</kbd>, <kbd>1</kbd>, or <kbd>2</kbd> to select a key scheme and then press <kbd>Enter</kbd>.

</TabItem>

<TabItem value="markdown" label="Markdown">

```
Press <kbd>0</kbd>, <kbd>1</kbd>, or <kbd>2</kbd> to select a key scheme and then press <kbd>Enter</kbd>.
```

</TabItem>
</Tabs>

#### Italic text 

Use italics when introducing a new term for the first time. 

> Example: The term for the cost of processing transaction blocks is _gas_.

#### Slashes {#slashes}

Do not use slashes in place of "and" or "or", such as True / False or True/False. Use True or False, or True | False in code documentation.

---

## Titles and headings 

Use enough words in headings and titles to make it easy to know which link to click on a search results page. One-word titles (for example, Installing) do not provide enough information to determine the contents of a topic.

#### Page titles 

Use **descriptive titles** that include relevant keywords so readers can quickly identify the content. Shorter titles are preferred in the navigation pane. You can set a different navigation title by adding a `sidebar_label` in the document frontmatter.

Readers usually search for information to complete a specific task. Avoid vague titles such as **Get Started**. Get started with what? If there are multiple products or features, the meaning is unclear.

A better option is **Get Started with Sui**, but even this is still too broad. Readers want guidance for a specific task or journey. Instead, use precise titles such as **Create a Sui Full Node** or **Install Sui Tooling**. These tell the reader exactly what they will learn or accomplish.

#### Page headings 

Use heading capitalization style (sentence case). Do not stack headings (place two one after the other without body text in between them).

If something is formatted as inline code in the body, format it the same in the heading.

Do not use a page title as a heading in a different page. This can interfere with search result accuracy. Page titles should be unique and descriptive, while headings can be reused.

> âœ… Correct usage: 
> Page 1: Page title "Sui Gas Profiling" with heading "Environment configuration"
> Page 2: Page title "Sui Indexing" with heading "Environment configuration"

> âŒ Incorrect usage: 
> Page 1: Page title "Sui Gas Profiling" with heading "Environment configuration"
> Page 2: Page title: "Sui Features" with heading "Sui gas profiling"

#### Heading sizes 

- Heading 1: (#) Reserved exclusively for the page title. When the title is specified in the frontmatter, the page is formatted automatically with that title as a Heading 1 element.

- Heading 2: (##) Top-level section headings. Used to introduce new topics on a page.

- Heading 3: (###) Sub-topics for each Heading 2. Used to introduce multiple concepts under a top-level heading.

- Heading 4: (####) Sub-topics for each Heading 3. Used to introduce examples for Heading 3 topics or format sub-sections distinctly. 

- Heading 5: (#####) Sub-topics for each Heading 4. When formatted, looks identical to bolded body text, but slightly larger. Can also be used as an alternative to bolded text to create unique formatting within other elements, such as:

<Tabs>
<TabItem value="example" label="Example" default>

> ##### Heading 5 text.

> **Bold body text.**

> Normal body text.

</TabItem>
<TabItem value="markdown" label="Markdown">

```
> ##### Heading 5 text.

> **Bold body text.**

> Normal body text.
```

</TabItem>
</Tabs>

#### Code elements in section headings

If a word or phrase is formatted in the page content as `inline code`, then it should be formatted the same in a section heading. 

> ##### Section heading: Install `suiup`

> Body content: Install `suiup` using the command: ...

See [inline code](#inline-code) for more information.

---

## Lists {#lists}

Use lists to present items or steps clearly. Introduce a list with a short description ending in a colon (:). Lists should be used in place of sentences that include more than 4 items as a serial comma list. 

All lists should use sentence capitalization unless listing the titles of documentation pages, in which case the title case should be respected..

> Title case example: The Build section includes:
> 
> - Building with Sui  
> - Using the CLI to Start a Network  
> - Creating Smart Contracts  
> - Sui Tutorial  
> - Sui Examples  

> Sentence case example: The Build section includes:
> 
> - For objects, the `tx.object(objectId)` function is used to construct an input that contains an object reference.
> - For pure values, the `tx.pure(type, value)` function is used to construct an input for a non-object input.

#### Numbered lists {#numbered-ordered-lists}

Use when items must be done in order, describe a sequence, or describe a specific number of items.

<Tabs>
<TabItem value="example" label="Example" default>

1. Create a fork of the repo.  
1. Clone your fork of the repo.  
1. Install Sui.  

</TabItem>
<TabItem value="markdown" label="Markdown">

```
1. Create a fork of the repo.
1. Clone your fork of the repo.
1. Install Sui.
```

</TabItem>
</Tabs>

#### Bulleted lists {#bulleted-lists}

Use for related items that do not need order. Use sentence capitalization and consistent punctuation. Add periods only if the item is a full sentence.

<Tabs>
<TabItem value="example" label="Example" default>

Sui Explorer supports the following browsers:

- Firefox version X or later  
- Chrome version X or later  
- Edge version X or later  

</TabItem>
<TabItem value="markdown" label="Markdown">

```
Sui Explorer supports the following browsers:

- Firefox version X or later
- Chrome version X or later
- Edge version X or later
```

</TabItem>
</Tabs>

#### Term lists {#term-list}

Use to define terms or concepts. The term should be bold text, followed by a colon (:) and the term's definition using sentence capitalization: 

> - **Term:** Sentence capitalization used for the term definition. 

<Tabs>
<TabItem value="example" label="Example" default>

- **Term:** A description of the term.  

- **DAG:** A directed acyclic graph (DAG) is a data modeling or structuring tool typically used in data architectures.  

</TabItem>
<TabItem value="markdown" label="Markdown">

```
- **Term:** A description of the term.

- **DAG:** A directed acyclic graph (DAG) is a data modeling or structuring tool typically used in data architectures.
```

</TabItem>
</Tabs>

#### Related links list

At the bottom of a page, you can direct the reader to additional, related content via a related links list. Use the `RelatedLink` component:

External links:

```jsx
<RelatedLink href="/path/to/page" label="Page Title" desc="Description of page." />
```

Internal links:

```jsx
<RelatedLink to="/guides/somepage.mdx" />
```


#### Attribute lists 

Use lists with inline code formatting to list attributes for components such as objects.

<Tabs>
<TabItem value="example" label="Example" default>

An event object in Sui consists of the following attributes:

- `id`: JSON object containing the transaction digest ID and event sequence.
- `packageId`: The object ID of the package that emits the event.
- `transactionModule`: The module that performs the transaction.
- `sender`: The Sui network address that triggered the event.
- `type`: The type of event being emitted.
- `parsedJson`: JSON object describing the event.
- `bcs`: Binary canonical serialization value.
- `timestampMs`: Unix epoch timestamp in milliseconds.

</TabItem>
<TabItem value="markdown" label="Markdown">

```
An event object in Sui consists of the following attributes:

- `id`: JSON object containing the transaction digest ID and event sequence.
- `packageId`: The object ID of the package that emits the event.
- `transactionModule`: The module that performs the transaction.
- `sender`: The Sui network address that triggered the event.
- `type`: The type of event being emitted.
- `parsedJson`: JSON object describing the event.
- `bcs`: Binary canonical serialization value.
- `timestampMs`: Unix epoch timestamp in milliseconds.
```

</TabItem>
</Tabs>

---

## Tables {#tables}

#### Table headings {#table-headings}

Capitalize the first word in the heading. Center align the text. Bold labels in the Header row.

<Tabs>
<TabItem value="example" label="Example" default>

| **Column one** | **Column two** | **Column three** | **Column four** |
| :------------- | :------------: | :--------------: | :-------------- |
| Metric name    |       10       |        X         | Text string.    |

</TabItem>
<TabItem value="markdown" label="Markdown">

```

| **Column one** | **Column two** | **Column three** | **Column four** |

```

</TabItem>
</Tabs>

#### Table alignment {#table-alignment}

Center align labels in the Heading row. Left align strings of text. Center align values and Xs or checkmarks.

<Tabs>
<TabItem value="example" label="Example" default>

| **Column one** | **Column two** | **Column three** | **Column four** |
| :------------- | :------------: | :--------------: | :-------------- |
| Metric name    |       10       |        X         | Text string.    |

</TabItem>
<TabItem value="markdown" label="Markdown">

```

| **Column one** | **Column two** | **Column three** | **Column four** |
| :--- | :---: | :---: | :--- |

```

</TabItem>
</Tabs>

#### Table text {#table-text}

Follow style guidelines for regular body text.

---

## Code {#code}

Words or phrases that refer to functions, object names, CLI tool names, or CLI commands should be formatted as inline code when used in a sentence. 

Use codeblocks for larger sections. Always use actual codeblocks (no images) formatted with the correct syntax highlighting.

#### Inline code {#inline-code}

Use backticks (\`) around inline code. 

Things that should always be formatted as inline code (body and headings) include:

- Object names: `myObject`

- Function names: `HelloWorld`

- File names with extensions: `myPackage.move`

- File extensions: `.jpg`

- CLI tool names: `brew`

- CLI commands when used within a sentence: If using the suggested location, type `export PATH=$PATH:~/sui` and press Enter.

- Variable names: `PATH`

- File paths: `~/.cargo/bin`

#### Console commands 

Console commands must be formatted in three backticks (\`\`\`) and start with `$`.

> Example:
```
$ brew install sui
```

Keep command and response outputs in different code blocks. This ensures commands can be copied and run correctly.

#### Codeblocks {#codeblocks}

Introduce codeblocks with descriptive text, including where the code should be placed within a project:

> Example: Create a new file in the `sources` directory with the name `house_data.move` and populate the file with the following code:

Follow with explanations:

> Example: There are a few details to note in this code:
> 1. The first line declares the module name as `house_data` within the package `satoshi_flip`.
> 1. Seven lines begin with the `use` keyword, which enables this module to use types and functions declared in other modules (in this case, they are all coming from the Sui standard library).
> 1. Two error codes. These codes are used in assertions and unit tests to ensure that the program is running as intended.

Use three backticks (\`\`\`) to initiate, followed by the code's language (Rust, Move, etc) for proper syntax highlighting, and a title indicating the file name.

<Tabs>
<TabItem value="example" label="Example" default>

```move title='house_data.move'
module satoshi_flip::house_data {

  use sui::balance::{Self, Balance};
  use sui::sui::SUI;
  use sui::coin::{Self, Coin};
  use sui::package::{Self};

  // Error codes
  const ECallerNotHouse: u64 = 0;
  const EInsufficientBalance: u64 = 1;

```

</TabItem>
<TabItem value="markdown" label="Markdown">

````
```move title='house_data.move'
module satoshi_flip::house_data {

  use sui::balance::{Self, Balance};
  use sui::sui::SUI;
  use sui::coin::{Self, Coin};
  use sui::package::{Self};

  // Error codes
  const ECallerNotHouse: u64 = 0;
  const EInsufficientBalance: u64 = 1;

```
````

</TabItem>
</Tabs>

---

## Procedures, tasks, and instructions {#procedures-tasks-instructions}

Introduce a procedure with an infinitive verb. Format procedures using a numbered or ordered list.

#### Keyboard keys in procedures {#keyboard-keys-procedures}

When you provide instructions to press keyboard keys, such as Press **Enter** to continue, use uppercase for the key name and format the key name as bold text.

<Tabs>
<TabItem value="example" label="Example" default>

To get the latest version of the Sui Wallet extension:

1. Open Google Chrome.
1. Click **Extensions**, then click **Manage Extensions**.
1. Click **Details** for the Sui Wallet extension, then click **View in Chrome Web Store**.

</TabItem>
<TabItem value="markdown" label="Markdown">

```

To get the latest version of the Sui Wallet extension:

1. Open Google Chrome.
1. Click **Extensions**, then click **Manage Extensions**.
1. Click **Details** for the Sui Wallet extension, then click **View in Chrome Web Store**.

```

</TabItem>
</Tabs>

#### UI elements {#ui-elements}

Format UI elements, such as field labels, button names, and menu commands, in bold text. Always match the exact text or label of the UI element, including capitalization. Do not include special characters, such as ellipses, if included in the element label.

> Example: Click **More Transactions** to open the **Transactions** page.

---

## Links and references

Always use full, relative links when linking to topics on [docs.sui.io].

For the link text, use either:

- The topic title of the target topic, respecting the title case format.

- A portion of the sentence that serves as the link text for the link in a list or "Learn more" sentences. Do not use a URL as the link text.

<Tabs>
<TabItem value="example" label="Example" default>

> To learn more, see [Examples of Sui Smart Contracts](/guides/developer/app-examples.mdx).

</TabItem>
<TabItem value="markdown" label="Markdown">

```markdown
To learn more, see [Examples of Sui Smart Contracts](/guides/developer/app-examples.mdx).

```

</TabItem>
</Tabs>

Use keywords from the target topic title when using inline links.

<Tabs>
<TabItem value="example" label="Example" default>

> Before you install Sui, make sure to install the [prerequisites](/guides/developer/getting-started/sui-install.mdx#prerequisites).

</TabItem>
<TabItem value="markdown" label="Markdown">

```

Before you install Sui, make sure to install the [prerequisites](/guides/developer/getting-started/sui-install.mdx#prerequisites).

```

</TabItem>
</Tabs>

### URLs and web addresses {#urls-web-addresses}

Create a link with descriptive text to a site or URL. Provide the URL only when a reader needs to copy it, such as in example code or configuration files.

### Referring to pages in our docs {#referring}

Refer to pages in the documentation set as "topic"s. A "guide" can comprise many related topics.

> Example: See the Install topic in the Validator guide for more information.

:::info

You can also just refer to a topic by title where it makes sense. See Installing Sui for more information.

:::

---

## Special components

### Collapsible component

Use the `<details><summary>` component to hide long or optional content so it doesn't overwhelm the page. Collapsible sections improve readability while still making supporting information available.  

Use a short, descriptive summary so readers know what's inside. Keep the summary in sentence case.  

Do not nest collapsible components inside one another. Limit collapsible content to material that supplements (not replaces) the visible text.  

#### Use collapsible components for:

- Large code snippets or sample files.  

- Verbose command-line output (for example, logs or stack traces).  

- Extended reference content that readers may not always need.  

#### Do not use collapsible components for:

- Required steps in a procedure. These should always be visible.  

- Short examples or essential commands (collapsing them adds friction). 

- Content that is critical for understanding the main topic.  

<Tabs>
<TabItem value="example" label="Example" default>

<details>
<summary>View full command output</summary>

```
Compiling dependencies...
Finished release [optimized] target(s) in 10.35s
Running `target/release/sui-node`
...
INFO: Sui node is now running
```

</details>

</TabItem>
<TabItem value="markdown" label="Markdown">

````markdown
<details>
<summary>View full command output</summary>

```
Compiling dependencies...
Finished release [optimized] target(s) in 10.35s
Running `target/release/sui-node`
...
INFO: Sui node is now running
```

</details>
````

</TabItem>
</Tabs>

### Alerts {#alerts}

Alerts add emphasis to information. Use Admonitions, a Docusaurus feature, to indicate the alert is a Note, Tip, or Caution. The explanation in the alert must be a complete sentence and use sentence case.

#### Caution {#caution}

Use caution alerts to call out when the following information could cause the developer to lose data, encounter errors, or encounter potentially breaking changes. Always explain the risk clearly.  

<Tabs>
<TabItem value="example" label="Example" default>

:::caution

Backup your configuration files before you delete your network.

:::

</TabItem>
<TabItem value="markdown" label="Markdown">

```

:::caution

Backup your configuration files before you delete your network.

:::

```

</TabItem>
</Tabs>

#### Danger {#danger}

Use danger alerts only for information where the consequences of a mistake are critical, such as permanent data loss, security vulnerabilities, or irreversible actions. Keep the explanation concise and serious in tone.  

<Tabs>
<TabItem value="example" label="Example" default>

:::danger

Deleting this key will permanently remove your access to the account.

:::

</TabItem>
<TabItem value="markdown" label="Markdown">

```

:::danger 

Deleting this key will permanently remove your access to the account.

:::

```

</TabItem>
</Tabs>

#### Info {#info}

Use info alerts to provide important but neutral context that readers should be aware of. It's less about best practices and more about ensuring readers do not miss critical background or conditions.  

<Tabs>
<TabItem value="example" label="Example" default>

:::info

You must install Rust before you can build Sui from source.

:::

</TabItem>
<TabItem value="markdown" label="Markdown">

```

:::info 

You must install Rust before you can build Sui from source.

:::

```

</TabItem>
</Tabs>

#### Note {#note}

While note alerts are a valid admonition, its visual styling is less impactful than other supported admonitions. It is recommended to avoid using note in favor of tip or info.  

<Tabs>
<TabItem value="example" label="Example" default>

:::note

This section applies only if you're using Devnet.

:::

</TabItem>
<TabItem value="markdown" label="Markdown">

```

:::note

This section applies only if you're using Devnet.

:::

```

</TabItem>
</Tabs>

#### Tip {#tip}

Use tip alerts to give the reader advice that might be helpful, such as a best practice or a shortcut.  

<Tabs>
<TabItem value="example" label="Example" default>

:::tip

Change your home directory after installing the IDE.

:::

</TabItem>
<TabItem value="markdown" label="Markdown">

```

:::tip

Navigate into your home directory after installing the IDE.

:::

```

</TabItem>
</Tabs>

---

## Images and graphics {#images-graphics}

Only use images and screenshots to supplement and help explain text. Images do not replace text. Readers should be able to understand the documentation without the images. However, images can help readers understand the text more clearly.

Use [Snagit](https://www.techsmith.com/snagit/) or other tools to capture screenshots.

#### Image format {#image-format}

Use `.png` when possible, otherwise use `.jpg`.

#### Image resolution {#image-resolution}

Images should be at least 400 pixels wide. If an image looks blurry when uploaded, try making a new image in higher resolution.

#### Captions {#captions}

Use alt text to describe what the image shows. Use the caption to explain why the image is meaningful in the context of the page.
See Accessibility considerations for captions.

#### Mermaid for images in Markdown {#mermaid}

You can create flowcharts and similar images directly in Markdown [using Mermaid](https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/).

---

## Index pages 

Section index pages must link to subcategory index pages when one exists. This is to ensure users can easily navigate deeper into subsections without relying solely on the sidebar and creates a consistent navigation structure. 

For example, if the docs folder looks like this:

```
/docs/
  guides/
    index.mdx
    setup/
      index.mdx
      install.mdx
```

Then `/docs/guides/index.mdx` must include a link to `/docs/guides/setup/index.mdx` rather than a link to `/docs/guides/setup/install.mdx`.

---

## Accessibility {#accessibility}

Reference works for making content accessible:

- [A11Y Style Guide](https://a11y-style-guide.com/style-guide/)
- [Bitsofcode Accessibility Cheatsheet](https://bitsofco.de/the-accessibility-cheatsheet/)
- [Atlassian Design System - Inclusive writing reference](https://atlassian.design/content/inclusive-writing)
- [MailChimp's writing style guide](https://styleguide.mailchimp.com/writing-for-accessibility/)
- [Microsoft Style Guide Accessibility Terms](https://learn.microsoft.com/en-us/style-guide/a-z-word-list-term-collections/term-collections/accessibility-terms)
- [Writing for All Abilities](https://learn.microsoft.com/en-us/style-guide/accessibility/writing-all-abilities) (Microsoft Style Guide)

### Formatting {#formatting}

Do not use color or special symbols to add emphasis to text. Screen readers are designed to interpret bold (`<strong>`) and italic (`<em>`) in web pages.

### Images {#images}

Add captions and alt text that describe the image for someone using a screen reader. What are the important details in the image that someone using a screen reader can't see?

Use alt text to describe what the image shows. Use the caption to explain why the image is meaningful in the context of the page.

An image is not a substitute for text; images should only supplement text. Do not rely on an image to convey information not in text form. For example, an image of a table of values does no one any good if the image fails to display for a host of possible reasons.

--- 

## Reference style guides {#reference-style-guides}

- [Write the Docs Style Guide article](https://www.writethedocs.org/guide/writing/style-guides/)
- [GitLab Style Guide](https://docs.gitlab.com/ee/development/documentation/styleguide/index.html) - managed as a community project
- [Digital Ocean Style Guide](https://www.digitalocean.com/community/tutorials/digitalocean-s-technical-writing-guidelines)
- [SUSE Style Guide](https://documentation.suse.com/style/current/#sec-techwriting)
- [Microsoft Style Guide](https://docs.microsoft.com/en-us/style-guide/welcome/)
- [Google Developer Style Guide](https://developers.google.com/style)
- [CDN Language and Style Reference](http://cdn.static-economist.com/sites/default/files/pdfs/style_guide_12.pdf)

>>>> sui/docs/content/references/contribute/sui-environment.mdx
---
title: Sui Environment Setup
description: Get the background information you need before you start developing on Sui. Learn the layout of the Sui monorepository and the suggested development environment for working with Move.
keywords: [ setup environment, setup dev environment, setup mono repo, download mono repo, monorepo, fork sui repo, how to contribute to sui repo, contribute to sui, develop sui locally ]
---

Before you start developing with Sui and Move, you should familiarize yourself with how to contribute to Sui, how Sui is structured, what tools and SDKs exist, and what plugins are available to use in your IDE.

## Fork the Sui repository {#fork}

The recommended way to contribute to the Sui repository is to fork the project, make changes on your fork, then submit a pull request (PR). The Sui repository is available on GitHub: https://github.com/MystenLabs/sui.

To create a local Sui repository:

1. Go to the [Sui repository](https://github.com/MystenLabs/sui) on GitHub.
1. Click the **Fork** button to create a copy of the repository in your account.

   ![Fork Sui repo](./images/fork.png)

1. In your forked repository on GitHub, click the green `Code <>` button and copy the **HTTPS** URL GitHub provides.

   ![Copy URL](./images/gh-url.png)

1. Open a terminal or console on your system at the location you want to save the repository locally. Type `git clone ` and paste the URL you copied in the previous step and press `Enter`.
1. Type `cd sui` to make `sui` the active directory.

You can use any [branching strategy](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-and-deleting-branches-within-your-repository) you prefer on your Sui fork. Make your changes locally and push to your repository, submitting PRs to the official Sui repository from your fork as needed.

:::tip

Be sure to synchronize your fork frequently to keep it up-to-date with active development.

:::

## Sui repository and how to contribute

The Sui repo is a monorepo, containing all the source code that is used to build and run the Sui network, as well as this documentation.

The root folder of the Sui monorepo has the following top-level folders:

- [apps](https://github.com/MystenLabs/apps): Contains the source code for the main web applications that Mysten Labs runs.
- [consensus](https://github.com/MystenLabs/sui/tree/main/consensus): Contains the source code of consensus.
- [crates](https://github.com/MystenLabs/sui/tree/main/crates): Contains all the Rust crates that are part of the Sui system.
- [dapps](https://github.com/MystenLabs/sui/tree/main/dapps): Contains some examples of decentralized applications built on top of Sui, such as Kiosk or Sponsored Transactions.
- [dashboards](https://github.com/MystenLabs/sui/tree/main/dashboards): Currently empty.
- [doc](https://github.com/MystenLabs/sui/tree/main/doc): Contains deprecated documentation related to Move and Sui.
- [docker](https://github.com/MystenLabs/sui/tree/main/docker): Contains the docker files needed to spin up a node, an indexer, a full node or other services.
- [docs](https://github.com/MystenLabs/sui/tree/main/docs): Contains this documentation and the source for this site.
- [examples](https://github.com/MystenLabs/sui/tree/main/examples): Contains examples of apps written for Sui and smart contracts written in Move.
- [external-crates](https://github.com/MystenLabs/sui/tree/main/external-crates): Contains the source code for the Move programming language.
- [kiosk](https://github.com/MystenLabs/sui/tree/main/kiosk): Contains the source code of the Mysten Labs Kiosk extensions and rules, as well as examples.
- [nre](https://github.com/MystenLabs/sui/tree/main/nre): Contains information about node and network reliability engineering.
- [scripts](https://github.com/MystenLabs/sui/tree/main/scripts): Contains a number of scripts that are used internally.
- [sui-execution](https://github.com/MystenLabs/sui/tree/main/sui-execution): Contains the source code responsible for abstracting access to the execution layer.

The following primary directories offer a good starting point for exploring the Sui codebase:

- [move](https://github.com/MystenLabs/sui/tree/main/external-crates/move) - Move VM, compiler, and tools.
- [consensus](https://github.com/MystenLabs/sui/tree/main/consensus) - Consensus engine.
- [typescript-sdk](https://github.com/MystenLabs/ts-sdks/tree/main/packages/typescript/) - the Sui TypeScript SDK.
- [wallet](https://chromewebstore.google.com/detail/slush-%E2%80%94-a-sui-wallet/opcgpfmipidbgpenhmajoajpbobppdil) - Chrome extension wallet for Sui.
- [sui](https://github.com/MystenLabs/sui/tree/main/crates/sui) - the Sui command line tool.
- [sui-core](https://github.com/MystenLabs/sui/tree/main/crates/sui-core) - Core Sui components.
- [sui-execution](https://github.com/MystenLabs/sui/tree/main/sui-execution) - Execution Layer (programmable transactions, execution integration).
- [sui-framework](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework) - Move system packages (0x1, 0x2, 0x3, 0xdee9).
- [sui-network](https://github.com/MystenLabs/sui/tree/main/crates/sui-network) - Networking interfaces.
- [sui-node](https://github.com/MystenLabs/sui/tree/main/crates/sui-node) - Validator and full node software.
- [sui-protocol-config](https://github.com/MystenLabs/sui/tree/main/crates/sui-protocol-config) - On-chain system configuration and limits.
- [sui-sdk](https://github.com/MystenLabs/sui/tree/main/crates/sui-sdk) - The Sui Rust SDK.
- [sui-types](https://github.com/MystenLabs/sui/tree/main/crates/sui-types) - Sui object types, such as coins and gas.

## Development branches

The Sui repository includes four primary branches: `devnet`, `testnet`, `mainnet`, and `main`.

The `devnet` branch includes the latest stable build of Sui. Choose the `devnet` branch if you want to build or test on Sui Devnet. If you encounter an issue or find a bug, it may already be fixed in the `main` branch. To submit a PR, you should push commits to your fork of the `main` branch.

The `testnet` branch includes the code running on the Sui Testnet network.

The `mainnet` branch includes the code running on the Sui Mainnet network.

The `main` branch includes the most recent changes and updates. Use the `main` branch if you want to contribute to the Sui project or to experiment with cutting-edge functionality. The `main` branch might include unreleased changes and experimental features, so use it at your own risk.

>>>> sui/docs/content/references/exchange-integration-guide.mdx
---
title: Exchange Integration Guide
sidebar_label: Exchange Integration
slug: /exchange-integration-guide
description: Learn the primary tasks necessary to integrate the SUI token with a cryptocurrency exchange. 
keywords: [ integrate sui, SUI token, SUI, integrate with exchange, integrate with cryptocurrency exchange, decentralized exchange, dex, integration with dex, dex integration, sui staking, staking ]
---

This topic describes how to integrate SUI, the token native to the Sui network, into a cryptocurrency exchange. The specific requirements and processes to implement an integration vary between exchanges. Rather than provide a step-by-step guide, this topic provides information about the primary tasks necessary to complete an integration. After the guidance about how to configure an integration, you can also find information and code samples related to staking on the Sui network.

## Requirements to configure a SUI integration {#requirements-sui-integration}

The requirements to configure a SUI integration include:

- A Sui full node. You can operate your own Sui full node or use a full node from a node operator.
- Suggested minimum hardware to run a Sui full node:
  - CPUs: 8 physical cores / 16 vCPUs
  - RAM: 128 GB
  - Storage (SSD): 4 TB NVMe drive

For best results, run Sui Full nodes on Linux. Sui supports the Ubuntu and Debian distributions. You can also fun a full node on macOS.

## Configure a Sui full node {#configure-full-node}

You can set up and configure a Sui full node using Docker or directly from source code in the Sui GitHub repository.

### Install a Sui full node using Docker {#full-node-docker}

Run the command in this section using the same branch of the repository for each. Replace `branch-name` with the branch you use. For example, use `devnet` to use the Sui Devnet network, or use `testnet` to use the Sui Testnet network. You must download all files to, and run all commands from, the same folder location.

1.  Install [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/). Docker Desktop version installs Docker Compose.
1.  Install dependencies for Linux:
    ```sh
    $ apt update \
    && apt install -y --no-install-recommends \
    tzdata \
    ca-certificates \
    build-essential \
    pkg-config \
    cmake
    ```
1.  Download the docker-compose.yaml file:
    ```sh
    $ wget https://github.com/MystenLabs/sui/blob/branch-name/docker/fullnode/docker-compose.yaml
    ```
1.  Download the fullnode-template.yaml file:
    ```sh
    $ wget https://github.com/MystenLabs/sui/raw/branch-name/crates/sui-config/data/fullnode-template.yaml
    ```
1.  Download the genesis.blob file:
    ```sh
    $ wget https://github.com/MystenLabs/sui-genesis/blob/main/mainnet/genesis.blob
    ```
    :::info
    
    Replace `mainnet` in the URL with the desired target branch if necessary. For example, `https://github.com/MystenLabs/sui-genesis/blob/main/testnet/genesis.blob` for Testnet.

    :::
1.  Start the full node. The -d switch starts it in the background (detached mode).
    ```sh
    $ docker-compose up -d
    ```

## Install a Sui full node from source {#install-full-node-source}

Use the steps in this section to install and configure a Sui full node directly from the Sui GitHub repository. These steps use [Cargo](https://doc.rust-lang.org/cargo/), the Rust package manager.

1.  Install prerequisites for Sui.
1.  Clone the Sui repository:
    ```sh
    $ git clone https://github.com/MystenLabs/sui.git -b branch-name
    ```
    Replace `branch-name` with the branch to use. You should use the same branch for all commands.
1.  Change directories to /sui:
    ```sh
    $ cd sui
    ```
1.  Copy the fullnode.yaml template:
    ```sh
    $ cp crates/sui-config/data/fullnode-template.yaml fullnode.yaml
    ```
1.  Download the genesis.blob file:
    ```sh
    $ wget https://github.com/MystenLabs/sui-genesis/blob/main/mainnet/genesis.blob
    ```
    Change `mainnet` in the URL to the same branch you used for previous commands, if needed.
1.  Optionally, if you installed Sui to a path other than the default, modify the fullnode.yaml file to use the path you used. Update the path to the folder where you installed sui-fullnode for the `db-path` and `genesis-file-location` as appropriate:
    `db-path: "/db-files/sui-fullnode-folder"`
    `genesis-file-location: "/sui-fullnode-folder/genesis.blob"`
1.  Start you Sui full node:
    ```sh
    $ cargo run --release --bin sui-node -- --config-path fullnode.yaml
    ```

## Set up Sui addresses {#setup-sui-addresses}

Sui addresses do not require on-chain initialization, you can spend from an address if it corresponds to your private key. You can derive a 32-byte Sui address by hashing the signature scheme flag byte concatenated with public key bytes `flag || pubkey` using the [BLAKE2b](https://www.blake2.net/) (256 bits output) hashing function.

Currently, Sui address supports these signature schemes: pure Ed25519, Secp256k1, Secp256r1 and Multisig. The corresponding flag bytes are 0x00, 0x01, 0x02, 0x03 respectively.

The following code sample demonstrates how to derive a Sui address in Rust:

```rust
let flag = 0x00; // 0x00 = ED25519, 0x01 = Secp256k1, 0x02 = Secp256r1, 0x03 = MultiSig
// Hash the [flag, public key] bytearray using Blake2b
let mut hasher = DefaultHash::default();
hasher.update([flag]);
hasher.update(pk);
let arr = hasher.finalize();
let sui_address_string = hex::encode(arr);
```

## Displaying addresses {#displaying-addresses}

Sui supports both addresses with and without a 0x prefix. Sui recommends that you always include the 0x prefix in API calls and when you display user addresses.

## Track balance changes for an address {#track-balance-changes}

You can track balance changes by calling `sui_getBalance` at predefined intervals. This call returns the total balance for an address. The total includes any coin or token type, but this document focuses on SUI. You can track changes in the total balance for an address between subsequent `sui_getBalance` requests.

The following bash example demonstrates how to use `sui_getBalance` for address 0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3. If you use a network other than Devnet, replace the value for `rpc` with the URL to the appropriate full node.

```sh
rpc="https://fullnode.devnet.sui.io:443"
address="0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3"
data="{\"jsonrpc\": \"2.0\", \"method\": \"sui_getBalance\", \"id\": 1, \"params\": [\"$address\"]}"
curl -X POST -H 'Content-type: application/json' --data-raw "$data" $rpc
```

The response is a JSON object that includes the totalBalance for the address:

```json
{
  "jsonrpc": "2.0",
  "result": {
    "coinType": "0x2::sui::SUI",
    "coinObjectCount": 40,
    "totalBalance": 10000000000,
    "lockedBalance": {}
  },
  "id": 1
}
```

The following example demonstrates using sui_getBalance in Rust:

```rust
use std::str::FromStr;
use sui_sdk::types::base_types::SuiAddress;
use sui_sdk::{SuiClient, SuiClientBuilder};


#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
   let sui = SuiClientBuilder::default().build(
      "https://fullnode.devnet.sui.io:443",
   ).await.unwrap();
   let address = SuiAddress::from_str("0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3")?;
   let objects = sui.read_api().get_balance(address).await?;
   println!("{:?}", objects);
   Ok(())
}
```

## Use events to track balance changes for an address {#events-balance-changes}

You can also track the balance for an address by subscribing to all of the events emitted from it. Use a filter to include only the events related to SUI coins, such as when the address acquires a coin or pays for a gas fee.
The following example demonstrates how to filter events for an address using bash and cURL:

```sh
rpc="https://fullnode.devnet.sui.io:443"
address="0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3"
data="{\"jsonrpc\": \"2.0\", \"id\":1, \"method\": \"sui_getEvents\", \"params\": [{\"Recipient\": {\"AddressOwner\": \"0x849d63687330447431a2e76fecca4f3c10f6884ebaa9909674123c6c662612a3\"}}, null, null, true ]}"
curl -X POST -H 'Content-type: application/json' --data-raw "$data" $rpc
```

The response can include a large number of events. Add pagination to the response using the `nextCursor` key in the request. You can determine the corresponding `txDigest` and `eventSeq` from the `id` field of a transaction.

You can add the `txDigest` value instead of the first `null` within the `params`. The second `null` is an integer that defines how many results (up to 1000) to return and the `true` means ascending order. You can use the `nextCursor` so the response starts from a desired point.

The `id` field of any transaction looks like:

```json
"id": {
  "txDigest": "GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2",
  "eventSeq": 6019
}
```

With this data, create a `nextCursor` as follows:

```sh
nextCursor : {"txDigest": "GZQN9pE3Zr9ZfLzBK1BfVCXtbjx5xKMxPSEKaHDvL3E2","eventSeq": 6019}
```

## Blocks vs Checkpoints {#blocks-vs-checkpoints}

Sui is a DAG-based blockchain and uses checkpoints for node synchronization and global transaction ordering. Checkpoints differ from blocks in the following ways:

- Sui creates checkpoints and adds finalized transactions. Note that transactions are finalized even before they are included in a checkpoint
- Checkpoints do not fork, roll back, or reorganize.
- Sui creates about four checkpoints every second. Find the most up-to-date statistic on the [Sui public dashboard](https://metrics.sui.io/public-dashboards/4ceb11cc210d4025b122294586961169).

### Checkpoint API operations {#checkpoint-api-operations}

Sui Checkpoint API operations include:

- [sui_getCheckpoint](/sui-api-ref#sui_getCheckpoint) - Retrieves the specified checkpoint.
- [sui_getLatestCheckpointSequenceNumber](/sui-api-ref#sui_getLatestCheckpointSequenceNumber) - Retrieves the sequence number of the most recently executed checkpoint.
- sui_getCheckpoints - Retrieves a paginated list of checkpoints that occurred during the specified interval. Pending a future release.

## SUI Balance transfer {#sui-balance-transfer}

To transfer a specific amount of SUI between addresses, you need a SUI token object with that specific value. In Sui, everything is an object, including SUI tokens. The amount of SUI in each SUI token object varies. For example, an address could own 3 SUI tokens with different values: one of 0.1 SUI, a second of 1.0 SUI, and a third with 0.005 SUI. The total balance for the address equals the sum of the values of the individual SUI token objects, in this case, 1.105 SUI.

You can merge and split SUI token objects to create token objects with specific values. To create a SUI token worth .6 SUI, split the token worth 1 SUI into two token objects worth .6 SUI and .4 SUI.

To transfer a specific amount of SUI, you need a SUI token worth that specific amount. To get a SUI token with that specific value, you might need to split or merge existing SUI tokens. Sui supports several methods to accomplish this, including some that do not require you to manually split or merge coins.

## Sui API operations for transfers {#api-operations-transfers}

Sui supports the following API operations related to transferring SUI between addresses:

- [sui_transferObject](/sui-api-ref#sui_transferObject)
  Because SUI tokens are objects, you can transfer SUI tokens just like any other object. This method requires a gas token, and is useful in niche cases only.

- [sui_payAllSui](/sui-api-ref#sui_payAllSui)
  This method accepts an array of SUI token IDs. It merges all existing tokens into one, deducts the gas fee, then sends the merged token to the recipient address.

  The method is especially useful if you want to transfer all SUI from an address. To merge together all coins for an address, set the recipient as the same address. This is a native Sui method so is not considered a transaction in Sui.

- [sui_paySui](/sui-api-ref#sui_paySui)
  This operation accepts an array of SUI token IDs, an array of amounts, and an array of recipient addresses.

  The amounts and recipients array map one to one. Even if you use only one recipient address, you must include it for each amount in the amount array.

  The operation merges all of the tokens provided into one token object and settles the gas fees. It then splits the token according to the amounts in the amounts array and sends the first token to the first recipient, the second token to the second recipient, and so on. Any remaining SUI on the token stays in the source address.

  The benefits of this method include: no gas fees for merging or splitting tokens, and the abstracted token merge and split. The `sui_paySui` operation is a native function, so the merge and split operations are not considered Sui transactions. The gas fees for them match typical transactions on Sui.You can use this operation to split coins in your own address by setting the recipient as your own address. Note that the total value of the input coins must be greater than the total value of the amounts to send.

- [sui_pay](/sui-api-ref#sui_pay)
  This method is similar to sui_paySui, but it accepts any kind of coin or token instead of only SUI. You must include a gas token, and all of the coins or tokens must be the same type.

- [sui_transferSui](/sui-api-ref#sui_transferSui)
  This method accepts only one SUI token object and an amount to send to the recipient. It uses the same token for gas fees, so the amount to transfer must be strictly less than the value of the SUI token used.

## Signing Transactions {#signing-transactions}

Please refer to Sui Signatures for more details on signature validity requirements.

## SUI Staking {#sui-staking}

The Sui blockchain uses a Delegated Proof-of-Stake mechanism (DPoS). This allows SUI token holders to stake their SUI tokens to any validator of their choice. When someone stakes their SUI tokens, it means those tokens are locked for the entire epoch. Users can withdraw their stake at any time, but new staking requests become active only at the start of the next epoch.

SUI holders who stake their tokens to validators earn rewards for helping secure the Sui network. Sui determines rewards for staking based on stake rewards on the network, and distributes them at the end of each epoch.

The total voting power in the Sui Network is always 10,000. The voting power of each individual validator is similar to basis points. For example, a voting power of 101 = 1.01%. Sui's quorum threshold (number of votes needed to confirm a transaction) is 6,667 (which is greater than 2/3). The voting power for a single validator is capped at 1,000 (10%) regardless of how much stake the validator has.

## Staking functions {#staking-functions}

Sui supports the following API operations related to staking. You can find the source code in the [sui_system](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-system/sources/sui_system.move) module.

- `request_add_stake`
  Add user stake to a validator's staking pool.

```move
public fun request_add_stake(
   self: &mut SuiSystemState,
   stake: Coin<SUI>,
   validator_address: address,
   ctx: &mut TxContext,
) {
   validator_set::request_add_stake(
       &mut self.validators,
       validator_address,
       coin::into_balance(stake),
       option::none(),
       ctx,
   );
}
```

- `request_add_stake_mul_coin`
  Add user stake to a validator's staking pool using multiple coins.

```move
public fun request_add_stake_mul_coin(
   self: &mut SuiSystemState,
   delegate_stakes: vector<Coin<SUI>>,
   stake_amount: option::Option<u64>,
   validator_address: address,
   ctx: &mut TxContext,
) {
   let balance = extract_coin_balance(delegate_stakes, stake_amount, ctx);
   validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::none(), ctx);
}
```

- `request_add_stake_with_locked_coin`
  Add user stake to a validator's staking pool using a locked SUI coin.

```move
public fun request_add_stake_with_locked_coin(
   self: &mut SuiSystemState,
   stake: LockedCoin<SUI>,
   validator_address: address,
   ctx: &mut TxContext,
) {
   let (balance, lock) = locked_coin::into_balance(stake);
   validator_set::request_add_stake(&mut self.validators, validator_address, balance, option::some(lock), ctx);
}
```

- `request_withdraw_stake`
  Withdraw some portion of a user stake from a validator's staking pool.

```move
public fun request_withdraw_stake(
   self: &mut SuiSystemState,
   delegation: &mut Delegation,
   staked_sui: &mut StakedSui,
   principal_withdraw_amount: u64,
   ctx: &mut TxContext,
) {
   validator_set::request_withdraw_stake(
       &mut self.validators,
       delegation,
       staked_sui,
       principal_withdraw_amount,
       ctx,
   );
}
```

>>>> sui/docs/content/references/framework.mdx
---
title: Sui Framework
description: The Sui framework libraries include Move modules that provide the logic for Sui and its standards. A Rust process creates the documentation for the modules directly from comments in the code.
keywords: [ sui framework, sui libraries, move modules, sui standards, rust, documentation from modules, generate framework documentation, crate documentation, build documentation locally, build docs ]
---

The documentation in this section is created from the Rust `cargo doc` process. The process builds the content from comments in the source code.

## Framework documentation

The child pages to this topic describe the module members for the following libraries:

- <UnsafeLink href="/references/framework/sui_bridge">`bridge`</UnsafeLink>
- <UnsafeLink href="/references/framework/sui_std">`std`</UnsafeLink>
- <UnsafeLink href="/references/framework/sui_sui">`sui`</UnsafeLink>
- <UnsafeLink href="/references/framework/sui_sui_system">`sui_system`</UnsafeLink>

## Source code

You can find the source code for these Move modules in the [crates/sui-framework/packages](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages) directory in the `sui` repository on GitHub. As previously mentioned, the comments included in the code provide context for the logic defined.

## Crate documentation

You can review the raw `cargo doc` output of the following documentation in the `sui` repository. The .md files are located in the `crates/sui-framework/docs` directory. Online, they are located at https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/docs.

## Build documentation locally

The most recent documentation is always available in the `main` branch of the `sui` repository. You shouldn't need to build the documentation locally, but if the need arises you can:

1. Open a terminal or console to the `sui/crates/sui-framework` directory.
1. Run `cargo doc --workspace --exclude "sui-benchmark" --no-deps`.
1. The docs are built to `crates/sui-framework/docs` into their respective subdirectories.

:::info

If the `cargo doc` process does not work as expected, try running `cargo clean` before attempting again. 

:::

>>>> sui/docs/content/references/fullnode-protocol.mdx
---
title: Sui Full Node gRPC
description: The Sui full node gRPC protocol is available on all Sui Full nodes.
keywords: [ sui full node, grpc, g rpc, rpc, rpc api, json-rpc, json rpc api, grpc api ]
---

import Protocol from "../../site/src/components/Protocol";

Sui full node gRPC API replaces JSON-RPC on full nodes. JSON-RPC is `deprecated`.

<Protocol />

>>>> sui/docs/content/references/ide/debugger.mdx
---
title: Move Trace Debugger
description: Debug Move execution traces directly in VS Code to understand how your code executes.
keywords: [ move trace debugger, debug move execution traces, debug move traces, move execution traces, vs code, debug in vs code, visual studio code, move extension, vs code extension, move vs code extension, debugging, debug interface, replay ]
---

The [Move Trace Debugger](https://marketplace.visualstudio.com/items?itemName=mysten.move-trace-debug) extension for Visual Studio Code provides a familiar [debugging interface](https://code.visualstudio.com/docs/debugtest/debugging) for Move unit tests and on-chain transactions, including [PTB](/concepts/transactions/prog-txn-blocks) debugging support. You can inspect the state of PTB commands, step through code execution, track local variable values, and set line breakpoints for Move code, either in unit tests or in on-chain Move calls.

Debugging is enabled via trace generation: traces can be generated during [unit test execution](#debugging-unit-tests) or during on-chain [transaction replay](#debugging-on-chain-transactions).

## Install

:::info
Use the debugger by installing the [Move extension](./move.mdx), which includes the Move Trace Debugger extension; you do not need to install it separately. The install instructions are included for certain cases where a separate install might be necessary.
:::

The Move Trace Debugger extension is available in the Visual Studio Code Marketplace. Search for `Move Trace Debugger` in the **Extensions** view, or press <kbd>Ctrl</kbd> + <kbd>P</kbd> or <kbd>âŒ˜</kbd> + <kbd>P</kbd> and type `ext install mysten.move-trace-debug`.

Alternatively, run `code --install-extension mysten.move-trace-debug` to install the extension from the command line.

To generate unit execution traces that enable unit test and on-chain transaction debugging, you need the `sui` binary installed with the `tracing` feature flag enabled. The `sui` binaries included in release tarballs, Homebrew, and Chocolatey installations have this feature enabled. See [Install Sui](/guides/developer/getting-started/sui-install) for more information.

## Features

The debugger provides a common set of features for all Move code debugging, whether you're debugging Move unit tests or on-chain Move calls. When debugging on-chain transactions, a Move call is just one of many PTB commands. The debugger supports inspecting not only the Move call itself, but also the state and execution of all remaining native PTB commands.

### Move code debugging features

Currently, the Move Trace Debugger supports forward debugging through execution traces. Reverse debugging is not currently available.

#### Disassembly and source-level debugging

Source code for debugging unit tests is available by definition, and when starting a debug session for unit tests, you will find yourself in the source view.

![Source view](./images/source_view.png)

When debugging an on-chain transaction, the source code for Move calls executed within the transaction is not available by default, as it is not stored on-chain. A debug session will start in the disassembly view where Move code is represented by disassembled bytecode.

![Disassembly view](./images/disassembly_view.png)

This is a lower level representation of the Move code that is still quite useful to improve one's understanding of the Move code behavior and execution flow. It also has one advantage over the source view: it is a much better match to what is recorded in the execution trace. In presence of Move compiler optimizations, disassembly view is the ultimate source of truth. For example, some variables present in the source may no longer be present in the trace, which you can verify in the disassembly view.

You can still provide [source code for on-chain transactions by hand](#source-level-debugging-for-on-chain-transactions) to enable source view. Support for automating source-level debugging for on-chain transactions will be available in the future.

If both source code and disassembled bytecode are available, you can toggle between source view and disassembly view via `Move: Toggle source view` and `Move: Toggle disassembly view` commands from the command palette. You can open these with <kbd>Shift</kbd> + <kbd>âŒ˜</kbd> + <kbd>P</kbd> on macOS, <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> on Windows/Linux).


#### Stepping through code execution

Move Trace Debugger supports the following standard [debug actions](https://code.visualstudio.com/docs/debugtest/debugging#_debug-actions):

- Step Over
- Step Into
- Step Out
- Continue
- Restart
- Stop

As you step through the code into other function calls, the resulting call stack view in the left-hand side bar will update.

![Stepping through code execution](./images/stepping.png)

#### Tracking variable values

Move Trace Debugger supports displaying values of primitive types, Move structs, and references. Note that some of the variables present in the source code can be optimized away by the Move compiler and are not available in the underlying trace. Consequently, their values cannot be tracked by the debugger.

![Variable values](./images/variables.png)

The debugger currently does not support setting watch points on variables.

#### Line breakpoints

Set line breakpoints in your code by placing a cursor on any given line and choosing **Run** -> **Toggle Breakpoint** from the main menu. You can use the **Continue** debug command to advance execution to the next breakpoint.

![Breakpoints](./images/breakpoints.png)

### PTB debugging features

When debugging PTBs, the debugger first displays a summary of the PTB structure. In the following example, you can see that the PTB being debugged consists of multiple Move calls and several native PTB commands (**Split Coins**, **Merge Coins**, and **Transfer Objects**).

![PTB summary](./images/ptb_summary.png)

In the PTB summary, you can step into specific commands or step over them, much like stepping into functions and and stepping over them when debugging Move code. Setting breakpoints in the PTB summary view is not currently supported.

Stepping into a Move function starts Move code debugging with all the relevant [features](#move-code-debugging-features) available (value tracking, breakpoints, etc.).

Stepping into a native command allows you to inspect its input and result values.

![Split coins](./images/split_coins.png)

There is no stepping "through" native commands. Once the state is inspected, you can only step out of it or keep stepping to move to the next command.

## Usage

Use the debugger to debug unit tests and existing on-chain transactions (including [PTB](/concepts/transactions/prog-txn-blocks) debugging support) with the help of of the [replay tool](/references/cli/replay).

### Debugging unit tests

Debugging a Move unit test is a two-step process:

**1. Generate execution traces**
   - Open the command palette (<kbd>Shift</kbd> + <kbd>âŒ˜</kbd> + <kbd>P</kbd> on macOS, <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>P</kbd> on Windows/Linux).

   - Run the `Move: Trace Move test execution` command.

      <div class="image-scale-50">
      ![Command palette](./images/trace_palette.png)
      </div>

      :::info
        This command uses the `sui` binary under the hood which needs to be [pre-installed](#install). The location of the binary needs to be [discoverable by the Move extension](/references/ide/move#build-test-and-trace).
      :::


   - The extension displays a filter prompt. Either type a filter string to target specific tests or leave the field blank to run all tests and press <kbd>Enter</kbd>.

      <div class="image-scale-50">
      ![Filter test string](./images/filter_string.png)
      </div>

   - Find the generated traces in the `traces` directory.

      :::info
        If trace generation in the Visual Studio Code extension does not work for some reason, you can generate traces by executing tests for your package using additional flags:
        ```bash
        sui move test  --trace-execution --disassemble
        ```
      :::


**2. Start debugging**
   - Open the Move file containing your test.

   - Select **Run** -> **Start Debugging** from the main menu.

      <div class="image-scale-30">
      ![Start test debugging](./images/start_debugging.png)
      </div>

   - If the file has multiple tests, select the specific test from the dropdown menu.

      <div class="image-scale-50">
      ![Test selection](./images/test_selection.png)
      </div>


### Debugging on-chain transactions

Debugging an on-chain transaction is a two-step process:

**1. Generate execution trace**

  You need to know a transaction's digest to generate a trace for it. For example, `0x42`.

  ```bash
  sui replay --trace --digest 0x42
  ```

  This command re-executes the transaction locally, generates a trace of its execution, and downloads all data required for debugging this transaction. Data is deposited in a subdirectory of replay tool's output directory (`.replay` by default, but its location is [configurable](../../references/cli/replay.mdx#usage)). This subdirectory is named after the transaction digest.

**2. Start debugging**
   - Open the subdirectory containing the transaction data downloaded for a transaction with the given digest. Open the trace file `trace.json.zst`.

      ![Replay trace](./images/replay_trace.png)

   - Select **Run** -> **Start Debugging** from the main menu.

      <div class="image-scale-30">
      ![Start txn debugging](./images/start_debugging.png)
      </div>

      :::info
        The first time you run this command you may be asked to select a debugger type. Select **Move Debugger**.
      :::

## Source-level debugging for on-chain transactions

Data downloaded from the network for debugging a transaction does not contain the source code for Move calls executed throughout the transaction. You can, however, provide the sources along with additional debugging metadata yourself to enable source-level debugging. If you have access to the source code of packages used throughout the transaction, you can build the packages to generate the debugging metadata and make the location of this data visible to the replay tool.

The source code version of each package should be the same version that was used to build the package used in the transaction. Otherwise, a discrepancy between execution trace (generated from on-chain data) and package debugging metadata (generated locally), might result in debugging failures.

For example, consider a situation when an on-chain transaction executes a call to some public function `foo` which then calls some private function `bar`. The package's source code used to generate the debugging metadata still has public function `foo` but `foo` not longer calls `bar`. When attempting to do source-level debugging in such case, if a call to `bar` was part of the execution trace, the debugger would have no source for function `bar` to display when the call is reached during the debugging session.

Using the newest version of a package might still work, particularly for packages whose existing functionality is largely stabilized and its source code rarely changes, such as Sui framework package. Below are the instructions on how to handle this simplified case, followed by instructions on how to locate precise versions of packages.

Consider the following: a mainnet transaction and with the digest `95oR1YipjSnqd18K4BMshkLgPijypwzARHV988eRhMDs`. Assume that all commands (unless stated otherwise) are executed in some `$ROOT_DIR` (such as your home directory).

Start by tracing execution of this transaction.

```bash
sui replay --digest 95oR1YipjSnqd18K4BMshkLgPijypwzARHV988eRhMDs  --trace
```

When you replay the transaction, the replay tool downloads data for all Move packages used by this transaction. In the case of this example, they reside in the `$ROOT_DIR/.replay/95oR1YipjSnqd18K4BMshkLgPijypwzARHV988eRhMDs` parent directory, with subdirectories named after package IDs:

    ```
    0x0000000000000000000000000000000000000000000000000000000000000001
    0x0000000000000000000000000000000000000000000000000000000000000002
    0x2c8d603bc51326b8c13cef9dd07031a408a48dddb541963357661df5d3204809
    0xb29d83c26cdd2a64959263abbcfc4a6937f0c9fccaf98580ca56faded65be244
    0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7
    0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270
    0xe0917b74a5912e4ad186ac634e29c922ab83903f71af7500969f9411706f9b9a
    0xecf47609d7da919ea98e7fd04f6e0648a0a79b337aaad373fa37aac8febf19c8
    ```

The second directory on the list corresponds to the ID of the Sui framework package. To enable source-level debugging for this package, provide the replay tool with access to its debugging metadata: obtain the package source, build it, and copy the metadata to a specific location (`source` directory) in the Sui framework package subdirectory.

<span id="metadata-generation">**Metadata generation**</span>


   - Clone the repository, unless you already have the Sui source code repository available.

        ```bash
        git clone https://github.com/MystenLabs/sui.git
        ```

   - Build Sui framework package source code.

        ```bash
        cd sui/crates/sui-framework/packages/sui-framework; sui move build
        ```

   - Copy the debugging metadata to the right location.

        ```bash
        cp -r $ROOT_DIR/sui/crates/sui-framework/packages/sui-framework/build/Sui $ROOT_DIR.replay/95oR1YipjSnqd18K4BMshkLgPijypwzARHV988eRhMDs/0x0000000000000000000000000000000000000000000000000000000000000002/source
        ```

When you start a debug session and reach the Sui framework code during debugging, you will be in the source view rather than disassembly view.

### Locating precise package versions

You should try to enable source-level debugging uniformly for all packages used throughout the transaction (both user-level and system packages), and use precise package versions to ensure a smooth [debugging experience](#precise-versions-for-all-packages). This may not always be possible, but in such case, you can still locate [precise versions of system packages](#precise-versions-for-system-packages) to enable limited source-level debugging.

Start debugging the transaction to collect some more information about Move code executed in the transaction.

![Deepbook PTB](./images/deepbook_ptb.png)

The PTB summary reveals that this transaction consists of only one Move call to the function `add_deep_price_point`, in module `pool`, in user package `0xb29d83c26cdd2a64959263abbcfc4a6937f0c9fccaf98580ca56faded65be244`. Ideally, you want to be able to locate the buildable source code for this package and the correct version of the source code. Then, build debugging metadata for this package, which will automatically include information for all dependent packages, enabling uniform source-level debugging. Barring that, you might want to find the correct version of the source code for system packages to at least enable source-level debugging for Sui framework code.

#### Precise versions for all packages

To locate the correct version of the source code for a user package, utilize a Sui explorer (such as [suiscan](https://suiscan.xyz)) and Sui's Move Package Registry ([MVR](https://www.moveregistry.com/)).

Search for the package in a Sui explorer.

<div class="image-scale-50">
![Package search](./images/deepbook_search.png)
</div>

You can see that the the package in question is `deepbook/core`. Look at the detailed information about this package available in the explorer.

<div class="image-scale-70">
![Package explorer](./images/deepbook_explorer.png)
</div>

You can see that the package description in the explorer includes an MVR link. When you follow that link, you get to the MVR page containing a different kind of description for this package. The MVR description includes a link to the package's source code repository and information that the ID represents the 3rd version of this package.

![Deepbook MVR](./images/deepbook_mvr.png)

While the source code repository for `deepbook/core` contains three different packages, the `pool` module in the PTB is only defined in the `deepbook` package.

Proceed to building a correct version of this package to generate debugging metadata that must accompany the package source code. Assume that all commands are executed in `$ROOT_DIR` unless stated otherwise.

- Clone the repository.

    ```bash
    git clone https://github.com/MystenLabs/deepbookv3.git
    ```

- Go to the `deepbook` package directory.

    ```bash
    cd deepbookv3/packages/deepbook
    ```

- Check the version tags.

    ```bash
    git tag -l
    ```

    In this repository, the tags indeed represent different package versions.

    ```
    v1.0.0
    v2.0.0
    v3.0.0
    ```

    Choose the exact version of the package to build.

    ```bash
    git checkout v3.0.0
    ```

    If tags are not found, you can proceed directly to the next step, but there is no guarantee that the most recent version of source code in the repository corresponds to the version of the package on-chain, which may affect debugging capabilities.

- Build the package and copying the debugging metadata.

    ```bash
    sui move build
    ```

    This creates a `build` directory with a `deepbook` subdirectory in it containing all the relevant metadata, which you now copy to the right directory.


    ```bash
    cp -r ~/deepbookv3/packages/deepbook/build/deepbook ~/.replay/0xb29d83c26cdd2a64959263abbcfc4a6937f0c9fccaf98580ca56faded65be244/source
    ```



#### Precise versions for system packages

If you cannot locate sources for a user package, you can still locate source code and its correct version for system packages that the user package depends on. This allows you to at least view the source of system packages during the debugging session.

System packages in Sui (the Sui framework package in particular), might only change when the protocol version for Sui changes. These changes [are tracked](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework-snapshot/manifest.json) and include information about protocol version numbers (starting with 3) and corresponding git revisions that represent the exact version of the Sui framework package's source code at a given protocol version. This allows you to locate which protocol version was in effect when the user package was published on-chain.

Run the following query against Mainnet's GraphQL [endpoint](https://graphql.mainnet.sui.io/graphql) where the `address` parameter is the ID of the user package (`0xb29d83c26cdd2a64959263abbcfc4a6937f0c9fccaf98580ca56faded65be244` in this example).

```
{
    object(address: "0xb29d83c26cdd2a64959263abbcfc4a6937f0c9fccaf98580ca56faded65be244") {
        previousTransaction {
            effects {
                epoch {
                    protocolConfigs {
                        protocolVersion
                    }
                }
            }
        }
    }
}
```

The result of this query looks as follows.

```
{
    "data": {
        "object": {
            "previousTransaction": {
                "effects": {
                    "epoch": {
                        "protocolConfigs": {
                            "protocolVersion": 84
                        }
                    }
                }
            }
        }
    }
}
```

In this example, the user package was published at protocol version 84. The corresponding git revision from the protocol version tracking file is `25804c243d07dd73c0d199e7794383bd855cd436`. Now, you can follow the debugging metadata generation [instructions](#metadata-generation) for Sui framework code. The only difference is that before building the framework package, you need choose the right git revision.

```bash
git checkout 25804c243d07dd73c0d199e7794383bd855cd436
```

>>>> sui/docs/content/references/ide/move.mdx
---
title: Move Analyzer VS Code Extension
sidebar_label: Move Analyzer
description: The Move extension provides language support features like code navigation, completion, and diagnostics for Move source code.
keywords: [ move analyzer, analyze move, syntax highlighting, move syntax highlight, move syntax, code completion, vs code, analyze in vs code, visual studio code, move extension, vs code extension, move vs code extension, analyzing, analyze interface ]
---

The Move Analyzer extension for Visual Studio Code provides language support features for the Move programming language. It enables syntax highlighting, code completion, and advanced features like definition linking and type checking.

## Install

You can install the Move extension from the Visual Studio Code Marketplace:

1. Open VS Code.
1. Open the **Extensions** view (<kbd>â‡§</kbd> + <kbd>âŒ˜</kbd> + <kbd>X</kbd> on macOS, <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>X</kbd> on Windows/Linux).
1. Search for `mysten.move`.
1. Click **Install** on the Move extension by Mysten Labs.

Alternative install methods include:

  - Use <kbd>Ctrl</kbd> + <kbd>P</kbd> or <kbd>âŒ˜</kbd> + <kbd>P</kbd> and type `ext install mysten.move`.
  - Use the command line: 

      ```sh
      $ code --install-extension mysten.move
      ```

The following extensions are included in the Move extension install:

- [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax)
- [Move Trace Debugger](/references/ide/debugger.mdx)

### Install move-analyzer

The Move extension attempts to install the appropriate `move-analyzer` binary for your platform. If this doesn't work, or you prefer to install it manually, build it with Cargo:

```sh
$ cargo install --git https://github.com/MystenLabs/sui.git sui-move-lsp
```

By default, the Move extension expects to find the `move-analyzer` binary in `~/.sui/bin`. You can either copy the binary to this location, or configure the extension to use a different path. 

## Features

The Move extension supports most Language Server Protocol features, as well as basic commands for building, testing, and tracing Move code.

### Build, test, and trace

The Move extension installs command palette commands for building, testing, and tracing Move code. 

![Move commands in the command palette](./images/commands.png)

These commands find the `Move.toml` file for the open Move source file and open a terminal to run the appropriate `sui move` command.

To execute these commands you must have `sui` binary installed, in particular, to generate a trace, the `sui` binary version must be trace-generation capable. See [Debugger](./debugger.mdx#install) for installation instructions. The extension will search for the `sui` binary on a system path but you can configure the extension to use a different path.

### Syntax highlighting

The [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax) extension provides syntax highlighting.

### Hover information

Hovering over identifiers shows type information, struct fields and attributes, and docstrings (if any) for the identifier. This works for all Move symbols including macros. 

- Hover over structs to see structure and definition.

  ![Struct hoverover](./images/hover_struct.png)

- Hover over functions for details and definition.

  ![Function hoverover](./images/hover_fun.png)

- Hover over macros for their functionality.

  ![Macro hoverover](./images/hover_macros.png)

### Code completion

The Move extension autocompletes upon a dot operator, displaying the available methods and fields for the type.

![Code completion](./images/dot_completion.png)

The Move extension also autocompletes after a `::` operator.

![Type completion](./images/colon_completion.png)

Finally, the Move extension provides _inlay hints_, where the plugin automatically inserts the correct type after a variable declaration, unpack, function parameters, and other places.

![Inlay hints](./images/inlay_hint.png)

### Navigation

The Move extension supports `go-to-definition` navigation for all Move symbols including types, functions, and macros, as long as the type was present when `move-analyzer` last built the file. 

The extension also supports `find-references` for functions, macros, constants, and types.
>>>> sui/docs/content/references/rust-sdk.mdx
---
title: Rust SDK
description: The Sui Rust SDK provides Rust wrappers around the Sui API. Using the SDK, you can interact with Sui networks using the Rust programming language.
keywords: [ rust, rust SDK, sui rust SDK, crates/sui-sdk, sui-sdk ]
---

The Sui Rust SDK crate is in the [**crates\sui-sdk** directory](https://github.com/MystenLabs/sui/tree/main/crates/sui-sdk) of the Sui repository.

<ImportContent source="crates/sui-sdk/README.md" mode="code" style="md" />

>>>> sui/docs/content/references/sui-api.mdx
---
title: Sui RPC
description: SuiJSON is a JSON-based format that enables alignment of JSON inputs with Move call arguments. 
keywords: [SuiJSON, json, json-based, json format, move call arguments, json inputs, move types, expected move types, move type mapping ]
pagination_prev: null
---

:::info

<ImportContent source="json-rpc-deprecation.mdx" mode="snippet" />

:::

:::info

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::

_SuiJSON_ is a JSON-based format with restrictions that allow Sui to align JSON inputs more closely with Move call arguments.

This table shows the restrictions placed on JSON types to make them SuiJSON compatible:

| JSON    | SuiJSON restrictions                         | Move type mapping                                                                        |
| ------- | -------------------------------------------- | ---------------------------------------------------------------------------------------- |
| Number  | Must be unsigned integer                     | u8, u6, u32, u64 (encoded as String), u128 (encoded as String), u256 (encoded as String) |
| String  | No restrictions                              | Vector`<u8>`, Address, ObjectID, TypeTag, Identifier, Unsigned integer (256 bit max)     |
| Boolean | No restrictions                              | Bool                                                                                     |
| Array   | Must be homogeneous JSON and of SuiJSON type | Vector                                                                                   |
| Null    | Not allowed                                  | N/A                                                                                      |
| Object  | Not allowed                                  | N/A                                                                                      |

## Type coercion reasoning {#type-coercion-reasoning}

Due to the loosely typed nature of JSON/SuiJSON and the strongly typed nature of Move types, you sometimes need to overload SuiJSON types to represent multiple Move types.

For example `SuiJSON::Number` can represent both _u8_ and _u32_. This means you have to coerce and sometimes convert types.

Which type you coerce depends on the expected Move type. For example, if the Move function expects a u8, you must have received a `SuiJSON::Number` with a value less than 256. More importantly, you have no way to easily express Move addresses in JSON, so you encode them as hex strings prefixed by `0x`.

Additionally, Move supports u128 and u256 but JSON doesn't. As a result Sui allows encoding numbers as strings.

## Type coercion rules {#type-coercion-rules}

|      Move Type      |                                                                                                                                         SuiJSON Representations                                                                                                                                          |                                                                          Valid Examples                                                                           |                                                                                                             Invalid examples                                                                                                              |
| :-----------------: | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: |
|        Bool         |                                                                                                                                                   Bool                                                                                                                                                   |                                                                            true, false                                                                            |                                                                                                                                                                                                                                           |
|         u8          |                                                                                            Supports 3 formats: Unsigned number < 256. Decimal string with value < 256. One byte hex string prefixed with 0x.                                                                                             |                                                                           7 "70" "0x43"                                                                           |                    -5: negative not allowed 3.9: float not allowed NaN: not allowed 300: U8 must be less than 256 " 9": Spaces not allowed in string "9A": Hex num must be prefixed with 0x "0x09CD": Too large for U8                    |
|         u16         |                                                                                      Three formats are supported Unsigned number < 65536. Decimal string with value < 65536. Two byte hex string prefixed with 0x.                                                                                       |                                                                         712 "570" "0x423"                                                                         |             -5: negative not allowed 3.9: float not allowed NaN: not allowed 98342300: U16 must be less than 65536 " 19": Spaces not allowed in string "9EA": Hex num must be prefixed with 0x "0x049C1D": Too large for U16              |
|         u32         |                                                                                 Three formats are supported Unsigned number < 4294967296. Decimal string with value < 4294967296. One byte hex string prefixed with 0x.                                                                                  |                                                                   9823247 "987120" "0x4BADE93"                                                                    |     -5: negative not allowed 3.9: float not allowed NaN: not allowed 123456789123456: U32 must be less than 4294967296 " 9": Spaces not allowed in string "9A": Hex num must be prefixed with 0x "0x3FF1FF9FFDEFF": Too large for U32     |
|         u64         |                                                                                                   Supports two formats Decimal string with value < U64::MAX. Up to 8 byte hex string prefixed with 0x.                                                                                                   |                                                                    "747944370" "0x2B1A39A15E"                                                                     |                                                                                123434: Although this is a valid U64 number, it must be encoded as a string                                                                                |
|        u128         |                                                                                               Two formats are supported Decimal string with value < U128::MAX. Up to 16 byte hex string prefixed with 0x.                                                                                                |                                                          "74794734937420002470" "0x2B1A39A1514E1D8A7CE"                                                           |                                                                                 34: Although this is a valid U128 number, it must be encoded as a string                                                                                  |
|        u256         |                                                                                               Two formats are supported Decimal string with value < U256::MAX. Up to 32 byte hex string prefixed with 0x.                                                                                                |                                         "747947349374200024707479473493742000247" "0x2B1762FECADA39753FCAB2A1514E1D8A7CE"                                         |                                              123434: Although this is a valid U256 number, it must be encoded as a string 0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de                                              |
|       Address       |                                                                                                                                   32 byte hex string prefixed with 0x                                                                                                                                    |                                               "0xbc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de"                                                |                                0xbc33: string too short bc33e6e4818f9f2ef77d020b35c24be738213e64d9e58839ee7b4222029610de: missing 0x prefix 0xG2B1A39A1514E1D8A7CE45919CFEB4FEE70B4E01: invalid hex char G                                |
|      ObjectID       |                                                                                                                                   32 byte hex string prefixed with 0x                                                                                                                                    |                                               "0x1b879f00b03357c95a908b7fb568712f5be862c5cb0a5894f62d06e9098de6dc"                                                |                                                                                                             Similar to above                                                                                                              |
|     Identifier      | Typically used for module and function names. Encoded as one of the following: A String whose first character is a letter and the remaining characters are letters, digits or underscore. A String whose first character is an underscore, and there is at least one further letter, digit or underscore |                                               "function", "\_function", "some_name", "\_\_\_\_some_name", "Another"                                               |                         "\_": missing trailing underscore, digit or letter, "8name": cannot start with digit, ".function": cannot start with period, " ": cannot be empty space, "func name": cannot have spaces                          |
| Vector`<Move Type>` / Option`<Move Type>` |                                                                                  Homogeneous vector of aforementioned types including nested vectors of primitive types (only "flat" vectors of ObjectIDs are allowed)                                                                                   | [1,2,3,4]: simple U8 vector [[3,600],[],[0,7,4]]: nested U32 vector ["0x2B1A39A1514E1D8A7CE45919CFEB4FEE", "0x2B1A39A1514E1D8A7CE45919CFEB4FEF"]: ObjectID vector | [1,2,3,false]: not homogeneous JSON [1,2,null,4]: invalid elements [1,2,"7"]: although Sui allows encoding numbers as strings meaning this array can evaluate to [1,2,7], the array is still ambiguous so it fails the homogeneity check. |
|    Vector`<u8>`     |                                                                                                            For convenience, Sui allows: U8 vectors represented as UTF-8 (and ASCII) strings.                                                                                                             |                                                      "âˆšÂ®Ë†bo72 âˆšâˆ‚â€ âˆ†Ëšâ€“Å“âˆ‘Ï€2ie": UTF-8 "abcdE738-2 \_=?": ASCII                                                      |                                                                                                                                                                                                                                           |

>>>> sui/docs/content/references/sui-api/rpc-best-practices.mdx
---
title: RPC Best Practices
description: Consider RPC best practices when configuring your RPC settings. 
keywords: [ rpc best practice, rpc provision, rpc guidelines, configure rpc, rpc provisioning, rpc settings ]
---

This topic provides some best practices for configuring your RPC settings to ensure a reliable infrastructure for your projects and services built on Sui.

<ImportContent source="warn-ml-rpcs.mdx" mode="snippet" />

## RPC provisioning guidance

Consider the following when working with a provider:

- **SLA and 24-hour support:** Choose a provider that offers a SLA that meets your needs and 24-hour support.
- **Onboarding call:** Always do an onboarding call with the provider you select to ensure they can provide service that meets your needs. If you have a high-traffic event, such as an NFT mint coming up, notify your RPC provider with the expected traffic increase at least 48 hours in advance.
- **Redundancy:** It is important for high-traffic and time-sensitive apps, like NFT marketplaces and DeFi protocols, to ensure they don't rely on just one provider for RPCs. Many projects default to just using a single provider, but that's extremely risky and you should use other providers to provide redundancy.
- **Traffic estimate:** You should have a good idea about the amount and type of traffic you expect, and you should communicate that information in advance with your RPC provider. During high-traffic events (such as NFT mints), request increased capacity from your RPC provider in advance.
Bot mitigation - As Sui matures, a lot of bots will emerge on the network. Sui dApp builders should think about bot mitigation at the infrastructure level. This depends heavily on use cases. For NFT minting, bots are undesirable. However, for certain DeFi use cases, bots are necessary. Think about the implications and prepare your infrastructure accordingly.
- **Provisioning notice:** Make RPC provisioning requests at least one week in advance. This gives operators and providers advance notice so they can arrange for the configure hardware/servers as necessary. If thereâ€™s a sudden, unexpected demand, please reach out to us so we can help set you up with providers that have capacity for urgent situations.

>>>> sui/docs/content/references/sui-compared.mdx
---
title: Comparison
slug: /sui-compared
description: Learn how Sui's unique architecture compares with other blockchain networks. 
keywords: [ sui compared to other chains, sui compared to other blockchains, sui compared to other networks, how sui compares to other networks, sui architecture, unique features of sui, what makes sui different, sui key features ]
---

This page summarizes how Sui compares with other blockchains and is intended for potential adopters of Sui to decide whether it fits their use cases. See How Sui Works for an introduction to the Sui architecture.

Here are Sui's key features:

- [Causal order vs. total order](#causal-order-vs-total-order) enables massively parallel execution
- Sui's variant of Move and its object-centric data model make composable objects/NFTs possible
- The blockchain-oriented [Move programming language](https://github.com/MystenLabs/awesome-move) eases the developer experience

## Traditional blockchains {#traditional-blockchains}

Traditional blockchain validators collectively build a shared accumulator: a cryptographically binding representation of the state of the blockchain, a chain to which they add increments over time, called blocks. In blockchains that offer deterministic finality, every time validators want to make an incremental addition to the blockchain, i.e., a block proposal, they sequence the proposal. This protocol lets them form an agreement over the current state of the chain, whether the proposed increment is valid, and what the state of the chain will be after the new addition.

This method of maintaining common state over time has known practical success over the last 14 years or so, using a wealth of theory from the last 50 years of research in the field of Byzantine Fault Tolerant distributed systems.

Yet it is inherently sequential: increments to the chain are added one at a time, like pearls on a string. In practice, this approach pauses the influx of transactions (often stored in a mempool), while the current block is under consideration.

## Sui's approach to validating new transactions {#validating}

A large number transactions do not have complex interdependencies with each other, since they operate on disconnected parts of the state. Often financial users just want to send an asset to a recipient, and the only data required to gauge whether this simple transaction is admissible is a fresh view of the sender's address. Hence Sui takes the approach of only taking a lock for the relevant piece of data rather than the whole chain; in this case, the address of the sender, which can only send one transaction at a time.

Sui further expands this approach to more involved transactions that may explicitly depend on multiple elements under their sender's control, using an object model and leveraging Move's strong ownership model. By requiring that dependencies be explicit, Sui applies a multi-lane approach to transaction validation, making sure those independent transaction flows can progress without impediment from the others.

This doesn't mean that Sui as a platform never orders transactions with respect to each other, or that it allows owners to affect only their owned microcosm of objects. Sui also processes transactions that have an effect on some shared state in a rigorous, consensus-ordered manner. See the [State-of-the-art consensus](#state-of-the-art-consensus) section for details on the consensus engine.

## A collaborative approach to transaction submission {#tx-submission}

Sui validates transactions individually, rather than batching them in the traditional blocks. The key advantage of this approach is low latency; each successful transaction quickly obtains a certificate of finality that proves to anyone that the transaction will persists its effects on the Sui network.

But the process of submitting a transaction is a bit more involved. That little more work occurs on the network. (With bandwidth getting cheaper, this is less of a concern.) Whereas a usual blockchain can accept a bunch of transactions from the same author in a fire-and-forget mode, Sui transaction submission follows these steps:

1.  Sender broadcasts a transaction to all Sui validators.
1.  Sui validators send individual votes on this transaction to the sender.
1.  Each vote has a certain weight since each validator has weight based upon the rules of [Proof of Stake](https://en.wikipedia.org/wiki/Proof_of_work).
1.  Sender collects a Byzantine-resistant-majority of these votes into a _certificate_ and broadcasts it to all Sui validators.
1.  The validators execute the transaction and sign the results. When the client receives a Byzantine-resistant-majority of the results _finality_ is reached, ie., assurance the transaction will not be dropped (revoked).
1.  Optionally, the sender assembles the votes to a certificate detailing the effects of the transaction.

While those steps demand more of the sender, performing them efficiently can still yield a cryptographic proof of finality with minimum latency. Aside from crafting the original transaction itself, the session management for a transaction does not require access to any private keys and can be delegated to a third party.

## A different approach to state {#state}

Because Sui focuses on managing specific objects rather than a single aggregate of state, it also reports on them in a unique way:

- Every object in Sui has a unique version number.
- Every new version is created from a transaction that may involve several dependencies, themselves versioned objects.

As a consequence, a Sui Validator can exhibit a causal history of an object, showing its history since genesis. Sui explicitly makes the bet that in many cases, the ordering of that causal history with the causal history of another object is irrelevant; and in the few cases where this information is relevant, Sui makes this relationship explicit in the data.

## Causal order vs. total order {#causal-order-vs-total-order}

Unlike most existing blockchain systems (and as the reader may have guessed from the description of write requests above), Sui does not always impose a total order on the transactions submitted by clients, with shared objects being the exception. Instead, many transactions are _causally_ ordered--if a transaction `T1` produces output objects `O1` that are used as input objects in a transaction `T2`, a validator must execute `T1` before it executes `T2`. Note that `T2` need not use these objects directly for a causal relationship to exist--e.g., `T1` might produce output objects which are then used by `T3`, and `T2` might use `T3`'s output objects. However, transactions with no causal relationship can be processed by Sui validators in any order.

## State-of-the-art consensus {#state-of-the-art-consensus}

[Mysticeti](https://arxiv.org/pdf/2310.14821) represents the latest variant of decades of work on multi-proposer, high-throughput consensus algorithms that reaches throughput more than 400,000 transactions per second on a WAN, with production cryptography and permanent storage.

## Where Sui excels {#where-sui-excels}

This section summarizes the main advantages of Sui with respect to traditional blockchains.

### High performance {#high-performance}

Sui's main selling point is its unprecedented performance. The following bullet points summarize the main performance benefits of Sui with respect to traditional blockchains:

- Sui forgoes consensus for many transactions while other blockchains always totally order them. Causally ordering transactions allows Sui to massively parallelize the execution of many transactions; this reduces latency and allows validators to take advantage of all their CPU cores.
- Sui pushes the complexity at the edges: the client is involved in a number of protocol steps. This minimizes the interactions between validators and keeps their code simpler and more efficient. Sui always gives the possibility to offload most of the client's workload to a Sui Gateway service for better user experience. In contrast, traditional blockchains follow a fire-and-forget model where clients monitor the blockchain state to assess the success of their transaction submission.
- Sui operates at network speed without waiting for system timeouts between protocol steps. This significantly reduces latency when the network is good and not under attack. In contrast, the security of a number of traditional blockchains (including most proof-of-work based blockchains) need to wait for predefined timeouts before committing transactions.
- Sui can take advantage of more machines per validator to increase its performance. Traditional blockchains are often designed to run on a single machine per validator (or even on a single CPU).

### Performance under faults {#performance-under-faults}

Sui runs a leaderless protocol to process simple transactions (i.e. containing only owned objects). As a result, faulty validators do not impact performance in any significant way. For transactions involving shared objects, Sui employs a state-of-the-art consensus protocol requiring no [view-change sub-protocol](https://pmg.csail.mit.edu/papers/osdi99.pdf) and thus experiences only slight performance degradations. In contrast, most leader-based blockchains experiencing even a single validator's crash see their throughput fall and their latency increase (often by more than one order of magnitude).

### Security assumptions {#security-assumptions}

Contrary to many traditional blockchains, Sui does not make strong synchrony assumptions on the network. This means that Sui maintains its security properties under bad network conditions (even excessively bad), network splits/partitions, or even powerful DoS attacks targeted on the validators. Sustained network attacks on synchronous blockchains (i.e., most proof-of-work based blockchains) can lead to double-spend of resources and deadlocks.

### Efficient local read operations {#local-read-operations}

The reading process of Sui enormously differs from other blockchains. Users interested in only a handful of objects and their history perform authenticated reads at a low granularity and low latency. Sui creates a narrow family tree of objects starting from the genesis, allowing it to read only objects tied to the sender of the transaction. Users requiring a global view of the system (e.g., to audit the system) can take advantage of checkpoints to improve performance.

In traditional blockchains, families are ordered with respect to each other to totally order transactions. This then requires querying a massive blob for the precise information needed. Disk I/O can become a performance bottleneck.

### Easier developer experience {#easier-developer-experience}

Sui provides these benefits to developers:

- Move and object-centric data model (enables composable objects/NFTs)
- Asset-centric programming model
- Easier developer experience

## Engineering trade-offs {#engineering-trade-offs}

This section presents the main disadvantages of Sui with respect to traditional blockchains.

### Design complexity {#design-complexity}

While traditional blockchains require implementing only a single consensus protocol, Sui requires two protocols: (i) a protocol based on Byzantine Consistent Broadcast to handle simple transactions, and (ii) a consensus protocol to handle transactions with shared objects. This means the Sui team needs to maintain a much larger codebase.

Transactions involving shared objects require a little overhead (adding two extra round trips - 200ms for well-connected clients using a Sui Gateway service) before submitting it to the consensus protocol. This overhead is required to securely compose the two protocols described above. Other blockchains can instead directly submit the transaction to the consensus protocol. Note the finality for shared object transactions is still in the 2-3 second range even with this overhead.

Building an efficient synchronizer is harder in Sui than in traditional blockchains. The synchronizer sub-protocol allows validators to update each other by sharing data, and it allows slow validators to catch up. Building an efficient synchronizer for traditional blockchains is no easy task, but still simpler than in Sui.

### Sequential writes in the simple case {#sequential-writes}

Traditional blockchains totally order all client transactions with respect to each other. This design requires reaching consensus across validators, which is effective but slow.

As mentioned in previous sections, Sui forgoes consensus for many transactions to reduce their latency. In this manner, Sui enables multi-lane processing and eliminates head-of-line blocking. All other transactions no longer need to wait for the completion of the first transaction's increment in a single lane. Sui provides a lane of the appropriate breadth for each transaction. Simple transactions require viewing only the sender address, which greatly improves the system's capacity.

The downside of allowing head-of-line blocking on the sender for these simple transactions is that the sender can send only one transaction at a time. As a result, it is imperative the transactions finalize quickly.

### Complex total queries {#complex-total-queries}

Sui can make total queries more difficult than in traditional blockchains since it does not always impose total order of transactions. Total queries are fairly rare with respect to local reads (see above) but useful in some scenarios. For example, a new validator joins the network and needs to download the total state to disk, or an auditor wishes to audit the entire blockchain.

Sui mitigates this with checkpoints. A checkpoint is established every time an increment is added to a blockchain resulting from a certified transaction. Checkpoints work much like a [write ahead log](https://en.wikipedia.org/wiki/Write-ahead_logging) that stores state prior to full execution of a program. The calls in that program represent a smart contract in a blockchain. A checkpoint contains not only the transactions but also commitments to the state of the blockchain before and after the transactions.

Sui uses the state commitment that arrives upon epoch change. Sui requires a single answer from the multiple validators and leverages an accessory protocol to derive the hash representing the state of the blockchain. This protocol consumes little bandwidth and does not impede the ingestion of transactions. Validators produce checkpoints at every epoch change. Sui requires the validators to also produce checkpoints even more frequently. So users may use these checkpoints to audit the blockchain with some effort.

## Conclusion {#conclusion}

In summary, Sui provides significant performance and usability enhancements. It introduces an innovative fastpath consensus for simple send transactions and utilizes a state-of-the-art consensus protocol that leads the industry with its low latency and high throughput.
>>>> sui/docs/content/references/sui-framework-reference.mdx
---
title: Sui Framework Reference
slug: /sui-framework-reference
description: The Sui Framework includes the essential libraries necessary for developing Move packages.
keywords: [ sui framework, libraries, on-chain libraries, sui framework reference ]
---

The Sui Framework includes the core on-chain libraries for Move developers. You can view the [Sui Framework Reference docs](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/docs) in Markdown format in the Sui GitHub repo.

>>>> sui/docs/content/references/sui-glossary.mdx
---
title: Glossary
slug: /sui-glossary
description: Learn about terminology specific to Sui.
keywords: [ casual history, casual order, certificate, epoch, equivocation, eventual consistency, finality, gas, genesis, multi-writer objects, objects, proof-of-stake, proof of stake, single-writer objects, sui, SUI token, total order, transaction, transfer, validator ]
pagination_prev: null
---

Find terms used in Sui defined below.

### Archival Service {#archival-service}

A gRPC API layer that exposes access to this store, enabling point lookups of historical data, ex., LedgerService

### Archival Store {#archival-store}

A long-term storage system that holds checkpoint-indexed Sui data, i.e., Bigtable.

### Causal history {#causal-history}

Causal history is the relationship between an object in Sui and its direct predecessors and successors. This history is essential to the causal order Sui uses to process transactions. In contrast, other blockchains read the entire state of their world for each transaction,
introducing latency.

### Causal order {#causal-order}

[Causal order](https://www.scattered-thoughts.net/writing/causal-ordering/) is a representation of the relationship between transactions and the objects they produce, laid out as dependencies. Validators cannot execute a transaction dependent on objects created by a prior transaction that has not finished. Rather than total order, Sui uses causal order (a partial order).

### Certificate {#certificate}

A certificate is the mechanism proving a transaction was approved or certified. Validators vote on transactions, and aggregators collect a Byzantine-resistant majority of these votes into a certificate and broadcast it to all Sui validators, thereby ensuring finality.

### Closed-Loop Token {#closed-loop-token}

A token that can be used only for a specific service, by an authorized account, or a token that certain accounts can be blocked from using.

#### DeepBook {#deepbook}

A decentralized central limit order book (CLOB) built on Sui. The Sui documentation refers to the DeepBook standard as "DeepBookV3" to avoid confusion with the recently deprecated version of DeepBook (DeepBookV2).

#### Devnet {#devnet}

A development network where data is wiped regularly as part of scheduled software updates.
 
### Epoch {#epoch}

Operation of the Sui network is temporally partitioned into non-overlapping, fixed-duration epochs. During a particular epoch, the set of validators participating in the network is fixed.

### Equivocation {#equivocation}

Equivocation in blockchains is the malicious action of dishonest actors giving conflicting information for the same message, such as inconsistent or duplicate voting.

### Eventual consistency {#eventual-consistency}

[Eventual consistency](https://en.wikipedia.org/wiki/Eventual_consistency) is the consensus model employed by Sui; if one honest validator
certifies the transaction, all of the other honest validators will too eventually.

### Finality {#finality}

[Finality](https://medium.com/mechanism-labs/finality-in-blockchain-consensus-d1f83c120a9a) is the assurance a transaction will not be revoked. This stage is considered closure for an exchange or other blockchain transaction.

### Gas {#gas}

[Gas](https://ethereum.org/en/developers/docs/gas/) refers to the computational effort required for executing operations on the Sui network. In Sui, gas is paid with the network's native currency SUI. The cost of executing a transaction in SUI units is referred to as the transaction fee.

### Genesis {#genesis}

Genesis is the initial act of creating accounts and gas objects for a Sui network. Sui provides a `genesis` command that allows users to create and inspect the genesis object setting up the network for operation.

### Localnet {#localnet}

A locally created development network running on your local machine.

### Kiosk {#kiosk}

A decentralized system for commerce applications on Sui. The Sui Kiosk standard consists of Kiosk objects: shared objects owned by individual parties that store assets that can be sold or traded.

### Mainnet {#mainnet}

The Sui production network. 

### Multi-writer objects {#multi-writer-objects}

Multi-writer objects are objects that are owned by more than one address. Transactions affecting multi-writer objects require consensus in Sui. This contrasts with transactions affecting only single-writer objects, which require only a confirmation of the owner's address contents.

### Mysticeti {#mysticeti}

The consensus protocol used on Sui. Mysticeti is a high-throughput, Directed Acyclic Graph (DAG)-based Byzantine consensus protocol. 

### Object {#object}

The basic unit of storage in Sui is an object. In contrast to many other blockchains, where storage is centered around an address and each address contains a key-value store, Sui's storage is centered around objects. Sui objects have one of the following primary states:

- **Immutable:** The object cannot be modified.
- **Mutable:** The object can be modified.

Further, mutable objects are divided into these categories:

- **Owned:** The object can be modified only by its owner.
- **Shared:** The object can be modified by anyone.

Immutable objects do not need this distinction because they have no owner.

#### Operation Cap {#operation-cap}

Allows a validator to authorize another account to perform certain actions on its behalf.

### Proof-of-stake {#proof-of-stake}

[Proof-of-stake](https://en.wikipedia.org/wiki/Proof_of_stake) is a blockchain consensus mechanism where the voting weight of each validator is proportional to a bonded amount of the network's native currency (called their stake in the network). This mitigates [Sybil attacks](https://en.wikipedia.org/wiki/Sybil_attack) by forcing bad actors to gain a large stake in the blockchain first.

### Single-writer objects {#single-writer-objects}

Single-writer objects are owned by one address. In Sui, transactions affecting only single-writer objects owned by the same address may proceed with only a verification of the sender's address, greatly speeding transaction times. These are _simple transactions_. See Single-Writer Apps for example applications of this simple transaction model.

### Smart contract {#smart-contract}

A [smart contract](https://en.wikipedia.org/wiki/Smart_contract) is an agreement based upon the protocol for conducting transactions in a blockchain. In Sui, smart contracts are written in the [Move](https://github.com/MystenLabs/awesome-move) programming language.

### Sui {#sui}

Sui refers to the Sui blockchain, and the [Sui open source project](https://github.com/MystenLabs/sui/) as a whole.

### SUI {#sui-1}

SUI is the native token to the Sui network.

#### Sui Keystore {#sui-keystore}

A secure storage system for managing your Sui cryptographic key pairs.

#### Sui Keytool {#sui-keytool}

A CLI tool that provides commands for managing and generating addresses, and interacting with private keys, signatures, or zkLogin.

#### SuiLink {#suilink}

A Mysten Labs product that connects wallets across chains to support use cases such as cross chain wallet verification, asset ownership verification, and asset distributions across chains.

#### Sui Object Display {#sui-object-display}

A template engine that enables on-chain management of off-chain representation (display) for a type. 

#### Soulbound {#soulbound}

An asset that is bound to an account and cannot be transferred.

#### Testnet {#testnet}

A development network. Data deployed to Testnet persists through the regular update process, but might be wiped when necessary. Testnet data wipes are announced ahead of time.

### Total order {#total-order}

[Total order](https://en.wikipedia.org/wiki/Total_order) refers to the ordered presentation of the history of all transactions processed by a traditional blockchain up to a given time. This is maintained by many blockchain systems, as the only way to process transactions. In contrast, Sui uses a causal (partial) order wherever possible and safe.

### Transaction {#transaction}

A transaction in Sui is a change to the blockchain. This may be a simple transaction affecting only single-writer, single-address objects, such as minting an NFT or transferring an NFT or another token. These transactions may bypass the consensus protocol in Sui.

More complex transactions affecting objects that are shared or owned by multiple addresses, such as asset management and other DeFi use cases, do go through consensus.

### Transfer {#transfer}

A transfer is switching the owner address of a token to a new one via command in Sui. This is accomplished via the Sui CLI client command line interface. It is one of the more common of many commands available in the CLI client.

### Validator {#validator}

A validator in Sui plays a passive role analogous to the more active role of validators and miners in other blockchains. In Sui, validators do not continuously participate in the consensus protocol but are called into action only when receiving a transaction or certificate.

#### Wallet Standard {#wallet-standard}

A cross-chain standard that defines how dApps can automatically discover and interact with wallets.


>>>> sui/docs/content/references/sui-graphql.mdx
---
title: GraphQL for Sui RPC (Beta)
sidebar_label: GraphQL (Beta)
description: GraphQL is a public service for the Sui RPC that enables you to efficiently interact with the Sui network.
beta: devnet, testnet, mainnet
keywords: [ graphql, sui rpc, rpc service, public rpc service, graphql api, api, graphql migration, graphql quick-start, graphql concepts, interact with sui through rpc, use rpc, graphql rpc ]
---

GraphQL for the Sui RPC is a public service that enables interacting with the Sui [network](https://sui.io/networkinfo).

To get started with GraphQL for the Sui RPC, check out the [Getting Started](/guides/developer/advanced/graphql-rpc) guide. If you'd like to learn more about the concepts used in the GraphQL service, check out the [GraphQL](../concepts/graphql-rpc.mdx) for Sui RPC concepts page.

:::info

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::

## GraphQL schemas

:::info

<ImportContent source="data-serving-gql-alpha.mdx" mode="snippet" />

:::

- [Beta](./sui-api/sui-graphql/beta/reference)

- [Alpha](./sui-api/sui-graphql/alpha/reference)



## Key types

All GraphQL API elements are accessible via the left sidebar, the following are good starting points to explore from.

- "Queries" lists all top-level queries for reading the chain state, from reading details about addresses and objects to <UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/operations/queries/simulate-transaction.mdx">dryRunTransactionBlock</UnsafeLink>, which has an execution-like interface but does not modify the chain.
- "Mutations" lists operations that can modify chain state, like <UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/operations/mutations/execute-transaction.mdx">executeTransactionBlock</UnsafeLink>.
- <UnsafeLink href="/references/sui-api/sui-graphql/alpha/reference/types/objects/object">Object</UnsafeLink> is the type representing all on-chain objects (Move values and packages).
- <UnsafeLink href="/references/sui-api/sui-graphql/alpha/reference/types/objects/address">Address</UnsafeLink> corresponds to account addresses (derived from the public keys of signatures that sign transactions) and can be used to query the objects owned by these accounts and the transactions they have signed or been affected by.
<UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/types/objects/owned-or-immutable">Owner</UnsafeLink> represents any entity that can own a <UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/types/objects/move-object">MoveObject</UnsafeLink> to handle cases where it is not known whether the owner is an <UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/types/objects/object">Object</UnsafeLink> or an <UnsafeLink href="/references/sui-api/sui-graphql/beta/reference/types/objects/address">Address</UnsafeLink> (for example, from the perspective of a Move object looking at its owner).

## Related links

<RelatedLink to="/guides/developer/advanced/graphql-rpc.mdx" />
<RelatedLink to="/concepts/graphql-rpc.mdx" />
<RelatedLink to="/concepts/graphql-indexer" />

>>>> sui/docs/content/references/sui-move.mdx
---
title: Move References
description: Learn more about Move.
keywords: [ move, move reference, move book ]
pagination_prev: null
---

<ImportContent source="move-summary.mdx" mode="snippet" />

- [Sui Framework](./framework.mdx): Provides `cargo doc`-generated content for core Sui modules. 
- [The Move Book](https://move-book.com): A definitive guide for learning the Move language on Sui. 
- [The Move Reference](https://move-book.com/reference): Architecture and syntax reference for the Move language.
>>>> sui/docs/content/references/sui-sdks.mdx
---
title: Sui and Community SDKs
description: Collection of SDKs and utilities for developing on Sui using various programming languages.
keywords: [ sui sdks, dApp kit, sui dApp kit, rust SDK, sui rust SDK, rust SDK auto-generated docs, rust SDK docs, zkSend SDK, community sdks, dApp vue, dark SDK, go SDK, kotlin SDK, swift SDK, python SDK ]
pagination_prev: null
---

Sui provides developer kits that act as wrappers for the Sui API. The Sui community broadens the code coverage with its own set of developer kits targeting the Sui blockchain. 

## Sui SDKs

<Cards>
<Card title="dApp Kit" href="https://sdk.mystenlabs.com/dapp-kit">
    A web frontend SDK that interacts with the Sui API. It is available as an NPM package.
</Card>
<Card title="Rust SDK" href="./rust-sdk">
    SDK configuration and examples of using the Sui API with Rust, using the `sui-sdk` crate.
</Card>
<Card title="Rust SDK Auto-generated Docs" href="https://mystenlabs.github.io/sui/sui_sdk/index.html">
    Auto-generated documentation for the `sui-sdk` crate in the Sui repository.
</Card>
<Card title="TypeScript SDK" href="https://sdk.mystenlabs.com/typescript">
    TypeScript SDK for integrating Sui in your TS dApps.
</Card>
<Card title="zkSend SDK" href="https://sdk.mystenlabs.com/zksend">
    zkSend SDK to enable you to incorporate Stashed functionality.
</Card>
</Cards>

## Community SDKs

:::info 

While the community projects are expertly developed, their maintenance and community support vary. You might want to research a project's history and support level before committing to using its utilities. 

:::

<Cards>
<Card title="dApp Kit (Vue)" href="https://github.com/SuiFansCN/suiue">
    Sui dApp Kit for the Vue framework.
</Card>
<Card title="Dart SDK" href="https://github.com/mofalabs/sui">
    A cross-platform Sui SDK for mobile, web, and desktop.
</Card>
<Card title="Go SDK" href="https://github.com/block-vision/sui-go-sdk">
    SDK for developing for Sui using Golang.
</Card>
<Card title="Kotlin SDK" href="https://github.com/mcxross/ksui">
    Ksui is a collection of Kotlin Multiplatform JSON-RPC wrapper and crypto utilities for interacting with a Sui full node.
</Card>
<Card title="Python SDK" href="https://github.com/FrankC01/pysui">
    pysui is a Python client for developing on the Sui blockchain. 
</Card>
<Card title="Swift SDK" href="https://github.com/opendive/suikit">
    SuiKit is a Swift SDK natively designed for developing on the Sui blockchain.
</Card>
</Cards>

>>>> sui/docs/content/snippets/address-prefix.mdx
You can pass literal addresses and objects IDs by prefixing them with '@'. This is needed to distinguish a hexadecimal value from an address in some situations. 

For addresses that are in your local wallet, you can use their alias instead (passing them without '@', for example, --transfer-objects my_alias).

>>>> sui/docs/content/snippets/app-examples-swap-source.mdx
:::info

You can view the [complete source code for this app example](https://github.com/MystenLabs/sui/tree/main/examples/trading) in the Sui repository.

:::
>>>> sui/docs/content/snippets/cli-check-install.mdx
## Check Sui CLI installation

Before you can use the Sui CLI, you must install it. To check if the CLI exists on your system, open a terminal or console and type the following command:

```sh
$ sui --version
```

If the terminal or console responds with a version number, you already have the Sui CLI installed.

If the command is not found, follow the instructions in [Install Sui](/guides/developer/getting-started/sui-install.mdx) to get the Sui CLI on your system.

>>>> sui/docs/content/snippets/coin-standards-migrate.mdx
## Migration from Coin to Currency Standard

Sui provides a migration path from the `CoinMetadata<T>` system while maintaining backward compatibility.

The migration system is designed with specific constraints to maintain data integrity and preserve existing functionality. Migration can only occur permissionlessly when done by reference, meaning the original `CoinMetadata` object remains intact while its data is copied to create a new `Currency` entry in the registry. This approach allows for safe registration of new currency data and updates to existing currency data, but only as long as the `MetadataCap` has not yet been claimed.

The system cannot allow permissionless migration by value, however, where the original `CoinMetadata` object would be consumed or destroyed during migration. This restriction exists because some coins have governance mechanisms that control `CoinMetadata` updates. Allowing value-based migration would irreversibly break those existing governance workflows by destroying the metadata objects that governance systems expect to manage.

The destruction of legacy `CoinMetadata` objects is only permitted after the corresponding `MetadataCap` has been claimed, serving as proof that the currency's owner has taken control through the new registry system. This ensures that legacy metadata cannot be accidentally destroyed while governance systems still depend on it, and provides a clear transition path where owners must explicitly claim control before legacy objects can be cleaned up.

This design preserves backward compatibility while enabling a smooth transition to the centralized registry system, protecting existing governance mechanisms until owners are ready to migrate fully to the new system.

Some of the benefits to migrate to the Coin Registry include:

- **Centralized management:** Single source of truth for all coin information.
- **Enhanced features:** Access to advanced supply models and regulatory tracking.
- **Ecosystem integration:** Better support for wallets, exchanges, and dApps.
- **Future-proofing:** Access to ongoing registry enhancements.

### Migration process

1. **Metadata migration:** Use `migrate_legacy_metadata<T>()` to create a new `Currency<T>` entry based on existing `CoinMetadata<T>` information.
    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="migrate_legacy_metadata" noTitle signatureOnly noComments />

1. **Regulatory migration:** For coins with deny list capabilities, use:
   - `migrate_regulated_state_by_metadata<T>()`: Migrate based on existing metadata.

        <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="migrate_regulated_state_by_metadata" noTitle signatureOnly noComments />

   - `migrate_regulated_state_by_cap<T>()`: Migrate based on deny capability.

        <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="migrate_regulated_state_by_cap" noTitle signatureOnly noComments />

### Migration function mappings

Update smart contract logic that relies on the `coin` module to use the `coin_registry` module instead:

- `coin::create_currency` -> `coin_registry::new_currency_with_otw`
- `coin::create_regulated_currency_v2` -> `coin_registry::new_currency_with_otw`

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="new_currency_with_otw" signatureOnly noComments />

>>>> sui/docs/content/snippets/coin-standards.mdx
### Add address to deny list

Use the `coin::deny_list_v2_add` function to add the provided address to the deny list for your coin. The signature for the function is:

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="deny_list_v2_add" noComments />

When using this function, you provide the `DenyList` object (`0x403`), the `DenyCap` you receive on coin creation, the address to add to the list, and the transaction context. After using this function, the address you provide is unable to use your coin by the next epoch.

### Remove address from deny list

Use the `coin::deny_list_v2_remove` function to remove addresses from the deny list for your coin.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="deny_list_v2_remove" noComments />

When using this function, you provide the `DenyList` object (`0x403`), the `DenyCapV2` you receive on coin creation, the address to remove from the list, and the transaction context. If you try to remove an address that isn't on the list, you receive an `ENotFrozen` error and the function aborts. After calling this function, the address you provide is able to use your coin by the next epoch.

### Using an SDK

You can use either the TypeScript or Rust SDK to manipulate the addresses held in the `DenyList` for your coin. The following examples are based on the [regulated coin sample](https://github.com/MystenLabs/regulated-coin-sample).

<Tabs groupId="sdk-language">

<TabItem label="TypeScript" value="typescript">

```ts
const tx = new Transaction();

tx.moveCall({
    target: `0x2::coin::deny_list_v2_add`,
    arguments: [
        tx.object(<SUI-DENY-LIST-OBJECT-ID>),
        tx.object(<DENY-CAP-ID>),
        tx.pure.address(options.address),
    ],
    typeArguments: [<COIN-TYPE>],
});
```

- `<SUI-DENY-LIST-OBJECT-ID>` is `"0x403"`.
- `<DENY-CAP-ID>` is the object of type `DenyCapV2<REGULATED_COIN>` you receive from publishing the contract.
- `options.address` is the address to ban.
- `<COIN-TYPE>` is `${PACKAGE-ID}::${MODULE-NAME}::${COIN-NAME}`, which is `${PACKAGE-ID}::regulated_coin::REGULATED_COIN` based on the example.

</TabItem>

<TabItem label="Rust" value="rust">

```rust
let mut ptb = ProgrammableTransactionBuilder::new();

let deny_list = ptb.obj(ObjectArg::SharedObject {
    id: deny_list.0,
    initial_shared_version: deny_list.1,
    mutable: true,
})?;
let deny_cap = ptb.obj(ObjectArg::ImmOrOwnedObject(deny_cap))?;
let address = ptb.pure(cmd.address())?;
ptb.command(Command::move_call(
    SUI_FRAMEWORK_PACKAGE_ID,
    Identifier::from(COIN_MODULE_NAME),
    Identifier::from_str("deny_list_v2_add".to_string())?,
    vec![<otw-type>],
    vec![deny_list, deny_cap, address],
));

let builder = ptb.finish();
```

- `deny_list` is of type `(ObjectID, SequenceNumber)`.
  - `ObjectID` is `0x403`.
  - `SequenceNumber` is the `initial_shared_version` of the `DenyList` singleton.
- `deny_cap` is the `ObjectRef` (`(ObjectID, SequenceNumber, ObjectDigest)`) of the `DenyCapV2<REGULATED_COIN>` the publisher has received.
- `otw_type` is the `TypeTag` created from `<PACKAGE_ID>::regulated_coin::REGULATED_COIN` type.
- `cmd.address()` returns the address to ban as a `SuiAddress`.

</TabItem>

</Tabs>

## Globally pausing and unpausing regulated coin activity

Globally pausing coin activity is only applicable to regulated coin types.

### Pause coin activity

To pause activity across the network for a regulated coin type with the `allow_global_pause` field set to `true`, use `coin::deny_list_v2_enable_global_pause`. You must provide the `DenyCapV2` object for the coin type to initiate the pause. Transaction activity is paused immediately, and no addresses can receive the coin in the epoch that follows the call to pause.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="deny_list_v2_enable_global_pause" noComments signatureOnly />

### Unpause coin activity

To restart network activity for a paused regulated coin, use the `coin::deny_list_v2_disable_global_pause` function. As with pausing, you must provide the `DenyCapV2` object for the coin type. Transaction activity resumes immediately, and addresses can begin receiving the coin in the epoch that follows the call to remove the pause.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="deny_list_v2_disable_global_pause" noComments signatureOnly  />
>>>> sui/docs/content/snippets/console-output/sui-client-call-help.mdx

```sh
Call Move function

Usage: sui client call [OPTIONS] --package <PACKAGE> --module <MODULE> --function <FUNCTION>

Options:
      --package <PACKAGE>
          Object ID of the package, which contains the module

      --module <MODULE>
          The name of the module in the package

      --function <FUNCTION>
          Function name in module

      --type-args <TYPE_ARGS>...
          Type arguments to the generic function being called. All must be specified, or the call
          will fail

      --args <ARGS>...
          Simplified ordered args like in the function syntax ObjectIDs, Addresses must be hex
          strings

      --gas <GAS>...
          IDs of gas objects to be used for gas payment. If none are provided, coins are selected
          automatically to cover the gas budget

      --gas-budget <GAS_BUDGET>
          An optional gas budget for this transaction (in MIST). If gas budget is not provided, the
          tool will first perform a dry run to estimate the gas cost, and then it will execute the
          transaction. Please note that this incurs a small cost in performance due to the
          additional dry run call

      --gas-price <GAS_PRICE>
          An optional gas price for this transaction (in MIST). If gas price is not provided, the
          tool will use the current reference gas price from RPC.
          
          Transactions with a gas price lower than the reference will not be signed by enough
          validators to execute. Transactions accessing congested shared objects are prioritized by
          gas price, so setting a higher gas price higher than the reference can ensure the
          transaction accesses the shared object sooner.

      --gas-sponsor <GAS_SPONSOR>
          An optional field to specify a gas sponsor address. If provided, the gas owner is set to
          this address, rather than the transaction's sender.
          
          Note that if the CLI does not have access to the sponsor's keys, it will not be able to
          sign and execute transactions that have a sponsor set.

      --tx-digest
          Compute the transaction digest and print it out, but do not execute the transaction

      --dry-run
          Perform a dry run of the transaction, without executing it

      --dev-inspect
          Perform a dev inspect

      --serialize-unsigned-transaction
          Instead of executing the transaction, serialize the bcs bytes of the unsigned transaction
          data (TransactionData) using base64 encoding, and print out the string <TX_BYTES>. The
          string can be used to execute transaction with `sui client execute-signed-tx --tx-bytes
          <TX_BYTES>`

      --serialize-signed-transaction
          Instead of executing the transaction, serialize the bcs bytes of the signed transaction
          data (SenderSignedData) using base64 encoding, and print out the string <SIGNED_TX_BYTES>.
          The string can be used to execute transaction with `sui client execute-combined-signed-tx
          --signed-tx-bytes <SIGNED_TX_BYTES>`

      --sender <SENDER>
          Set the transaction sender to this address. When not specified, the sender is inferred by
          finding the owner of the gas payment. Note that when setting this field, the transaction
          will fail to execute if the sender's private key is not in the keystore; similarly, it
          will fail when using this with `--serialize-signed-transaction` flag if the private key
          corresponding to this address is not in keystore

      --json
          Return command outputs in json format

  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version
```

>>>> sui/docs/content/snippets/console-output/sui-client-help.mdx

```sh
Client for interacting with the Sui network

Usage: sui client [OPTIONS] [COMMAND]

Commands:
  active-address              Default address used for commands when none specified
  active-env                  Default environment used for commands when none specified
  addresses                   Obtain the Addresses managed by the client
  balance                     List the coin balance of an address
  call                        Call Move function
  chain-identifier            Query the chain identifier from the rpc endpoint
  dynamic-field               Query a dynamic field by its address
  envs                        List all Sui environments
  execute-signed-tx           Execute a Signed Transaction. This is useful when the user prefers
                                  to sign elsewhere and use this command to execute
  execute-combined-signed-tx  Execute a combined serialized SenderSignedData string
  faucet                      Request gas coin from faucet. By default, it will use the active
                                  address and the active network
  gas                         Obtain all gas objects owned by the address. An address' alias can
                                  be used instead of the address
  merge-coin                  Merge two coin objects into one coin
  new-address                 Generate new address and keypair with keypair scheme flag {ed25519
                                  | secp256k1 | secp256r1} with optional derivation path, default to
                                  m/44'/784'/0'/0'/0' for ed25519 or m/54'/784'/0'/0/0 for secp256k1
                                  or m/74'/784'/0'/0/0 for secp256r1. Word length can be { word12 |
                                  word15 | word18 | word21 | word24} default to word12 if not
                                  specified
  new-env                     Add new Sui environment
  object                      Get object info
  objects                     Obtain all objects owned by the address. It also accepts an
                                  address by its alias
  party-transfer              Transfer object to party ownership
  pay                         Pay coins to recipients following specified amounts, with input
                                  coins. Length of recipients must be the same as that of amounts
  pay-all-sui                 Pay all residual SUI coins to the recipient with input coins,
                                  after deducting the gas cost. The input coins also include the
                                  coin for gas payment, so no extra gas coin is required
  pay-sui                     Pay SUI coins to recipients following following specified amounts,
                                  with input coins. Length of recipients must be the same as that of
                                  amounts. The input coins also include the coin for gas payment, so
                                  no extra gas coin is required
  ptb                         Run a PTB from the provided args
  publish                     Publish Move modules
  serialized-tx               Execute, dry-run, dev-inspect or otherwise inspect an already
                                  serialized transaction
  serialized-tx-kind          Execute, dry-run, dev-inspect or otherwise inspect an already
                                  serialized transaction kind
  split-coin                  Split a coin object into multiple coins
  switch                      Switch active address and network(e.g., devnet, local rpc server)
  tx-block                    Get the effects of executing the given transaction block
  transfer                    Transfer object
  transfer-sui                Transfer SUI, and pay gas with the same SUI coin object. If amount
                                  is specified, only the amount is transferred; otherwise the entire
                                  object is transferred
  upgrade                     Upgrade Move modules
  verify-bytecode-meter       Run the bytecode verifier on the package
  verify-source               Verify local Move packages against on-chain packages, and
                                  optionally their dependencies
  remove-address              Remove an existing address by its alias or hexadecimal string
  replay-transaction          Replay a given transaction to view transaction effects. Set
                                  environment variable MOVE_VM_STEP=1 to debug
  replay-batch                Replay transactions listed in a file
  help                        Print this message or the help of the given subcommand(s)

Options:
      --client.config <CONFIG>  Sets the file storing the state of our user accounts (an empty one
                                will be created if missing)
      --client.env <ENV>        The Sui environment to use. This must be present in the current
                                config file
      --json                    Return command outputs in json format
  -y, --yes                     
  -h, --help                    Print help
  -V, --version                 Print version
```

>>>> sui/docs/content/snippets/console-output/sui-client-ptb-help.mdx

```sh
Build, preview, and execute programmable transaction blocks. Depending on your shell, you might have
to use quotes around arrays or other passed values. Use --help to see examples for how to use the
core functionality of this command.

Usage: sui client ptb [OPTIONS]

Options:
      --assign <NAME> <VALUE>
          Assign a value to a variable name to use later in the PTB. 
           If only a name is supplied, the result of the last transaction is bound to that name.
           If a name and value are supplied, then the name is bound to that value. 
          
          Examples: 
           --assign MYVAR 100 
           --assign X [100,5000] 
           --split-coins gas [1000, 5000, 75000] 
           --assign new_coins # bound new_coins to the result of previous transaction

      --dry-run
          Perform a dry run of the PTB instead of executing it.

      --dev-inspect
          Perform a dev-inspect of the PTB instead of executing it.

      --gas-coin <ID>
          The object ID of the gas coin to use. If not specified, it will try to use the first gas
          coin that it finds that has at least the requested gas-budget balance.

      --gas-budget <MIST>
          An optional gas budget for this PTB (in MIST). If gas budget is not provided, the tool
          will first perform a dry run to estimate the gas cost, and then it will execute the
          transaction. Please note that this incurs a small cost in performance due to the
          additional dry run call.

      --gas-price <MIST>
          An optional gas price for this PTB (in MIST). If not specified, the reference gas price is
          fetched from RPC.

      --gas-sponsor <ADDRESS>
          An optional gas sponsor for this PTB. If not specified, the sender is used as the gas
          sponsor.

      --make-move-vec <TYPE> <[VALUES]>
          Given n-values of the same type, it constructs a vector. For non objects or an empty
          vector, the type tag must be specified.
          
          Examples:
           --make-move-vec <u64> []
           --make-move-vec <u64> [1, 2, 3, 4]
           --make-move-vec <std::option::Option<u64>> [none,none]
           --make-move-vec <sui::coin::Coin<sui::sui::SUI>> [gas]

      --merge-coins <INTO_COIN> <[COIN OBJECTS]>
          Merge N coins into the provided coin.
          
          Examples:
           --merge-coins @coin_object_id [@coin_obj_id1, @coin_obj_id2]

      --move-call <PACKAGE::MODULE::FUNCTION> <TYPE_ARGS> <FUNCTION_ARGS>
          Make a move call to a function.
          
          Examples:
           --move-call std::option::is_none <u64> none
           --assign a none
           --move-call std::option::is_none <u64> a

      --split-coins <COIN> <[AMOUNT]>
          Split the coin into N coins as per the given array of amounts.
          
          Examples:
           --split-coins gas [1000, 5000, 75000]
           --assign new_coins # bounds the result of split-coins command to variable new_coins
           --split-coins @coin_object_id [100]

      --transfer-objects <[OBJECTS]> <TO>
          Transfer objects to the specified address.
          
          Examples:
           --transfer-objects [obj1, obj2, obj3] @address
                      
           --split-coins gas [1000, 5000, 75000]
           --assign new_coins # bound new_coins to result of split-coins to use next
           --transfer-objects [new_coins.0, new_coins.1, new_coins.2] @to_address

      --publish <MOVE_PACKAGE_PATH>
          Publish the Move package. It takes as input the folder where the package exists.
          
          Examples:
           --move-call sui::tx_context::sender
           --assign sender
           --publish "."
           --assign upgrade_cap
           --transfer-objects sender "[upgrade_cap]"

      --upgrade <MOVE_PACKAGE_PATH>
          Upgrade the Move package. It takes as input the folder where the package exists.

      --preview
          Instead of executing the transaction, preview its PTB commands.

      --tx-digest
          Instead of executing the transaction, print its digest.

      --sender <SENDER>
          Set the sender to this address instead of the active address.

      --serialize-unsigned-transaction
          Instead of executing the transaction, serialize the bcs bytes of the unsigned transaction
          data using base64 encoding.

      --serialize-signed-transaction
          Instead of executing the transaction, serialize the bcs bytes of the signed transaction
          data using base64 encoding.

      --summary
          Show only a short summary (digest, execution status, gas cost). Do not use this flag when
          you need all the transaction data and the execution effects.

      --warn-shadows
          Enable shadow warning when the same variable name is declared multiple times. Off by
          default.

      --json
          Return command outputs in json format.

  -h, --help
          Print help (see a summary with '-h')
```

>>>> sui/docs/content/snippets/console-output/sui-keytool-help.mdx

```sh
Sui keystore tool

Usage: sui keytool [OPTIONS] <COMMAND>

Commands:
  update-alias
          Update an old alias to a new one. If a new alias is not provided, a random one will be
          generated
  convert
          Convert private key in Hex or Base64 to new format (Bech32 encoded 33 byte flag || private
          key starting with "suiprivkey"). Hex private key format import and export are both
          deprecated in Sui Wallet and Sui CLI Keystore. Use `sui keytool import` if you wish to
          import a key to Sui Keystore
  decode-or-verify-tx
          Given a Base64 encoded transaction bytes, decode its components. If a signature is
          provided, verify the signature against the transaction and output the result
  decode-multi-sig
          Given a Base64 encoded MultiSig signature, decode its components. If tx_bytes is passed
          in, verify the multisig
  generate
          Generate a new keypair with key scheme flag {ed25519 | secp256k1 | secp256r1} with
          optional derivation path, default to m/44'/784'/0'/0'/0' for ed25519 or m/54'/784'/0'/0/0
          for secp256k1 or m/74'/784'/0'/0/0 for secp256r1. Word length can be { word12 | word15 |
          word18 | word21 | word24} default to word12 if not specified
  import
          Add a new key to Sui CLI Keystore using either the input mnemonic phrase or a Bech32
          encoded 33-byte `flag || privkey` starting with "suiprivkey", the key scheme flag {ed25519
          | secp256k1 | secp256r1} and an optional derivation path, default to m/44'/784'/0'/0'/0'
          for ed25519 or m/54'/784'/0'/0/0 for secp256k1 or m/74'/784'/0'/0/0 for secp256r1.
          Supports mnemonic phrase of word length 12, 15, 18, 21, 24. Set an alias for the key with
          the --alias flag. If no alias is provided, the tool will automatically generate one
  export
          Output the private key of the given key identity in Sui CLI Keystore as Bech32 encoded
          string starting with `suiprivkey`
  list
          List all keys by its Sui address, Base64 encoded public key, key scheme name in
          sui.keystore
  load-keypair
          This reads the content at the provided file path. The accepted format can be [enum
          SuiKeyPair] (Base64 encoded of 33-byte `flag || privkey`) or `type AuthorityKeyPair`
          (Base64 encoded `privkey`). This prints out the account keypair as Base64 encoded `flag ||
          privkey`, the network keypair, worker keypair, protocol keypair as Base64 encoded
          `privkey`
  multi-sig-address
          To MultiSig Sui Address. Pass in a list of all public keys `flag || pk` in Base64. See
          `keytool list` for example public keys
  multi-sig-combine-partial-sig
          Provides a list of participating signatures (`flag || sig || pk` encoded in Base64),
          threshold, a list of all public keys and a list of their weights that define the MultiSig
          address. Returns a valid MultiSig signature and its sender address. The result can be used
          as signature field for `sui client execute-signed-tx`. The sum of weights of all
          signatures must be >= the threshold
  multi-sig-combine-partial-sig-legacy
          
  show
          Read the content at the provided file path. The accepted format can be [enum SuiKeyPair]
          (Base64 encoded of 33-byte `flag || privkey`) or `type AuthorityKeyPair` (Base64 encoded
          `privkey`). It prints its Base64 encoded public key and the key scheme flag
  sign
          Create signature using the private key for the given address (or its alias) in sui
          keystore. Any signature commits to a [struct IntentMessage] consisting of the Base64
          encoded of the BCS serialized transaction bytes itself and its intent. If intent is
          absent, default will be used
  sign-kms
          Creates a signature by leveraging AWS KMS. Pass in a key-id to leverage Amazon KMS to sign
          a message and the base64 pubkey. Generate PubKey from pem using MystenLabs/base64pemkey
          Any signature commits to a [struct IntentMessage] consisting of the Base64 encoded of the
          BCS serialized transaction bytes itself and its intent. If intent is absent, default will
          be used
  unpack
          This takes [enum SuiKeyPair] of Base64 encoded of 33-byte `flag || privkey`). It outputs
          the keypair into a file at the current directory where the address is the filename, and
          prints out its Sui address, Base64 encoded public key, the key scheme, and the key scheme
          flag
  zk-login-sign-and-execute-tx
          Given the max_epoch, generate an OAuth url, ask user to paste the redirect with id_token,
          call salt server, then call the prover server, create a test transaction, use the
          ephemeral key to sign and execute it by assembling to a serialized zkLogin signature
  zk-login-enter-token
          A workaround to the above command because sometimes token pasting does not work (for
          Facebook). All the inputs required here are printed from the command above
  zk-login-sig-verify
          Given a zkLogin signature, parse it if valid. If `bytes` provided, parse it as either as
          TransactionData or PersonalMessage based on `intent_scope`. It verifies the zkLogin
          signature based its latest JWK fetched. Example request: sui keytool zk-login-sig-verify
          --sig $SERIALIZED_ZKLOGIN_SIG --bytes $BYTES --intent-scope 0 --network devnet
          --curr-epoch 10
  zk-login-insecure-sign-personal-message
          TESTING ONLY: Generate a fixed ephemeral key and its JWT token with test issuer. Produce a
          zklogin signature for the given data and max epoch. e.g. sui keytool
          zk-login-insecure-sign-personal-message --data "hello" --max-epoch 5
  help
          Print this message or the help of the given subcommand(s)

Options:
      --keystore-path <KEYSTORE_PATH>  
      --json                           Return command outputs in json format
  -h, --help                           Print help
  -V, --version                        Print version
```

>>>> sui/docs/content/snippets/console-output/sui-keytool-sign-help.mdx

```sh
Create signature using the private key for the given address (or its alias) in sui keystore. Any
signature commits to a [struct IntentMessage] consisting of the Base64 encoded of the BCS serialized
transaction bytes itself and its intent. If intent is absent, default will be used

Usage: sui keytool sign [OPTIONS] --address <ADDRESS> --data <DATA>

Options:
      --address <ADDRESS>  
      --data <DATA>        
      --json               Return command outputs in json format
      --intent <INTENT>    
  -h, --help               Print help
  -V, --version            Print version
```

>>>> sui/docs/content/snippets/console-output/sui-move-build-help.mdx

```sh
Usage: sui move build [OPTIONS]

Options:
  -p, --path <PACKAGE_PATH>
          Path to a package which the command should be run with respect to
      --with-unpublished-dependencies
          Include the contents of packages in dependencies that haven't been published (only
          relevant when dumping bytecode as base64)
      --dump-bytecode-as-base64
          Whether we are printing in base64
      --ignore-chain
          [Mainly for testing, not recommended for production] Don't specialize the package to the
          active chain when dumping bytecode as Base64. This allows building to proceed without a
          network connection or active environment, but it will not be able to automatically
          determine the addresses of its dependencies
  -d, --dev
          Compile in 'dev' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used if
          this flag is set. This flag is useful for development of packages that expose named
          addresses that are not set to a specific value
      --generate-struct-layouts
          If true, generate struct layout schemas for all struct types passed into `entry` functions
          declared by modules in this package These layout schemas can be consumed by clients (e.g.,
          the TypeScript SDK) to enable serialization/deserialization of transaction arguments and
          events
      --test
          Compile in 'test' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used
          along with any code in the 'tests' directory
      --doc
          Generate documentation for packages
      --disassemble
          Save disassembly for generated bytecode along with bytecode maps (source maps for
          disassembled bytecode)
      --install-dir <INSTALL_DIR>
          Installation directory for compiled artifacts. Defaults to current directory
      --force
          Force recompilation of all packages
      --fetch-deps-only
          Only fetch dependency repos to MOVE_HOME
      --skip-fetch-latest-git-deps
          Skip fetching latest git dependencies
      --default-move-flavor <DEFAULT_FLAVOR>
          Default flavor for move compilation, if not specified in the package's config
      --default-move-edition <DEFAULT_EDITION>
          Default edition for move compilation, if not specified in the package's config
      --dependencies-are-root
          If set, dependency packages are treated as root packages. Notably, this will remove
          warning suppression in dependency packages
      --silence-warnings
          If set, ignore any compiler warnings
      --warnings-are-errors
          If set, warnings become errors
      --json-errors
          If set, reports errors at JSON
      --no-lint
          If `true`, disable linters
      --lint
          If `true`, enables extra linters
      --mode <MODE>
          Arbitrary mode -- this will be used to enable or filter user-defined `#[mode(<MODE>)]`
          annotations during compilation
  -h, --help
          Print help
  -V, --version
          Print version
```

>>>> sui/docs/content/snippets/console-output/sui-move-help.mdx

```sh
Tool to build and test Move applications

Usage: sui move [OPTIONS] <COMMAND>

Commands:
  build
  coverage        Inspect test coverage for this package. A previous test run with the
                      `--coverage` flag must have previously been run
  disassemble
  manage-package  Record addresses (Object IDs) for where this package is published on chain
                      (this command sets variables in Move.lock)
  migrate         Migrate to Move 2024 for the package at `path`. If no path is provided
                      defaults to current directory
  new             Create a new Move package with name `name` at `path`. If `path` is not
                      provided the package will be created in the directory `name`
  test            Run Move unit tests in this package
  summary         Generate a serialized summary of a Move package (e.g., functions, structs,
                      annotations, etc.)
  help            Print this message or the help of the given subcommand(s)

Options:
  -p, --path <PACKAGE_PATH>
          Path to a package which the command should be run with respect to
      --client.config <CONFIG>
          Sets the file storing the state of our user accounts (an empty one will be created if
          missing)
      --client.env <ENV>
          The Sui environment to use. This must be present in the current config file
  -d, --dev
          Compile in 'dev' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used if
          this flag is set. This flag is useful for development of packages that expose named
          addresses that are not set to a specific value
      --test
          Compile in 'test' mode. The 'dev-addresses' and 'dev-dependencies' fields will be used
          along with any code in the 'tests' directory
      --doc
          Generate documentation for packages
      --disassemble
          Save disassembly for generated bytecode along with bytecode maps (source maps for
          disassembled bytecode)
      --install-dir <INSTALL_DIR>
          Installation directory for compiled artifacts. Defaults to current directory
      --force
          Force recompilation of all packages
      --fetch-deps-only
          Only fetch dependency repos to MOVE_HOME
      --skip-fetch-latest-git-deps
          Skip fetching latest git dependencies
      --default-move-flavor <DEFAULT_FLAVOR>
          Default flavor for move compilation, if not specified in the package's config
      --default-move-edition <DEFAULT_EDITION>
          Default edition for move compilation, if not specified in the package's config
      --dependencies-are-root
          If set, dependency packages are treated as root packages. Notably, this will remove
          warning suppression in dependency packages
      --silence-warnings
          If set, ignore any compiler warnings
      --warnings-are-errors
          If set, warnings become errors
      --json-errors
          If set, reports errors at JSON
      --no-lint
          If `true`, disable linters
      --lint
          If `true`, enables extra linters
      --mode <MODE>
          Arbitrary mode -- this will be used to enable or filter user-defined `#[mode(<MODE>)]`
          annotations during compilation
  -h, --help
          Print help
  -V, --version
          Print version
```

>>>> sui/docs/content/snippets/console-output/sui-replay-help.mdx

```sh
[error] Command failed: sui replay --help
Command failed: sui replay --help
error: unrecognized subcommand 'replay'

Usage: sui <COMMAND>

For more information, try '--help'.

```

>>>> sui/docs/content/snippets/console-output/sui-validator-help.mdx

```sh
A tool for validators and validator candidates

Usage: sui validator [OPTIONS] [COMMAND]

Commands:
  make-validator-info               
  become-candidate                  
  join-committee                    
  leave-committee                   
  display-metadata                  
  update-metadata                   
  update-gas-price                  Update gas price that is used to calculate Reference Gas
                                        Price
  report-validator                  Report or un-report a validator
  serialize-payload-pop             Serialize the payload that is used to generate Proof of
                                        Possession. This is useful to take the payload offline for
                                        an Authority protocol keypair to sign
  display-gas-price-update-raw-txn  Print out the serialized data of a transaction that sets the
                                        gas price quote for a validator
  register-bridge-committee         Sui native bridge committee member registration
  update-bridge-committee-node-url  Update sui native bridge committee node url
  help                              Print this message or the help of the given subcommand(s)

Options:
      --client.config <CONFIG>  Sets the file storing the state of our user accounts (an empty one
                                will be created if missing)
      --json                    Return command outputs in json format
  -y, --yes                     
  -h, --help                    Print help
  -V, --version                 Print version
```

>>>> sui/docs/content/snippets/console-output/sui-validator-report-validator-help.mdx

```sh
Report or un-report a validator

Usage: sui validator report-validator [OPTIONS] <reportee-address>

Arguments:
  <reportee-address>  The Sui Address of the validator is being reported or un-reported

Options:
      --operation-cap-id <operation-cap-id>
          Optional when sender is reporter validator itself and it holds the Cap object. Required
          when sender is not the reporter validator itself. Validator's OperationCap ID can be found
          by using the `display-metadata` subcommand
      --undo-report <undo-report>
          If true, undo an existing report [possible values: true, false]
      --gas-budget <gas-budget>
          Gas budget for this transaction
      --json
          Return command outputs in json format
  -h, --help
          Print help
  -V, --version
          Print version
```

>>>> sui/docs/content/snippets/contact-nautilus.mdx
For questions about Nautilus, use case discussions, or integration support, contact the Nautilus team on [Sui Discord](https://discord.com/channels/916379725201563759/1361500579603546223).
>>>> sui/docs/content/snippets/crypto-schemes.mdx
The options are:

- `ed25519`: Small key size and compact signatures. 

- `secp256k1`: Provides security through generating and verifying keys using ECDSA. 

- `secp256r1`: Uses randomly generated curves to generate keys.


The client will return your new address and 12-word recovery phrase:

```
Generated new key pair for address with scheme "ed25519" [0xb9c83a8b40d3263c9ba40d551514fbac1f8c12e98a4005a0dac072d3549c2442]
Secret Recovery Phrase : [cap wheat many line human lazy few solid bored proud speed grocery]
```
>>>> sui/docs/content/snippets/data-serving-gql-alpha.mdx
The GraphQL RPC release stage is currently in beta. Refer to the high-level timeline for releases in [Access Sui Data](/guides/developer/sui-101/data-serving.mdx).
>>>> sui/docs/content/snippets/data-serving-msg.mdx
Refer to [Access Sui Data](/guides/developer/sui-101/data-serving.mdx) for an overview of options to access Sui network data.
>>>> sui/docs/content/snippets/data-wipe.mdx
:::info 

Testnet and Devnet data persistence is not guaranteed. 

Devnet data is wiped regularly as part of [weekly scheduled software updates](https://sui.io/networkinfo).

Testnet data persists through the regular update process, but might be wiped occasionally. Testnet data wipes are [announced ahead of time](https://discord.com/channels/916379725201563759/1095151359642304612).

For more information about the release schedule of Sui networks, see [Sui Network Release](https://sui.io/networkinfo/).

:::

>>>> sui/docs/content/snippets/deepbook-v2-dep.mdx
:::warning 

DeepBook V2 is now deprecated. Update your integrations to use <a href="/standards/deepbook">DeepBook V3</a> instead.

:::
>>>> sui/docs/content/snippets/faucet-online.mdx
https://faucet.sui.io/: Visit the online faucet to request SUI tokens. You can refresh your browser to perform multiple requests, but the requests are rate-limited per IP address.

>>>> sui/docs/content/snippets/indexer-graphql.mdx
The GraphQL and `sui-indexer-alt` (Indexer) stack are part of the [Sui data access infrastructure](../guides/developer/sui-101/data-serving.mdx). The stack provides access to on-chain data through a high-performance GraphQL service backed by a scalable and general-purpose indexer. This stack is optimized for developers who need flexible queries, structured output, and historical access to data (with configurable retention) across the Sui network.

GraphQL is ideal for applications that require rich query patterns over structured data, such as fetching owned objects, transaction history, specific onchain attributes, and more. The GraphQL service runs on top of a Postgres-compatible database that is updated by different Indexer pipelines in parallel.

The General-purpose Indexer includes configurable checkpoint-based pipelines that extract data from the Sui remote checkpoint store and full nodes. The pipelines write processed data to a database optimized for GraphQL query access.

Together, the GraphQL service and Indexer offer a modular and production-ready data stack for builders, wallet developers, explorers, and indexer/data providers.

:::info

<ImportContent source="json-rpc-deprecation.mdx" mode="snippet" />

:::

:::info

<ImportContent source="data-serving-msg.mdx" mode="snippet" />

:::
>>>> sui/docs/content/snippets/indexer-pipeline-processor.mdx
The `Processor` is the concurrent processing engine, handling multiple tasks running at the same time for maximum throughput. Its primary responsibility is to convert raw checkpoint data into database-ready rows using parallel workers.

The component handles this task by spawning `FANOUT` worker tasks (default: 10) for parallel processing. The `FANOUT` is the key configuration as it controls parallel processing capacity.

<ImportContent source="crates/sui-indexer-alt-framework/src/pipeline/processor.rs" mode="code" variable="FANOUT" />

Each worker calls your `Handler::process()` method independently. 

<ImportContent source="crates/sui-indexer-alt-framework/src/pipeline/processor.rs" mode="code" variable="values" />

Each of these workers can process different checkpoints simultaneously and in any order. The workers send their processed data to the `Collector` with checkpoint metadata.

>>>> sui/docs/content/snippets/info-easy-install.mdx
:::tip

These instructions are for special use cases. For most users, [Quick Install](/guides/developer/getting-started/sui-install.mdx) shows the best way to install Sui.

:::
>>>> sui/docs/content/snippets/info-gas-budget.mdx
:::tip

Beginning with the Sui `v1.24.1` [release](https://github.com/MystenLabs/sui/releases/tag/mainnet-v1.24.1), the `--gas-budget` option is no longer required for CLI commands.

:::
>>>> sui/docs/content/snippets/info-pnpm-required.mdx
:::info

You must use the pnpm or yarn package managers to create Sui project scaffolds. Follow the [pnpm install](https://pnpm.io/installation) or [yarn install](https://classic.yarnpkg.com/lang/en/docs/install/#mac-stable) instructions, if needed.

:::
>>>> sui/docs/content/snippets/initialize-sui-client-cli.mdx
:::info 

See ["Hello, World!"](/guides/developer/getting-started/hello-world.mdx) for a more detailed guide on publishing packages or [Sui Client CLI](/references/cli/client.mdx) for a complete reference of `client` commands in the Sui CLI.

:::

Before publishing your code, you must first initialize the Sui Client CLI, if you haven't already. To do so, in a terminal or console at the root directory of the project enter `sui client`. If you receive the following response, complete the remaining instructions:

```
Config file ["<FILE-PATH>/.sui/sui_config/client.yaml"] doesn't exist, do you want to connect to a Sui full node server [y/N]?
```

Enter `y` to proceed. You receive the following response:

```
Sui full node server URL (Defaults to Sui Testnet if not specified) :
```

Leave this blank (press Enter). You receive the following response:

```
Select key scheme to generate key pair (0 for ed25519, 1 for secp256k1, 2: for secp256r1):
```

Select `0`. Now you should have a Sui address set up.


>>>> sui/docs/content/snippets/install-prereqs.mdx
<Tabs>
<TabItem label="macOS" value="macos">

Most modern MacOS systems have Homebrew and cURL preinstalled.

- [x] Download and install [Homebrew](https://brew.sh/): 
  <div className="pl-8">
    ```sh
    $ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    ```
  </div>

- [x] Download and install CMake:
  <div className="pl-8">
    ```sh
    $ brew install cmake
    ``` 
    Verify installation with 
    ```sh
    $ cmake --version
    ```
  </div>

- [x] Download and install **libpq**:
  <div className="pl-8">
    ```sh
    $ brew install libpq
    ```
    Verify installation with
    ```sh
    $ libpq --version
    ```
  </div>

- [x] Download and install [PostgreSQL](https://wiki.postgresql.org/wiki/Main_Page).

</TabItem>

<TabItem label="Linux" value="linux">

These prerequisites use the `apt` package manager for Linux. Adjust the commands accordingly per your package manager.

:::tip
You can install all of the prerequisites for Linux at once using the following command:

<ImportContent source="linux-deps.mdx" mode="snippet" />
:::

- [x] Download and install Rust:
  <div className="pl-8">
    ```sh
    $ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
    ```
    If you have Rust installed, update to the latest version: 
    ```sh
    $ rustup update stable
    ```
  </div>

- [x] Download and install Cargo
  <div className="pl-8">
    ```sh
    $ curl https://sh.rustup.rs -sSf | sh
    ```
  </div>
- [x] Download and install cURL:
  <div className="pl-8">
    ```sh
    $ sudo apt-get install curl
    ```
    Verify installation with 
    ```sh
    $ curl --version
    ```
  </div>
- [x] Download and install Git CLI:
  <div className="pl-8">
    ```sh
    $ sudo apt-get install git-all
    ```
    Verify installation with 
    ```sh
    $ git --version
    ```
  </div>
- [x] Download and install CMake:
  <div className="pl-8">
    ```sh
    $ sudo apt-get install cmake
    ```
    
    Verify installation with

    ```sh
    $ cmake --version
    ```
  </div>
- [x] Download and install GCC:

  <div className="pl-8">
    ```sh
    $ sudo apt-get install gcc
    ```
    Verify installation with 
    ```sh
    $ gcc --version
    ```
  </div>

- [x] Download and install **libssl-dev**:

  <div className="pl-8">
    ```sh
    $ sudo apt-get install libssl-dev
    ```
    If the version of Linux you use doesn't support **libssl-dev**, find an equivalent package for it on the [ROS Index](https://index.ros.org/d/libssl-dev/).

    If you have OpenSSL you might also need to also install **pkg-config**:
    ```sh
    $ sudo apt-get install pkg-config
    ```
  </div>

- [x] Download and install **libclang-dev**:
  <div className="pl-8">

    ```sh
    $ sudo apt-get install libclang-dev
    ```

    If the version of Linux you use doesn't support **libclang-dev**, find an equivalent package for it on the [ROS Index](https://index.ros.org/d/libclang-dev/).

  </div>

- [x] If you plan to use the `--with-indexer` and `--with-graphql` options with `sui start`, download and install **libpq-dev**:
  <div className="pl-8">

    ```sh
    $ sudo apt-get install libpq-dev
    ```

    See [Local Network](/guides/developer/sui-101/local-network) for more information.

    If the version of Linux you use doesn't support **libpq-dev**, find an equivalent package for it on the [ROS Index](https://index.ros.org/d/libpq-dev/).

  </div>

- [x] Download and install **build-essential**: 
  <div className="pl-8">
    ```sh
    $ sudo apt-get install build-essential
    ```
  </div>

</TabItem>

<TabItem label="Windows" value="windows">

- [x] Download and install [C++ build tools](https://visualstudio.microsoft.com/downloads/) before downloading Rust.

- [x] Download and install Rust. 
  <div className="pl-8">
  If you use Windows 11, see information about using the [Rust installer](https://www.rust-lang.org/tools/install) on the Rust website. The installer checks for C++ build tools and prompts you to install them if necessary. Select the option that best defines your environment and follow the instructions in the install wizard.

  If you have Rust installed, update to the latest version: 
  ```sh
  $ rustup update stable
  ```
  </div>

- [x] Download and install Cargo: Download and install [`rustup-init.exe`](https://win.rustup.rs/)

- [x] Windows 11 ships with a Microsoft version of [cURL](https://curl.se/windows/microsoft.html) already installed; however, if you are using Windows 10 or want to use the cURL project version instead, download and install it from [https://curl.se/windows/](https://curl.se/windows/).

- [x] Download and install the [Git command line interface](https://git-scm.com/download/).

- [x] Download and install [CMake](https://cmake.org/download/).

- [x] Download [Protocol Buffers](https://github.com/protocolbuffers/protobuf/releases) (`protoc-xx.x-win32.zip` or `protoc-xx.x-win64.zip`) and add the `\bin` directory to your Windows `PATH` environment variable.

- [x] For Windows on ARM64 only: Download and install [Visual Studio 2022 Preview](https://visualstudio.microsoft.com/vs/preview/).

- [x] Download and install the [LLVM Compiler Infrastructure](https://releases.llvm.org/). Look for a file with a name similar to `LLVM-15.0.7-win64.exe` for 64-bit Windows, or `LLVM-15.0.7-win32.exe` for 32-bit Windows.

</TabItem>
</Tabs>
>>>> sui/docs/content/snippets/install-sui-node.mdx
:::info

The [`sui-node` binary from AWS](#aws-sui-node) only supports Ubuntu version 22.04.

:::


The `sui-node` binaries for Ubuntu 22.04 are available for download from AWS. You can use either the commit SHA or version tag in the URL to retrieve the specific version of Sui you want. Use one of these values to construct the AWS download URL.

The URL is in the form:

```
https://sui-releases.s3-accelerate.amazonaws.com/<SHA-OR-TAG>/sui-node
```

Replace `<SHA-OR-TAG>` with the proper value. For example, the URL is `https://sui-releases.s3-accelerate.amazonaws.com/00544a588bb71c395d49d91f756e8bfe96067eca/sui-node` to download the release with the relevant commit SHA. If you visit the URL using a browser, the binary downloads automatically.

After downloading, open a console to the file's location and change its permission to `755`.

```sh
$ chmod 755 sui-node
```

Add the file's location to your `$PATH` variable if its directory is not already included. Follow the steps in [Configure a Sui full node](/guides/operator/sui-full-node.mdx) to complete the setup.
>>>> sui/docs/content/snippets/json-rpc-deprecation.mdx
**JSON-RPC is deprecated**. Migrate to either [gRPC](/concepts/grpc-overview.mdx) or [GraphQL RPC](/concepts/graphql-indexer.mdx) by April 2026.

Refer to the [list of RPC or data providers](https://www.notion.so/mystenlabs/RPC-providers-offering-future-Sui-data-primitives-2466d9dcb4e980a99a36e9aafd8c17e0?source=copy_link) that have enabled gRPC on their full nodes or offer GraphQL RPC. Contact a provider directly to request access. If your RPC or data provider doesnâ€™t yet support these data access methods, ask them to enable support or contact the Sui Foundation team on Discord, Telegram, or Slack for help.

>>>> sui/docs/content/snippets/libpq-req.mdx
:::info

You need `libpq-dev` only if you plan to use the `--with-indexer` and `--with-graphql` options with `sui start`. See [Local Network](/guides/developer/sui-101/local-network.mdx#start-the-local-network) for more information.

:::
>>>> sui/docs/content/snippets/linux-deps.mdx
```sh
$ sudo apt-get install curl git-all cmake gcc libssl-dev pkg-config libclang-dev libpq-dev build-essential
```

>>>> sui/docs/content/snippets/lists/binaries-file-list.mdx
    | Name | Description |
    | --- | --- |
    | `move-analyzer` | Language Server Protocol implementation. | 
    | `sui` | Main Sui binary. |
    | `sui-bridge` | Sui native bridge. |
    | `sui-data-ingestion` | Capture full node data for indexer to store in a database. |
    | `sui-faucet` | Local faucet to mint coins on local network. |
    | `sui-graphql-rpc` | GraphQL service for Sui RPC. |
    | `sui-node` | Run a local node. |
    | `sui-test-validator` | Run test validators on a local network for development. |
    | `sui-tool` | Provides utilities for Sui. |

>>>> sui/docs/content/snippets/lists/sui-explorers.mdx

- [Polymedia Explorer](https://github.com/juzybits/polymedia-explorer): Community fork of the discontinued Sui Explorer from Mysten Labs that you can build locally or use online at https://explorer.polymedia.app/.
- [Sui Explorer](https://github.com/suiware/sui-explorer): Community fork of the discontinued Sui Explorer from Mysten Labs that you can build locally. 
- [suiscan](https://suiscan.xyz/): Popular Sui network scanner available online.
- [SuiVision](https://suivision.xyz/): Popular Sui network scanner available online.
>>>> sui/docs/content/snippets/macos-deps.mdx
```sh
$ brew install curl cmake libpq git
```

>>>> sui/docs/content/snippets/migrate-to-graphql.mdx
This guide compares JSON-RPC queries to their equivalent GraphQL counterpart. While it is possible to systematically rewrite JSON-RPC queries (for example, <code>sui_getTotalTransactionBlocks</code>) to their GraphQL counterparts using this guide, it is recommended that you revisit your application's query patterns to take full advantage of the flexibility that GraphQL offers in serving queries that touch multiple potentially nested endpoints (for example transactions, balances, coins), and use the following examples to get a flavor of how the two APIs express similar concepts.
>>>> sui/docs/content/snippets/move-summary.mdx
Move is an open source language for writing safe packages to manipulate on-chain objects (sometimes referred to as _smart contracts_). Move is a platform-agnostic language to enable common libraries, tooling, and developer communities across blockchains with vastly different data and execution models. Move is adaptable to meet the needs of the blockchain the code operates on, see [Move on Sui](concepts/sui-move-concepts.mdx#differences) to review enhancements made to Move for optimization on the Sui blockchain.

>>>> sui/docs/content/snippets/openid-providers.mdx
The following table lists the OpenID providers that can support zkLogin or are currently being reviewed to determine whether they can support zkLogin.

| Provider     | Can support? | Devnet   | Testnet  | Mainnet  |
| ------------ | ----------   | -------- | -------- | -------- |
| Facebook     | Yes          |	  Yes    |  Yes     | Yes      |
| Google       | Yes          |   Yes    |  Yes     | Yes      |
| Twitch       | Yes          |   Yes    |  Yes     | Yes      |
| Apple        | Yes          |   Yes    |  Yes     | Yes      |
| Slack        | Yes          |   Yes    |  No      | No       |
| Kakao        | Yes          |   Yes    |  No      | No       |
| Microsoft    | Yes          |   Yes    |  No      | No       |
| AWS (Tenant)*| Yes          |   Yes    |  Yes     | Yes      |
| Karrier One  | Yes          |   Yes    |  Yes     | Yes      |
| Credenza3    | Yes          |   Yes    |  Yes     | Yes      |
| RedBull      | Under review |   No     |  No      | No       |
| Amazon       | Under review |   No     |  No      | No       |
| WeChat       | Under review |   No     |  No      | No       |
| Auth0        | Under review |   No     |  No      | No       |
| Okta         | Under review |   No     |  No      | No       |

* Sui supports AWS (Tenant) but the provider is enabled per tenant. Contact us for more information.
>>>> sui/docs/content/snippets/prerequisites.mdx

<Tabs className="tabsHeadingCentered--small">
<TabItem value="prereq" label="Prerequisites">

- [x] [Install the latest version of Sui](/guides/developer/getting-started/sui-install).

- [x] Set up your Sui account and CLI environment. 

<details className="nudge-details">

<summary>

Create Sui account and setup CLI environment

</summary>

```sh
$ sui client
```

If this is the first time running the `sui client` CLI tool, it asks you to provide a Sui full node server URL and a meaningful environment alias. It also generates an address with a random key pair in `sui.keystore` and a config `client.yaml`.

By default, the `client.yaml` and `sui.keystore` files are located in `~/.sui/sui_config`. For more information, refer to the [Sui client CLI tutorial](/references/cli/client.mdx).

If this is not your first time running `sui client`, then you already have a `client.yaml` file in your local environment. If you'd like to create a new address for this tutorial, use the command:

```sh 
$ sui client new-address ed25519
```

</details>

- [x] Obtain test tokens. 

<details className="nudge-details">

<summary>

How to obtain tokens

</summary>

If you are connected to Devnet or Testnet networks, use the [Faucet UI](https://faucet.sui.io/) to request tokens.

If you are connected to a local full node, [learn how to get local network tokens](/guides/developer/sui-101/local-network).

</details>

</TabItem>
</Tabs>
>>>> sui/docs/content/snippets/publish-to-devnet-with-coins.mdx
Before being able to publish your package to Testnet, you need Testnet SUI tokens. To get some, visit the online faucet at https://faucet.sui.io/. For other ways to get SUI in your Testnet account, see [Get SUI Tokens](/guides/developer/getting-started/get-coins).

Now that you have an account with some Testnet SUI, you can deploy your contracts. To publish your package, use the following command in the same terminal or console:

```
sui client publish --gas-budget <GAS-BUDGET>
```

For the gas budget, use a standard value such as `20000000`.
>>>> sui/docs/content/snippets/quick-install.mdx
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="install-tool">

<TabItem label="suiup" value="suiup">

First, install `suiup`:

```sh
$ curl -sSfL \
  https://raw.githubusercontent.com/Mystenlabs/suiup/main/install.sh \
  | sh
```

Then, install Sui:

```sh
$ suiup install sui@testnet
```

For alternative installation methods, refer to the [`suiup` repository](https://github.com/MystenLabs/suiup).

:::danger

Installing Sui with `suiup` does not configure the client. To use `sui` commands, you must [configure the Sui client](/guides/developer/getting-started/configure-sui-client.mdx).

To confirm that Sui installed correctly:

1. Open a terminal or console
2. Type `sui --version` and press Enter

If you receive a "command not found" error, verify the Sui binaries directory is in your `PATH` environment variable.

:::

</TabItem>

<TabItem label="Homebrew" value="brew">

You must have [Homebrew](https://brew.sh/) installed before running the following command:

```sh
$ brew install sui
```

To confirm that Sui installed correctly:

1. Open a terminal or console
2. Type `sui --version` and press Enter

If you receive a "command not found" error, verify the Sui binaries directory is in your `PATH` environment variable.


</TabItem>

<TabItem label="Chocolatey" value="choco">

You must have [Chocolately](https://chocolatey.org/) installed before running the following command:

```sh
$ choco install sui
```

Find more [versions of Sui for Windows](https://community.chocolatey.org/packages/sui) on the Chocolatey community website.

To confirm that Sui installed correctly:

1. Open a terminal or console
2. Type `sui --version` and press Enter

If you receive a "command not found" error, verify the Sui binaries directory is in your `PATH` environment variable.

</TabItem>

</Tabs>

>>>> sui/docs/content/snippets/staking-pool-reqs.mdx
### Validator staking pool requirements 

There are minimum staking requirements a validator must satisfy to become active and to stay in the active validator set.

##### Stake requirements

The Sui network is rolling out [SIP-39](https://github.com/sui-foundation/sips/blob/main/sips/sip-39.md), which will significantly lower the barrier to entry for validators. Instead of requiring a minimum amount of SUI tokens, validators will need a minimum amount of *voting power*.

When fully rolled out, SIP-39 will mean the following validator requirements:

- A validator candidate must accrue at least 3 voting power before they can request to join the validator set.
- If an active validator's stake falls below 2 voting power, they have seven epochs of grace period to gain back the stake before being removed from the validator set.
- If an active validator's stake falls below 1 voting power, they are removed from the validator set at the end of the current epoch boundary. Sui uses 24-hour epochs.

For more information on voting power, see [Understanding the voting power formula](/concepts/tokenomics.mdx#understanding-the-voting-power-formula).

:::tip
Want to be a Sui validator?

If you have the required stake and plan to operate a validator on Sui, your participation is welcome and Sui is committed to supporting your onboarding. Kindly complete [this form](https://docs.google.com/forms/d/e/1FAIpQLSf6ZngRJ6Q5RdEiBfnbpUq4Htj8ShL58I6JRkmRTwTVSzeNtQ/viewform) to be added to our Validator Discord and keep up with upcoming validator releases and technical support.
:::

>>>> sui/docs/content/snippets/suiplay.mdx
:::tip

This guide will be updated as the Playtron SDK and additional tooling become available. Check back regularly for the latest recommendations and implementation details.

:::
>>>> sui/docs/content/snippets/upgrade-single-key-risk.mdx
- The entity owning that key might make changes that are in their own interests but not the interests of the broader community.
- Upgrades might happen without enough time for package users to consult on the change or stop using the package if they disagree.
- The key might get lost.
>>>> sui/docs/content/snippets/warn-ml-rpcs.mdx
:::caution

Use dedicated nodes/shared services rather than public endpoints for production apps. The public endpoints maintained by Mysten Labs (`fullnode.<NETWORK>.sui.io:443`) are rate-limited, and support only 100 requests per 30 seconds. Do not use public endpoints in production applications with high traffic volume.

You can either run your own Full nodes, or outsource this to a professional infrastructure provider (preferred for apps that have high traffic). You can find a list of reliable RPC endpoint providers for Sui on the [Sui Dev Portal](https://sui.io/developers#dev-tools) using the **Node Service** tag.

:::
>>>> sui/docs/content/standards.mdx
---
title: Sui Standards Overview
sidebar_label: Overview
description: Sui publishes standards for features, frameworks, or apps that you can extend or customize.
keywords: [ sui standards, feature standards, frameworks, frameworks standards, app standards ]
---

Standards on Sui are features, frameworks, or apps that you can extend or customize.

<Cards>
	<Card title="Closed-Loop Token" href="standards/closed-loop-token" />
	<Card title="Coin" href="standards/coin" />
	<Card title="Currency" href="standards/currency" />
	<Card title="DeepBook" href="standards/deepbook" />
	<Card title="Kiosk" href="standards/kiosk" />
	<Card title="Kiosk Apps" href="standards/kiosk-apps" />
	<Card title="Sui Object Display" href="standards/display" />
	<Card title="Wallet Standard" href="standards/wallet-standard" />
	<Card title="Payment Kit" href="standards/payment-kit" />
</Cards>

>>>> sui/docs/content/standards/closed-loop-token.mdx
---
title: Closed-Loop Token
description: Closed-Loop tokens can only be used for a specific service or by authorized users. 
keywords: [token::keep, token::join, token::split, token::zero, token::destroy_zero, token::transfer, token::to_coin, token::from_coin, token::spend, closed-loop, closed-loop tokens, closed loop, difference between closed-loop and coin, coin vs closed-loop ]
pagination_prev: null
---

Using the Closed-Loop Token standard, you can limit the applications that can use the token and set up custom policies for transfers, spends, and conversions. The [`sui::token` module](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/token.md) in the Sui framework defines the standard.

## Background and use cases

The [Currency Standard](/standards/currency.mdx) on Sui is an example of an open-loop system. Coins are free-flowing, [wrappable](/concepts/object-ownership/wrapped.mdx), [freely transferable](/concepts/transfers/custom-rules.mdx#the-store-ability-and-transfer-rules) and you can store them in any application. 

Some applications, however, require constraining the scope of the token to a specific purpose. For example, some applications might need a token that you can only use for a specific service, or that an authorized account can only use, or a token that you can block certain accounts from using. A real-world analogy would be a bank account that is regulated, bank-controlled, and compliant with certain rules and policies.

## Difference with Coin

```mermaid
flowchart RL
    subgraph "&nbsp;&nbsp;Balance has store { u64 }&nbsp;&nbsp;"
        A["Balance&lt;T>
        Supply&lt;T>"];
    end
    subgraph "&nbsp;&nbsp;Coin has key, store { Balance }&nbsp;&nbsp;"
        B["Coin&lt;T>
        TreasuryCap&lt;T>"];
    end
        subgraph "&nbsp;&nbsp;Token has key { Balance }&nbsp;&nbsp;"
        C["Token&lt;T>
        TreasuryCap&lt;T>"];
    end
    B-- to_balance -->A;
    C-- to_coin -->B;
```

```mermaid
flowchart LR
    subgraph "&nbsp;&nbsp;Balance has store { u64 }&nbsp;&nbsp;"
        A["Balance&lt;T>
        Supply&lt;T>"];
    end
    subgraph "&nbsp;&nbsp;Coin has key, store { Balance }&nbsp;&nbsp;"
        B["Coin&lt;T>
        TreasuryCap&lt;T>"];
    end
        subgraph "&nbsp;&nbsp;Token has key { Balance }&nbsp;&nbsp;"
        C["Token&lt;T>
        TreasuryCap&lt;T>"];
    end
    A-- from_balance -->B;
    B-- from_coin -->C;
```

Unlike Coin, which has `key + store` abilities and thus supports wrapping and public transfers, Token has only the `key` ability and cannot be wrapped, stored as a dynamic field, or freely transferred (unless there's a custom policy for that). Due to this restriction, Token **can only be owned by an account** and can't be stored in an application (however, [it can be spent](/standards/closed-loop-token/spending.mdx).

```move
// defined in `sui::coin`
struct Coin<phantom T> has key, store { id: UID, balance: Balance<T> }

// defined in `sui::token`
struct Token<phantom T> has key { id: UID, balance: Balance<T> }
```

## Compliance and rules

You can set up any rules for transfers, spends, and conversions for the tokens you create. You specify these rules per action in the [TokenPolicy](/standards/closed-loop-token/token-policy.mdx). [Rules](/standards/closed-loop-token/rules.mdx) are custom programmable restrictions that you can use to implement any request authorization or validation logic.

For example, a policy can set a limit on a transfer - `X` tokens per operation; or require user verification before spending tokens; or allow spending tokens only on a specific service.

You can reuse rules across different policies and applications; and you can freely combine rules to create complex policies.

## Public actions

Tokens have a set of public and protected actions that you can use to manage the token. Public actions are available to everyone and don't require any authorization. They have similar APIs to coins, but operate on the `Token` type:

- `token::keep`: Send a token to the transaction sender
- `token::join`: Join two tokens
- `token::split`: Split a token into two, specify the amount to split
- `token::zero`: Create an empty (zero balance) token
- `token::destroy_zero`: Destroy a token with zero balance

See [Coin Token Comparison](/standards/closed-loop-token/coin-token-comparison.mdx) for coin and token methods comparison.

## Protected actions

Protected actions are ones that issue an [`ActionRequest`](/standards/closed-loop-token/action-request.mdx) - a hot-potato struct that must be resolved for the transaction to succeed. There are three main ways to resolve an `ActionRequest`, most common of which is via the [`TokenPolicy`](/standards/closed-loop-token/token-policy.mdx).

- `token::transfer`: Transfer a token to a specified address
- `token::to_coin`: Convert a token to a coin
- `token::from_coin`: Convert a coin to a token
- `token::spend`: Spend a token on a specified address

The previous methods are included in the base implementation, however it is possible to create `ActionRequest`s for custom actions.

## Token policy and rules

Protected actions are disabled by default but you can enable them in a [`TokenPolicy`](/standards/closed-loop-token/token-policy.mdx). Additionally, you can set custom restrictions called [rules](/standards/closed-loop-token/rules.mdx) that a specific action must satisfy for it to succeed.

>>>> sui/docs/content/standards/closed-loop-token/action-request.mdx
---
title: Action Request
description: Tokens do not allow transfers, conversions, or spends by default. To allow these actions, use an `ActionRequest`. 
keywords: [ action request, protected actions, action, request, from_coin, to_coin, transfer, spend, approve actions, create custom action requests, custom requests ]
---

The main difference between tokens and coins is that tokens do not allow transfers, conversions, or spends by default. There is an authorization mechanism, however, that allows these actions. This mechanism is called an `ActionRequest`. You can choose to allow or disallow any of the actions independently (see the [Request confirmation](#request-confirmation) section).

## Protected actions

Tokens have four protected actions that create an `ActionRequest`:

| Function           | Action name | Description                     | Special fields in `ActionRequest` |
| ------------------ | ----------- | ------------------------------- | --------------------------------- |
| `token::from_coin` | `from_coin` | Convert a coin into a token     | -                                 |
| `token::to_coin`   | `to_coin`   | Convert a token into a coin     | -                                 |
| `token::transfer`  | `transfer`  | Transfer a token to a recipient | Contains `recipient` field        |
| `token::spend`     | `spend`     | Spend a token                   | Contains `spent_balance` field    |

## ActionRequest structure

`ActionRequest` is defined in the `sui::token` module and contains the following fields:

- `name`: Name of the performed action, standard ones are `transfer`, `spend`, `to_coin` and `from_coin`, and you can create custom actions.
- `amount`: The amount of the token that is being transferred, spent, converted, and so on.
- `sender`: The account that initiated the action.
- `recipient`: The account that receives the token in `transfer` action (use for custom actions).
- `spent_balance`: The balance of a spent token in the [`spend` action](./spending.mdx) (use in custom actions).

Rules can use these fields to determine whether the action should be allowed or not. Rules are custom modules that implement restriction logic. See [Rules](./rules.mdx) for more details.

An example of a function creating an `ActionRequest`:

```move
// module: sui::token
public fun transfer<T>(
    t: Token<T>, recipient: address, ctx: &mut TxContext
): ActionRequest<T>;
```

## Request confirmation {#request-confirmation}

There are three ways to confirm an `ActionRequest` using a:

1. `TreasuryCap` - you (or an application storing the `TreasuryCap`) can call the `token::confirm_with_treasury_cap` function to confirm any request. This method is useful for applications that store the `TreasuryCap` and implement custom logic; it also allows you to `mint` and `transfer` tokens, bypassing the restrictions.
2. [`TokenPolicy`](./token-policy.mdx) - create a shared `TokenPolicy` and set up allowed actions and requirements for each action. This way, applications or wallets know which actions are considered `public` and so they are able to perform them.
3. `TokenPolicyCap` - use the capability managing the `TokenPolicy` to confirm requests. This can be useful for applications that have the `TreasuryCap` wrapped and inaccessible; and you need to authorize some administrator action.

:::info

You can't use `TokenPolicyCap` to confirm `spend` requests.

:::

### Confirming with TreasuryCap

Use the `TreasuryCap` to confirm any action request for the token. It's useful for administrator actions (like `mint` and `transfer`), as well as for simple applications that don't require a token policy and wrap the `TreasuryCap` into the main object.

The signature for the `token::confirm_with_treasury_cap` function is:

```move
// module: sui::token
public fun confirm_with_treasury_cap<T>(
    treasury_cap: &mut TreasuryCap<T>,
    request: ActionRequest<T>,
    ctx: &mut TxContext
): (String, u64, address, Option<address>);
```

An example of a transaction implemented in TypeScript with sui.js, confirming an action request with a `TreasuryCap`. Here the admin account owns the `TreasuryCap`, which is used to mint and confirm the transfer request for the token:

```js
let tx = new Transaction();
let tokenType = '0x....::my_token::MY_TOKEN';
let treasuryCapArg = tx.object('0x....');

// mint 10 tokens using the `TreasuryCap`
let token = tx.moveCall({
	target: '0x2::token::mint',
	arguments: [treasuryCapArg, tx.pure.u64(10)],
	typeArguments: [tokenType],
});

// transfer the token to a recipient; receive an `ActionRequest`
let request = tx.moveCall({
	target: '0x2::token::transfer',
	arguments: [token, tx.pure.address('0x...')],
	typeArguments: [tokenType],
});

// confirm the request with the `TreasuryCap`
tx.moveCall({
	target: '0x2::token::confirm_with_treasury_cap',
	arguments: [treasuryCapArg, request],
	typeArguments: [tokenType],
});

// submit the transaction
// ...
```

### Confirming with TokenPolicy

`TokenPolicy` is a way of enabling certain actions network-wide. After sharing, the `TokenPolicy` is available to everyone. Hence, wallets or other clients can use it to confirm allowed operations.

The signature for the `token::confirm_request` function is:

```move
// module: sui::token
public fun confirm_request<T>(
    treasury_cap: &TokenPolicy<T>,
    request: ActionRequest<T>,
    ctx: &mut TxContext
): (String, u64, address, Option<address>);
```

:::info

If it's a `spend` request, use the `confirm_request_mut` function instead.

:::

An example of a client transfer request confirmation in JavaScript:

```js
let tx = new Transaction();
let tokenType = '0x....::my_token::MY_TOKEN';
let myTokenArg = tx.object('0x...token_object');
let receiverArg = tx.pure.address('0x...receiver');
let tokenPolicyArg = tx.object('0x...token_policy');

let request = tx.moveCall({
	target: '0x2::token::transfer',
	arguments: [myTokenArg, receiverArg],
	typeArguments: [tokenType],
});

// expecting the `TokenPolicy` to have the `transfer` operation allowed
tx.moveCall({
	target: '0x2::token::confirm_request',
	arguments: [tokenPolicyArg, request],
	typeArguments: [tokenType],
});

// submit the transaction
// ...
```

### Confirming with TokenPolicyCap

Use `TokenPolicyCap` to confirm action requests. A convenient approach when the `TreasuryCap` is wrapped in another object, and `TokenPolicy` does not allow certain action or has rules that make the default way of confirming impossible.

:::info

You can't use `TokenPolicyCap` to confirm `spend` requests.

:::

```move
// module: sui::token

public fun confirm_with_policy_cap<T>(
    token_policy_cap: &TokenPolicyCap<T>,
    request: ActionRequest<T>,
    ctx: &mut TxContext
): (String, u64, address, Option<address>);
```

An example of a client transfer request confirmation in JavaScript:

```js
let tx = new Transaction();
let tokenType = '0x....::my_token::MY_TOKEN';
let myTokenArg = tx.object('0x...token_object');
let receiverArg = tx.pure.address('0x...receiver');
let tokenPolicyCapArg = tx.object('0x...token_policy_cap');

let request = tx.moveCall({
	target: '0x2::token::transfer',
	arguments: [myTokenArg, receiverArg],
	typeArguments: [tokenType],
});

// confirming the request with the TokenPolicyCap
tx.moveCall({
	target: '0x2::token::confirm_with_policy_cap',
	arguments: [tokenPolicyCapArg, request],
	typeArguments: [tokenType],
});

// submit the transaction
// ...
```

## Approving actions

`ActionRequest`s can collect approvals - witness stamps from applications or rules. They carry the confirmation that a certain module or a rule has approved the action. This mechanic allows gating actions behind certain requirements.

The signature for the `token::add_approval` function is:

```move
// module: sui::token
public fun add_approval<T, W: drop>(
    _t: W, request: &mut ActionRequest<T>, _ctx: &mut TxContext
);
```

Approvals are mostly used for rules, but they can carry confirmations from any module.

## Creating a custom request

Anyone can create a new `ActionRequest` using the `token::new_request` function. You can use it to create custom actions and rules, not necessarily related to the token itself.

:::info

Because you can create an `ActionRequest` freely for any type `T`, you can't use them as a proof of the action. Their purpose is **authorization**, not proof.

:::

The signature for the `token::new_request` function is:

```move
public fun new_request<T>(
    name: vector<u8>,
    amount: u64,
    recipient: option<address>,
    spent_balance: option<Balance<T>>,
    ctx: &mut TxContext
): ActionRequest<T>;
```

>>>> sui/docs/content/standards/closed-loop-token/coin-token-comparison.mdx
---
title: Coin/Token API comparison
description: Compare and contrast the API used for the `coin` and `token` modules.
keywords: [ mint, burn, join, split, zero, destroy_zero, keep, transfer, to_balance, to_coin, from_balance, from_coin, spend, difference between coin and token, difference between token and coin, coin vs token, token vs coin ]
---

Use this appendix as a quick reference to compare the API of the `coin` and `token` modules.

| Function                    | Coin | Token       | Note                                                                             |
|-----------------------------|------|-------------|----------------------------------------------------------------------------------|
| `mint`                        | +    | +           | Requires `TreasuryCap`                                                             |
| `burn`                        | +    | +           | Requires `TreasuryCap`                                                             |
| `join`                        | +    | +           | Public                                                                           |
| `split`                       | +    | +           | Public                                                                           |
| `zero`                        | +    | +           | Public                                                                           |
| `destroy_zero`                | +    | +           | Public                                                                           |
| `keep`                        | -    | +           | Send token to sender, not required for coin due to lack of transfer restrictions |
| `transfer`                    | +    | \[protected] | Coin is transferable by default, token requires authorization                   |
| `to_balance`/`to_coin`        | +    | \[protected] | Token can be converted `to_coin`, requires authorization                        |
| `from_balance`/`from_coin`    | +    | \[protected] | Token can be created `from_coin`, requires authorization                        |
| `spend`                       | -    | \[protected] | Token can be spent, requires authorization                   |

>>>> sui/docs/content/standards/closed-loop-token/rules.mdx
---
title: Rules
description: Rule modules are used to create programmable restrictions that apply any action within a `TokenPolicy`. 
keywords: [ rule module, token rules, tokenpolicy, rules for tokens, token policies, configuring rules, rule configuration, rule structure, rule compliance, rule regulation, token regulation ]
---

Rules are programmable restrictions that you can apply to any action in the [`TokenPolicy`](./token-policy.mdx). They are the tool of compliance, regulation, and enforcement of certain business logic in the closed-loop system.

## Rule structure

A rule is represented as a type with a `drop` ability. This type is called a witness. You can either encode it in your application logic, or include it as part of a separate module for a more modular approach.

```move
/// The Rule type
struct Rule has drop {}
```

After you [add a rule](./token-policy.mdx#adding-rules) to an action in the `TokenPolicy`, the action requires a stamp of the rule to pass confirmation.

See the [Approving actions](./action-request.mdx#approving-actions) section for more details on how to approve an action.

## Modular rules

You can publish rules as separate reusable modules. This enables you to create a library of rules that you can use in different token policies, maximizing code reuse and minimizing the risk of errors.

A rule module is a regular module with a `verify`-like function that typically takes a `TokenPolicy`, [`ActionRequest`](./action-request.mdx), and a `TxContext` as arguments. The function is responsible for verifying the action and stamping the `ActionRequest` with the rule type.

```move
module example::pass_rule {
    use sui::tx_context;
    use sui::token::{Self, ActionRequest, TokenPolicy};

    /// The Rule type
    struct Pass has drop {}

    /// Add approval from the Pass rule to the ActionRequest
    public fun verify<T>(
        _policy: &TokenPolicy<T>,
        action_request: &mut ActionRequest<T>,
        ctx: &mut TxContext,
    ) {
        // ...
        token::add_approval(Pass {}, action_request, ctx)
    }
}
```

## Rule configuration

Some rules, such as `denylist` or `allowlist` require configuration. For example, a `denylist` rule might require a list of addresses that are not allowed to perform certain actions. A rule module can define a configuration structure and provide functions to add, modify, retrieve, and remove the configuration.

:::info

A single rule has a single configuration, even when assigned to multiple actions. If there's a need to have configuration per action, a rule module needs to define a storage structure that can hold and manage multiple configurations.

:::

The configuration system comes with a set of guarantees to protect token owners from malicious actions (or upgrades) from rule module developers:

1. The `rule` module defines the type and structure of the configuration.
2. Addition or modification and removal of the configuration are available only to the `TokenPolicy` owner.
3. Only a rule can read the configuration.
4. Rules cannot modify the configuration without the `TokenPolicy` owner's approval.

The only attack vector available to the rule creator is upgrading the module and creating a function to bypass the restriction. Make sure to use rules provided by a trusted developer.

## Configuration API

The `sui::token` module defines the configuration API and has the following set of functions.

### Add new configuration

A rule must approve new configurations (the rule witness) and the `TokenPolicy` owner. The type of the configuration can be any as long as it has the `store` ability.

```move
// module: sui::token
public fun add_rule_config<T, Rule: drop, Config: store>(
    _rule: Rule,
    policy: &mut TokenPolicy<T>,
    policy_cap: &TokenPolicyCap<T>,
    config: Config,
    _ctx: &mut TxContext
);
```

### Read the configuration

Rules can read the configuration stored in the `TokenPolicy`.

```move
// module: sui::token
public fun rule_config<T, Rule: drop, Config: store>(
    _rule: Rule, policy: &TokenPolicy<T>
): &Config;
```

### Modify the configuration

A rule must approve configuration modifications (the rule witness) as well as the `TokenPolicy` owner.

```move
// module: sui::token
public fun rule_config_mut<T, Rule: drop, Config: store>(
    _rule: Rule, policy: &mut TokenPolicy<T>, policy_cap: &TokenPolicyCap<T>
): &mut Config;
```

### Remove configuration

A good practice for rules is to provide a method to remove the configuration, as a rule can use a custom type for it. However, a token owner can always call the `remove_rule_config` function to remove the configuration.

```move
// module: sui::token
public fun remove_rule_config<T, Rule, Config: store>(
    policy: &mut TokenPolicy<T>,
    policy_cap: &TokenPolicyCap<T>,
    _ctx: &mut TxContext
): Config;
```

Because the configuration has `store`, the token owner can wrap and transfer or store the configuration somewhere else. If the `Config` type has `drop`, the value can be ignored.

## Cheat sheet: Rule configuration API

| Method name                 | Description                              | Notes                                          |
|-----------------------------|------------------------------------------|------------------------------------------------|
| `add_rule_config`           | Adds a new config for the rule           | Requires rule witness and token owner approval |
| `remove_rule_config`        | Removes config object from the policy    | Token Owner can perform any time           |
| `rule_config`               | Access the config immutably              | Only available to a rule                       |
| `rule_config_mut`           | Get mutable reference to config          | Requires rule witness and token owner approval |
| `has_rule_config`           | Check if the rule has a config set       | -                                              |
| `has_rule_config_with_type` | Check if the rule has a config with type | -                                              |

>>>> sui/docs/content/standards/closed-loop-token/spending.mdx
---
title: Spending
description: Token types cannot use the `store` ability to store other objects. Instead, Tokens have a `spend` method. 
keywords: [ token, store, spend, spend action, spent token, actionrequest, action request, gating the spend action, assigning rules, rules for spending, authorizing spending, authorized spending, token policies, tokenpolicy, treasureycap, treasury cap ]
---

Because `Token` types do not have the `store` ability, it is impossible to store them in another object. Hence, `Coin`-like approaches to spending are not possible. An application that takes `Token` as a payment won't be able to add it to its balance. To address this issue, `Token` has a `spend` method, which allows spending it in one application and then delivering it as a `spent_balance` to the [`TokenPolicy`](./token-policy.mdx) or burning right away with a `TreasuryCap`.

## Spend action

Tokens can be spent by calling the `spend` method. It takes the following arguments:

```move
// module sui::token
public fun spend<T>(token: Token<T>, ctx: &mut TxContext): ActionRequest<T>;
```

As the signature shows, the `Token` object is consumed. Its balance becomes the `spent_balance` in the [`ActionRequest`](./action-request.mdx#actionrequest-structure).

## Spent token

The `ActionRequest` for the `spend` action contains the `Balance` of the spent `Token`, and it can either be confirmed [with a `TreasuryCap`](./action-request#confirming-with-treasurycap) or [delivered to the `TokenPolicy`](./action-request#confirming-with-tokenpolicy). In the first case, the balance is burned directly in the `TreasuryCap`, and in the second case, it's delivered to the `TokenPolicy` `spent_balance`.

Spent balance cannot be used in any way, and it is not possible to withdraw it. The only available action is [flushing](./token-policy#consume-spent-balance) - burning the `spent_balance` by bringing a `TreasuryCap`.


## Gating the spend action

Normally, the `spend` action should have at least one rule assigned to it to prevent aimless spending, and the recommended way of authorizing the spend in an application that accepts the token is to stamp it right in the function where a spend is performed. For example:

```move
/// Rule-like witness to stamp the ActionRequest
struct GiftShop has drop {}

/// Spend the token and return a Gift + ActionRequest
public fun buy_gift(
    token: Token<CREDITS>,
    ctx: &mut TxContext
): (Gift, ActionRequest<CREDITS>) {

    // token is spent
    let action_request = token::spend(token, ctx);

    // stamp the ActionRequest as performed by GiftShop
    token::add_approval(GiftShop {}, &mut action_request, ctx);

    // return already stamped ActionRequest
    (Gift { ... }, action_request)
}
```

>>>> sui/docs/content/standards/closed-loop-token/token-policy.mdx
---
title: Token Policy
description: A `TokenPolicy` is a shared object that defines a token's allowed actions and conditions. Wallets and other financial services often use `TokenPolicy` objects.
keywords: [ token policy, tokenpolicy,token::new_policy, treasurycap, token::share_policy, new_policy, allow, disallow, add_rule_for_action, remove_rule_for_action, confirm_request, confirm_request_mut, flush ]
---

`TokenPolicy` is a shared object that a token owner can create using the `TreasuryCap`. Having a publicly available `TokenPolicy` enables on-chain discovery of allowed actions and their conditions. This is useful for wallets and other services that want to provide a better user experience for token holders.

## Create and share

You create a new `TokenPolicy` using the `token::new_policy` function. The function takes the `TreasuryCap` as an argument and returns a `TokenPolicy` object and a managing capability.

```move
// module: sui::token
public fun new_policy<T>(
    treasury_cap: &TreasuryCap<T>,
    ctx: &mut TxContext
): (TokenPolicy<TokenType>, TokenPolicyCap<TokenType>);
```

You must use the `token::share_policy` function to share the `TokenPolicy` object.

## Allow and disallow

To allow methods without any conditions, use the `token::allow` function. The function takes a `TokenPolicy` and `TokenPolicyCap` as arguments. If allowed, the action can be confirmed in the `TokenPolicy` using the `token::confirm_request` function (see [`ActionRequest`](./action-request.mdx#confirming-with-tokenpolicy)).

```move
// module sui::token
public fun allow<T>(
    policy: &mut TokenPolicy<T>,
    policy_cap: &TokenPolicyCap<T>,
    action: String,
    ctx: &mut TxContext
);
```

Similarly, you can use the `token::disallow` function to completely disable an action; it takes the same arguments as `token::allow`.

## Adding rules

`TokenPolicy` can specify custom conditions for each action. These conditions are called rules and are typically implemented as separate Move modules. The identifier of the rule is its type. See [Rules](./rules.mdx) for more information.

The pseudo-code structure of the `TokenPolicy` is as follows. Each action can have multiple rules associated with it.

```yaml
TokenPolicy
  rules:
    - action: "transfer"
      rules:
        - 0x0...::denylist::Denylist
    - action: "to_coin"
      rules:
        - 0x0...::limiter::Limiter
        - 0x0...::allowlist::Allowlist
    ...
```

To add a rule for an action, use the `token::add_rule_for_action` function. The function takes a `TokenPolicy` and `TokenPolicyCap` as arguments. The rule is specified by its type (for example, `0x0...::denylist::Denylist`).

```move
// module: sui::token
public fun add_rule_for_action<T, Rule: drop>(
    policy: &mut TokenPolicy<T>,
    policy_cap: &TokenPolicyCap<T>,
    action: String,
    ctx: &mut TxContext
);
```

Signature for the reverse operation `token::remove_rule_for_action` is symmetrical to `token::add_rule_for_action`.

## Consume spent balance

Spent balance can be consumed from the `TokenPolicy` using the `token::flush` function. It requires a `TreasuryCap`.

```move
// module sui::token
public fun flush<T>(
    policy: &mut TokenPolicy<T>,
    treasury_cap: &mut TreasuryCap<T>,
    ctx: &mut TxContext
);
```

## Cheat sheet: TokenPolicy API

| Function                    | Note                                                                 |
|-----------------------------|----------------------------------------------------------------------|
| new_policy                  | Create a new `TokenPolicy` using the `TreasuryCap`                       |
| allow                       | Allow an action in the `TokenPolicy`                                   |
| disallow                    | Disallow an action in the `TokenPolicy`                                |
| add_rule_for_action         | Add a rule for an action in the `TokenPolicy`                          |
| remove_rule_for_action      | Remove a rule for an action in the `TokenPolicy`                       |
| confirm_request             | Confirm an `ActionRequest` with a `TokenPolicy`                          |
| confirm_request_mut         | Similar to `confirm_request` but only works for `spend` action       |
| flush                       | Flush the spent balance from the `TokenPolicy` (see [Spending](./spending.mdx)) |

>>>> sui/docs/content/standards/coin.mdx
---
title: Coin Standard
description: The Coin standard enables you to create a broad range of fungible tokens on the Sui network to satisfy a number of use cases. 
sidebar_label: Coin
keywords: [ sui coin standard, erc-20, erc-20 equivalent, creating coins, coin standard, fungible tokens, fungible token standard, treasury capability, regulated coins, denylist object, coin metadata, create coin with SDK, use SDK to create coin, mint coin, minting coins ]
pagination_prev: null
---

:::tip

The Coin and Currency standards are both used to create fungible tokens. However, they use different creation methods and store metadata in a different type of object. 

Coin creates tokens using `coin::create_currency` while Currency uses `sui::coin_registry`.

Coin uses `CoinMetadata` while Currency uses `Currency`. 

Fungible tokens created on Sui using the Coin or Currency standard are referred to as _coins_. 

For fungible tokens created on Sui using the [Closed-Loop Token standard](/standards/closed-loop-token.mdx), the documentation uses the term _tokens_. In practice, the terms for both these objects are often interchangeable.

:::

The Coin Standard is a technical standard used by Move smart contracts for creating currency on Sui. The `sui::coin` module provides the logic that defines the standard.

The standardization of currency creation on Sui means that wallets, exchanges, and other smart contracts can manage currency created on Sui the same as they manage SUI, without any additional processing logic.

See [Sui Tokenomics](/concepts/tokenomics.mdx) to learn more about the SUI native currency and its use on the network.

## Fungible tokens

The `Coin<T>` type represents open-loop fungible tokens (see `Token<T>` for closed-loop tokens). Coins are denominated by their type parameter, `T`, which is also associated with metadata (like name, symbol, decimal precision, and so on) that applies to all instances of `Coin<T>`. The `sui::coin` module exposes an interface over `Coin<T>` that treats it as fungible, meaning that a unit of `T` held in one instance of `Coin<T>` is interchangeable with any other unit of `T`, much like how traditional fiat currencies operate.

## Coin creation

When you create a coin using the `coin::create_currency` function, the publisher of the smart contract that creates the coin receives a `TreasuryCap` object. 

### Supply states

The registry supports three different supply management models:

- **Fixed supply:** The total supply is permanently locked and cannot be changed.
- **Burn-only supply:** Coins can be freely burned through the `Currency` object.
- **Uncontrolled supply:** `TreasuryCap` holder controls minting and burning.

### Regulatory states

Currencies can have different regulatory states:

- **Regulated:** The currency has an associated `DenyCapV2` that can restrict addresses from using it.
- **Unregulated:** The currency was created without any deny list capabilities.
- **Unknown:** Regulatory status is undetermined, typically from legacy migrations.

## Treasury capability

:::danger 

While `TreasuryCap` is freely transferable, never freeze or share the `TreasuryCap`. Doing so might allow malicious actors to call functions as the currency owner and the latter allows anyone to mint new coins and act as the owner of the currency.

:::

The `TreasuryCap` object is required to mint new coins or to burn current ones. Consequently, only addresses that have access to this object can maintain the coin supply on the Sui network.

The `TreasuryCap` object is transferable, so a third party can take over the management of a coin that you create if you transfer the `TreasuryCap`. After transferring the capability, however, you can no longer mint and burn tokens yourself.

## Regulated coins

The Coin standard includes the ability to create regulated coins. To create a regulated coin, you use the `coin::create_regulated_currency_v2` function (which uses the `coin::create_currency` function itself), but which also returns a `DenyCap` capability. The `DenyCap` capability allows the bearer to maintain a list of addresses that cannot use the token.

:::tip

The [regulated-coin-sample repository](https://github.com/MystenLabs/regulated-coin-sample) provides an example of regulated coin creation.

:::

### `DenyList` object

The list of addresses that cannot use a particular regulated coin is held within a system-created `DenyList` shared object. If you have access to the `DenyCap`, then you can use the `coin::deny_list_v2_add` and `coin::deny_list_v2_remove` functions to add and remove addresses.

### Global pause switch

Regulated coin objects include an `allow_global_pause` Boolean field. When set to `true`, the bearer of the `DenyCapV2` object for the coin type can use the `coin::deny_list_v2_enable_global_pause` function to pause coin activity indefinitely. Immediately upon the bearer initiating the pause, the network disallows the coin type as input for any transactions. At the start of the next epoch (epochs last approximately 24 hours), the network additionally disallows all addresses from receiving the coin type.

When the bearer of the `DenyCapV2` object for the coin type removes the pause using `coin::deny_list_v2_disable_global_pause`, the coins are immediately available to use again as transaction inputs. Addresses cannot receive the coin type, however, until the following epoch.

The global pause functionality does not affect the deny list for the coin. After clearing the pause for the coin, any addresses included in the deny list are still unable to interact with the coin.

## Coin metadata

Each coin you create includes metadata that describes it. Typically, smart contracts freeze this object upon creation using the `transfer::public_freeze_object` function because the metadata for coins should almost never change. Regulated coins freeze the metadata they create automatically.

Regular coins using the Coin standard include a `CoinMetadata` object. As mentioned previously, regulated coins build on top of the same procedure that creates regular coins, so they receive the same metadata object in addition to a `RegulatedCoinMetadata` object that includes deny list information.

### Metadata fields

The fields of the metadata objects include the following:

#### `CoinMetadata`

| Name          | Description  |
| ------------- | ---------------------|
| `id`          | The object ID of the metadata for the token. |
| `decimals`    | The number of decimals the token uses. If you set this field to `3`, then a token of value `1000` displays as `1.000`.|
| `name`        | Name of the coin. |
| `symbol`      | Symbol for the coin. This might be the same as `name`, but is typically fewer than 5 all capital letters. For example, `SUI` is the `symbol` for the native coin on Sui but its `name` is also `SUI`. |
| `description` | A short description to describe the token. |
| `icon_url`    | The URL for the token's icon, used for display in wallets, explorers, and other apps. |

#### `RegulatedCoinMetadata`

| Name                   | Description  |
| ---------------------- | ---------------------------------------------------------- |
| `id`                   | The ID of the metadata object for the regulated token. |
| `coin_metadata_object` | The ID of the underlying metadata object (`CoinMetadata`) for the regulated token.|
| `deny_cap_object`      | The ID of the token's `DenyCapV2` object, which is necessary to maintain the deny list entries that controls who can and cannot use the token. |

## Minting and burning coins

The `coin` module provides the logic for creating and destroying coins on the Sui network (as long as you own the associated `TreasuryCap`). These functions are the same for all coins and each requires the `TreasuryCap` as an input.

### Mint

Use the `coin::mint` function to create new tokens.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="mint" noComments />

The signature shows that a `Coin<T>` results from calling the function with a `TreasuryCap`, value for the coin created, and the transaction context. The function updates the total supply in `TreasuryCap` automatically. Upon display, the coin `value` respects the `decimals` value in the metadata. So, if you supply 1000000 as the coin `value` that has a `decimal` value of `6`, the coin's value displays as `1.000000`.

### Burn

Use the `coin::burn` function to destroy current tokens.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="burn" noComments />

The signature shows that only the `TreasuryCap` and coin object you want to burn are necessary inputs, returning the amount by which the supply was decreased (value of the coin). The function does not allow you to burn more coins than are available in the supply.

## Adding and removing addresses to and from the deny list

The deny list is only applicable to regulated coins. As mentioned previously, when you create a regulated coin you receive a `DenyCapV2` that authorizes the bearer to add and remove addresses from the system-created `DenyList` object. Any address on the list for your coin cannot use the coin as an input to transactions starting immediately upon being added. At the epoch that follows address addition to the deny list, the addresses additionally cannot receive the coin type. In other words, an address that gets added to the deny list for a coin type is immediately unable to send the coin. At the start of the following epoch, the address is still unable to send the coin but is also unable to receive it. From that point, the address cannot interact with the coin until expressly removed from the deny list by the `DenyCapV2` bearer.

<ImportContent source="coin-standards.mdx" mode="snippet" />

## Reading coin data

### Metadata

:::danger 

`CoinMetadata` is planned for deprecation. The Coin standard itself is not.

:::

You can use the following functions to retrieve data from coins.


Use the following functions to get the values for the respective fields on the metadata object for coins.

| Function          | Signature                                                                                |
| ----------------- | ---------------------------------------------------------------------------------------- |
| `get_decimals`    | `public fun get_decimals<T>(metadata: &coin::CoinMetadata<T>): u8`                       |
| `get_name`        | `public fun get_name<T>(metadata: &coin::CoinMetadata<T>): string::String`               |
| `get_symbol`      | `public fun get_symbol<T>(metadata: &coin::CoinMetadata<T>): ascii::String`              |
| `get_description` | `public fun get_description<T>(metadata: &coin::CoinMetadata<T>): string::String`        |
| `get_icon_url`    | `public fun get_icon_url<T>(metadata: &coin::CoinMetadata<T>): option::Option<url::Url>` |

### Total supply

Use the `coin::supply` function to get the current supply of a given coin.

## Update coin metadata

If the `CoinMetadata` object was not frozen upon creation, you can use the following functions to update its values.

Each function signature is similar. Replace `<FUNCTION-NAME>` and `<ATTRIBUTE-TYPE>` with the values defined in the table to get the signature of each function:

```move
public entry fun <FUNCTION-NAME><T>(
  _treasury: &coin::TreasuryCap<T>,
  metadata: &mut coin::CoinMetadata<T>,
  <ATTRIBUTE-TYPE>
)
```

| `<FUNCTION-NAME>`    | `<ATTRIBUTE-TYPE>`            |
| -------------------- | ----------------------------- |
| `update_name`        | `name: string::String`        |
| `update_symbol`      | `symbol: ascii::String`       |
| `update_description` | `description: string::String` |
| `update_icon_url`    | `url: ascii::String`          |

:::info

`RegulatedCoinMetadata` is frozen upon creation, so there are no functions to update its data.

:::

<ImportContent source="coin-standards-migrate.mdx" mode="snippet" />

## Related links

<RelatedLink to="/standards/closed-loop-token.mdx" />
<RelatedLink href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/coin.md" label="`coin` module rustdoc documentation" desc="Automated documentation output for the Sui framework `coin` module." />
<RelatedLink href="https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/docs/sui/token.md" label="`token` module rustdoc documentation" desc="Automated documentation output for the Sui framework `token` module." />
<RelatedLink to="/concepts/tokenomics.mdx" />
>>>> sui/docs/content/standards/currency.mdx
---
title: Currency Standard
description: The Sui Currency Standard enables you to create a broad range of fungible tokens on the Sui network using either the legacy coin creation or the centralized coin registry system. 
sidebar_label: Currency
keywords: [ sui Currency Standard, erc-20, erc-20 equivalent, creating coins, Currency Standard, fungible tokens, fungible token standard, treasury capability, regulated coins, denylist object, coin registry, create coin with SDK, use SDK to create coin, mint coin, minting coins, currency registry ]
pagination_prev: null
---

:::tip

The Coin and Currency standards are both used to create fungible tokens. However, they use different creation methods and store metadata in a different type of object. 

Coin creates assets using `coin::create_currency` while Currency uses `sui::coin_registry`.

Coin uses `CoinMetadata` while Currency uses `Currency`. Fungible tokens created on Sui using the Coin or Currency standard are referred to as _coins_. 

**Coin** refers to a single object wrapper for a fungible asset, while the term **currency** refers to the object that is created in `CoinRegistry`, which describes the currency properties and setup.

For fungible tokens created on Sui using the [Closed-Loop Token standard](/standards/closed-loop-token.mdx), the documentation uses the term _tokens_. In practice, the terms for both these objects are often interchangeable.

:::

The Currency Standard is a technical standard used by Move smart contracts for creating coins on Sui. The `sui::coin_registry` module provides the logic that defines the standard, unifies metadata, enhances supply tracking, and improves regulatory features.

The standardization of coin creation on Sui means that wallets, exchanges, and other smart contracts can manage coins created on Sui the same as they manage SUI, without any additional processing logic.

See [Sui Tokenomics](/concepts/tokenomics.mdx) to learn more about the SUI native currency and its use on the network.

Coins on Sui can offer specialized abilities while following the Currency Standard. For example, you can create regulated coins that allow their creator to add specific addresses to a deny list, so that the identified addresses cannot use the coin as inputs to transactions.

## Fungible tokens

The `Currency<T>` type represents open-loop fungible tokens (see `Token<T>` for closed-loop tokens). Currencies are denominated by their type parameter, `T`, which is also associated with metadata (like name, symbol, decimal precision, and so on) that applies to all instances of `Currency<T>`. The `sui::coin_registry` module exposes an interface over `Currency<T>` that treats it as fungible, meaning that a unit of `T` held in one instance of `Currency<T>` is interchangeable with any other unit of `T`, much like how traditional fiat currencies operate.


## Coin creation

The Coin Registry is a centralized system that provides unified coin management through the `sui::coin_registry` module.

:::info

The registry is a system-level shared object located at address `0xc`.

:::

<details>
<summary>
`sui::coin_registry` module
</summary>
<ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" />
</details>

### Core components

**`CoinRegistry`:** The main system object that coordinates all coin-related operations. This shared object serves as the entry point for all registry operations and is created once during network initialization. Its address is `0xc`.

**`Currency<T>`:** The core of the registry system, storing comprehensive information about each coin type including:
- **Metadata management:** Basic coin information like name, symbol, decimals, description, and icon URL.
- **Supply tracking:** Maintains supply state information (fixed, burn-only, or unknown).
- **Regulatory status:** Tracks whether the coin is regulated with deny list capabilities.
- **Capability references:** Links to `TreasuryCap`s and `MetadataCap`s for the coin type.
- **Extensibility:** Includes extra fields for future enhancements.

### Supply states

The registry supports three different supply management models:

- **Fixed supply:** The total supply is permanently locked and cannot be changed.
- **Burn-only supply:** New coins cannot be minted, but existing coins can be burned.
- **Uncontrolled supply:** `TreasuryCap` holder controls minting and burning.

### Regulatory states

Coins can have different regulatory states:

- **Regulated:** The coin has an associated `DenyCapV2` that can restrict addresses from using it.
- **Unregulated:** The coin was created without any deny list capabilities.
- **Unknown:** Regulatory status is undetermined, typically from legacy migrations.

### Creation options

The registry supports two different coin creation flows:

- **Standard creation (recommended):**

    Use the `new_currency` function at any time after the coin type is published. The function immediately creates a shared `Currency<T>` object. The type `T` must be a key-only type, as in `public struct MyCoin has key { id: UID }`.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="new_currency" signatureOnly noComments />

- **One-Time Witness (OTW) creation:**

    :::caution

    OTW creation of a new coin is a two-step process. The initialization process begins with package publication. Then, a call to `finalize_registration` is needed to place the coin into the registry.

    :::

    The `new_currency_with_otw` function uses an OTW for uniqueness proof. See [One-Time Witness](https://move-book.com/programmability/one-time-witness) in The Move Book for more information.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="new_currency_with_otw" signatureOnly noComments />

### Coin initialization

Both creation methods return a `CurrencyInitializer<T>` that allows for additional configuration:

- **Make regulated:** Add deny list capabilities.
- **Set supply model:** Choose between fixed, burn-only, or flexible supply.
- **Add extensions:** Include additional fields for custom functionality.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" struct="CurrencyInitializer" />

### Coin finalization

A coin is not complete until after you call the `finalize` function. The function returns the `MetadataCap<T>` for metadata management. If you used an OTW to create the coin, the function sends the coin to the coin registry. Otherwise, it creates the final shared `Currency<T>` object.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="finalize" signatureOnly />

If you publish a package that uses an OTW to create a coin in the package `init` function, then a call must be made to `finalize_registration` after initialization. The function transforms the coin into a shared object.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="finalize_registration" signatureOnly />


## Treasury capability

When you create a coin using the `coin_registry::new_currency` or `coin_registry::new_currency_with_otw` functions, the publisher of the smart contract that creates the coin receives a `TreasuryCap` object upon finalization of the coin. The `TreasuryCap` object is required to mint new coins or to burn current ones (depending on coin supply state). Consequently, only addresses that have access to this object can maintain the coin supply on the Sui network.

The `TreasuryCap` object is transferable, so a third party can take over the management of a coin that you create if you transfer the `TreasuryCap` to them. After transferring the object, you can no longer mint and burn coins yourself.


## Regulated coins

The Currency Standard supports creating regulated coins. Use the `make_regulated` function during the initialization phase before calling `finalize`. The function adds deny list capabilities to the `Currency<T>` and tracks the regulatory status within the Coin Registry. The function returns a `DenyCap` that allows the bearer to maintain the list of addresses on the deny list.

<details>
<summary>
Regulated coin example
</summary>
<ImportContent source="examples/move/coin/sources/regcoin_new.move" mode="code" />
</details>

### `DenyList` object

The list of addresses that cannot use a particular regulated coin is held within a system-created `DenyList` shared object. If you have access to the `DenyCap`, then you can use the `coin::deny_list_v2_add` and `coin::deny_list_v2_remove` functions to add and remove addresses.

### Global pause switch

Regulated coin objects include an `allow_global_pause` Boolean field. When set to `true`, the bearer of the `DenyCapV2` object for the coin type can use the `coin::deny_list_v2_enable_global_pause` function to pause coin activity indefinitely. Immediately upon the bearer initiating the pause, the network disallows the coin type as input for any transactions. At the start of the next epoch (epochs last approximately 24 hours), the network additionally disallows all addresses from receiving the coin type.

When the bearer of the `DenyCapV2` object for the coin type removes the pause using `coin::deny_list_v2_disable_global_pause`, the coins are immediately available to use again as transaction inputs. Addresses cannot receive the coin type, however, until the following epoch.

The global pause functionality does not affect the deny list for the coin. After clearing the pause for the coin, any addresses included in the deny list are still unable to interact with the coin.

## Currency metadata

Currency metadata is stored centrally within the `Currency<T>` object in the registry. Metadata updates are controlled by the `MetadataCap<T>` capability, which can be:

- **Unclaimed:** `MetadataCap` has not yet been claimed.
- **Claimed:** `MetadataCap` has been claimed and can be used for updates.
- **Deleted:** `MetadataCap` has been permanently deleted, preventing future updates.

### Metadata fields

The fields of the metadata objects include the following:

| Name          | Description  |
| ------------- | ---------------------|
| `registry`    | The `CoinRegistry` system object ID (`0x3`). |
| `decimals`    | The number of decimals the coin uses. If you set this field to `3`, then a coin of value `1000` displays as `1.000`.|
| `name`        | Name of the coin. |
| `symbol`      | Symbol for the coin. This might be the same as `name`, but is typically fewer than 5 all capital letters. For example, `SUI` is the `symbol` for the native coin on Sui but its `name` is also `SUI`. |
| `description` | A short description to describe the coin. |
| `icon_url`    | The URL for the coin's icon, used for display in wallets, explorers, and other apps. |

## Minting and burning coins

The Coin Registry supports advanced supply management models:

- **Unknown supply:** Traditional minting/burning via `TreasuryCap`.
- **Fixed supply:** Total supply is permanently locked, no minting or burning allowed.
- **Burn-only supply:** No new minting allowed, but existing coins can be burned through registry functions.

### Mint

Use the `coin::mint` function to create new coins.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="mint" signatureOnly noComments />

The signature shows that a `Coin<T>` results from calling the function with a `TreasuryCap`, value for the coin created, and the transaction context. The function updates the total supply in `TreasuryCap` automatically. Upon display, the coin `value` respects the `decimals` value in the metadata. So, if you supply 1000000 as the coin `value` that has a `decimal` value of `6`, the coin's value displays as `1.000000`.

### Burn
Coins with a burn-only supply status can be burned directly through the registry using `coin_registry::burn` and `coin_registry::burn_balance` functions without requiring the `TreasuryCap`.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="burn,burn_balance" signatureOnly noComments />

For coins with an unknown supply status, use the `coin::burn` function to destroy current coins.

<ImportContent source="crates/sui-framework/packages/sui-framework/sources/coin.move" mode="code" fun="burn" signatureOnly noComments />

The signature shows that only the `TreasuryCap` and coin object you want to burn are necessary inputs, returning the amount by which the supply was decreased (value of the coin). The function does not allow you to burn more coins than are available in the supply.

## Adding and removing addresses to and from the deny list

The deny list is only applicable to regulated coins. As mentioned previously, when you create a regulated coin you receive a `DenyCapV2` that authorizes the bearer to add and remove addresses from the system-created `DenyList` object. Any address on the list for your coin cannot use the coin as an input to transactions starting immediately upon being added. At the epoch that follows address addition to the deny list, the addresses additionally cannot receive the coin type. In other words, an address that gets added to the deny list for a coin type is immediately unable to send the coin. At the start of the following epoch, the address is still unable to send the coin but is also unable to receive it. From that point, the address cannot interact with the coin until expressly removed from the deny list by the `DenyCapV2` bearer.

<ImportContent source="coin-standards.mdx" mode="snippet" />

## Query functions

You can query information directly from the `Currency<T>` object.

### Metadata

- `decimals<T>()`: Get number of decimals.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="decimals" noTitle signatureOnly noComments />

- `name<T>()`: Get coin name.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="name" noTitle signatureOnly noComments />

- `symbol<T>()`: Get coin symbol.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="symbol" noTitle signatureOnly noComments />

- `description<T>()`: Get coin description.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="description" noTitle signatureOnly noComments />

- `icon_url<T>()`: Get icon URL.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="icon_url" noTitle signatureOnly noComments />

### Supply information

- `total_supply<T>()`: Get current total supply.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="total_supply" noTitle signatureOnly noComments />

- `is_supply_fixed<T>()`: Check if supply is fixed.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="is_supply_fixed" noTitle signatureOnly noComments />

- `is_supply_burn_only<T>()`: Check if supply is burn-only.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="is_supply_burn_only" noTitle signatureOnly noComments />

### Capability status

- `is_metadata_cap_claimed<T>()`: Check if metadata cap is claimed.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="is_metadata_cap_claimed" noTitle signatureOnly noComments />

- `is_metadata_cap_deleted<T>()`: Check if metadata cap is deleted.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="is_metadata_cap_deleted" noTitle signatureOnly noComments />

- `treasury_cap_id<T>()`: Get treasury cap object ID.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="treasury_cap_id" noTitle signatureOnly noComments />

- `metadata_cap_id<T>()`: Get metadata cap object ID.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="metadata_cap_id" noTitle signatureOnly noComments />

### Regulatory information

- `is_regulated<T>()`: Check if coin is regulated.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="is_regulated" noTitle signatureOnly noComments />

- `deny_cap_id<T>()`: Get deny cap object ID.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="deny_cap_id" noTitle signatureOnly noComments />

## Update currency metadata

Metadata updates require the `MetadataCap<T>` object, which is only available to the bearer of the `TreasuryCap` for a coin. The bearer of the `TreasuryCap` can claim the `MetadataCap` using the `claim_metadata_cap` function only once. `Currency` tracks the claimed status of the capability through its `metadata_cap_id` field.

The bearer of the `MetadataCap` can use the available getter functions to update values.

- `set_name<T>()`: Update coin name.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="set_name" noTitle noComments signatureOnly />

- `set_symbol<T>()`: Update coin symbol.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="set_symbol" noTitle noComments signatureOnly />

- `set_description<T>()`: Update coin description.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="set_description" noTitle noComments signatureOnly />

- `set_icon_url<T>()`: Update icon URL.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="set_icon_url" noTitle noComments signatureOnly />

Manage the metadata capability using:

- `claim_metadata_cap<T>()`: Claim the metadata capability one time.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="claim_metadata_cap" noTitle noComments signatureOnly />

- `delete_metadata_cap<T>()`: Permanently delete the capability to prevent future updates.

    <ImportContent source="crates/sui-framework/packages/sui-framework/sources/registries/coin_registry.move" mode="code" fun="delete_metadata_cap" noTitle noComments signatureOnly />

    :::caution

    Deleting the `MetadataCap` using `delete_metadata_cap<T>()` is an irreversible action.

    :::

<ImportContent source="coin-standards-migrate.mdx" mode="snippet" />

## Best practices

### For coin creators

- **Set supply model early:** Decide on supply model during initialization (fixed, burn-only, or flexible).
- **Consider regulation:** Evaluate whether deny list capabilities are needed.
- **Manage metadata cap:** Decide whether to keep, transfer, or delete the metadata capability.

### For dApp developers

- **Query registry first:** Check the registry for coin information before falling back to legacy methods.
- **Handle migration states:** Account for coins in various migration states.
- **Respect supply models:** Understand the implications of different supply states (fixed, burn-only, unknown).
- **Check regulatory status:** Be aware of regulated coins and their restrictions.

### For infrastructure providers

- **Monitor registry changes:** Track new coin registrations and updates.
- **Index supply changes:** Monitor burn events for burn-only coins.
- **Handle legacy coins:** Support both registry and legacy metadata systems.
- **Cache efficiently:** Registry data changes infrequently and can be cached.

### Security considerations

**Capability security:**
- **`MetadataCap`:** Protect metadata capabilities as they control coin branding.
- **`TreasuryCap`:** Treasury capabilities determine minting and burning permissions.
- **`DenyCapV2`:** Deny capabilities can restrict coin usage.

**Validation:**
The registry enforces several important validations:
- **Symbol validation:** Symbols must be ASCII printable characters.
- **Uniqueness:** Each coin type can only be registered once.
- **Supply consistency:** Supply states cannot be downgraded.
- **Permission checks:** Only appropriate capability holders can make changes.

**Migration safety:**
- **One-time migration:** Legacy metadata can only be migrated once.
- **Capability proof:** Metadata deletion requires capability ownership.
- **State consistency:** Regulatory state migration prevents double-setting.

## Related links

<RelatedLink to="/guides/developer/currency.mdx" />
<RelatedLink to="/standards/closed-loop-token.mdx" />
<RelatedLink to="/concepts/sui-move-concepts/derived-objects.mdx" />
<RelatedLink href="/references/framework/sui_sui/coin" label="`coin` module rustdoc documentation" desc="Automated documentation output for the Sui framework `coin` module." />
<RelatedLink href="/references/framework/sui_sui/token" label="`token` module rustdoc documentation" desc="Automated documentation output for the Sui framework `token` module." />
<RelatedLink to="/concepts/tokenomics.mdx" />

>>>> sui/docs/content/standards/deepbook-margin-sdk.mdx
---
title: DeepBook Margin SDK
description: Use the DeepBook TypeScript SDK to interact directly with the DeepBook Margin package.
keywords:
  [
    deepbook margin,
    margin trading,
    typescript,
    typescript SDK,
    mysten/deepbook,
    deepbook margin SDK,
    margin manager,
    margin pool,
  ]
---

The DeepBook Margin TypeScript SDK abstracts away the transaction calls, allowing for direct interactions with the `DeepBook Margin` package for leveraged trading.

- [SDK repository](https://github.com/MystenLabs/ts-sdks/tree/main/packages/deepbook-v3)
- [NPM version](https://www.npmjs.com/package/@mysten/deepbook-v3)

## Install

To use the SDK in your projects, install the `@mysten/deepbook-v3` package, which includes the margin trading functionality.

```sh npm2yarn
npm install @mysten/deepbook-v3
```

## Constants

The DeepBook SDK includes a constants file (`/utils/constants.ts`) that maintains the latest deployed addresses for DeepBook Margin, as well as margin pools and configurations.

<details>
<summary>
`constants.ts`
</summary>

```ts reference
https://github.com/MystenLabs/ts-sdks/blob/main/packages/deepbook-v3/src/utils/constants.ts
```

</details>

## DeepBookClient

To work with DeepBook Margin, you must create a `DeepBookClient`. To construct the `DeepBookClient`, pass in a `SuiClient`, the sender address, and environment. The [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript) provides the `SuiClient` and key functionality necessary to process transactions. The following example imports those libraries, as well.

```tsx
import { DeepBookClient } from '@mysten/deepbook-v3';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';

class DeepBookMarginTrader {
	dbClient: DeepBookClient; // For building transactions
	suiClient: SuiClient; // For executing transactions
	keypair: Ed25519Keypair; // For signing transactions

	constructor(privateKey: string, env: 'testnet' | 'mainnet') {
		this.keypair = this.getSignerFromPK(privateKey);
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: env,
			client: this.suiClient,
		});
	}

	getSignerFromPK = (privateKey: string): Ed25519Keypair => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	getActiveAddress() {
		return this.keypair.toSuiAddress();
	}
}
```

## Keys: Coin, Pool, and MarginManager {#keys}

Functions that require the input of a coin, pool, or a margin manager require the key of any such object as the parameter. The SDK manages a `key:value` relationship of this data in memory. Some default data comes with the SDK (as seen in `utils/constants.ts`). Coins are stored in a `CoinMap`, pools in a `PoolMap`, and margin managers in a `MarginManagerMap` in the config.

### Margin manager

Before placing any margin trade, you must supply a margin manager address to the client. The manager key points to an object defined by the `MarginManager` interface in the client. [MarginManager docs](./deepbook-margin/margin-manager.mdx). Initialize the margin manager with the client. If you don't create a margin manager, you can rely on the client to create one, but then the user must reinitialize the client.

Example using an existing margin manager:

```tsx
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { config } from 'dotenv';

import { DeepBookClient } from '../src';
import { MarginManager } from './types';

config();

// Used wherever margin manager key is required
const MARGIN_MANAGER_KEY = 'MARGIN_MANAGER_1';

class DeepBookMarginTrader {
	dbClient: DeepBookClient; // For building transactions
	suiClient: SuiClient; // For executing transactions
	keypair: Ed25519Keypair; // For signing transactions
	env: 'testnet' | 'mainnet';

	constructor(privateKey: string, env: 'testnet' | 'mainnet') {
		this.env = env;
		this.keypair = this.getSignerFromPK(privateKey);
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: env,
			client: this.suiClient,
			marginManagers: this.getMarginManagers(),
		});
	}

	getSignerFromPK = (privateKey: string): Ed25519Keypair => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	getActiveAddress() {
		return this.keypair.toSuiAddress();
	}

	getMarginManagers(): { [key: string]: MarginManager } {
		// Used wherever margin manager key is required
		const marginManagerAddress = process.env.MARGIN_MANAGER_ADDRESS;
		const poolKey = process.env.POOL_KEY || 'SUI_DBUSDC';
		if (!marginManagerAddress) {
			throw new Error('No margin manager address found');
		}
		return {
			[MARGIN_MANAGER_KEY]: {
				address: marginManagerAddress,
				poolKey: poolKey,
			},
		};
	}
}
```

Example creating a margin manager:

```tsx
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';

import { DeepBookClient } from '../src';
import { MarginManager } from './types';

// Used wherever margin manager key is required
const MARGIN_MANAGER_KEY = 'MARGIN_MANAGER_1';

class DeepBookMarginTrader {
	dbClient: DeepBookClient; // For building transactions
	suiClient: SuiClient; // For executing transactions
	keypair: Ed25519Keypair; // For signing transactions
	env: 'testnet' | 'mainnet';

	constructor(privateKey: string, env: 'testnet' | 'mainnet') {
		this.env = env;
		this.keypair = this.getSignerFromPK(privateKey);
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: env,
			client: this.suiClient,
		});
	}

	getSignerFromPK = (privateKey: string): Ed25519Keypair => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	getActiveAddress() {
		return this.keypair.toSuiAddress();
	}

	async createMarginManagerAndReinitialize() {
		let tx = new Transaction();
		const poolKey = 'SUI_DBUSDC';
		tx.add(this.dbClient.marginManager.newMarginManager(poolKey));

		const res = await this.suiClient.signAndExecuteTransaction({
			transaction: tx,
			signer: this.keypair,
			options: {
				showEffects: true,
				showObjectChanges: true,
			},
		});

		// @ts-ignore
		const marginManagerAddress = res.objectChanges?.find((change) => {
			return change.type === 'created' && change.objectType.includes('MarginManager');
		})?.['objectId'];

		const marginManagers: { [key: string]: MarginManager } = {
			[MARGIN_MANAGER_KEY]: {
				address: marginManagerAddress,
				poolKey: poolKey,
			},
		};

		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: this.env,
			client: this.suiClient,
			marginManagers: marginManagers,
		});
	}
}
```

### Coin

The SDK comes with four default coins on Testnet and five default coins on Mainnet.

**Default Testnet coins**

- DEEP
- SUI
- DBUSDC
- DBUSDT

**Default Mainnet coins**

- DEEP
- SUI
- USDC
- USDT
- WETH

You can also initialize the SDK with custom coins to interact with margin pools that are not supported by default. To do this, create a `CoinMap` object and pass it to the constructor of the client.

### Pool

Similar to coins, the SDK comes with default pools. You can provide a `PoolMap` during construction to override this behavior.

```tsx
import { decodeSuiPrivateKey } from '@mysten/sui.js/cryptography';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import type { Keypair } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import type { Transaction } from '@mysten/sui/transactions';

import { DeepBookClient } from '../src/index.js'; // Adjust path according to new structure
import type { MarginManager } from '../src/types/index.js';

export class DeepBookMarginTrader extends DeepBookClient {
	keypair: Keypair;
	suiClient: SuiClient;

	constructor(
		keypair: string | Keypair,
		env: 'testnet' | 'mainnet',
		marginManagers?: { [key: string]: MarginManager },
		maintainerCap?: string,
	) {
		let resolvedKeypair: Keypair;

		if (typeof keypair === 'string') {
			resolvedKeypair = DeepBookMarginTrader.#getSignerFromPK(keypair);
		} else {
			resolvedKeypair = keypair;
		}

		const address = resolvedKeypair.toSuiAddress();

		super({
			address: address,
			env: env,
			client: new SuiClient({
				url: getFullnodeUrl(env),
			}),
			marginManagers: marginManagers,
			marginMaintainerCap: maintainerCap,
		});

		this.keypair = resolvedKeypair;
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
	}

	static #getSignerFromPK = (privateKey: string) => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	signAndExecute = async (tx: Transaction) => {
		return this.suiClient.signAndExecuteTransaction({
			transaction: tx,
			signer: this.keypair,
			options: {
				showEffects: true,
				showObjectChanges: true,
			},
		});
	};

	getActiveAddress() {
		return this.keypair.getPublicKey().toSuiAddress();
	}
}
```

### Example setup

The following example uses the default pools and coins provided, and demonstrates margin trading operations.

```tsx
import { Transaction } from '@mysten/sui/transactions';

import { DeepBookMarginTrader } from './deepbookMarginTrader.js';

(async () => {
	const privateKey = ''; // Can encapsulate this in a .env file

	// Initialize with margin managers if created
	const marginManagers = {
		MARGIN_MANAGER_1: {
			address: '',
			poolKey: 'SUI_DBUSDC',
		},
	};
	const traderClient = new DeepBookMarginTrader(privateKey, 'testnet', marginManagers);

	const tx = new Transaction();

	// Margin manager contract calls
	traderClient.marginManager.deposit('MARGIN_MANAGER_1', 'DBUSDC', 10000)(tx);
	traderClient.marginManager.borrowBase('MARGIN_MANAGER_1', 'SUI_DBUSDC', 100)(tx);

	// Place leveraged orders
	traderClient.poolProxy.placeLimitOrder({
		poolKey: 'SUI_DBUSDC',
		marginManagerKey: 'MARGIN_MANAGER_1',
		clientOrderId: '12345',
		price: 2.5,
		quantity: 100,
		isBid: true,
		payWithDeep: true,
	})(tx);

	// Margin pool operations
	const supplierCap = tx.add(traderClient.marginPool.mintSupplierCap());
	traderClient.marginPool.supplyToMarginPool('DBUSDC', supplierCap, 5000)(tx);

	let res = await traderClient.signAndExecute(tx);

	console.dir(res, { depth: null });
})();
```

## Related links

<RelatedLink
	href="https://www.npmjs.com/package/@mysten/deepbook-v3"
	label="DeepBookV3 SDK node package"
	desc="The DeepBookV3 SDK node package on NPM."
/>
<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>

>>>> sui/docs/content/standards/deepbook-margin-sdk/maintainer.mdx
---
title: Maintainer SDK
sidebar_label: Maintainer
description: Learn how to use the DeepBook Margin SDK to manage margin pools and system configuration.
keywords:
  [
    maintainer,
    margin pool admin,
    pool configuration,
    interest rates,
    protocol config,
    deepbook margin sdk,
  ]
---

The Maintainer SDK provides administrative functions for managing margin pools, configuring interest rates, and controlling which DeepBook pools can access margin lending. These functions are restricted to maintainers with the appropriate capabilities.

## Maintainer functions

The DeepBook Margin SDK provides the following functions for pool administration and configuration.

### `createMarginPool`

Use `createMarginPool` to create a new margin pool for a specific asset. Requires the maintainer capability. The call returns a function that takes a `Transaction` object.

**Parameters**

- `coinKey`: String that identifies the asset type.
- `poolConfig`: `TransactionArgument` representing the protocol configuration.

<ImportContent source="/packages/deepbook-v3/src/transactions/marginMaintainer.ts" mode="code" fun="createMarginPool" org="MystenLabs" repo="ts-sdks" signatureOnly />

### `newProtocolConfig`

Use `newProtocolConfig` to create a new protocol configuration object combining margin pool settings and interest parameters. The call returns a function that takes a `Transaction` object.

**Parameters**

- `coinKey`: String that identifies the asset type.
- `marginPoolConfig`: `MarginPoolConfigParams` object with pool settings.
- `interestConfig`: `InterestConfigParams` object with interest rate parameters.

<ImportContent source="/packages/deepbook-v3/src/transactions/marginMaintainer.ts" mode="code" fun="newProtocolConfig" org="MystenLabs" repo="ts-sdks" signatureOnly />

### `newMarginPoolConfig`

Use `newMarginPoolConfig` to create a margin pool configuration object. The call returns a function that takes a `Transaction` object.

**Parameters**

- `coinKey`: String that identifies the asset type.
- `marginPoolConfig`: `MarginPoolConfigParams` object containing:
  - `supplyCap`: Number representing maximum supply allowed
  - `maxUtilizationRate`: Number representing maximum utilization (e.g., 0.8 for 80%)
  - `referralSpread`: Number representing protocol spread percentage
  - `minBorrow`: Number representing minimum borrow amount

<ImportContent source="/packages/deepbook-v3/src/transactions/marginMaintainer.ts" mode="code" fun="newMarginPoolConfig" org="MystenLabs" repo="ts-sdks" signatureOnly />

### `newInterestConfig`

Use `newInterestConfig` to create an interest configuration object. The call returns a function that takes a `Transaction` object.

**Parameters**

- `interestConfig`: `InterestConfigParams` object containing:
  - `baseRate`: Number representing base interest rate
  - `baseSlope`: Number representing interest rate slope before kink
  - `optimalUtilization`: Number representing the kink point (e.g., 0.8)
  - `excessSlope`: Number representing interest rate slope after kink

<ImportContent source="/packages/deepbook-v3/src/transactions/marginMaintainer.ts" mode="code" fun="newInterestConfig" org="MystenLabs" repo="ts-sdks" signatureOnly />

### `enableDeepbookPoolForLoan`, `disableDeepbookPoolForLoan`

Use these functions to control which DeepBook pools can borrow from the margin pool. The call returns a function that takes a `Transaction` object.

**Parameters**

- `deepbookPoolKey`: String that identifies the DeepBook pool.
- `coinKey`: String that identifies the margin pool asset.
- `marginPoolCap`: String representing the margin pool capability ID.

<ImportContent source="/packages/deepbook-v3/src/transactions/marginMaintainer.ts" mode="code" fun="enableDeepbookPoolForLoan,disableDeepbookPoolForLoan" org="MystenLabs" repo="ts-sdks" signatureOnly />

### `updateInterestParams`

Use `updateInterestParams` to update the interest rate parameters for a margin pool. The call returns a function that takes a `Transaction` object.

**Parameters**

- `coinKey`: String that identifies the margin pool asset.
- `marginPoolCap`: String representing the margin pool capability ID.
- `interestConfig`: `InterestConfigParams` object with new interest parameters.

<ImportContent source="/packages/deepbook-v3/src/transactions/marginMaintainer.ts" mode="code" fun="updateInterestParams" org="MystenLabs" repo="ts-sdks" signatureOnly />

### `updateMarginPoolConfig`

Use `updateMarginPoolConfig` to update the configuration settings for a margin pool. The call returns a function that takes a `Transaction` object.

**Parameters**

- `coinKey`: String that identifies the margin pool asset.
- `marginPoolCap`: String representing the margin pool capability ID.
- `marginPoolConfig`: `MarginPoolConfigParams` object with new pool settings.

<ImportContent source="packages/deepbook-v3/src/transactions/marginMaintainer.ts" mode="code" fun="updateMarginPoolConfig" org="MystenLabs" repo="ts-sdks" signatureOnly />

## Examples

The following examples demonstrate common maintainer operations.

### Create a margin pool

```tsx
// Example: Create a USDC margin pool
createUsdcMarginPool = (tx: Transaction) => {
	const coinKey = 'USDC';

	// Create pool configuration
	const poolConfig = tx.add(
		this.maintainerContract.newProtocolConfig(
			coinKey,
			{
				supplyCap: 10_000_000, // 10M USDC
				maxUtilizationRate: 0.8, // 80%
				referralSpread: 0.1, // 10% protocol spread
				minBorrow: 100, // 100 USDC minimum
			},
			{
				baseRate: 0.02, // 2% base rate
				baseSlope: 0.1, // 10% slope before kink
				optimalUtilization: 0.8, // 80% kink point
				excessSlope: 1.0, // 100% slope after kink
			},
		),
	);

	// Create the pool
	tx.add(this.maintainerContract.createMarginPool(coinKey, poolConfig));
};
```

### Enable a DeepBook pool for borrowing

```tsx
// Example: Allow SUI/USDC pool to borrow from USDC margin pool
enablePoolForBorrowing = (tx: Transaction) => {
	const deepbookPoolKey = 'SUI_DBUSDC';
	const coinKey = 'USDC';
	const marginPoolCapId = '0x...'; // Margin pool cap ID

	tx.add(
		this.maintainerContract.enableDeepbookPoolForLoan(deepbookPoolKey, coinKey, marginPoolCapId),
	);
};
```

### Update interest rate parameters

```tsx
// Example: Update USDC margin pool interest rates
updateInterestRates = (tx: Transaction) => {
	const coinKey = 'USDC';
	const marginPoolCapId = '0x...';

	tx.add(
		this.maintainerContract.updateInterestParams(coinKey, marginPoolCapId, {
			baseRate: 0.03, // Increase to 3% base rate
			baseSlope: 0.12, // Increase slope
			optimalUtilization: 0.75, // Lower kink to 75%
			excessSlope: 1.5, // Steeper excess slope
		}),
	);
};
```

### Update margin pool configuration

```tsx
// Example: Update USDC margin pool limits
updatePoolConfig = (tx: Transaction) => {
	const coinKey = 'USDC';
	const marginPoolCapId = '0x...';

	tx.add(
		this.maintainerContract.updateMarginPoolConfig(coinKey, marginPoolCapId, {
			supplyCap: 20_000_000, // Increase to 20M USDC
			maxUtilizationRate: 0.85, // Allow 85% utilization
			referralSpread: 0.12, // Increase protocol spread
			minBorrow: 50, // Lower minimum to 50 USDC
		}),
	);
};
```

### Complete pool setup workflow

```tsx
// Example: Complete workflow for setting up a new margin pool
setupNewMarginPool = (tx: Transaction) => {
	const coinKey = 'SUI';

	// Step 1: Create protocol config
	const poolConfig = tx.add(
		this.maintainerContract.newProtocolConfig(
			coinKey,
			{
				supplyCap: 1_000_000, // 1M SUI
				maxUtilizationRate: 0.75,
				referralSpread: 0.1,
				minBorrow: 10,
			},
			{
				baseRate: 0.01,
				baseSlope: 0.08,
				optimalUtilization: 0.8,
				excessSlope: 0.8,
			},
		),
	);

	// Step 2: Create the margin pool
	tx.add(this.maintainerContract.createMarginPool(coinKey, poolConfig));

	// Step 3: Enable specific DeepBook pools for borrowing
	const marginPoolCapId = '0x...'; // Get from pool creation event
	tx.add(this.maintainerContract.enableDeepbookPoolForLoan('SUI_DBUSDC', coinKey, marginPoolCapId));
	tx.add(this.maintainerContract.enableDeepbookPoolForLoan('SUI_USDT', coinKey, marginPoolCapId));
};
```

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/packages/deepbook_margin"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>
<RelatedLink
	href="https://www.npmjs.com/package/@mysten/deepbook-v3"
	label="DeepBookV3 SDK node package"
	desc="The DeepBookV3 SDK node package on NPM."
/>

>>>> sui/docs/content/standards/deepbook-margin-sdk/margin-manager.mdx
---
title: Margin Manager SDK
sidebar_label: Margin Manager
description: Learn how to use the DeepBook Margin SDK to manage margin accounts and leveraged positions.
keywords:
  [
    margin manager,
    margin trading,
    leveraged trading,
    borrow,
    repay,
    liquidation,
    deposit,
    withdraw,
    deepbook margin sdk,
  ]
---

Managing margin accounts is essential for leveraged trading on DeepBook. The Margin Manager SDK provides functions for creating margin managers, depositing collateral, borrowing assets, and managing risk.

## Margin Manager functions

The DeepBook Margin SDK provides the following functions for managing margin accounts.

### `newMarginManager`

Use `newMarginManager` to create and share a new margin manager in one transaction. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the DeepBook pool.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="newMarginManager" signatureOnly />

### `newMarginManagerWithInitializer`

Use `newMarginManagerWithInitializer` to create a margin manager and return it with an initializer. You must call `shareMarginManager` afterward to share it. The call returns an object with `manager` and `initializer`.

**Parameters**

- `poolKey`: String that identifies the DeepBook pool.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="newMarginManagerWithInitializer" signatureOnly />

### `shareMarginManager`

Use `shareMarginManager` to share a margin manager created with `newMarginManagerWithInitializer`. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the DeepBook pool.
- `manager`: `TransactionArgument` representing the margin manager.
- `initializer`: `TransactionArgument` representing the initializer.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="shareMarginManager" signatureOnly />

### `depositBase`, `depositQuote`, `depositDeep`

Use these functions to deposit assets into a margin manager. The call returns a function that takes a `Transaction` object.

**Parameters**

- `managerKey`: String that identifies the margin manager.
- `amount`: Number representing the amount to deposit.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="depositBase,depositQuote,depositDeep" signatureOnly />

### `withdrawBase`, `withdrawQuote`, `withdrawDeep`

Use these functions to withdraw assets from a margin manager. Withdrawals are subject to risk ratio limits. The call returns a function that takes a `Transaction` object.

**Parameters**

- `managerKey`: String that identifies the margin manager.
- `amount`: Number representing the amount to withdraw.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="withdrawBase,withdrawQuote,withdrawDeep" signatureOnly />

### `borrowBase`, `borrowQuote`

Use these functions to borrow assets from margin pools. Borrowing is subject to risk ratio limits. The call returns a function that takes a `Transaction` object.

**Parameters**

- `managerKey`: String that identifies the margin manager.
- `amount`: Number representing the amount to borrow.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="borrowBase,borrowBase" signatureOnly />

### `repayBase`, `repayQuote`

Use these functions to repay borrowed assets. If no amount is specified, it repays the maximum available balance up to the total debt. The call returns a function that takes a `Transaction` object.

**Parameters**

- `managerKey`: String that identifies the margin manager.
- `amount`: Optional number representing the amount to repay.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="repayBase,repayQuote" signatureOnly />

### `liquidate`

Use `liquidate` to liquidate an undercollateralized margin manager. The call returns a function that takes a `Transaction` object.

**Parameters**

- `managerAddress`: String representing the address of the margin manager to liquidate.
- `poolKey`: String that identifies the DeepBook pool.
- `debtIsBase`: Boolean indicating whether the debt is in the base asset.
- `repayCoin`: `TransactionArgument` representing the coin to use for repayment.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="liquidate" signatureOnly />

## Read-only functions

The following functions query margin manager state without modifying it.

### `owner`, `deepbookPool`, `marginPoolId`

Query basic margin manager information.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="ownerByPoolKey,deepbookPool,marginPoolId" signatureOnly />

### `borrowedShares`, `borrowedBaseShares`, `borrowedQuoteShares`, `hasBaseDebt`

Query borrowed position information.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="borrowedShares,borrowedBaseShares,borrowedQuoteShares,hasBaseDebt" signatureOnly />

### `balanceManager`, `calculateAssets`, `calculateDebts`

Query balance and debt information.

<ImportContent source="packages/deepbook-v3/src/transactions/marginManager.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="balanceManager,calculateAssets,calculateDebts" signatureOnly />

## Examples

The following examples demonstrate common margin manager operations.

### Create a margin manager

```tsx
/**
 * @description Create a new margin manager
 * @param {string} poolKey The key to identify the pool
 * @returns A function that takes a Transaction object
 */
newMarginManager = (poolKey: string) => (tx: Transaction) => {};

// Example usage
createMarginManager = (tx: Transaction) => {
	const poolKey = 'SUI_DBUSDC';
	tx.add(this.marginContract.newMarginManager(poolKey));
};
```

### Deposit collateral

```tsx
// Example: Deposit 100 SUI as collateral
depositCollateral = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	tx.add(this.marginContract.depositBase(managerKey, 100));
};
```

### Borrow assets

```tsx
// Example: Borrow 500 USDC
borrowFunds = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	tx.add(this.marginContract.borrowQuote(managerKey, 500));
};
```

### Repay loan

```tsx
// Example: Repay all borrowed quote assets
repayLoan = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	// No amount specified = repay all
	tx.add(this.marginContract.repayQuote(managerKey));
};
```

### Liquidate a position

```tsx
// Example: Liquidate an undercollateralized position
liquidatePosition = (tx: Transaction) => {
	const managerAddress = '0x...'; // Address of margin manager to liquidate
	const poolKey = 'SUI_DBUSDC';
	const debtIsBase = false; // Debt is in USDC (quote)
	const repayCoin = tx.splitCoins(tx.gas, [500 * 1_000_000]); // 500 USDC
	tx.add(this.marginContract.liquidate(managerAddress, poolKey, debtIsBase, repayCoin));
};
```

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/packages/deepbook_margin"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>
<RelatedLink
	href="https://www.npmjs.com/package/@mysten/deepbook-v3"
	label="DeepBookV3 SDK node package"
	desc="The DeepBookV3 SDK node package on NPM."
/>

>>>> sui/docs/content/standards/deepbook-margin-sdk/margin-pool.mdx
---
title: Margin Pool SDK
sidebar_label: Margin Pool
description: Learn how to use the DeepBook Margin SDK to supply liquidity and manage positions in margin pools.
keywords:
  [
    margin pool,
    liquidity,
    supply,
    withdraw,
    supplier cap,
    referral,
    interest rate,
    utilization rate,
    deepbook margin sdk,
  ]
---

Supplying liquidity to margin pools enables lenders to earn interest on their assets while providing borrowing capacity for margin traders. The Margin Pool SDK provides functions for managing liquidity positions and earning referral fees.

## Margin Pool functions

The DeepBook Margin SDK provides the following functions for interacting with margin pools.

### `mintSupplierCap`

Use `mintSupplierCap` to create a new supplier capability that can be used to supply and withdraw from margin pools. One `SupplierCap` can be used across multiple margin pools. The call returns a function that takes a `Transaction` object.

<ImportContent source="packages/deepbook-v3/src/transactions/marginPool.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="mintSupplierCap" signatureOnly />

### `supplyToMarginPool`

Use `supplyToMarginPool` to supply assets to a margin pool and earn interest. You can optionally provide a referral ID to share fees with the referrer. The call returns a function that takes a `Transaction` object.

**Parameters**

- `coinKey`: String that identifies the asset type.
- `supplierCap`: `TransactionObjectArgument` representing the supplier cap.
- `amountToDeposit`: Number representing the amount to supply.
- `referralId`: Optional string representing the referral ID.

<ImportContent source="packages/deepbook-v3/src/transactions/marginPool.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="supplyToMarginPool" signatureOnly />

### `withdrawFromMarginPool`

Use `withdrawFromMarginPool` to withdraw supplied assets from a margin pool. If no amount is specified, it withdraws all available shares. The call returns a function that takes a `Transaction` object.

**Parameters**

- `coinKey`: String that identifies the asset type.
- `supplierCap`: `TransactionObjectArgument` representing the supplier cap.
- `amountToWithdraw`: Optional number representing the amount to withdraw.

<ImportContent source="packages/deepbook-v3/src/transactions/marginPool.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="withdrawFromMarginPool" signatureOnly />

### `mintSupplyReferral`

Use `mintSupplyReferral` to create a supply referral for earning fees. The call returns a function that takes a `Transaction` object.

**Parameters**

- `coinKey`: String that identifies the asset type.

<ImportContent source="packages/deepbook-v3/src/transactions/marginPool.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="mintSupplyReferral" signatureOnly />

### `withdrawReferralFees`

Use `withdrawReferralFees` to withdraw accumulated referral fees. The call returns a function that takes a `Transaction` object.

**Parameters**

- `coinKey`: String that identifies the asset type.
- `referralId`: String representing the referral ID.

<ImportContent source="packages/deepbook-v3/src/transactions/marginPool.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="withdrawReferralFees" signatureOnly />

## Read-only functions

The following functions query margin pool state without modifying it.

### Pool information

Query basic pool information and configuration.

<ImportContent source="packages/deepbook-v3/src/transactions/marginPool.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="getId,deepbookPoolAllowed,supplyCap,maxUtilizationRate,protocolSpread,minBorrow" signatureOnly />

### Supply and borrow metrics

Query current supply and borrow amounts and shares.

<ImportContent source="packages/deepbook-v3/src/transactions/marginPool.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="totalSupply,supplyShares,totalBorrow,borrowShares,lastUpdateTimestamp" signatureOnly />

### Interest rate

Query the current interest rate based on utilization.

<ImportContent source="packages/deepbook-v3/src/transactions/marginPool.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="interestRate" signatureOnly />

### User positions

Query a supplier's position in the pool.

<ImportContent source="packages/deepbook-v3/src/transactions/marginPool.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="userSupplyShares,userSupplyAmount" signatureOnly />

## Examples

The following examples demonstrate common margin pool operations.

### Create a supplier cap

```tsx
/**
 * @description Mint a supplier cap for margin pool
 * @returns A function that takes a Transaction object
 */
mintSupplierCap = () => (tx: Transaction) => {};

// Example usage
createSupplierCap = (tx: Transaction) => {
	const supplierCap = tx.add(this.marginPoolContract.mintSupplierCap());
	// Transfer to user or store for later use
	tx.transferObjects([supplierCap], tx.pure.address(this.config.address));
};
```

### Supply liquidity

```tsx
// Example: Supply 1000 USDC to the margin pool
supplyLiquidity = (tx: Transaction) => {
	const coinKey = 'USDC';
	const supplierCapId = '0x...'; // ID of your supplier cap
	const supplierCap = tx.object(supplierCapId);
	const amountToSupply = 1000;

	tx.add(
		this.marginPoolContract.supplyToMarginPool(
			coinKey,
			supplierCap,
			amountToSupply,
			// Optional: provide referral ID
		),
	);
};
```

### Supply with referral

```tsx
// Example: Supply 1000 USDC with a referral
supplyWithReferral = (tx: Transaction) => {
	const coinKey = 'USDC';
	const supplierCapId = '0x...';
	const supplierCap = tx.object(supplierCapId);
	const referralId = '0x...'; // Referral object ID

	tx.add(
		this.marginPoolContract.supplyToMarginPool(
			coinKey,
			supplierCap,
			1000,
			referralId, // Referral will earn fees
		),
	);
};
```

### Withdraw liquidity

```tsx
// Example: Withdraw 500 USDC from the margin pool
withdrawLiquidity = (tx: Transaction) => {
	const coinKey = 'USDC';
	const supplierCapId = '0x...';
	const supplierCap = tx.object(supplierCapId);

	tx.add(this.marginPoolContract.withdrawFromMarginPool(coinKey, supplierCap, 500));
};

// Example: Withdraw all available liquidity
withdrawAll = (tx: Transaction) => {
	const coinKey = 'USDC';
	const supplierCapId = '0x...';
	const supplierCap = tx.object(supplierCapId);

	// No amount specified = withdraw all
	tx.add(this.marginPoolContract.withdrawFromMarginPool(coinKey, supplierCap));
};
```

### Create and manage referrals

```tsx
// Example: Create a supply referral
createReferral = (tx: Transaction) => {
	const coinKey = 'USDC';
	tx.add(this.marginPoolContract.mintSupplyReferral(coinKey));
};

// Example: Withdraw referral fees
claimReferralFees = (tx: Transaction) => {
	const coinKey = 'USDC';
	const referralId = '0x...'; // Your referral object ID
	tx.add(this.marginPoolContract.withdrawReferralFees(coinKey, referralId));
};
```

### Query pool state

```tsx
// Example: Check interest rate and utilization
checkPoolMetrics = async (tx: Transaction) => {
	const coinKey = 'USDC';

	// Get total supply and borrow
	const totalSupply = tx.add(this.marginPoolContract.totalSupply(coinKey));
	const totalBorrow = tx.add(this.marginPoolContract.totalBorrow(coinKey));

	// Get current interest rate
	const interestRate = tx.add(this.marginPoolContract.interestRate(coinKey));

	// Query user position
	const supplierCapId = '0x...';
	const userShares = tx.add(this.marginPoolContract.userSupplyShares(coinKey, supplierCapId));
	const userAmount = tx.add(this.marginPoolContract.userSupplyAmount(coinKey, supplierCapId));
};
```

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/packages/deepbook_margin"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>
<RelatedLink
	href="https://www.npmjs.com/package/@mysten/deepbook-v3"
	label="DeepBookV3 SDK node package"
	desc="The DeepBookV3 SDK node package on NPM."
/>

>>>> sui/docs/content/standards/deepbook-margin-sdk/orders.mdx
---
title: Orders SDK
sidebar_label: Orders
description: Learn how to use the DeepBook Margin SDK to place and manage orders with margin managers.
keywords:
  [
    margin orders,
    limit orders,
    market orders,
    reduce only,
    cancel orders,
    modify orders,
    staking,
    governance,
    deepbook margin sdk,
  ]
---

Placing and managing orders through margin managers enables leveraged trading on DeepBook. The Orders SDK provides functions for placing limit and market orders, managing positions, and participating in governance.

## Order functions

The DeepBook Margin SDK provides the following functions for managing orders through margin managers.

### `placeLimitOrder`

Use `placeLimitOrder` to place a limit order through a margin manager. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `PlaceMarginLimitOrderParams` object containing:
  - `poolKey`: String that identifies the DeepBook pool
  - `marginManagerKey`: String that identifies the margin manager
  - `clientOrderId`: String for the client-side order ID
  - `price`: Number representing the order price
  - `quantity`: Number representing the order quantity
  - `isBid`: Boolean indicating if this is a buy order
  - `expiration`: Optional number for order expiration timestamp
  - `orderType`: Optional `OrderType` enum
  - `selfMatchingOption`: Optional `SelfMatchingOptions` enum
  - `payWithDeep`: Optional boolean to pay fees with DEEP tokens

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="placeLimitOrder" signatureOnly />

### `placeMarketOrder`

Use `placeMarketOrder` to place a market order through a margin manager. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `PlaceMarginMarketOrderParams` object containing similar parameters to limit orders (without price and expiration).

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="placeMarketOrder" signatureOnly />

### `placeReduceOnlyLimitOrder`

Use `placeReduceOnlyLimitOrder` to place a limit order that can only reduce your existing debt position. Useful when margin trading is disabled and you need to close positions. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `PlaceMarginLimitOrderParams` object (same as `placeLimitOrder`).

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="placeReduceOnlyLimitOrder" signatureOnly />

### `placeReduceOnlyMarketOrder`

Use `placeReduceOnlyMarketOrder` to place a market order that can only reduce your existing debt position. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `PlaceMarginMarketOrderParams` object (same as `placeMarketOrder`).

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="placeReduceOnlyMarketOrder" signatureOnly />

### `modifyOrder`

Use `modifyOrder` to modify the quantity of an existing order. The call returns a function that takes a `Transaction` object.

:::warning
The `orderId` is the protocol `orderId` generated during order placement, which is different from the client `orderId`.
:::

**Parameters**

- `marginManagerKey`: String that identifies the margin manager.
- `orderId`: String of the protocol order ID.
- `newQuantity`: Number representing the new order quantity.

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="modifyOrder" signatureOnly />

### `cancelOrder`, `cancelOrders`, `cancelAllOrders`

Use these functions to cancel orders for a margin manager. The call returns a function that takes a `Transaction` object.

**Parameters**

- `marginManagerKey`: String that identifies the margin manager.
- `orderId` (cancelOrder only): String of the protocol order ID.
- `orderIds` (cancelOrders only): Array of protocol order IDs.

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="cancelOrder,cancelOrders,cancelAllOrders" signatureOnly />

### `withdrawSettledAmounts`

Use `withdrawSettledAmounts` to withdraw settled amounts from completed trades. The call returns a function that takes a `Transaction` object.

**Parameters**

- `marginManagerKey`: String that identifies the margin manager.

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="withdrawSettledAmounts" signatureOnly />

### `stake`, `unstake`

Use these functions to stake and unstake DEEP tokens through the margin manager for trading fee benefits. The call returns a function that takes a `Transaction` object.

**Parameters**

- `marginManagerKey`: String that identifies the margin manager.
- `stakeAmount` (stake only): Number representing the amount to stake.

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="stake,unstake" signatureOnly />

### `submitProposal`, `vote`

Use these functions to participate in pool governance through the margin manager. The call returns a function that takes a `Transaction` object.

**Parameters**

- `marginManagerKey`: String that identifies the margin manager.
- `params` (submitProposal): `MarginProposalParams` object with `takerFee`, `makerFee`, and `stakeRequired`.
- `proposalId` (vote): String representing the proposal ID.

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="submitProposal,vote" signatureOnly />

### `claimRebate`

Use `claimRebate` to claim trading rebates earned through the margin manager. The call returns a function that takes a `Transaction` object.

**Parameters**

- `marginManagerKey`: String that identifies the margin manager.

<ImportContent source="packages/deepbook-v3/src/transactions/poolProxy.ts" mode="code" org="MystenLabs" repo="ts-sdks" fun="claimRebate" signatureOnly />

## Examples

The following examples demonstrate common margin order operations.

### Place a limit order

```tsx
// Params for limit order
interface PlaceMarginLimitOrderParams {
	poolKey: string;
	marginManagerKey: string;
	clientOrderId: string;
	price: number;
	quantity: number;
	isBid: boolean;
	expiration?: number | bigint;
	orderType?: OrderType;
	selfMatchingOption?: SelfMatchingOptions;
	payWithDeep?: boolean;
}

// Example: Place a buy limit order for 10 SUI at $2.50
placeLimitOrder = (tx: Transaction) => {
	const poolKey = 'SUI_DBUSDC';
	const managerKey = 'MARGIN_MANAGER_1';
	tx.add(
		this.poolProxyContract.placeLimitOrder({
			poolKey,
			marginManagerKey: managerKey,
			clientOrderId: '12345',
			price: 2.5,
			quantity: 10,
			isBid: true,
			payWithDeep: true,
		}),
	);
};
```

### Place a market order

```tsx
// Example: Place a market sell order for 5 SUI
placeMarketOrder = (tx: Transaction) => {
	const poolKey = 'SUI_DBUSDC';
	const managerKey = 'MARGIN_MANAGER_1';
	tx.add(
		this.poolProxyContract.placeMarketOrder({
			poolKey,
			marginManagerKey: managerKey,
			clientOrderId: '12346',
			quantity: 5,
			isBid: false,
			payWithDeep: true,
		}),
	);
};
```

### Place a reduce-only order

```tsx
// Example: Place a reduce-only limit order to close a position
placeReduceOnly = (tx: Transaction) => {
	const poolKey = 'SUI_DBUSDC';
	const managerKey = 'MARGIN_MANAGER_1';
	tx.add(
		this.poolProxyContract.placeReduceOnlyLimitOrder({
			poolKey,
			marginManagerKey: managerKey,
			clientOrderId: '12347',
			price: 2.6,
			quantity: 10,
			isBid: true, // Buying back to reduce short position
			payWithDeep: true,
		}),
	);
};
```

### Modify and cancel orders

```tsx
// Example: Modify order quantity
modifyExistingOrder = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	const orderId = '123456789'; // Protocol order ID
	const newQuantity = 8; // Reduce from 10 to 8
	tx.add(this.poolProxyContract.modifyOrder(managerKey, orderId, newQuantity));
};

// Example: Cancel a single order
cancelSingleOrder = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	const orderId = '123456789';
	tx.add(this.poolProxyContract.cancelOrder(managerKey, orderId));
};

// Example: Cancel multiple orders
cancelMultipleOrders = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	const orderIds = ['123456789', '987654321'];
	tx.add(this.poolProxyContract.cancelOrders(managerKey, orderIds));
};

// Example: Cancel all orders
cancelAll = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	tx.add(this.poolProxyContract.cancelAllOrders(managerKey));
};
```

### Stake and participate in governance

```tsx
// Example: Stake DEEP tokens
stakeDeep = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	const stakeAmount = 1000; // Stake 1000 DEEP
	tx.add(this.poolProxyContract.stake(managerKey, stakeAmount));
};

// Example: Submit a governance proposal
submitGovernanceProposal = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	tx.add(
		this.poolProxyContract.submitProposal(managerKey, {
			takerFee: 0.0005, // 5 bps
			makerFee: 0.0002, // 2 bps
			stakeRequired: 1000,
		}),
	);
};

// Example: Vote on a proposal
voteOnProposal = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	const proposalId = '0x...';
	tx.add(this.poolProxyContract.vote(managerKey, proposalId));
};

// Example: Claim trading rebates
claimTradingRebate = (tx: Transaction) => {
	const managerKey = 'MARGIN_MANAGER_1';
	tx.add(this.poolProxyContract.claimRebate(managerKey));
};
```

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/packages/deepbook_margin"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>
<RelatedLink
	href="https://www.npmjs.com/package/@mysten/deepbook-v3"
	label="DeepBookV3 SDK node package"
	desc="The DeepBookV3 SDK node package on NPM."
/>

>>>> sui/docs/content/standards/deepbook-margin.mdx
---
title: DeepBook Margin
description: Leveraged trading capabilities for DeepBookV3, enabling users to trade with borrowed funds and increase their buying power.
keywords:
  [
    deepbook margin,
    margin trading,
    leveraged trading,
    deepbookv3,
    collateral,
    liquidation,
    isolated margin,
    deep book,
  ]
---

DeepBook Margin extends the trading capabilities of DeepBookV3 by enabling leveraged trading positions. With margin trading, users can borrow funds to increase their buying power.

## Key features

DeepBook Margin provides the following capabilities:

- **Leveraged positions**: Trade with borrowed funds to increase position sizes beyond available capital
- **Risk management**: Built-in liquidation mechanisms to protect lenders and maintain system solvency
- **Collateral flexibility**: Support for multiple assets as collateral for isolated margin positions
- **Interest accrual**: Transparent interest rate calculations for borrowed funds

## Risk considerations

Margin trading carries additional risks, including the potential for liquidation if positions move against the trader. Users should understand these risks before engaging in margin trading on DeepBookV3.

### Liquidation mechanisms

When a margin position falls below the maintenance margin requirement, the position will be liquidated to protect lenders and maintain system solvency. The liquidation engine operates on-chain through smart contracts, ensuring transparent and fair execution.

### Interest rates

Interest rates for borrowed funds are calculated transparently based on utilization rates and market conditions.

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/packages/deepbook_margin"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>

>>>> sui/docs/content/standards/deepbook-margin/design.mdx
---
title: Design
description: Learn about DeepBook Margin design, including MarginPool, MarginManager, and MarginRegistry shared objects.
keywords:
  [
    deepbook margin design,
    margin pool,
    margin manager,
    margin registry,
    leveraged trading,
    lending protocol,
    state,
    interest accrual,
  ]
---

At a high level, the DeepBook Margin design revolves around four main shared objects that work together to enable leveraged trading:

- `MarginPool`: A shared object that manages liquidity for a specific asset, handling supply and borrow operations with interest accrual. See the [MarginPool shared object](#margin-pool) section to learn more.
- `MarginManager`: A shared object that wraps a `BalanceManager` and provides capabilities for leveraged trading, including borrowing, repaying, and risk management. See the [MarginManager shared object](#margin-manager) section to learn more.
- `MarginRegistry`: A central registry that manages all margin pools and margin managers, enforces system-wide configurations, and tracks enabled pools. See the [MarginRegistry](#margin-registry) section to learn more.
- `BalanceManager`: Inherited from DeepBookV3, used to source funds for trading. See [BalanceManager](../deepbookv3/balance-manager.mdx) to learn more.

## `MarginPool` shared object {#margin-pool}

The `MarginPool` is responsible for managing liquidity for a single asset type. It consists of several key components:

- [`State`](#state)
- [`ProtocolConfig`](#protocol-config)
- [`ProtocolFees`](#protocol-fees)
- [`PositionManager`](#position-manager)

### State

The `State` component tracks the total supply and borrow amounts, along with their corresponding shares. It uses a shares-based accounting system where:

- **Supply shares:** Represent a lender's proportional ownership of the total supplied assets.
- **Borrow shares:** Represent a borrower's proportional debt obligation.

Interest accrues continuously based on the utilization rate (ratio of borrowed to supplied assets). The state updates on every supply, borrow, repay, and withdraw operation, ensuring interest is always current.

The interest rate is calculated dynamically based on the pool's utilization rate, following a piecewise linear model defined in the `InterestConfig`. Higher utilization leads to higher interest rates, incentivizing more supply and less borrowing.

### Protocol config

The `ProtocolConfig` stores critical parameters that govern the margin pool's behavior:

- **Interest rate parameters:** Base rate, multipliers, and kink points that define the interest rate curve.
- **Supply cap:** Maximum amount that can be supplied to the pool.
- **Max utilization rate:** Upper bound on how much of the pool can be borrowed (ex., 80%).
- **Min borrow amount:** Minimum loan size to prevent spam.
- **Protocol spread:** Percentage of interest that goes to protocol fees.

These parameters can be updated by the pool operator using the `MarginPoolCap`.

### Protocol fees

The `ProtocolFees` component manages the distribution of interest earned. When borrowers pay interest, the protocol spread (ex., 10%) is taken as fees, with the remaining portion (ex., 90%) distributed to suppliers based on their shares.

The protocol spread is then distributed as follows:

- **Referral fees:** 50% of the protocol spread goes to supply referrals who bring in liquidity.
- **Protocol fees:** 25% of the protocol spread goes to the protocol treasury.
- **Maintainer fees:** 25% of the protocol spread goes to the pool maintainer.

For example, if 100 USDC in interest is paid, 10 USDC goes to protocol fees (at 10% spread) and 90 USDC goes to suppliers. The 10 USDC is then split: 5 USDC to referrals, 2.5 USDC to protocol, and 2.5 USDC to the maintainer.

The protocol tracks shares owned by each referral and calculates their proportional fees based on the liquidity they've referred.

### Position Manager

The `PositionManager` tracks individual supplier positions, including:

- Supply shares owned by each `SupplierCap`.
- Referral associations for fee distribution.
- Historical position data.

## `MarginManager` shared object {#margin-manager}

The `MarginManager` wraps a `BalanceManager` and adds margin trading capabilities. Each `MarginManager` is associated with a specific DeepBook pool and tracks:

- **Borrowed shares:** Amount borrowed from base and quote asset margin pools.
- **Margin pool ID:** Which margin pool the current loan is from (if any).
- **DeepBook pool:** Which trading pool this manager is authorized to trade on.

### Borrowing and risk management

A `MarginManager` can only borrow from one margin pool at a time (either base or quote asset). This simplifies risk calculations and prevents complex cross-collateral scenarios.

Risk is measured using a **risk ratio** calculated as:

$$\text{Risk Ratio} = \frac{\text{Total Assets}}{\text{Total Debt}}$$

Different risk ratio thresholds determine allowable actions:

- **Withdraw threshold** (ex., 2.0): Minimum ratio to withdraw collateral.
- **Borrow threshold** (ex., 1.25): Minimum ratio to take out new loans.
- **Target liquidation ratio** (ex., 1.25): Target ratio after partial liquidation.
- **Liquidation threshold** (ex., 1.15): Below this, the position can be liquidated.

### Liquidation process

When a `MarginManager` risk ratio falls below the liquidation threshold, anyone can liquidate the position:

1. The liquidator provides repayment for the debt.
2. The liquidator receives collateral plus a liquidation reward (ex., 5%).
3. The margin pool may also receive a reward (ex., 3%).
4. If assets are insufficient, the pool records bad debt.

Liquidations can be partial or full, depending on the position's health and the liquidator's input.

## `MarginRegistry` {#margin-registry}

The `MarginRegistry` serves as the central coordination point for the margin system:

- **Pool registration:** Tracks all margin pools by asset type.
- **Pool enablement:** Determines which DeepBook pools are enabled for margin trading.
- **Risk parameters:** Stores risk ratios and liquidation parameters per pool.
- **Manager tracking:** Maintains a list of all margin managers.

The registry enforces that only one margin pool can exist per asset type and ensures margin managers can only trade on enabled DeepBook pools.

## Liquidation flow

The following describes a typical liquidation scenario:

1. **Risk calculation:** A `MarginManager` falls below the liquidation threshold due to price movements or interest accrual.
2. **Liquidator action:** A liquidator calls `liquidate()` providing repayment coins.
3. **Order cancellation:** All open orders for the manager are cancelled.
4. **Debt calculation:** The system calculates the maximum debt that can be repaid.
5. **Asset transfer:** Collateral assets are transferred to the liquidator with the reward.
6. **Pool update:** The margin pool processes the repayment and any potential bad debt.
7. **Position update:** The manager's borrowed shares are reduced or cleared.

## Interest accrual

Interest accrues continuously in DeepBook Margin based on the utilization rate:

$$\text{Utilization Rate} = \frac{\text{Total Borrowed}}{\text{Total Supplied}}$$

The interest rate follows a kinked model:

- Below the kink (ex., 80% utilization): Linear growth at a moderate rate.
- Above the kink: Steep linear growth to discourage over-borrowing.

Interest compounds every time the state is updated (on any supply, borrow, repay, or withdraw operation). The protocol spread determines what portion of the interest goes to fees versus suppliers.

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/packages/deepbook_margin"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>

>>>> sui/docs/content/standards/deepbook-margin/margin-manager.mdx
---
title: Margin Manager
description: Learn about the margin manager and how it enables leveraged trading on DeepBook.
keywords:
  [
    margin manager,
    marginmanager,
    leveraged trading,
    margin trading,
    borrow,
    repay,
    liquidation,
    collateral,
    deepbook margin,
  ]
---

The `MarginManager` is a shared object that wraps a `BalanceManager` and provides the necessary capabilities to deposit, withdraw, trade, and manage leveraged positions. It enables users to borrow assets from margin pools to amplify their trading positions while managing risk through collateralization.

Each `MarginManager` is associated with a specific DeepBook pool and can borrow from margin pools that allow trading on that pool. The margin manager tracks borrowed positions and enforces risk ratio limits to maintain system solvency.

## API

Following are the different public functions that the `MarginManager` exposes.

### Create a `MarginManager`

The `new()` function creates and shares a `MarginManager` in one transaction. It validates that margin trading is enabled for the specified pool.

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="new"
	noComments
/>

### Create a `MarginManager` with initializer

The `new_with_initializer()` function creates a `MarginManager` and returns it along with an initializer hot potato. The initializer ensures the margin manager is properly shared after creation using the `share()` function.

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="new_with_initializer,share"
	noComments
/>

### Set or unset referral

The owner of a `MarginManager` can set or unset a referral for trading fee benefits.

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="set_referral,unset_referral"
/>

### Deposit funds

Only the owner can deposit funds into the `MarginManager`. The deposited asset must be either the base asset, quote asset, or DEEP token.

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="deposit"
/>

### Withdraw funds

Only the owner can withdraw funds from the `MarginManager`. Withdrawals are subject to risk ratio limits when the manager has active loans.

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="withdraw"
/>

### Borrow assets

Borrow base or quote assets from margin pools to increase position sizes. Borrowing is subject to risk ratio limits and the margin pool must allow trading on the manager's DeepBook pool.

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="borrow_base,borrow_quote"
/>

### Repay loans

Repay borrowed assets to reduce debt. You can specify an exact amount or repay all available balance up to the total debt.

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="repay_base,repay_quote"
/>

### Liquidate position

Liquidate an undercollateralized margin manager. The liquidator provides repayment and receives collateral assets plus a liquidation reward. The margin pool might also receive a reward or incur bad debt depending on the position's health.

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="liquidate"
/>

### Calculate risk ratio

Returns the risk ratio of the margin manager, which represents the ratio of assets to debt. Higher ratios indicate healthier positions.

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="risk_ratio"
/>

### Read endpoints

<ImportContent
	source="packages/deepbook_margin/sources/margin_manager.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="balance_manager,calculate_assets,calculate_debts,owner,deepbook_pool,margin_pool_id,borrowed_shares,borrowed_base_shares,borrowed_quote_shares,has_base_debt"
/>

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/packages/deepbook_margin"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>

>>>> sui/docs/content/standards/deepbook-margin/margin-pool.mdx
---
title: Margin Pool
description: Learn about margin pools and how they enable liquidity for leveraged trading.
keywords:
  [
    margin pool,
    marginpool,
    liquidity pool,
    lending pool,
    supply,
    borrow,
    interest rate,
    utilization rate,
    deepbook margin,
  ]
---

The `MarginPool` is a shared object that manages liquidity for a specific asset, enabling lenders to supply assets and margin traders to borrow them. Each margin pool tracks supply and borrow positions, accrues interest over time, and enforces risk parameters to maintain system health.

Margin pools use a shares-based accounting system where suppliers receive shares representing their proportion of the total supply. Interest accrues continuously, increasing the value of these shares over time. Borrowers can only borrow from pools that have enabled their specific DeepBook trading pool.

## API

Following are the different public functions that the `MarginPool` exposes.

### Create a margin pool

Creates and registers a new margin pool for a specific asset. Only one margin pool can exist per asset type.

<ImportContent
	source="packages/deepbook_margin/sources/margin_pool.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="create_margin_pool"
	noComments
/>

### Enable or disable DeepBook pools

Control which DeepBook pools can borrow from this margin pool. Only margin managers associated with enabled pools can take loans.

<ImportContent
	source="packages/deepbook_margin/sources/margin_pool.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="enable_deepbook_pool_for_loan,disable_deepbook_pool_for_loan"
/>

### Update pool parameters

Update interest rate parameters and margin pool configuration settings.

<ImportContent
	source="packages/deepbook_margin/sources/margin_pool.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="update_interest_params,update_margin_pool_config"
/>

### Mint a `SupplierCap`

Create a new `SupplierCap` that can be used to supply and withdraw from margin pools. One `SupplierCap` can be used across multiple margin pools.

<ImportContent
	source="packages/deepbook_margin/sources/margin_pool.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="mint_supplier_cap"
/>

### Supply liquidity

Supply assets to the margin pool to earn interest. Returns the total supply shares owned by the supplier after this operation.

<ImportContent
	source="packages/deepbook_margin/sources/margin_pool.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="supply"
/>

### Withdraw liquidity

Withdraw supplied assets from the margin pool. You can specify an exact amount or withdraw all available shares.

<ImportContent
	source="packages/deepbook_margin/sources/margin_pool.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="withdraw"
/>

### Referral system

Create supply referrals and withdraw referral fees. Referrals earn a portion of the interest generated by assets supplied through their referral link.

<ImportContent
	source="packages/deepbook_margin/sources/margin_pool.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="mint_supply_referral,withdraw_referral_fees,admin_withdraw_default_referral_fees"
/>

### Withdraw fees

Withdraw accumulated maintainer and protocol fees from the margin pool.

<ImportContent
	source="packages/deepbook_margin/sources/margin_pool.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="withdraw_maintainer_fees,withdraw_protocol_fees"
/>

### Read endpoints

<ImportContent
	source="packages/deepbook_margin/sources/margin_pool.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="id,deepbook_pool_allowed,total_supply,supply_shares,total_borrow,borrow_shares,last_update_timestamp,supply_cap,protocol_fees,max_utilization_rate,protocol_spread,min_borrow,interest_rate,user_supply_shares,user_supply_amount"
/>

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/packages/deepbook_margin"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>

>>>> sui/docs/content/standards/deepbook-margin/orders.mdx
---
title: Orders
description: Learn how to place and manage orders using margin managers.
keywords:
  [
    orders,
    limit order,
    market order,
    reduce only,
    cancel order,
    modify order,
    margin trading,
    deepbook margin,
  ]
---

The `pool_proxy` module provides wrapper functions for trading with margin managers. These functions enable placing orders, modifying and canceling them, and managing staking and governance participation through a margin manager. All trading operations require the margin manager to be associated with the correct DeepBook pool.

## API

Following are the different public functions for managing orders with margin managers.

### Place orders

Place limit and market orders through a margin manager. Orders can only be placed if margin trading is enabled for the pool.

<ImportContent
	source="packages/deepbook_margin/sources/pool_proxy.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="place_limit_order,place_market_order"
/>

### Place reduce-only orders

Place reduce-only orders that can only decrease your debt position. These orders are useful when margin trading is disabled and you need to close existing positions.

<ImportContent
	source="packages/deepbook_margin/sources/pool_proxy.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="place_reduce_only_limit_order,place_reduce_only_market_order"
/>

### Modify order

Modify an existing order by changing its quantity.

<ImportContent
	source="packages/deepbook_margin/sources/pool_proxy.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="modify_order"
/>

### Cancel orders

Cancel one, multiple, or all orders for the margin manager.

<ImportContent
	source="packages/deepbook_margin/sources/pool_proxy.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="cancel_order,cancel_orders,cancel_all_orders"
/>

### Withdraw settled amounts

Withdraw settled amounts from completed trades back to the margin manager's balance manager.

<ImportContent
	source="packages/deepbook_margin/sources/pool_proxy.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="withdraw_settled_amounts"
/>

### Staking

Stake and unstake DEEP tokens through the margin manager. Note that margin managers for pools with DEEP as base or quote asset cannot stake.

<ImportContent
	source="packages/deepbook_margin/sources/pool_proxy.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="stake,unstake"
/>

### Governance

Submit proposals and vote on governance decisions through the margin manager.

<ImportContent
	source="packages/deepbook_margin/sources/pool_proxy.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="submit_proposal,vote"
/>

### Claim rebates

Claim trading rebates earned through the margin manager.

<ImportContent
	source="packages/deepbook_margin/sources/pool_proxy.move"
	mode="code"
	org="MystenLabs"
	repo="deepbookv3"
	fun="claim_rebates"
/>

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3/tree/main/packages/deepbook_margin"
	label="DeepBook Margin package"
	desc="The DeepBook Margin package on GitHub."
/>


>>>> sui/docs/content/standards/deepbook.mdx
---
title: DeepBookV3
description: A central limit order book that offers features and functionality for marketplaces on Sui. Token exchanges leveraging the layer can feature transparency, a full range of trading options, and customer privacy.
keywords:
  [
    deepbook,
    deep book,
    limit order book,
    order book,
    orderbook,
    deepbookv3,
    deep book v3,
    deep book 3,
    decentralized central limit order book,
    clob,
    DEEP token,
    deep,
    liquidity support,
    digital ledger,
  ]
pagination_prev: null
---

DeepBookV3 is a next-generation decentralized central limit order book (CLOB) built on Sui. DeepBookV3 leverages Sui's parallel execution and low transaction fees to bring a highly performant, low-latency exchange on chain.

The latest version delivers new features including flash loans, governance, improved account abstraction, and enhancements to the existing matching engine. This version also introduces its own tokenomics with the [DEEP token](https://suivision.xyz/coin/0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP), which you can stake for additional benefits.

DeepBookV3 does not include an end-user interface for token trading. Rather, it offers built-in trading functionality that can support token trades from decentralized exchanges, wallets, or other apps. The available SDK abstracts away a lot of the complexities of interacting with the chain and building programmable transaction blocks, lowering the barrier of entry for active market making.

:::info

The documentation refers to the DeepBook standard as "DeepBookV3" to avoid confusion with the recently deprecated version of DeepBook (DeepBookV2).

:::

## DeepBookV3 tokenomics

The DEEP token pays for trading fees on the exchange. Users can pay trading fees using DEEP tokens or input tokens, but owning, using, and staking DEEP continues to provide the most benefits to active DeepBookV3 traders on the Sui network.

As an example, governance determines the fee for paying in DEEP tokens, which is 20% lower than the fee for using input tokens.

Users that stake DEEP can enjoy taker and maker incentives. Taker incentives can reduce trading fees by half, dropping them to as low as 0.25 basis points (bps) on stable pairs and 2.5 bps on volatile pairs. Maker incentives are rebates earned based on maker volume generated.

## Liquidity support

Similar to order books for other market places, DeepBookV3's CLOB architecture enables you to enter market and limit orders. You can sell SUI tokens, referred to as an _ask_, can set your price, referred to as a limit order, or sell at the market's going rate. If you are seeking to buy SUI, referred to as a _bid_, you can pay the current market price or set a limit price. Limit orders only get fulfilled if the CLOB finds a match between a buyer and seller.

If you put in a limit order for 1,000 SUI, and no single seller is currently offering that quantity of tokens, DeepBookV3 automatically pools the current asks to meet the quantity of your bid.

## Transparency and privacy

As a CLOB, DeepBookV3 works like a digital ledger, logging bids and asks in chronological order and automatically finding matches between the two sides. It takes into account user parameters on trades such as prices.

The digital ledger is open so people can view the trades and prices, giving clear proof of fairness. You can use this transparency to create metrics and dashboards to monitor trading activity.

## Documentation

This documentation outlines the design of DeepBookV3, its public endpoints, and provides guidance for integrations. The SDK abstracts away a lot of the complexities of interacting with the chain and building programmable transaction blocks, lowering the barrier of entry for active market making.

## Open source

DeepBookV3 is open for community development. You can use the [Sui Improvement Proposals](https://github.com/sui-foundation/sips?ref=blog.sui.io) (SIPs) process to suggest changes to make DeepBookV3 better.

## Related links

<RelatedLink
	href="https://github.com/MystenLabs/deepbookv3"
	label="DeepBookV3 repository"
	desc="The DeepBookV3 repository on GitHub."
/>

>>>> sui/docs/content/standards/deepbookv3-indexer.mdx
---
title: DeepBookV3 Indexer
sidebar_label: Indexer
description: DeepBookV3 Indexer provides streamlined, real-time access to order book and trading data from the DeepBookV3 protocol. It acts as a centralized service to aggregate and expose critical data points.
keywords: [ DeepBook Indexer, DeepBook, public indexer, viewing pool information, historical volume analysis, volume tracking, balance manager, BalanceManager, trading pairs ]
---

DeepBookV3 Indexer provides streamlined, real-time access to order book and trading data from the DeepBookV3 protocol. It acts as a centralized service to aggregate and expose critical data points for developers, traders, and analysts who interact with DeepBookV3.

DeepBookV3 Indexer simplifies data retrieval by offering endpoints that enable:

-	**Viewing pool information:** Retrieve detailed metadata about all available trading pools, including base and quote assets, tick sizes, and lot sizes.
-	**Historical volume analysis:** Fetch volume metrics for specific pools or balance managers over custom time ranges, with support for interval-based breakdowns.
-	**User-specific volume tracking:** Provide insights into individual trader activities by querying their balance manager-specific volumes.

You can either use a publicly available indexer or spin up your own service. The choice you make depends on a few factors.

Use the public service if:

-	You have standard data needs.
-	Latency and availability provided by the public endpoint meet your requirements.
-	You want to avoid the operational overhead of running your own service.

Run your own indexer if:

-	You require guaranteed uptime and low latency.
-	You have specific customization needs.
-	Your application depends on proprietary features or extended data sets.

## Public DeepBookV3 Indexer

[Mysten Labs](https://www.mystenlabs.com/) provides a public indexer for DeepBookV3. You can access this indexer at the following URL:

```http
https://deepbook-indexer.mainnet.mystenlabs.com/
```

## Asset conversions

Volumes returned by the following endpoints are expressed in the smallest unit of the corresponding asset. 

- `/all_historical_volume`
- `/historical_volume`
- `/historical_volume_by_balance_manager_id`
- `/historical_volume_by_balance_manager_id_with_interval`

Following are the decimal places (scalars) used to determine the base unit for each asset.

| Asset | Scalar |
| --- | --- |
| AUSD | 6 |
| Bridged Eth (bETH) | 8 |
| Deepbook Token (DEEP) | 6 |
| Native USDC | 6 |
| SUI | 9 |
| SuiNS Token (NS) | 6 |
| TYPUS | 9 |
| Wrapped USDC (wUSDC) | 6 |
| Wrapped USDT (wUSDT) | 6 |

To convert the returned volume to the standard asset unit, divide the value by 10^SCALAR. For example:

If the volume returned in the base asset for the SUI/USDC pool is 1,000,000,000 SUI UNIT, the correct volume in SUI is 1,000,000,000 / 10^(SUI_SCALAR) = 1 SUI. Similarly, if the volume returned in the quote asset for the SUI/USDC pool is 1,000,000,000 USDC UNIT, the correct volume is  1,000,000,000 / 10^(USDC_SCALAR) = 1,000 USDC.

Use these conversions to interpret the volumes correctly across all pools and assets.

## API endpoints

You can perform the following tasks using the endpoints that the indexer API for DeepBookV3 provides.

### Get all pool information

```
/get_pools
```

Returns a list of all available pools, each containing detailed information about the base and quote assets, as well as pool parameters like minimum size, lot size, and tick size.

#### Response

```json
[
	{
	  "pool_id": "string",
	  "pool_name": "string",
	  "base_asset_id": "string",
	  "base_asset_decimals": integer,
	  "base_asset_symbol": "string",
	  "base_asset_name": "string",
	  "quote_asset_id": "string",
	  "quote_asset_decimals": integer,
	  "quote_asset_symbol": "string",
	  "quote_asset_name": "string",
	  "min_size": integer,
	  "lot_size": integer,
	  "tick_size": integer
	},
	...
]
```

Each pool object in the response includes the following fields:

-	**pool_id:** ID for the pool.
-	**pool_name:** Name of the pool.
-	**base_asset_id:** ID for the base asset.
-	**base_asset_decimals:** Number of decimals for the base asset.
-	**base_asset_symbol:** Symbol for the base asset.
-	**base_asset_name:** Name of the base asset.
-	**quote_asset_id:** ID for the quote asset.
-	**quote_asset_decimals:** Number of decimals for the quote asset.
-	**quote_asset_symbol:** Symbol for the quote asset.
-	**quote_asset_name:** Name of the quote asset.
-	**min_size:** Minimum trade size for the pool, in smallest units of the base asset.
-	**lot_size:** Minimum increment for trades in this pool, in smallest units of the base asset.
-	**tick_size:** Minimum price increment for trades in this pool.

#### Example

A successful request to the following endpoint

```http
/get_pools
```

produces a response similar to

```json
[
	{
		"pool_id": "0xb663828d6217467c8a1838a03793da896cbe745b150ebd57d82f814ca579fc22",
		"pool_name": "DEEP_SUI",
		"base_asset_id": "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP",
		"base_asset_decimals": 6,
		"base_asset_symbol": "DEEP",
		"base_asset_name": "DeepBook Token",
		"quote_asset_id": "0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI",
		"quote_asset_decimals": 9,
		"quote_asset_symbol": "SUI",
		"quote_asset_name": "Sui",
		"min_size": 100000000,
		"lot_size": 10000000,
		"tick_size": 10000000
	},
	{
		"pool_id": "0xf948981b806057580f91622417534f491da5f61aeaf33d0ed8e69fd5691c95ce",
		"pool_name": "DEEP_USDC",
		"base_asset_id": "0xdeeb7a4662eec9f2f3def03fb937a663dddaa2e215b8078a284d026b7946c270::deep::DEEP",
		"base_asset_decimals": 6,
		"base_asset_symbol": "DEEP",
		"base_asset_name": "DeepBook Token",
		"quote_asset_id": "0xdba34672e30cb065b1f93e3ab55318768fd6fef66c15942c9f7cb846e2f900e7::usdc::USDC",
		"quote_asset_decimals": 6,
		"quote_asset_symbol": "USDC",
		"quote_asset_name": "USDC",
		"min_size": 100000000,
		"lot_size": 10000000,
		"tick_size": 10000
	}
]
```

### Get historical volume for pool in a specific time range

```http
/historical_volume/:pool_names?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

Use this endpoint to get historical volume for pools for a specific time range. Delimit the	`pool_names` with commas, and use Unix timestamp seconds for `start_time` and `end_time` values. 

By default, this endpoint retrieves the last 24-hour trading volume in the quote asset for specified pools. If you want to query the base asset instead, set `volume_in_base` to `true`.

#### Response

Returns the historical volume for each specified pool within the given time range.

```json
{
	"pool_name_1": total_pool1_volume,
	"pool_name_2": total_pool2_volume,
	...
}
```

#### Example

A successful request to the following endpoint

```http
/historical_volume/DEEP_SUI,SUI_USDC?start_time=1731260703&end_time=1731692703&volume_in_base=true
```

produces a response similar to

```json
{
	"DEEP_SUI": 22557460000000,
	"SUI_USDC": 19430171000000000
}
```

### Get historical volume for all pools

```http
/all_historical_volume?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

Use this endpoint to get historical volume for all pools. Include the optional `start_time` and `end_time` values as Unix timestamp seconds to retrieve the volume within that time range.

By default, this endpoint retrieves the last 24-hour trading volume in the quote asset. If you want to query the base asset instead, set `volume_in_base` to `true`.

#### Response

Returns the historical volume for all available pools within the time range (if provided).

```json
{
	"pool_name_1": total_pool1_volume,
	"pool_name_2": total_pool2_volume
}
```

#### Example

A successful request to the following endpoint

```http
/all_historical_volume?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

produces a response similar to

```json
{
	"DEEP_SUI": 22557460000000,
	"WUSDT_USDC": 10265000000,
	"NS_USDC": 4399650900000,
	"NS_SUI": 6975475200000,
	"SUI_USDC": 19430171000000000,
	"WUSDC_USDC": 23349574900000,
	"DEEP_USDC": 130000590000000
}
```

### Get historical volume by balance manager

```http
/historical_volume_by_balance_manager_id/:pool_names/:balance_manager_id?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

Get historical volume by balance manager for a specific time range. Delimit the	`pool_names` with commas, and use Unix timestamp seconds for the optional `start_time` and `end_time` values.

By default, this endpoint retrieves the last 24-hour trading volume for the balance manager in the quote asset for specified pools. If you want to query the base asset instead, set `volume_in_base` to `true`.

#### Response

```json
{
	"pool_name_1": [maker_volume, taker_volume],
	"pool_name_2": â€¦
}
```

#### Example

A successful request to the following endpoint

```http
/historical_volume_by_balance_manager_id/SUI_USDC,DEEP_SUI/0x344c2734b1d211bd15212bfb7847c66a3b18803f3f5ab00f5ff6f87b6fe6d27d?start_time=1731260703&end_time=1731692703&volume_in_base=true
```

produces a response similar to

```json
{
	"DEEP_SUI": [
		14207960000000,
		3690000000
	],
	"SUI_USDC": [
		2089300100000000,
		17349400000000
	]
}
```

### Get historical volume by balance manager within a specific time range and intervals

```http
/historical_volume_by_balance_manager_id_with_interval/:pool_names/:balance_manager_id?start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&interval=<UNIX_TIMESTAMP_SECONDS>&volume_in_base=<BOOLEAN>
```

Get historical volume by `BalanceManager` for a specific time range with intervals. Delimit `pool_names` with commas and use Unix timestamp seconds for the optional `start_time` and `end_time` values. Use number of seconds for the `interval` value. As a simplified interval example, if `start_time` is 5, `end_time` is 10, and `interval` is 2, then the response includes volume from 5 to 7 and 7 to 9, with start time of the periods as keys.

By default, this endpoint retrieves the last 24-hour trading volume for the balance manager in the quote asset for specified pools. If you want to query the base asset instead, set `volume_in_base` to `true`.

#### Response

```json
{
	"[time_1_start, time_1_end]": {
		"pool_name_1": [maker_volume, taker_volume],
		"pool_name_2": â€¦
	},
	"[time_2_start, time_2_end]": {
		"pool_name_1": [maker_volume, taker_volume],
		"pool_name_2": â€¦
	}
}
```

#### Example

A successful request to the following endpoint with an interval of 24 hours

```http
/historical_volume_by_balance_manager_id_with_interval/USDC_DEEP,SUI_USDC/0x344c2734b1d211bd15212bfb7847c66a3b18803f3f5ab00f5ff6f87b6fe6d27d?start_time=1731460703&end_time=1731692703&interval=86400&volume_in_base=true
```
produces a response similar to

```json
{
	"[1731460703, 1731547103]": {
		"SUI_USDC": [
			505887400000000,
			2051300000000
		]
	},
	"[1731547103, 1731633503]": {
		"SUI_USDC": [
			336777500000000,
			470600000000
		]
	}
}
```

### Get summary 

```http
/summary
```

Returns a summary in JSON for all trading pairs in DeepBookV3.

#### Response

Each summary object has the following form. The order of fields in the JSON object is not guaranteed.

```json
{
	"trading_pairs": "string",
	"quote_currency": "string",
	"last_price": float,
	"lowest_price_24h": float,
	"highest_bid": float,
	"base_volume": float,
	"price_change_percent_24h": float,
	"quote_volume": float,
	"lowest_ask": float,
	"highest_price_24h": float,
	"base_currency": "string"
}
```

#### Example

A successful request to 

```
/summary
```
produces a response similar to
```json
[
	{
    "trading_pairs": "AUSD_USDC",
    "quote_currency": "USDC",
    "last_price": 1.0006,
    "lowest_price_24h": 0.99905,
    "highest_bid": 1.0006,
    "base_volume": 1169.2,
    "price_change_percent_24h": 0.07501125168773992,
    "quote_volume": 1168.961637,
    "lowest_ask": 1.0007,
    "highest_price_24h": 1.00145,
    "base_currency": "AUSD"
  },
  {
    "quote_volume": 4063809.55231,
    "lowest_price_24h": 0.9999,
    "highest_price_24h": 1.009,
    "base_volume": 4063883.6,
    "quote_currency": "USDC",
    "price_change_percent_24h": 0.0,
    "base_currency": "WUSDC",
    "trading_pairs": "WUSDC_USDC",
    "last_price": 1.0,
    "highest_bid": 1.0,
    "lowest_ask": 1.0001
  },
  {
		"price_change_percent_24h": 0.0,
		"quote_currency": "USDC",
		"lowest_price_24h": 0.0,
		"quote_volume": 0.0,
		"base_volume": 0.0,
		"highest_price_24h": 0.0,
		"lowest_ask": 1.04,
		"last_price": 1.04,
		"base_currency": "WUSDT",
		"highest_bid": 0.90002,
		"trading_pairs": "WUSDT_USDC"
	},
	...
]
```

### Get ticker information

```http
/ticker
```

Returns all trading pairs volume (already scaled), last price, and `isFrozen` value. Possible values for `isFrozen` is either:
- `0`: Pool is active
- `1`: Pool is inactive

#### Response

```json
{
  "TRADING_PAIR": {
    "base_volume": float,
    "quote_volume": float,
    "last_price": float,
    "isFrozen": integer (0 | 1)
  }
}
```

#### Example

A successful request to 

```
/ticker
```
produces a response similar to

```json
{
	"DEEP_USDC": {
		"last_price": 0.07055,
		"base_volume": 43760440.0,
		"quote_volume": 3096546.9161,
		"isFrozen": 0
	},
	"NS_SUI": {
		"last_price": 0.08323,
		"base_volume": 280820.8,
		"quote_volume": 23636.83837,
		"isFrozen": 0
	},
	...
}
```

### Get trades

```http
/trades/:pool_name?limit=<INTEGER>&start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&maker_balance_manager_id=<ID>&taker_balance_manager_id=<ID>
```

Returns the most recent trade in the pool. 

#### Response

```json
[
    {
        "trade_id": "string",
        "base_volume": integer,
        "quote_volume": integer,
        "price": integer,
        "type": "string",
        "timestamp": integer,
        "maker_order_id": "string",
        "taker_order_id": "string",
        "maker_balance_manager_id": "string",
        "taker_balance_manager_id": "string"
    }
]
```

The `timestamp` value is in Unix milliseconds.

#### Example

A successful request to 

```http
trades/SUI_USDC?limit=2&start_time=1738093405&end_time=1738096485&maker_balance_manager_id=0x344c2734b1d211bd15212bfb7847c66a3b18803f3f5ab00f5ff6f87b6fe6d27d&taker_balance_manager_id=0x47dcbbc8561fe3d52198336855f0983878152a12524749e054357ac2e3573d58
```

produces a response similar to

```json
[
    {
        "trade_id": "136321457151457660152049680",
        "base_volume": 405,
        "quote_volume": 1499,
        "price": 3695,
        "type": "sell",
        "timestamp": 1738096392913,
        "maker_order_id": "68160737799100866923792791",
        "taker_order_id": "170141183460537392451039660509112362617",
        "maker_balance_manager_id": "0x344c2734b1d211bd15212bfb7847c66a3b18803f3f5ab00f5ff6f87b6fe6d27d",
        "taker_balance_manager_id": "0x47dcbbc8561fe3d52198336855f0983878152a12524749e054357ac2e3573d58"
    },
	...
]
```

### Get order updates

```http
/order_updates/:pool_name?limit=<INTEGER>&start_time=<UNIX_TIMESTAMP_SECONDS>&end_time=<UNIX_TIMESTAMP_SECONDS>&status=<"Placed" or "Canceled">&balance_manager_id=<ID>
```

Returns the orders that were recently placed or canceled in the pool

#### Response

```json
[
    {
        "order_id": "string",
        "balance_manager_id": "string",
        "timestamp": integer,
        "original_quantity": integer,
        "remaining_quantity": integer,
        "filled_quantity": integer,
        "price": integer,
        "status": "string",
        "type": "string"
    }
]
```

The `timestamp` value is in Unix milliseconds.

#### Example

A successful request to 

```http
/order_updates/DEEP_USDC?start_time=1738703053&end_time=1738704080&limit=2&status=Placed&balance_manager_id=0xd335e8aa19d6dc04273d77e364c936bad69db4905a4ab3b2733d644dd2b31e0a
```

produces a response similar to

```json
[
    {
        "order_id": "170141183464610341308794360958165054983",
        "balance_manager_id": "0xd335e8aa19d6dc04273d77e364c936bad69db4905a4ab3b2733d644dd2b31e0a",
        "timestamp": 1738704071994,
        "original_quantity": 8910,
        "remaining_quantity": 8910,
        "filled_quantity": 0,
        "price": 22449,
        "status": "Placed",
        "type": "sell"
    },
	...
]
```

### Get order book information

```http
/orderbook/:pool_name?level={1|2}&depth={integer}
```

Returns the bids and asks for the relevant pool. The bids and asks returned are each sorted from best to worst. There are two optional query parameters in the endpoint:

- **level**: The `level` value can be either 1 or 2. 
	- `1`: Only the best bid and ask. 
	- `2`: Arranged by best bids and asks. This is the default value.
- **depth**: The `depth` value can be `0` or greater than `1`. A value of `0` returns the entire order book, and a value greater than `1` returns the specified number of both bids and asks. In other words, if you provide `depth=100`, then your response includes 50 bids and 50 asks. If the `depth` value is odd, it's treated as the next lowest even value. Consequently, `depth=101` also returns 50 bids and 50 asks. If you do not provide a `depth` parameter, the response defaults to all orders in the order book.

#### Response

```json
{
	"timestamp": "string",
	"bids": [
		[
			"string",
			"string"
		],
		[
			"string",
			"string"
		]
	],
	"asks": [
		[
			"string",
			"string"
		],
		[
			"string",
			"string"
		]
	]
}
```

The timestamp returned is a string that represents a Unix timestamp in milliseconds.

#### Example

A successful request to 

```json
/orderbook/SUI_USDC?level=2&depth=4
```

produces a response similar to

```json
{
	"timestamp": "1733874965431",
	"bids": [
		[
			"3.715",
			"2.7"
		],
		[
			"3.713",
			"2294.8"
		]
	],
	"asks": [
		[
			"3.717",
			"0.9"
		],
		[
			"3.718",
			"1000"
		]
	]
}
```

### Get asset information

```http
/assets
```

Returns asset information for all coins being traded on DeepBookV3.

#### Response

Each asset object has the following form:

```json
"ASSET_NAME": {
	"unified_cryptoasset_id": "string",
	"name": "string",
	"contractAddress": "string",
	"contractAddressUrl": "string",
	"can_deposit": "string (true | false)",
	"can_withdraw": "string (true | false)"
}
```

#### Example

A successful request to 

```json
/assets
```

produces a response similar to

```json
{
  "NS": {
    "unified_cryptoasset_id": "32942",
    "name": "Sui Name Service",
    "contractAddress": "0x5145494a5f5100e645e4b0aa950fa6b68f614e8c59e17bc5ded3495123a79178",
    "contractAddressUrl": "https://suiscan.xyz/mainnet/object/0x5145494a5f5100e645e4b0aa950fa6b68f614e8c59e17bc5ded3495123a79178",
    "can_deposit": "true",
    "can_withdraw": "true"
  },
  "AUSD": {
    "unified_cryptoasset_id": "32864",
    "name": "AUSD",
    "contractAddress": "0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2",
    "contractAddressUrl": "https://suiscan.xyz/mainnet/object/0x2053d08c1e2bd02791056171aab0fd12bd7cd7efad2ab8f6b9c8902f14df2ff2",
    "can_deposit": "true",
    "can_withdraw": "true"
  },
	...
}
```

## Related links

<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />
>>>> sui/docs/content/standards/deepbookv3-sdk.mdx
---
title: DeepBookV3 SDK
description: Use the DeepBook TypeScript SDK to interact directly with the DeepBook package. 
keywords: [ deepbook, deep book, deepbook v3, typescript, typescript SDK, mysten/deepbook, deepbookV3 SDK, Coin, Pool, Manager ] 
---

The DeepBookV3 TypeScript SDK abstracts away the transaction calls, allowing for direct interactions with the `DeepBook` package.

- [SDK repository](https://github.com/MystenLabs/ts-sdks/tree/main/packages/deepbook-v3)
- [NPM version](https://www.npmjs.com/package/@mysten/deepbook-v3)

## Install

To use the SDK in your projects, install the `@mysten/deepbook` package.

```sh npm2yarn
npm install @mysten/deepbook-v3
```

## Constants

The DeepBookV3 SDK includes a constants file (`/utils/constants.ts`) that maintains the latest deployed addresses for DeepBookV3, as well as a few staple coins and pools.

<details>
<summary>
`constants.ts`
</summary>

```ts reference
https://github.com/MystenLabs/ts-sdks/blob/main/packages/deepbook-v3/src/utils/constants.ts
```

</details>

## DeepBookClient

To work with DeepBookV3, you must create a `DeepBookClient`. To construct the `DeepBookClient`, pass in a `SuiClient`, the sender address, and environment. The [Sui TypeScript SDK](https://sdk.mystenlabs.com/typescript) provides the `SuiClient` and key functionality necessary to process transactions. The following example imports those libraries, as well.

```tsx
import { DeepBookClient } from '@mysten/deepbook-v3';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';

class DeepBookMarketMaker {
	dbClient: DeepBookClient; // For building transactions
	suiClient: SuiClient; // For executing transactions
	keypair: Ed25519Keypair; // For signing transactions

	constructor(privateKey: string, env: 'testnet' | 'mainnet') {
		this.keypair = this.getSignerFromPK(privateKey);
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: env,
			client: this.suiClient,
		});
	}

	getSignerFromPK = (privateKey: string): Ed25519Keypair => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	getActiveAddress() {
		return this.keypair.toSuiAddress();
	}
}
```

## Keys: Coin, Pool, and Manager {#keys}

Functions that require the input of a coin, pool, or a manager require the key of any such object as the parameter. The SDK manages a `key:value` relationship of this data in memory. Some default data comes with the SDK (as seen in `utils/constants.ts`). Coins are stored in a `CoinMap` and pools in a `PoolMap` in the config.

### Balance manager

Before placing any trade, you must supply a balance manager address to the client. The manager key points to an object defined by the `BalanceManager` interface in the client. [BalanceManager docs](./deepbookv3/balance-manager.mdx). Initialize the balance manager with the client. If you don't create a balance manager, you can rely on the client to create one, but then the user must reinitialize the client.

Example using an existing balance manager:

```tsx
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { config } from 'dotenv';

import { DeepBookClient } from '../src';
import { BalanceManager } from './types';

config();

// Used wherever balance manager key is required
const BALANCE_MANAGER_KEY = 'MANAGER_1';

class DeepBookMarketMaker {
	dbClient: DeepBookClient; // For building transactions
	suiClient: SuiClient; // For executing transactions
	keypair: Ed25519Keypair; // For signing transactions
	env: 'testnet' | 'mainnet';

	constructor(privateKey: string, env: 'testnet' | 'mainnet') {
		this.env = env;
		this.keypair = this.getSignerFromPK(privateKey);
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: env,
			client: this.suiClient,
			balanceManagers: this.getBalanceManagers(),
		});
	}

	getSignerFromPK = (privateKey: string): Ed25519Keypair => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	getActiveAddress() {
		return this.keypair.toSuiAddress();
	}

	getBalanceManagers(): { [key: string]: BalanceManager } {
		// Used wherever balance manager key is required
		const balanceManagerAddress = process.env.BALANCE_MANAGER_ADDRESS;
		const balanceManagerTradeCap = process.env.BALANCE_MANAGER_TRADE_CAP;
		if (!balanceManagerAddress) {
			throw new Error('No balance manager address found');
		}
		return {
			[BALANCE_MANAGER_KEY]: {
				address: balanceManagerAddress,
				tradeCap: balanceManagerTradeCap,
			},
		};
	}
}
```

Example creating a balance manager:

```tsx
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import { decodeSuiPrivateKey } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import { Transaction } from '@mysten/sui/transactions';

import { DeepBookClient } from '../src';
import { BalanceManager } from './types';

// Used wherever balance manager key is required
const BALANCE_MANAGER_KEY = 'MANAGER_1';

class DeepBookMarketMaker {
	dbClient: DeepBookClient; // For building transactions
	suiClient: SuiClient; // For executing transactions
	keypair: Ed25519Keypair; // For signing transactions
	env: 'testnet' | 'mainnet';

	constructor(privateKey: string, env: 'testnet' | 'mainnet') {
		this.env = env;
		this.keypair = this.getSignerFromPK(privateKey);
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: env,
			client: this.suiClient,
		});
	}

	getSignerFromPK = (privateKey: string): Ed25519Keypair => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	getActiveAddress() {
		return this.keypair.toSuiAddress();
	}

	async createBalanceManagerAndReinitialize() {
		let tx = new Transaction();
		tx.add(this.dbClient.balanceManager.createAndShareBalanceManager());

		const res = await this.suiClient.signAndExecuteTransaction({
			transaction: tx,
			signer: this.keypair,
			options: {
				showEffects: true,
				showObjectChanges: true,
			},
		});

		// @ts-ignore
		const balanceManagerAddress = res.objectChanges?.find((change) => {
			return change.type === 'created' && change.objectType.includes('BalanceManager');
		})?.['objectId'];

		const balanceManagers: { [key: string]: BalanceManager } = {
			[BALANCE_MANAGER_KEY]: {
				address: balanceManagerAddress,
				tradeCap: undefined,
			},
		};

		this.dbClient = new DeepBookClient({
			address: this.getActiveAddress(),
			env: this.env,
			client: this.suiClient,
			balanceManagers: balanceManagers,
		});
	}
}
```

### Coin

The SDK comes with four default coins on Testnet and five default coins on Mainnet.

**Default Testnet coins**

- DEEP
- SUI
- DBUSDC
- DBUSDT

**Default Mainnet coins**

- DEEP
- SUI
- USDC
- USDT
- WETH

You can also initialize the SDK with custom coins to interact with pools that are not supported by default. To do this, create a `CoinMap` object and pass it to the constructor of the client.

### Pool

Similar to coins, the SDK comes with default pools. You can provide a `PoolMap` during construction to override this behavior.

```tsx
import { decodeSuiPrivateKey } from '@mysten/sui.js/cryptography';
import { getFullnodeUrl, SuiClient } from '@mysten/sui/client';
import type { Keypair } from '@mysten/sui/cryptography';
import { Ed25519Keypair } from '@mysten/sui/keypairs/ed25519';
import type { Transaction } from '@mysten/sui/transactions';

import { DeepBookClient } from '../src/index.js'; // Adjust path according to new structure
import type { BalanceManager } from '../src/types/index.js';

export class DeepBookMarketMaker extends DeepBookClient {
	keypair: Keypair;
	suiClient: SuiClient;

	constructor(
		keypair: string | Keypair,
		env: 'testnet' | 'mainnet',
		balanceManagers?: { [key: string]: BalanceManager },
		adminCap?: string,
	) {
		let resolvedKeypair: Keypair;

		if (typeof keypair === 'string') {
			resolvedKeypair = DeepBookMarketMaker.#getSignerFromPK(keypair);
		} else {
			resolvedKeypair = keypair;
		}

		const address = resolvedKeypair.toSuiAddress();

		super({
			address: address,
			env: env,
			client: new SuiClient({
				url: getFullnodeUrl(env),
			}),
			balanceManagers: balanceManagers,
			adminCap: adminCap,
		});

		this.keypair = resolvedKeypair;
		this.suiClient = new SuiClient({
			url: getFullnodeUrl(env),
		});
	}

	static #getSignerFromPK = (privateKey: string) => {
		const { schema, secretKey } = decodeSuiPrivateKey(privateKey);
		if (schema === 'ED25519') return Ed25519Keypair.fromSecretKey(secretKey);

		throw new Error(`Unsupported schema: ${schema}`);
	};

	signAndExecute = async (tx: Transaction) => {
		// remove arguments
		return this.suiClient.signAndExecuteTransaction({
			transaction: tx,
			signer: this.keypair,
			options: {
				showEffects: true,
				showObjectChanges: true,
			},
		});
	};

	getActiveAddress() {
		return this.keypair.getPublicKey().toSuiAddress();
	}
}
```

### Example setup

The following example uses the default pools and coins provided.

```tsx
import { Transaction } from '@mysten/sui/transactions';

import { DeepBookMarketMaker } from './deepbookMarketMaker.js';

(async () => {
	const privateKey = ''; // Can encapsulate this in a .env file

	// Initialize with balance managers if created
	const balanceManagers = {
		MANAGER_1: {
			address: '',
			tradeCap: '',
		},
	};
	const mmClient = new DeepBookMarketMaker(privateKey, 'testnet', balanceManagers);

	const tx = new Transaction();

	// Read only call
	console.log(await mmClient.checkManagerBalance('MANAGER_1', 'SUI'));
	console.log(await mmClient.getLevel2Range('SUI_DBUSDC', 0.1, 100, true));

	// Balance manager contract call
	mmClient.balanceManager.depositIntoManager('MANAGER_1', 'DBUSDT', 10000)(tx);
	mmClient.balanceManager.withdrawAllFromManager(
		'MANAGER_1',
		'DBUSDT',
		mmClient.getActiveAddress(),
	)(tx);

	// Example custom PTB call in DeepBookMarketMaker class
	mmClient.placeLimitOrderExample(tx);
	mmClient.flashLoanExample(tx);

	let res = await mmClient.signAndExecute(tx);

	console.dir(res, { depth: null });
})();
```

## Related links

<RelatedLink href="https://github.com/MystenLabs/ts-sdks/tree/main/packages/deepbook-v3" label="DeepBookV3 Indexer repository" desc="The DeepBookV3 SDK repository on GitHub." />
<RelatedLink href="https://www.npmjs.com/package/@mysten/deepbook-v3" label="DeepBookV3 SDK node package" desc="The DeepBookV3 SDK node package on NPM." />
<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />

>>>> sui/docs/content/standards/deepbookv3-sdk/flash-loans.mdx
---
title: Flash Loans SDK
sidebar_label: Flash Loans
description: Learn how to use the DeepBookV3 SDK to execute functions relating to flash loans.
keywords: [ uncollaterized, flash loans, loans, uncollaterized loans, programmable transaction blocks, ptbs, borrow flash loan base, borrow flash loan quote, retrieve flash loan base, retrieve flash loan quote ]
---

A flash loan is one where the borrowing and returning of loans from pools is performed within a single programmable transaction block. The SDK exposes functions that allow you to implement this functionality. See [Flash Loans](https://docs.sui.io/standards/deepbookv3/flash-loans) for more details on the API.

## Flash loan functions

The DeepBookV3 SDK provides the following flash loan related functions. 

### borrowBaseAsset

Use `borrowBaseAsset` to borrow a base asset from the pool identified by the `poolKey` value you provide. The call returns a function that takes a `Transaction` object

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `borrowAmount`: Number that represents the amount to borrow from the pool.

```tsx
borrowBaseAsset(poolKey: string, borrowAmount: number);
```

### returnBaseAsset

Use `returnBaseAsset` to return the base asset to the pool identified by the `poolKey` value you provide. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `borrowAmount`: Number that represents the amount to borrow from the pool.
- `baseCoinInput`: Coin object representing the base asset to be returned.
- `flashLoan`: Flash loan object representing the loan to be settled.

```tsx
returnBaseAsset(
  {
    poolKey: string,
    borrowAmount: number,
    baseCoinInput: TransactionObjectArgument,
    flashLoan: TransactionObjectArgument,
  }
)
```

### borrowQuoteAsset

Use `borrowQuoteAsset` to borrow a quote asset from the pool identified by the `poolKey` value you provide. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `borrowAmount`: Number that represents the amount to borrow from the pool.

```tsx
borrowQuoteAsset(poolKey: string, borrowAmount: number);
```

### returnQuoteAsset

Use `returnQuoteAsset` to return a quote asset to the pool identified by the `poolKey` you provide. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `borrowAmount`: Number that represents the amount to borrow from the pool.
- `baseCoinInput`: Coin object representing the quote asset to be returned.
- `flashLoan`: Flash loan object representing the loan to be settled.

```tsx
returnQuoteAsset(
  poolKey: string,
  borrowAmount: number,
  quoteCoinInput: TransactionObjectArgument,
  flashLoan: TransactionObjectArgument,
);
```

## Flash loan example

The following example demonstrates flash loan usage in `DeepBookMarketMaker` class.
    
```tsx
// Example of a flash loan transaction
// Borrow 1 DEEP from DEEP_SUI pool
// Swap 0.5 DBUSDC for SUI in SUI_DBUSDC pool, pay with deep borrowed
// Swap SUI back to DEEP
// Return 1 DEEP to DEEP_SUI pool
flashLoanExample = async (tx: Transaction) => {
  const borrowAmount = 1;
  const [deepCoin, flashLoan] = tx.add(this.flashLoans.borrowBaseAsset('DEEP_SUI', borrowAmount));

  // Execute trade using borrowed DEEP
  const [baseOut, quoteOut, deepOut] = tx.add(
    this.deepBook.swapExactQuoteForBase({
      poolKey: 'SUI_DBUSDC',
      amount: 0.5,
      deepAmount: 1,
      minOut: 0,
      deepCoin: deepCoin,
    }),
  );

  tx.transferObjects([baseOut, quoteOut, deepOut], this.getActiveAddress());

  // Execute second trade to get back DEEP for repayment
  const [baseOut2, quoteOut2, deepOut2] = tx.add(
    this.deepBook.swapExactQuoteForBase({
      poolKey: 'DEEP_SUI',
      amount: 10,
      deepAmount: 0,
      minOut: 0,
    }),
  );

  tx.transferObjects([quoteOut2, deepOut2], this.getActiveAddress());

  // Return borrowed DEEP
  const loanRemain = tx.add(
    this.flashLoans.returnBaseAsset('DEEP_SUI', borrowAmount, baseOut2, flashLoan),
  );
  
  // Send the remaining coin to user's address
  tx.transferObjects([loanRemain], this.getActiveAddress());
};
```

## Related links

<RelatedLink href="https://github.com/MystenLabs/ts-sdks/tree/main/packages/deepbook-v3" label="DeepBookV3 Indexer repository" desc="The DeepBookV3 SDK repository on GitHub." />
<RelatedLink href="https://www.npmjs.com/package/@mysten/deepbook-v3" label="DeepBookV3 SDK node package" desc="The DeepBookV3 SDK node package on NPM." />
<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />
>>>> sui/docs/content/standards/deepbookv3-sdk/orders.mdx
---
title: Orders SDK
sidebar_label: Orders
description: Learn how to use the DeepBookV3 SDK to leverage orders against pools.
keywords: [ limit orders, market orders, modify orders, cancel orders, balancemanager, deepbookv3, pay_with_deep, DEEP token, reduce order size, lower expiration time, order options, self-matching options, orderinfo, orderdeepprice, fill, events, place market order, withdraw amount, withdraw settled amount ]
---

Placing orders is a main function of any DeepBook integration. Before you can place orders, though, you must first set up a balance manager. See [DeepBookV3 SDK](../deepbookv3-sdk.mdx) for information on setting up a balance manager.

## Order functions

The DeepBookV3 SDK provides the following functions for leveraging orders against pools.

### placeLimitOrder

Use `placeLimitOrder` to place limit orders. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `SwapParams` object that represents the parameters for the swap.

```tsx
placeLimitOrder({ params: PlaceLimitOrderParams });
```

### placeMarketOrder

Use `placeMarketOrder` to place market orders. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `SwapParams` object that represents the parameters for the swap.

```tsx
placeMarketOrder({ params: PlaceMarketOrderParams });
```

### cancelOrder

Use `cancelOrder` to cancel an existing order that is identified by the `orderId` that you provide. The call returns a function that takes a `Transaction` object.

:::warning
The `orderId` is the protocol `orderId` generated during order placement, which is different from the client `orderId`.
:::

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `balanceManagerKey`: String that identifies the `BalanceManager`.
- `orderId`: String of the protocol order ID that identifies the order to cancel. 

```tsx
cancelOrder(poolKey: string, balanceManagerKey: string, orderId: string);
```

### cancelAllOrders

Use `cancelAllOrders` to cancel every order for the balance manager whose key you provide. The call returns a function that takes a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool from which to borrow.
- `balanceManagerKey`: String that identifies the `BalanceManager`.

```tsx
cancelAllOrders(poolKey: string, balanceManagerKey: string);
```

## Examples

The following examples demonstrate some custom functions for DeepBookV3 orders.

### Limit orders

See the [Order API](../deepbookv3/orders) for the different order types and self matching options.
    
```tsx
// Params for limit order
interface PlaceLimitOrderParams {
    poolKey: string;
    balanceManagerKey: string;
    clientOrderId: string;
    price: number;
    quantity: number;
    isBid: boolean;
    expiration?: number | bigint; // Default no expiration
    orderType?: OrderType; // Default no restrictions
    selfMatchingOption?: SelfMatchingOptions; // Default self matching allowed
    payWithDeep?: boolean; // Default true
}

/**
  * @description Place a limit order
  * @param {PlaceLimitOrderParams} params Parameters for placing a limit order
  * @returns A function that takes a Transaction object
  */
placeLimitOrder = (params: PlaceLimitOrderParams) => (tx: Transaction) => {}

// Example usage in DeepBookMarketMaker class
// Place a bid of 10 DEEP at $0.1
customPlaceLimitOrder = (tx: Transaction) => {
  const poolKey = 'DEEP_DBUSDC'; // Pool key, check constants.ts for more
  const managerKey = 'MANAGER_1'; // Balance manager key, initialized during client creation by user
  tx.add(
    this.deepBook.placeLimitOrder({
      poolKey: poolKey,
      balanceManagerKey: managerKey,
      clientOrderId: '1',
      price: 0.1,
      quantity: 10,
      isBid: true,
      payWithDeep: true,
    }),
  );
};
```

### Place market order

Example of placing a market order.

```tsx
// Params for market order
interface PlaceMarketOrderParams {
    poolKey: string;
    balanceManagerKey: string;
    clientOrderId: string;
    quantity: number;
    isBid: boolean;
    selfMatchingOption?: SelfMatchingOptions;
    payWithDeep?: boolean;
}

// Example usage in DeepBookMarketMaker class
// Place a market sell of 10 SUI in the SUI_DBUSDC pool
customPlaceMarketOrder = (tx: Transaction) => {
  const poolKey = 'SUI_DBUSDC'; // Pool key, check constants.ts for more
  const managerKey = 'MANAGER_1'; // Balance manager key, initialized during client creation by user
  tx.add(
    this.deepBook.placeMarketOrder({
      poolKey: poolKey,
      balanceManagerKey: managerKey,
      clientOrderId: '2',
      quantity: 10,
      isBid: true,
      payWithDeep: true,
    }),
  );
};
```
    
### Cancel an order

Example of canceling a single order in a pool for a balance manager. 
    
```tsx
/**
  * @description Cancel an existing order
  * @param {string} poolKey The key to identify the pool
  * @param {string} balanceManagerKey The key to identify the BalanceManager
  * @param {number} orderId Order ID to cancel
  * @returns A function that takes a Transaction object
  */
cancelOrder = (
  poolKey: string, 
  balanceManagerKey: string, 
  orderId: number
) => (tx: Transaction) => {}

// Example usage in DeepBookMarketMaker class
// Cancel order 12345678 in SUI_DBUSDC pool
cancelOrder = (tx: Transaction) => {
  const poolKey = 'SUI_DBUSDC'; // Pool key, check constants.ts for more
  const managerKey = 'MANAGER_1'; // Balance manager key, initialized during client creation by user
  tx.add(this.deepBook.cancelOrder(poolKey, managerKey, 12345678));
};
```

### Cancel all orders

Example of canceling all orders in a pool for a balance manager.
    
```tsx
/**
  * @description Cancel all open orders for a balance manager
  * @param {string} poolKey The key to identify the pool
  * @param {string} balanceManagerKey The key to identify the BalanceManager
  * @returns A function that takes a Transaction object
  */
cancelAllOrders = (
  poolKey: string, 
  balanceManagerKey: string
) => (tx: Transaction) => {}

// Example usage in DeepBookMarketMaker class
// Cancel order 12345678 in SUI_DBUSDC pool
cancelOrder = (tx: Transaction) => {
  const poolKey = 'SUI_DBUSDC'; // Pool key, check constants.ts for more
  const managerKey = 'MANAGER_1'; // Balance manager key, initialized during client creation by user
  tx.add(this.deepBook.cancelAllOrders(poolKey, managerKey));
};
```

## Related links

<RelatedLink href="https://github.com/MystenLabs/ts-sdks/tree/main/packages/deepbook-v3" label="DeepBookV3 Indexer repository" desc="The DeepBookV3 SDK repository on GitHub." />
<RelatedLink href="https://www.npmjs.com/package/@mysten/deepbook-v3" label="DeepBookV3 SDK node package" desc="The DeepBookV3 SDK node package on NPM." />
<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />

>>>> sui/docs/content/standards/deepbookv3-sdk/pools.mdx
---
title: Pools SDK
sidebar_label: Pools
description: Learn how to use the DeepBookV3 SDK to read the state of a pool.
keywords: [ deepbook design, deepbookv3, deep book, pool, poolregistry, balancemanager, pool shared object, poolregister shared object, balancemanager shared object, book, state, vault, governance, history, account, bigvector ]
---

Pools are shared objects that represent a market. See [Query the Pool](../deepbookv3/query-the-pool.mdx) for more information on pools.

## Pool functions

The DeepBookV3 SDK exposes functions that you can call to read the state of a pool. These functions typically require a `managerKey`, `coinKey`, `poolKey`, or a combination of these. For details on these keys, see [DeepBookV3 SDK](../deepbookv3-sdk.mdx#keys). The SDK includes some default keys that you can view in the `constants.ts` file.

:::tip SDK Unit Handling
Input amounts, quantities, and prices should be provided in standard decimal format (e.g., `10.5` SUI, `0.00001` nBTC). The SDK handles conversion to base units internally. Returned amounts are also in standard decimal format.
:::


### account

Use `account` to retrieve the account information for a `BalanceManager` in a pool, which has the following form:

```tsx
{
  epoch: '511',
  open_orders: {
    constants: [
      '170141211130585342296014727715884105730',
      '18446744092156295689709543266',
      '18446744092156295689709543265'
    ]
  },
  taker_volume: 0,
  maker_volume: 0,
  active_stake: 0,
  inactive_stake: 0,
  created_proposal: false,
  voted_proposal: null,
  unclaimed_rebates: { base: 0, quote: 0, deep: 0 },
  settled_balances: { base: 0, quote: 0, deep: 0 },
  owed_balances: { base: 0, quote: 0, deep: 0 }
}
```

**Parameters**

- `poolKey`: String that identifies the pool to query. 
- `balanceManagerKey`: key of the balance manager defined in the SDK.

```tsx
async account(poolKey: string, managerKey: string) {}
```

### accountOpenOrders

Use `accountOpenOrders` to retrieve open orders for the balance manager and pool with the IDs you provide. The call returns a `Promise` that contains an array of open order IDs.

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `managerKey`: String that identifies the balance manager to query.

```tsx
async accountOpenOrders(poolKey: string, managerKey: string) {}
```

### checkManagerBalance

Use `checkManagerBalance` to check the balance manager for a specific coin. The call returns a `Promise` in the form:

```
{ 
  coinType: string,
  balance: number 
}
```

**Parameters**

- `managerKey`: String that identifies the balance manager to query.
- `coinKey`: String that identifies the coin to query the balance of.

```tsx
async checkManagerBalance(managerKey: string, coinKey: string) {}
```

### getOrder

Use `getOrder` to retrieve an order's information. The call returns a `Promise` in the `Order` struct, which has the following form:

```tsx
{
  balance_manager_id: {
    bytes: '0x6149bfe6808f0d6a9db1c766552b7ae1df477f5885493436214ed4228e842393'
  },
  order_id: '9223372036873222552073709551614',
  client_order_id: '888',
  quantity: '50000000',
  filled_quantity: '0',
  fee_is_deep: true,
  order_deep_price: { asset_is_base: false, deep_per_asset: '0' },
  epoch: '440',
  status: 0,
  expire_timestamp: '1844674407370955161'
}
```

**Parameters**

`poolKey`: String that identifies the pool to query.
`orderId`: ID of the order to query.

```tsx
async getOrder(poolKey: string, orderId: string) {}
```

### getQuoteQuantityOut

Use `getQuoteQuantityOut` to retrieve the quote quantity out for the base quantity you provide. The call returns a `Promise` in the form:
```
{ 
  baseQuantity: number,
  baseOut: number,
  quoteOut: number,
  deepRequired: number 
}
```
where `deepRequired` is the amount of DEEP required for the dry run.

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `baseQuantity`: Number that defines the base quantity you want to convert.

 ```tsx
async getQuoteQuantityOut(poolKey: string, baseQuantity: number) {}
```

### getBaseQuantityOut

Use `getBaseQuantityOut` to retrieve the base quantity out for the quote quantity that you provide. The call returns a `Promise` in the form:
```
{
  quoteQuantity: number,
  baseOut: number,
  quoteOut: number,
  deepRequired: number
}
```
where `deepRequired` is the amount of DEEP required for the dry run.

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `quoteQuantity`: Number that defines the quote quantity you want to convert.

```tsx
async getBaseQuantityOut(poolKey: string, quoteQuantity: number) {}
```

### getQuantityOut

Use `getQuantityOut` to retrieve the output quantities for the base or quote quantity you provide. You provide values for both quantities, but only one of them can be non-zero. The call returns a `Promise` with the form:
```
{
  baseQuantity: number,
  quoteQuantity: number,
  baseOut: number,
  quoteOut: number,
  deepRequired: number
}
```
where `deepRequired` is the amount of DEEP required for the dry run.

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `baseQuantity`: Number that defines the base quantity you want to convert. Set to `0` if using quote quantity.
- `quoteQuantity`: Number that defines the quote quantity you want to convert. Set to `0` if using base quantity.

```tsx
async getQuantityOut(poolKey: string, baseQuantity: number, quoteQuantity: number) {}
```

### getLevel2Range

Use `getLevel2Range` to retrieve level 2 order book within the boundary price range you provide. The call returns a `Promise` in the form:
```
{
  prices: Array<number>,
  quantities: Array<number>
}
```

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `priceLow`: Number for lower bound of price range.
- `priceHigh`: Number for upper bound of price range.
- `isBid`: Boolean when set to `true` gets bid orders, else retrieve ask orders.

 ```tsx
async getLevel2Range(poolKey: string, priceLow: number, priceHigh: number, isBid: boolean) {}
```

### getLevel2TicksFromMid

Use `getLevel2TicksFromMid` to retrieve level 2 order book ticks from mid-price for a pool with the ID you provide. The call returns a `Promise` in the form:
```
{
  bid_prices: Array<number>,
  bid_quantities: Array<number>,
  ask_prices: Array<number>,
  ask_quantities: Array<number>
}
```

**Parameters**

- `poolKey`: String that identifies the pool to query.
- `ticks`: Number of ticks from mid-price.

 ```tsx
async getLevel2TicksFromMid(poolKey: string, ticks: number) {}
```

### lockedBalance

Use `lockedBalance` to retrieve a `BalanceManager` locked balance in the pool. The call returns a `Promise` in the `Order` struct, which has the following form:

```tsx
{
  base: 5.5,
	quote: 2,
	deep: 0.15,
}
```

**Parameters**

`poolKey`: String that identifies the pool to query. `balanceManagerKey`: key of the balance manager defined in the SDK.

```tsx
async lockedBalance(poolKey: string, balanceManagerKey: string) {}
```

### poolTradeParams

Use `poolTradeParams` to retrieve the trade params for the pool, which has the following form:

```tsx
{
  takerFee: 0.001,
	makerFee: 0.0005,
	stakeRequired: 100,
}
```

**Parameters**

- `poolKey`: String that identifies the pool to query.

```tsx
async poolTradeParams(poolKey: string) {}
```

### vaultBalances

Use `vaultBalances` to get the vault balances for a pool with the ID you provide. The call returns a `Promise` in the form:

```tsx
{
  base: number, 
  quote: number, 
  deep: number
} 
```

**Parameters**

- `poolKey`: String that identifies the pool to query.

```tsx
async vaultBalances(poolKey: string) {}
```

### getPoolIdByAssets

Use `getPoolIdByAssets` to retrieve the pool ID for the asset types you provide. The call returns a `Promise` with the address of the pool if it's found.

**Parameters**

- `baseType`: String of the type of base asset.
- `quoteType`: String of the type of quote asset.

```tsx
async getPoolIdByAssets(baseType: string, quoteType: string) {}
```

### midPrice

Use `midPrice` to retrieve the mid price for a pool with the ID that you provide. The call returns a `Promise` with the mid price.

**Parameters**

- `poolKey`: String that identifies the pool to query.

```tsx
async midPrice(poolKey: string) {}
```

### whitelisted

Use `whitelisted` to check if the pool with the ID you provide is whitelisted. The call returns a `Promise` as a boolean indicating whether the pool is whitelisted.

**Parameters**

- `poolKey`: String that identifies the pool to query.

```tsx
async whitelisted(poolKey: string) {}
```

## Related links

<RelatedLink href="https://github.com/MystenLabs/ts-sdks/tree/main/packages/deepbook-v3" label="DeepBookV3 Indexer repository" desc="The DeepBookV3 SDK repository on GitHub." />
<RelatedLink href="https://www.npmjs.com/package/@mysten/deepbook-v3" label="DeepBookV3 SDK node package" desc="The DeepBookV3 SDK node package on NPM." />
<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />

>>>> sui/docs/content/standards/deepbookv3-sdk/staking-governance.mdx
---
title: Staking and Governance SDK
sidebar_label: Staking and Governance
description: Learn how to use the DeepBookV3 SDK to interact with staking and governance.
keywords: [ taker fee, maker fee, stake, staking, governance, unstake, submit proposal, vote, claim rebates, deepbook pool, deepbook governance, deepbookv3 ]
---

Examples of interacting with staking and governance. These functions typically require a `balanceManagerKey`, `poolKey`, or both. For details on these keys, see [DeepBookV3 SDK](../deepbookv3-sdk.mdx#keys). The SDK includes some default keys that you can view in the `constants.ts` file. 

See [Staking and Governance](../deepbookv3/staking-governance.mdx) for more information on the staking and governance API.

## Staking and governance functions

### stake

Use `stake` to stake an amount you specify into a specific pool. The call returns a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool.
- `balanceManagerKey`: String that identifies the balance manager.
- `stakeAmount`: Number representing the amount to stake.

```tsx
stake(poolKey: string, balanceManagerKey: string, stakeAmount: number);
```

### unstake

Use `unstake` to unstake from a particular pool. The call returns a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool.
- `balanceManagerKey`: String that identifies the balance manager.

```tsx
unstake(poolKey: string, balanceManagerKey: string);
```

### submitProposal

Use `submitProposal` to submit a governance proposal. The call returns a `Transaction` object.

**Parameters**

- `params`: A `ProposalParams` object that defines the proposal.

```tsx
submitProposal({ params: ProposalParams });
```

### vote

Use `vote` to vote on a proposal. The call returns a `Transaction` object.

**Parameters**

- `poolKey`: String that identifies the pool.
- `balanceManagerKey`: String that identifies the balance manager.
- `proposal_id`: String that identifies the proposal to vote on.

```tsx
vote(poolKey: string, balanceManagerKey: string, proposal_id: string)
```

## Examples

The following examples demonstrate custom staking and governance functions that you can place into the `DeepBookMarketMaker` class. 

### stake custom function

```tsx
stake = (
  poolKey: string, 
  balanceManagerKey: string, 
  stakeAmount: number
) => (tx: Transaction) => {}

// Custom function to stake 100 DEEP in DeepBookMarketMaker class
stake = (tx: Transaction) => {
  const poolKey = 'DBUSDT_DBUSDC';
  const balanceManagerKey = 'MANAGER_1';
  tx.add(this.governance.stake(poolKey, balanceManagerKey, 100));
};
```

### unstake custom function

```tsx
unstake = (
  poolKey: string, 
  balanceManagerKey: string
) => (tx: Transaction) => {}

// Custom function to unstake in DeepBookMarketMaker class
unstake = (tx: Transaction) => {
  const poolKey = 'DBUSDT_DBUSDC';
  const balanceManagerKey = 'MANAGER_1';
  tx.add(this.governance.unstake(poolKey, balanceManagerKey));
};
```

### submitProposal custom function

```tsx
// Proposal params
export interface ProposalParams {
  poolKey: string;
  balanceManagerKey: string;
  takerFee: number;
  makerFee: number;
  stakeRequired: number;
}

submitProposal = (params: ProposalParams) => (tx: Transaction) => {}

// Custom function to submit proposal in DeepBookMarketMaker class
submitProposal = (tx: Transaction) => {
  const poolKey = 'DBUSDT_DBUSDC';
  const balanceManagerKey = 'MANAGER_1';
  tx.add(
    this.governance.submitProposal({
      poolKey,
      balanceManagerKey,
      takerFee: 0.002,
      makerFee: 0.001,
      stakeRequired: 100,
    }),
  );
};
```

### vote custom function

```tsx
vote = (
  poolKey: string, 
  balanceManagerKey: string, 
  proposal_id: string
) => (tx: Transaction) => {}

// Custom function to vote in DeepBookMarketMaker class
vote = (tx: Transaction) => {
  const poolKey = 'DBUSDT_DBUSDC';
  const balanceManagerKey = 'MANAGER_1';
  const proposalID = '0x123456789';
  tx.add(this.governance.vote(poolKey, balanceManagerKey, proposalID));
};
```

## Related links

<RelatedLink href="https://github.com/MystenLabs/ts-sdks/tree/main/packages/deepbook-v3" label="DeepBookV3 Indexer repository" desc="The DeepBookV3 SDK repository on GitHub." />
<RelatedLink href="https://www.npmjs.com/package/@mysten/deepbook-v3" label="DeepBookV3 SDK node package" desc="The DeepBookV3 SDK node package on NPM." />
<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />

>>>> sui/docs/content/standards/deepbookv3-sdk/swaps.mdx
---
title: Swaps
description: Learn how to use the DeepBookV3 SDK to interact a swap-like interface.
keywords: [ automatic market makers, amms, swap_exact_amount, balancemanager, base_in, quote_in, deep_in, swaps, swap base quantity, deep quantity, DEEP, swap exact quantity, deepbook, deepbookv3  ]
---

DeepBookV3 provides a swap-like interface commonly seen in automatic market makers (AMMs). The DeepBookV3 SDK provides functions to leverage the features of this interface. See [Swaps](../deepbookv3/swaps.mdx) in the API section for more details.

## Swap functions

The SDK provides the following functions to perform swaps between the base and quote asset.

### swapExactBaseForQuote

Use `swapExactBaseForQuote` to swap exact base amount for quote amount. The call returns a function that takes a `Transaction` object.

**Parameters**

- `params`: `SwapParams` object that represents the parameters for the swap.

```tsx
swapExactBaseForQuote({ params: SwapParams });
```

### swapExactQuoteForBase

Use `swapExactQuoteForBase` to swap exact quote amount for base amount. The call returns a function that takes a `Transaction` object. 

**Parameters**

- `params`: `SwapParams` object that represents the parameters for the swap.

```tsx
swapExactQuoteForBase({ params: SwapParams });
```

### Examples

The following examples demonstrate custom swap functions that you can place into the `DeepBookMarketMaker` class. Base coin, quote coin, and deep coin are automatically determined by the coin available in the user address unless you explicitly pass one in as an argument. You can transfer the coin outputs to their address or execute other operations using the outputs.

```tsx
swapExactBaseForQuote = (tx: Transaction) => {
  const [baseOut, quoteOut, deepOut] = this.deepBook.swapExactBaseForQuote({
    poolKey: 'SUI_DBUSDC',
    amount: 1, // amount of SUI to swap
    deepAmount: 1, // amount of DEEP to pay as fees, excess is returned
    minOut: 0.1, // minimum amount of DBUSDC to receive or transaction fails
  })(tx);

  // Transfer received coins to own address
  tx.transferObjects([baseOut, quoteOut, deepOut], this.getActiveAddress());
};

swapExactQuoteForBase = (tx: Transaction) => {
  const [baseOut, quoteOut, deepOut] = this.deepBook.swapExactQuoteForBase({
    poolKey: 'SUI_DBUSDC',
    amount: 1, // amount of DBUSDC to swap
    deepAmount: 1, // amount of DEEP to pay as fees, excess is returned
    minOut: 0.1, // minimum amount of SUI to receive or transaction fails
  })(tx);

  // Transfer received coins to own address
  tx.transferObjects([baseOut, quoteOut, deepOut], this.getActiveAddress());
};
```

## Related links

<RelatedLink href="https://github.com/MystenLabs/ts-sdks/tree/main/packages/deepbook-v3" label="DeepBookV3 Indexer repository" desc="The DeepBookV3 SDK repository on GitHub." />
<RelatedLink href="https://www.npmjs.com/package/@mysten/deepbook-v3" label="DeepBookV3 SDK node package" desc="The DeepBookV3 SDK node package on NPM." />
<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />

>>>> sui/docs/content/standards/deepbookv3/balance-manager.mdx
---
title: BalanceManager
description: Learn about the balance manager and how it works.
keywords: [ balancemanager, balance manager, manage balances, balances for different assets, deepbook, deepbookv3, create balance manager, balance manager with custom owner, mint trade cap, trade cap, tradecap, DepositCap, WithdrawCap, deposit cap, withdraw cap, deposit funds, withdraw funds, generate a TradeProof, tradeproof ]
---

The `BalanceManager` shared object holds all balances for different assets. To perform trades, pass a combination of `BalanceManager` and `TradeProof` into a [pool](./design.mdx#pool). `TradeProof`s are generated in one of two ways, either by the `BalanceManager` owner directly, or by any `TradeCap` owner. The owner can generate a `TradeProof` without the risk of equivocation. The `TradeCap` owner, because it's an owned object, risks equivocation when generating a `TradeProof`. Generally, a high frequency trading engine trades as the default owner.

With exception to swaps, all interactions with DeepBookV3 require a `BalanceManager` as one of its inputs. When orders are matched, funds are transferred to or from the `BalanceManager`. You can use a single `BalanceManager` between all pools.

## API

Following are the different public functions that the `BalanceManager` exposes.

### Create a BalanceManager

The `new()` function creates a `BalanceManager` hot potato (a struct with no abilities). Combine it with `share`, or else the transaction fails. You can combine the transaction with deposit calls, allowing you to create, deposit, then share the balance manager in one transaction.

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="new" noComments />

### Create a BalanceManager with custom owner

The `new_with_owner()` function creates a `BalanceManager` hot potato (a struct with no abilities) with a custom owner. Combine it with `share`, or else the transaction fails. You can combine the transaction with deposit calls, allowing you to create, deposit, then share the balance manager in one transaction.

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="new_with_owner" noComments />

### Mint a TradeCap

The owner of a `BalanceManager` can mint a `TradeCap` and send it to another address. Upon receipt, that address will have the capability to place orders with this `BalanceManager`. The address owner cannot deposit or withdraw funds, however. The maximum total number of `TradeCap`, `WithdrawCap`, and `DepositCap` that can be assigned for a `BalanceManager` is `1000`. If this limit is reached, one or more existing caps must be revoked before minting new ones. You can also use `revoke_trade_cap` to revoke `DepositCap` and `WithdrawCap`.

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="mint_trade_cap,revoke_trade_cap" />

### Mint a DepositCap or WithdrawCap

The owner of a `BalanceManager` can mint a `DepositCap` or `WithdrawCap` and send it to another address. Upon receipt, that address will have the capability to deposit in or withdraw from `BalanceManager`. The address owner cannot execute trades, however. The maximum total number of `TradeCap`, `WithdrawCap`, and `DepositCap` that can be assigned for a `BalanceManager` is `1000`. If this limit is reached, one or more existing caps must be revoked before minting new ones.

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="mint_deposit_cap,mint_withdraw_cap" />

### Generate a TradeProof

To call any function that requires a balance check or transfer, the user must provide their `BalanceManager` as well as a `TradeProof`. There are two ways to generate a trade proof, one used by the owner and another used by a `TradeCap` owner.

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="generate_proof_as_owner,generate_proof_as_trader" />

### Deposit funds

Only the owner can call this function to deposit funds into the `BalanceManager`.

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="deposit" />

### Withdraw funds

Only the owner can call this function to withdraw funds from the `BalanceManager`.

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="withdraw,withdraw_all" />

### Deposit funds using DepositCap

Only holders of a `DepositCap` for the `BalanceManager` can call this function to deposit funds into the `BalanceManager`.

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="deposit_with_cap" />

### Withdraw funds using WithdrawCap

Only holders of a `WithdrawCap` for the `BalanceManager` can call this function to withdraw funds from the `BalanceManager`.

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="withdraw_with_cap" />

### Read endpoints

<ImportContent source="packages/deepbook/sources/balance_manager.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="validate_proof,balance,owner,id" />

## Related links

<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />
>>>> sui/docs/content/standards/deepbookv3/design.mdx
---
title: Design
description: Learn about DeepBookV3 design, including the Pool, PoolRegistry, and BalanceManager shared objects.
keywords: [ deepbook design, deepbookv3, deep book, pool, poolregistry, balancemanager, pool shared object, poolregister shared object, balancemanager shared object, book, state, vault, governance, history, account, bigvector ]
---

At a high level, the DeepBookV3 design follows the following flow, which revolves around three shared objects:

- `Pool`: A shared object that represents one market and is responsible for managing its order book, users, stakes, and so on. See the [Pool shared object](#pool) section to learn more.
- `PoolRegistry`: Used only during pool creation, it makes sure that duplicate pools are not created and maintains package versioning.
- `BalanceManager`: Used to source a user's funds when placing orders. A single `BalanceManager` can be used between all pools. See [BalanceManager](./balance-manager.mdx) to learn more.

<p class="flex justify-center">![1](./images/DBv3Architecture.png)</p>

## Pool shared object {#pool}

All public facing functions take in the `Pool` shared object as a mutable or immutable reference. `Pool` is made up of three distinct components: 

- [`Book`](#book)
- [`State`](#state)
- [`Vault`](#vault)

Logic is isolated between components and each component builds on top of the previous one. By maintaining a book, then state, then vault relationship, DeepBookV3 can provide data availability guarantees, improve code readability, and help make maintaining and upgrading the protocol easier. 

<p class="flex justify-center">![Pool Modules](./images/pool.png)</p>

### Book

This component is made up of the main `Book` module along with `Fill`, `OrderInfo`, and `Order` modules. The `Book` struct maintains two `BigVector<Order>` objects for bids and asks, as well as some metadata. It is responsible for storing, matching, modifying, and removing `Orders`.

When placing an order, an `OrderInfo` is first created. If applicable, it is first matched against existing maker orders, accumulating `Fill`s in the process. Any remaining quantity will be used to create an `Order` object and injected into the book. By the end of book processing, the `OrderInfo` object has enough information to update all relevant users and the overall state.

### State

`State` stores `Governance`, `History`, and `Account`. It processes all requests, updating at least one of these stored structs.

#### Governance

The `Governance` module stores data related to the pool's trading params. These parameters are the taker fee, maker fee, and the stake required. Stake required represents the amount of DEEP tokens that a user must have staked in this specific pool to be eligible for taker and maker incentives.

Every epoch, users with non zero stake can submit a proposal to change these parameters. The proposed fees are bounded.

<style jsx>{`
  table {
    width: 100%;
    display: inline-table;
  }
  th:nth-child(1),
  td:nth-child(1) {
    width: 15%;
  }
  th:nth-child(2),
  td:nth-child(2) {
    width: 15%;
  }
`}</style>

| min_value (bps) | max_value (bps) | Pool type | Taker or maker |
| --- | --- | --- | --- |
| 1 | 10 | Volatile | Taker |
| 0 | 5 | Volatile | Maker |
| 0.1 | 1 | Stable | Taker |
| 0 | 0.5 | Stable | Maker |
| 0 | 0 | Whitelisted | Taker and maker |

Users can also vote on live proposals. When a proposal exceeds the quorum, the new trade parameters are queued to go live from the following epoch and onwards.  Proposals and votes are reset every epoch. Users can start submitting and voting on proposals the epoch following their stake. Quorum is equivalent to half of the total voting power. A user's voting power is calculated with the following formula where ${V}$ is the voting power, ${S}$ is the amount staked, and ${V_c}$ is the voting power cutoff. ${V_c}$ is currently set to 100,000 DEEP.

<p class="flex justify-center">$\LARGE V=\min\lparen S,V_c \rparen + \max\lparen \sqrt{S} - \sqrt{V_c} ,0 \rparen$</p>

The following diagram helps visualize the governance lifecycle.

<p class="flex justify-center">![DeepBookV3 Governance Timeline](./images/governance.png)</p>

#### History

The `History` module stores aggregated volumes, trading params, fees collected and fees to burn for the current epoch and previous epochs. During order processing, fills are used to calculate and update the total volume. Additionally, if the maker of the trade has enough stake, the total staked volume is also updated.

The first operation of every epoch will trigger an update, moving the current epoch data into historic data, and resetting the current epoch data.

User rebate calculations are done in this module. During every epoch, a maker is eligible for rebates as long as their DEEP staked is over the stake required and have contributed in maker volume. The following formula is used to calculate maker fees, quoted from the [Whitepaper: DeepBook Token](/doc/deepbook.pdf) document. Details on maker incentives can be found in section 2.2 of the whitepaper.

<blockquote cite="/doc/deepbook.pdf">

The computation of incentives â€“ which happens after an epoch ends and is only given to makers
who have staked the required number of DEEP tokens in advance â€“ is calculated in Equation (3) for
a given maker ${i}$. Equation (3) introduces several new variables. First, ${M}$ refers to the set of makers
who stake a sufficient number of DEEP tokens, and $\bar{M}$ refers to the set of makers who do not fulfill
this condition. Second, ${F}$ refers to total fees (collected both from takers and the maker) that a
makerâ€™s volume has generated in a given epoch. Third, ${L}$ refers to the total liquidity provided by
a maker â€“ and specifically the liquidity traded, not just the liquidity quoted. Finally, the critical
point ${p}$ is the â€œphaseoutâ€ point, at which â€“ if total liquidity provided by other makersâ€™ crosses this
point â€“ incentives are zero for the maker in that epoch. This point ${p}$ is constant for all makers in
a pool and epoch.

<p class="flex justify-center">$\LARGE \textsf {Incentives }  \textsf {for } \textsf {Maker } i = \max\Bigg\lbrack F_i\Bigg\lparen 1 + \large\cfrac{\sum_{j \in \bar{M}} F_j} {\sum_{j \in M} F_j} \Bigg\rparen\Bigg\lparen \LARGE 1 - \large\cfrac{\sum_{j \in M \cup \bar{M}} L_j - L_i}{p}\Bigg\rparen \LARGE ,0 \Bigg\rbrack$ (3)</p>

</blockquote>

In essence, if the total volume during an epoch is greater than the median volume from the last 28 days, then there are no rebates. The lower the volume compared to the median, the more rebates are available. The maximum amount of rebates for an epoch is equivalent to the total amount of DEEP collected during that epoch. Remaining DEEP is burned.

#### Account

`Account` represents a single user and their relevant data. Everything related to volumes, stake, voted proposal, unclaimed rebates, and balances to be transferred. There is a one to one relationship between a `BalanceManager` and an `Account`.

Every epoch, the first action that a user performs will update their account, triggering a calculation of any potential rebates from the previous epoch, as well as resetting their volumes for the current epoch. Any new stakes from the previous epoch become active.

Each account has settled and owed balances. Settled balances are what the pool owes to the user, and owed balances are what the user owes to the pool. For example, when placing an order, the user's owed balances increase, representing the funds that the user has to pay to place that order. Then, if a maker order is taken by another user, the maker's settled balances increase, representing the funds that the maker is owed.

### Vault

Every transaction that a user performs on DeepBookV3 resets their settled and owed balances. The vault then processes these balances for the user, deducting or adding to funds to their `BalanceManager`.

The vault also stores the `DeepPrice` struct. This object holds up to 100 data points representing the conversion rate between the pool's base or quote asset and DEEP. These data points are sourced from a whitelisted pool, DEEP/USDC or DEEP/SUI. This conversion rate is used to determine the quantity of DEEP tokens required to pay for trading fees.

### BigVector

`BigVector` is an arbitrary sized vector-like data structure, implemented using an on-chain B+ Tree to support almost constant time (log base max_fan_out) random access, insertion and removal.

Iteration is supported by exposing access to leaf nodes (slices). Finding the initial slice can be done in almost constant time, and subsequently finding the previous or next slice can also be done in constant time.

Nodes in the B+ Tree are stored as individual dynamic fields hanging off the `BigVector`.

## Place limit order flow

The following diagram of the lifecycle of an order placement action helps visualize the book, then state, then vault flow.

<p class="flex justify-center">![Place limit order flow](./images/placeorder.png)</p>

### Pool

In the `Pool` module, `place_order_int` is called with the user's input parameters. In this function, four things happen in order: 

1. An `OrderInfo` is created.
1. The `Book` function `create_order` is called.
1. The `State` function `process_create` is called.
1. The `Vault` function `settle_balance_manager` is called. 

### Book

The order creation within the book involves three primary tasks:

- Validate inputs.
- Match against existing orders.
- Inject any remaining quantity into the order book as a limit order.

Validation of inputs ensures that quantity, price, timestamp, and order type are within expected ranges.

To match an `OrderInfo` against the book, the list of `Order`s is iterated in the opposite side of the book. If there is an overlap in price and the existing maker order has not expired, then DeepBookV3 matches their quantities and generates a `Fill`. DeepBookV3 appends that fill to the `OrderInfo` fills, to use later in state. DeepBookV3 updates the existing maker order quantities and status during each match, and removes them from the book if they are completely filled or expired.

Finally, if the `OrderInfo` object has any remaining quantity, DeepBookV3 converts it into a compact `Order` object and injects it into the order book. `Order` has the minimum amount of data necessary for matching, while `OrderInfo` has the maximum amount of data for general processing.

Regardless of direction or order type, all DeepBookV3 matching is processed in a single function.

### State

The `process_create` function in `State` handles the processing of an order creation event within the pool's state: calculating the transaction amounts and fees for the order, and updating the account volumes accordingly. 

First, the function processes the list of fills from the `OrderInfo` object, updating volumes tracked and settling funds for the makers involved. Next, the function retrieves the account's total trading volume and active stake. It calculates the taker's fee based on the user's account stake and volume in DEEP tokens, while the maker fee is retrieved from the governance trade parameters. To receive discounted taker fees, the account must have more than the minimum stake for the pool, and the trading volume in DEEP tokens must exceed the same threshold. If any quantity remains in the `OrderInfo` object, it is added to the account's list of orders as an `Order` and is already created in `Book`. 

Finally, the function calculates the partial taker fills and maker order quantities, if there are any, with consideration for the taker and maker fees. It adds these to the previously settled and owed balances from the account. Trade history is updated with the total fees collected from the order and two tuples are returned to `Pool`, settled and owed balances, in (base, quote, DEEP) format, ensuring the correct assets are transferred in `Vault`.

### Vault

The `settle_balance_manager` function in `Vault` is responsible for managing the transfer of any settled and owed amounts for the `BalanceManager`. 

First, the function validates that a trader is authorized to use the `BalanceManager`. 

Then, for each asset type the process compares `balances_out` against `balances_in`. If the `balances_out` total exceeds `balances_in`, the function splits the difference from the vault's balance and deposits it into the `BalanceManager`. Conversely, if the `balances_in` total exceeds `balances_out`, the function withdraws the difference from the `BalanceManager` and joins it to the vault's balance. 

This process is repeated for base, quote, and DEEP asset balances, ensuring all asset balances are accurately reflected and settled between the vault and the `BalanceManager`.

## Related links

<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />

>>>> sui/docs/content/standards/deepbookv3/flash-loans.mdx
---
title: Flash Loans
description: Use DeepBookV3 to perform flash loans, uncollaterized loans that are borrowed and repaid within the same programmable transaction block.
keywords: [ uncollateralized, flash loans, loans, uncollateralized loans, programmable transaction blocks, ptbs, borrow flash loan base, borrow flash loan quote, retrieve flash loan base, retrieve flash loan quote ]
---

Flash loans by definition are uncollateralized loans that are borrowed and repaid within the same programmable transaction block. Users can borrow flash loans in the base or quote asset from any DeepBookV3 pool. Flash loans return a `FlashLoan` hot potato (struct with no abilities), which must be returned back to the pool by the end of the call. The transaction is atomic, so the entire transaction fails if the loan is not returned.

The quantity borrowed can be the maximum amount that the pool owns. Borrowing from a pool and trading in the same pool can result in failures because trading requires the movement of funds. If the funds are borrowed, then there are no funds to move.

## API

Following are the endpoints that the `Pool` exposes for flash loans.

### Borrow flash loan base

Borrow base assets from the `Pool`. The function returns a hot potato, forcing the borrower to return the assets within the same transaction.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="borrow_flashloan_base" noComments />

### Borrow flash loan quote

Borrow quote assets from the `Pool`. The function returns a hot potato, forcing the borrower to return the assets within the same transaction.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="borrow_flashloan_quote" noComments />

### Retrieve flash loan base

Return the flash loaned base assets to the `Pool`. `FlashLoan` object is unwrapped only if the assets are returned, otherwise the transaction fails.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="return_flashloan_base" noComments />

### Retrieve flash loan quote

Return the flash loaned quote assets to the `Pool`. `FlashLoan` object is unwrapped only if the assets are returned,
otherwise the transaction fails.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="return_flashloan_quote" noComments />

## Related links

<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />
>>>> sui/docs/content/standards/deepbookv3/orders.mdx
---
title: Orders
description: Use DeepBookV3 to create limit and market orders, modify orders, or cancel orders. 
keywords: [ limit orders, market orders, modify orders, cancel orders, balancemanager, deepbookv3, pay_with_deep, DEEP token, reduce order size, lower expiration time, order options, self-matching options, orderinfo, orderdeepprice, fill, events, place market order, withdraw amount, withdraw settled amount ]
---

Users can create limit or market orders, modify orders, and cancel orders. The `BalanceManager` must have the necessary funds to process orders. DeepBookV3 has four order options and three self matching options. If you set the `pay_with_deep` flag to `true`, trading fees are paid with the DEEP token. If you set the `pay_with_deep` flag to `false`, trading fees are paid with the input token.

Users can modify their existing order, reducing the size, lowering the expiration time, or both. Users cannot modify their order to increase their size or increase their expiration time. To do that, they must cancel the original order and place a new order.

Users can cancel a single order or cancel all of their orders.

## API

Following are the order related endpoints that `Pool` exposes.

### Order options

The following constants define the options available for orders.

<ImportContent source="packages/deepbook/sources/helper/constants.move" mode="code" org="MystenLabs" repo="deepbookv3" variable="NO_RESTRICTION,IMMEDIATE_OR_CANCEL,FILL_OR_KILL,POST_ONLY" />

### Self-matching options

The following constants define the options available for self-matching orders.

<ImportContent source="packages/deepbook/sources/helper/constants.move" mode="code" org="MystenLabs" repo="deepbookv3" variable="SELF_MATCHING_ALLOWED,CANCEL_TAKER,CANCEL_MAKER" />

### OrderInfo struct

Placing a limit order or a market order creates and returns an `OrderInfo` object. DeepBookV3 automatically drops this object after the order completes or is placed in the book. Use `OrderInfo` to inspect the execution details of the request as it represents all order information. DeepBookV3 does not catch any errors, so if thereâ€™s a failure of any kind, then the entire transaction fails.

<ImportContent source="packages/deepbook/sources/book/order_info.move" org="MystenLabs" repo="deepbookv3" mode="code" struct="OrderInfo" />

### OrderDeepPrice struct

The `OrderDeepPrice` struct represents the conversion rate of DEEP at the time the order was placed.

<ImportContent source="packages/deepbook/sources/vault/deep_price.move" mode="code" org="MystenLabs" repo="deepbookv3" struct="OrderDeepPrice" />

### Fill struct

The `Fill` struct represents the results of a match between two orders. Use this struct to update the state.

<ImportContent source="packages/deepbook/sources/book/fill.move" mode="code" org="MystenLabs" repo="deepbookv3" struct="Fill" />

### Events

DeepBookV3 emits `OrderFilled` when a maker order is filled.

<ImportContent source="packages/deepbook/sources/book/order_info.move" mode="code" org="MystenLabs" repo="deepbookv3" struct="OrderFilled" />

DeepBookV3 emits `OrderCanceled` when a maker order is canceled.

<ImportContent source="packages/deepbook/sources/book/order.move" mode="code" org="MystenLabs" repo="deepbookv3" struct="OrderCanceled" />

DeepBookV3 emits `OrderModified` on modification of a maker order.

<ImportContent source="packages/deepbook/sources/book/order.move" mode="code" org="MystenLabs" repo="deepbookv3" struct="OrderModified" />

DeepBookV3 emits `OrderPlaced` when it injects a maker order into the order book.

<ImportContent source="packages/deepbook/sources/book/order_info.move" mode="code" org="MystenLabs" repo="deepbookv3" struct="OrderPlaced" />

### Place limit order

Place a limit order. Quantity is in base asset terms. For current version `pay_with_deep` must be true, so the 
fee is paid with DEEP tokens. 

You must combine a `BalanceManager` call of generating a `TradeProof` before placing orders.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="place_limit_order" noComments />

### Place market order

Place a market order. Quantity is in base asset terms. Calls `place_limit_order` with a price of `MAX_PRICE` for bids and `MIN_PRICE` for asks. DeepBookV3 cancels the order for any quantity not filled.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="place_market_order" noComments />

### Modify order

Modifies an order given `order_id` and `new_quantity`. New quantity must be less than the original quantity and more than the filled quantity. Order must not have already expired.

The `modify_order` function does not return anything. If the transaction is successful, then assume the modification was successful.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="modify_order" noComments />

### Cancel order

Cancel an order. The order must be owned by the `balance_manager`. The order is removed from the book and the `balance_manager` open orders. The `balance_manager` balance is updated with the order's remaining quantity.

Similar to modify, `cancel_order` does not return anything. DeepBookV3 emits `OrderCanceled` event.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="cancel_order" noComments />

### Withdraw settled amounts

Withdraw settled amounts to the `balance_manager`. All orders automatically withdraw settled amounts. This can be called explicitly to withdraw all settled funds from the pool.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="withdraw_settled_amounts" noComments />

## Related links

<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />
>>>> sui/docs/content/standards/deepbookv3/permissionless-pool.mdx
---
title: Permissionless Pool Creation
description: Learn how to create a pool permissionlessly.
keywords: [ pool, create pool, permissionlessly, permissionless, SUI, USDC, SUI/USDC, DEEP price point, MIST ]
---

The `Pool` shared object represents a market, such as a SUI/USDC market. That `Pool` is the only one representing that unique pairing (SUI/USDC) and the pairing is the only member of that particular `Pool`. See [DeepBookV3 Design](./design.mdx#pool) to learn more about the structure of pools.

## API

### Create a `Pool`

The `create_permissionless_pool()` function creates a `Pool`

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="create_permissionless_pool" noComments />

Tick size should be 10^(9 - base_decimals + quote_decimals - decimal_desired). For example, if creating a SUI(9 decimals)/USDC(6 decimals) pool, with a desired decimal of 3 for tick size (0.001), tick size should be 10^(9 - 9 + 6 - 3) = 10^(3) = 1000.

Decimal desired should be at most 1bps, or 0.01%, of the price between base and quote asset. For example, if 3 decimals is the target, 0.001 (three decimals) / price should be less than or equal to 0.0001. Consider a lower tick size for pools where both base and quote assets are stablecoins.

Lot size is in MIST of the base asset, and should be approximately &dollar;0.01 to &dollar;0.10 nominal of the base asset. Lot size must be a power of 10, and less than or equal to min size. Lot size should also be greater than or equal to 1,000.

Min size is in MIST of the base asset, and should be approximately &dollar;0.10 to &dollar;1.00 nominal of the base asset. Min size must be a power of 10, and larger than or equal to lot size.

Creation fee is 500 DEEP tokens.

:::info

Pools can only be created if the asset pair has not already been created before.

:::

### Add DEEP price point

The `add_deep_price_point()` function allows for the calculation of DEEP price and correct collection of fees in DEEP.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="add_deep_price_point" noComments />

All pools support input token fees. To allow a permissionless pool to pay fees in DEEP, which has a 20% discount compared to input token fees, two conditions must be met:

1. Either the base or quote asset must be `USDC` or `SUI`.
2. To calculate DEEP fees accurately, you must set up a cron job to call the `add_deep_price_point()` function on the pool every 1-10 minutes.

For a pool with `USDC` as an asset, use the `DEEP/USDC` pool at `0xf948981b806057580f91622417534f491da5f61aeaf33d0ed8e69fd5691c95ce` as the reference pool.

For a pool with `SUI` as an asset, use the `DEEP/SUI` pool at `0xb663828d6217467c8a1838a03793da896cbe745b150ebd57d82f814ca579fc22` as the reference pool.

### Update allowed versions

The `update_allowed_versions()` function takes a pool and the registry, and updates the allowed contract versions within the pool.
This is very important after contract upgrades to ensure the newest contract can be used on the pool.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="update_allowed_versions" noComments />

## Related links

<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />
>>>> sui/docs/content/standards/deepbookv3/query-the-pool.mdx
---
title: Query the Pool
description: A Pool is a shared object that represents a unique market pair, such as SUI/USDC. 
keywords: [ deepbook, deepbookv3, pool, balancemanager, tradeproof, query a pool, query pool, whitelist status, base quantity against quote, quote quantity against base, DEEP fees, input token fees, quote quantity against quote or base, check fee required, reserve mid price, reserve pool mid price ]
---

The `Pool` shared object represents a market, such as a SUI/USDC market. That `Pool` is the only one representing that unique pairing (SUI/USDC) and the pairing is the only member of that particular `Pool`. See [DeepBookV3 Design](./design.mdx#pool) to learn more about the structure of pools.

To perform trades, you pass a `BalanceManager` and `TradeProof` into the relevant `Pool`. Unlike `Pool`s, `BalanceManager` shared objects can contain any type of token, such that the same `BalanceManager` can access multiple `Pool`s to interact with many different trade pairings. See [BalanceManager](./balance-manager.mdx) to learn more.

## API

DeepBookV3 exposes a set of endpoints that can be used to query any pool.

### Check whitelist status

Accessor to check whether the pool is whitelisted.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="whitelisted" noComments />

### Check quote quantity against base (DEEP fees)

Dry run to determine the quote quantity out for a given base quantity. Uses DEEP as fee.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_quote_quantity_out" noComments />

### Check base quantity against quote (DEEP fees)

Dry run to determine the base quantity out for a given quote quantity. Uses DEEP as fee.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_base_quantity_out" noComments />

### Check quote quantity against base (input token fees)

Dry run to determine the quote quantity out for a given base quantity. Uses input token as fee.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_quote_quantity_out_input_fee" noComments />

### Check base quantity against quote (input token fees)

Dry run to determine the base quantity out for a given quote quantity. Uses input token as fee.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_base_quantity_out_input_fee" noComments />

### Check quote quantity against quote or base

Dry run to determine the quantity out for a given base or quote quantity. Only one out of base or quote quantity should be non-zero. Returns the (`base_quantity_out`, `quote_quantity_out`, `deep_quantity_required`).

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_quantity_out" noComments />

### Check fee required

Returns the DEEP required for an order if it's a taker or maker given quantity and price (`deep_required_taker`, `deep_required_maker`).

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_order_deep_required" noComments />

### Retrieve mid price for a pool

Returns the mid price of the pool.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="mid_price" noComments />

### Retrieve order IDs

Returns the `order_id` for all open orders for the `balance_manager` in the pool.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="account_open_orders" noComments />

### Retrieve prices and quantities for an order book

Returns vectors holding the prices (`price_vec`) and quantities (`quantity_vec`) for the level2 order book. The `price_low` and `price_high` are inclusive, all orders within the range are returned. `is_bid` is `true` for bids and `false` for asks.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_level2_range" noComments />

Returns vectors holding the prices (`price_vec`) and quantities (`quantity_vec`) for the level2 order book. `ticks` are the maximum number of ticks to return starting from best bid and best ask. (`bid_price`, `bid_quantity`, `ask_price`, `ask_quantity`) are returned as four vectors. The price vectors are sorted in descending order for bids and ascending order for asks.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_level2_ticks_from_mid" noComments />

### Retrieve balances

Get all balances held in this pool.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="vault_balances" noComments />

### Retrieve pool ID

Get the ID of the pool given the asset types.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_pool_id_by_asset" noComments />

### Retrieve order information

Returns the `Order` struct using the order ID.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_order" noComments />

Returns a vector of `Order` structs using a vector of order IDs.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_orders" noComments />

Returns a vector of `Order` structs for all orders that belong to a `BalanceManager` in the pool.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_account_order_details" noComments />

### Retrieve locked balance

Returns the locked balance for a `BalanceManager` in the pool (`base_quantity`, `quote_quantity`, `deep_quantity`).

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="locked_balance" noComments />

### Retrieve pool parameters

Returns the trade parameters for the pool (`taker_fee`, `maker_fee`, `stake_required`).

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="pool_trade_params" noComments />

Returns the trade parameters for the next epoch for the currently leading proposal of the pool (`taker_fee`, `maker_fee`, `stake_required`).

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="pool_trade_params_next" noComments />

Returns the quorum needed to pass proposal in the current epoch.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="quorum" noComments />

Returns the book parameters for the pool (`tick_size`, `lot_size`, `min_size`).

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="pool_book_params" noComments />

Returns the `OrderDeepPrice` struct for the pool, which determines the conversion for DEEP fees.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="get_order_deep_price" noComments />

## Related links

<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />
>>>> sui/docs/content/standards/deepbookv3/staking-governance.mdx
---
title: Staking and Governance
description: Learn how to stake DEEP tokens and take advantage of taker and minter incentives.
keywords: [ taker fee, maker fee, stake, staking, governance, unstake, submit proposal, vote, claim rebates, deepbook pool, deepbook governance, deepbookv3 ]
---

DeepBook's novel approach to governance allows users to update a single pool's three parameters: 

- Taker fee rate
- Maker fee rate
- Stake required

Stake required is the amount of DEEP tokens a user must have staked in the pool to take advantage of taker and maker incentives. Each individual DeepBook pool has independent governance, and governance can be conducted every epoch. See [Design](./design.mdx#governance) to learn more about governance.

![DeepBook Governance Timeline.png](./images/governance.png)

## API

`Pool` exposes the following endpoints for staking and governance.

### Stake

DEEP tokens must be available in the `balance_manager` for staking. A user's stake becomes active in the following epoch. If the user's active stake is greater than the stake required, the user can get reduced taker fees and can accumulate trading fee rebates during that epoch.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="stake" noComments />

### Unstake

All of the user's active and inactive stake are removed and added back into the `BalanceManager`. Any casted votes are removed. Maker rebates for the epoch are forfeited, and any reduced taker fees for the remaining epoch are disabled.

The `balance_manager` must have enough staked DEEP tokens. The `balance_manager` data is updated with the unstaked amount. Balance is transferred to the `balance_manager` immediately.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="unstake" noComments />

### Submit proposal

Users with a non zero active stake can submit proposals. One proposal per user. The user automatically votes for the proposal they submit.

Submit a proposal to change the taker fee, maker fee, and stake required. The `balance_manager` must have enough staked DEEP tokens to participate. Each `balance_manager` can only submit one proposal per epoch. If the maximum proposal is reached, the proposal with the lowest vote is removed. If the `balance_manager` has less voting power than the lowest voted proposal, the proposal is not added.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="submit_proposal" noComments />

### Vote

Users with non-zero voting power can vote on a proposal. All voting power is used on a single proposal. If the user has voted on a different proposal during this epoch, then that vote is removed and recasted into the new proposal. The `balance_manager` must have enough staked DEEP tokens to participate.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="vote" noComments />

### Claim rebates

Use `claim_rebates` to claim the rewards for the `balance_manager`. The `balance_manager` must have rewards to claim. The `balance_manager` data is updated with the claimed rewards.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="claim_rebates" noComments />

## Related links

<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />
>>>> sui/docs/content/standards/deepbookv3/swaps.mdx
---
title: Swaps
description: Use DeepBookV3 to execute token swaps.
keywords: [ automatic market makers, amms, swap_exact_amount, balancemanager, base_in, quote_in, deep_in, swaps, swap base quantity, deep quantity, DEEP, swap exact quantity, deepbook, deepbookv3  ]
---

DeepBook provides a swap-like interface commonly seen in automatic market makers (AMMs). Unlike the order functions, you can call `swap_exact_amount` without a `BalanceManager`. You call it directly with `Coin` objects instead. When swapping from base to quote, `base_in` must have a positive value while `quote_in` must be zero. When swapping from quote to base, `quote_in` must be positive and `base_in` zero. Some `deep_in` amount is required to pay for trading fees. You can overestimate this amount, as the unused DEEP tokens are returned at the end of the call.

You can use the `get_amount_out` endpoint to simulate a swap. The function returns the exact amount of DEEP tokens that the swap requires.

## API

Following are the endpoints that the `Pool` exposes for swaps.

### Swap exact base for quote

Swap exact base quantity without needing a `balance_manager`. DEEP quantity can be overestimated. Returns three `Coin` objects:     

- `BaseAsset`
- `QuoteAsset`
- `DEEP` 

Some base quantity may be left over, if the input quantity is not divisible by lot size.

You can overestimate the amount of DEEP required. The remaining balance is returned.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="swap_exact_base_for_quote" noComments />

### Swap exact quote for base

Swap exact quote quantity without needing a `balance_manager`. You can overestimate DEEP quantity. Returns three `Coin` objects:

- `BaseAsset`
- `QuoteAsset`
- `DEEP`

Some quote quantity might be left over if the input quantity is not divisible by lot size.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3"  fun="swap_exact_quote_for_base" noComments />

### Swap exact quantity

This function is what the previous two functions call with `coin::zero()` set for the third coin. Users can call this directly for base â†’ quote or quote â†’ base as long as base or quote have a zero value.

<ImportContent source="packages/deepbook/sources/pool.move" mode="code" org="MystenLabs" repo="deepbookv3" fun="swap_exact_quantity" noComments />

## Related links

<RelatedLink href="https://github.com/MystenLabs/deepbookv3" label="DeepBookV3 repository" desc="The DeepBookV3 repository on GitHub." />

>>>> sui/docs/content/standards/display.mdx
---
title: Sui Object Display
description: The Sui Object Display standard is a template engine that enables on-chain management of off-chain representation (display) for a type.
keywords: [ Object Display, object, display, display properties, object properties, sui::display, display<T>, Sui utility objects, Unique objects with dynamic representation, objects with unique static content ]
pagination_prev: null
---

The Sui Object Display standard is a template engine that enables on-chain management of off-chain representation (display) for a type. With it, you can substitute data for an object into a template string. The standard doesnâ€™t limit the fields you can set. You can use the  `{property}` syntax to access all object properties, and then insert them as a part of the template string.

Use a `Publisher` object that you own to set `sui::display` for a type. For more information about `Publisher` objects, see [Publisher](https://examples.sui.io/basics/publisher.html) topic in *Sui Move by Example*.

In Sui Move, `Display<T>` represents an object that specifies a set of named templates for the type `T`. For example, for a type `0x2::capy::Capy` the display syntax is:  `Display<0x2::capy::Capy>`.

Sui Full nodes process all objects of the type `T` by matching the `Display` definition, and return the processed result when you query an object with the `{ showDisplay: true }` setting in the query.

## Display properties

The basic set of properties suggested includes:

- `name`: A name for the object. The name is displayed when users view the object.
- `description`: A description for the object. The description is displayed when users view the object.
- `link`: A link to the object to use in an application.
- `image_url`: A URL or a blob with the image for the object.
- `thumbnail_url`: A URL to a **smaller** image to use in wallets, explorers, and other products as a preview.
- `project_url`: A link to a website associated with the object or creator.
- `creator`: A string that indicates the object creator.


### Example: Sui Hero module

The following code sample demonstrates how the `Display` for an example `Hero` module varies based on the `name`, `id`, and `image_url` properties of the type `Hero`.
The following represents the template the `init` function defines:

```json
{
    "name": "{name}",
    "link": "https://sui-heroes.io/hero/{id}",
    "image_url": "https://sui-heroes.io/hero/{image_url}",
    "description": "A true Hero of the Sui ecosystem!",
    "project_url": "https://sui-heroes.io",
    "creator": "Unknown Sui Fan"
}
```

```move
/// Example of an unlimited "Sui Hero" collection - anyone can
/// mint their Hero. Shows how to initialize the `Publisher` and how
/// to use it to get the `Display<Hero>` object - a way to describe a
/// type for the ecosystem.
module examples::my_hero;

use std::string::String;

// The creator bundle: these two packages often go together.
use sui::package;
use sui::display;

/// The Hero - an outstanding collection of digital art.
public struct Hero has key, store {
    id: UID,
    name: String,
    image_url: String,
}

/// One-Time-Witness for the module.
public struct MY_HERO has drop {}

/// Claim the `Publisher` object in the module initializer 
/// to then create a `Display`. The `Display` is initialized with
/// a set of fields (but can be modified later) and published via
/// the `update_version` call.
///
/// Keys and values are set in the initializer but could also be
/// set after publishing if a `Publisher` object was created.
fun init(otw: MY_HERO, ctx: &mut TxContext) {
    let keys = vector[
        b"name".to_string(),
        b"link".to_string(),
        b"image_url".to_string(),
        b"description".to_string(),
        b"project_url".to_string(),
        b"creator".to_string(),
    ];

    let values = vector[
        // For `name` one can use the `Hero.name` property
        b"{name}".to_string(),
        // For `link` one can build a URL using an `id` property
        b"https://sui-heroes.io/hero/{id}".to_string(),
        // For `image_url` use an IPFS template + `image_url` property.
        b"ipfs://{image_url}".to_string(),
        // Description is static for all `Hero` objects.
        b"A true Hero of the Sui ecosystem!".to_string(),
        // Project URL is usually static
        b"https://sui-heroes.io".to_string(),
        // Creator field can be any
        b"Unknown Sui Fan".to_string(),
    ];

    // Claim the `Publisher` for the package!
    let publisher = package::claim(otw, ctx);

    // Get a new `Display` object for the `Hero` type.
    let mut display = display::new_with_fields<Hero>(
        &publisher, keys, values, ctx
    );

    // Commit first version of `Display` to apply changes.
    display.update_version();

    transfer::public_transfer(publisher, ctx.sender());
    transfer::public_transfer(display, ctx.sender());
}

/// Anyone can mint their `Hero`!
public fun mint(name: String, image_url: String, ctx: &mut TxContext): Hero {
    Hero {
        id: object::new(ctx),
        name,
        image_url
    }
}
```

## Work with Object Display

The `display::new<T>` call creates a `Display`, either in a custom function or module initializer, or as part of a programmable transaction.
The following code sample demonstrates how to create a `Display`:

```move
module sui::display;

/// Get a new Display object for the `T`.
/// Publisher must be the publisher of the T, `from_package`
/// check is performed.
public fun new<T>(pub: &Publisher): Display<T> { /* ... */ }
```

After you create the `Display`, you can modify it. The following code sample demonstrates how to modify a `Display`:

```move
module sui::display;

/// Sets multiple fields at once
public fun add_multiple(
    self: &mut Display,
    keys: vector<String>,
    values: vector<String>
) { /* ... */ }

/// Edit a single field
public fun edit(self: &mut Display, key: String, value: String) { /* ... */ }

/// Remove a key from Display
public fun remove(self: &mut Display, key: String ) { /* ... */ }
```

Next, the `update_version` call applies the changes and sets the `Display` for the `T` by emitting an event. Full nodes receive the event and use the data in the event to retrieve a template for the type.

The following code sample demonstrates how to use the `update_version` call:

```move
module sui::display;

/// Update the version of Display and emit an event
public fun update_version(self: &mut Display) { /* ... */ }
```

## Sui utility objects

In Sui, utility objects enable authorization for capabilities. Almost all modules have features that can be accessed only with the required capability. Generic modules allow one capability per application, such as a marketplace. Some capabilities mark ownership of a shared object on-chain, or access the shared data from another account.
With capabilities, it is important to provide a meaningful description of objects to facilitate user interface implementation. This helps avoid accidentally transferring the wrong object when objects are similar. It also provides a user-friendly description of items that users see.

The following example demonstrates how to create a capy capability:

```move
module capy::utility;

/// A capability which grants Capy Manager permission to add
/// new genes and manage the Capy Market
public struct CapyManagerCap has key, store { id: UID }
```

## Typical objects with data duplication

A common case with in-game items is to have a large number of similar objects grouped by some criteria. It is important to optimize their size and the cost to mint and update them. Typically, a game uses a single source image or URL per group or item criteria. Storing the source image inside of every object is not optimal.
In some cases, users mint in-game items when a game allows them or when they purchase an in-game item. To enable this, some IPFS/Arweave metadata must be created and stored in advance. This requires additional logic that is usually not related to the in-game properties of the item.

The following example demonstrates how to create a Capy:

```move
module capy::capy_items;

use std::string::String;

/// A wearable Capy item. For some items there can be an
/// unlimited supply. And items with the same name are identical.
public struct CapyItem has key, store {
    id: UID,
    name: String
}
```

## Unique objects with dynamic representation

Sui Capys use dynamic image generation. When a Capy is born, its attributes determine the Capyâ€™s appearance, such as color or pattern. When a user puts an item on a Capy, the Capyâ€™s appearance changes. When users put multiple items on a Capy, thereâ€™s a chance of a bonus for a combination of items.

To implement this, the Capys game API service refreshes the image in response to a user-initiated change. The URL for a Capy is a template with the `capy.id`. But storing the full URL - as well as other fields in the Capy object due to their diverse population - also leads to users paying for excess storage and increased gas fees.

The following example demonstrates how to implement dynamic image generation:

```move
module capy::capy;

/// A Capy - very diverse object with different combination
/// of genes. Created dynamically + for images a dynamic SVG
/// generation is used.
public struct Capy has key, store {
    id: UID,
    genes: vector<u8>
}
```

## Objects with unique static content

This is the simplest scenario - an object represents everything itself. It is very easy to apply a metadata standard to an object of this kind, especially if the object stays immutable forever. However, if the metadata standard evolves and some ecosystem projects add new features for some properties, this object always stays in its original form and might require backward-compatible changes.

```move
module sui::devnet_nft;

use std::string::String;

/// A Collectible with a static data. URL, name, description are
/// set only once on a mint event
public struct DevNetNFT has key, store {
    id: UID,
    name: String,
    description: String,
    url: String,
}
```

>>>> sui/docs/content/standards/kiosk-apps.mdx
---
title: Kiosk Apps
description: Kiosk apps are a way to extend the functionality of Sui Kiosk while keeping the core functionality intact. You can develop apps to add new features to a kiosk without having to modify the core code or move the assets elsewhere.
keywords: [kiosk apps, basic kiosk apps, permissioned kiosk apps, UID access via uid_mut, uid_mut, kiosk::uid_mut_as_owner, Kiosk Apps API, kiosk extension ]
pagination_prev: null
---

Kiosk apps are a way to extend the functionality of Sui Kiosk while keeping the core functionality intact. You can develop apps to add new features to a kiosk without having to modify the core code or move the assets elsewhere.

There are two types of apps:

- [Basic apps](#basic-apps)
- [Permissioned apps](#permissioned-apps)

## Basic apps

Basic Kiosk apps do not require Kiosk Apps API to function. They usually serve the purpose of adding custom metadata to a kiosk or wrapping/working with existing objects such as `Kiosk` or `KioskOwnerCap`. An example of an app that does not require the API is the Personal Kiosk app.

### UID access via the uid_mut

Kiosk has an `id: UID` field like all objects on Sui, which allows this object to be uniquely identified and carry custom dynamic fields and dynamic object fields. The Kiosk itself is built around dynamic fields and features like place and list are built around dynamic object fields.

### The uid_mut_as_owner function

Kiosk can carry additional dynamic fields and dynamic object fields. The `uid_mut_as_owner` function allows the Kiosk owner to mutably access the UID of the Kiosk object and use it to add or remove custom fields.

Function signature:

`kiosk::uid_mut_as_owner(self: &mut Kiosk, cap: &KioskOwnerCap): &mut UID`

### The public uid getter

Anyone can read the `uid` of kiosks. This allows third party modules to read the fields of the kiosk if they're allowed to do so. Therefore enabling the object capability and other patterns.

### Basic app ideas

You can attach custom dynamic fields to your kiosks that anyone can then read (but only you can modify), you can use this to implement basic apps. For example, a Kiosk Name app where you as the kiosk owner can set a name for the kiosk, attach it as a dynamic field, and make it readable by anyone.

```move
module examples::kiosk_name_ext;

use std::string::String;
use sui::dynamic_field as df;
use sui::kiosk::{Self, Kiosk, KioskOwnerCap};

/// The dynamic field key for the Kiosk Name Extension
struct KioskName has copy, store, drop {}

/// Add a name to the Kiosk (in this implementation can be called only once)
public fun add(self: &mut Kiosk, cap: &KioskOwnerCap, name: String) {
    let uid_mut = self.uid_mut_as_owner(cap);
    df::add(uid_mut, KioskName {}, name)
}

/// Try to read the name of the Kiosk - if set - return Some(String), if not - None
public fun name(self: &Kiosk): Option<String> {
    if (df::exists_(self.uid(), KioskName {})) {
        option::some(*df::borrow(self.uid(), KioskName {}))
    } else {
        option::none()
    }
}
```

## Permissioned apps using the Kiosk Apps API {#permissioned-apps}

Permissioned apps use the Kiosk Apps API to perform actions in the kiosk. They usually imply interaction with a third party and provide guarantees for the storage access (preventing malicious actions from the seller).

Just having access to the `uid` is often not enough to build an app due to the security limitations. Only the owner of a kiosk has full access to the `uid`, which means that an app involving a third party would require involvement from the kiosk owner in every step of the process.

In addition to limited and constrained access to storage, app permissions are also owner dependent. In the default setup, no party can place or lock items in a kiosk without its owner's consent. As a result, some cases such as collection bidding (offering X SUI for any item in a collection) requires the kiosk owner to approve the bid.

## kiosk_extension module

The `kiosk_extension` module addresses concerns over owner bottlenecks and provides more guarantees for storage access. The module provides a set of functions that enable you to perform certain actions in the kiosk without the kiosk owner's involvement and have a guarantee that the storage of the app is not tampered with.

```move
module example::my_extension;

use sui::kiosk_extension;

// ...
```

## App lifecycle

These are the key points in the lifecycle of a Sui Kiosk app:

- You can only install an app with an explicit call in the `kiosk_extension` module.
- A kiosk owner can revoke permissions of an app at any time by calling the `disable` function.
- A kiosk owner can re-enable a disabled app at any time by calling the `enable` function.
- You can only remove apps if the app storage is empty (all items are removed).

## Adding an app

For the app to function, the kiosk owner first needs to install it. To achieve that, an app needs to implement the `add` function that the kiosk owner calls to request all necessary permissions.

### Implementing add function

The signature of the `kiosk_extension::add` function requires the app witness, making it impossible to install an app without an explicit implementation. The following example shows how to implement the `add` function for an app that requires the `place` permission:

```move
module examples::letterbox_ext;

use sui::kiosk_extension;

// ... dependencies

/// The expected set of permissions for extension. It requires `place`.
const PERMISSIONS: u128 = 1;

/// The Witness struct used to identify and authorize the extension.
struct Extension has drop {}

/// Install the Mallbox extension into the Kiosk.
public fun add(kiosk: &mut Kiosk, cap: &KioskOwnerCap, ctx: &mut TxContext) {
    kiosk_extension::add(Extension {}, kiosk, cap, PERMISSIONS, ctx)
}
```

## App permissions

Apps can request permissions from the kiosk owner on installation. Permissions follow the all or nothing principle. If the kiosk owner adds an app, it gets all of the requested permissions; if the kiosk owner then disables an app, it loses all of its permissions.

### Structure

Permissions are represented as a `u128` integer storing a bitmap. Each of the bits corresponds to a permission, the first bit is the least significant bit. The following table lists all permissions and their corresponding bit:

| Bit |	Decimal	| Permission |
| --- | --- | --- |
| 0000 | 0 | No permissions |
| 0001 | 1 | App can place |
| 0010| 2 |	App can place and lock |
| 0011| 3 |	App can place and lock |

:::info

Currently, Sui Kiosk has only two permissions: `place` (first bit) and `lock` and `place` (second bit). The remaining bits are reserved for future use.

:::

### Using permissions in the add function

It's considered good practice to define a constant containing permissions of the app:

```move
module examples::letterbox_ext;
// ... dependencies

/// The expected set of permissions for the app. It requires `place`.
const PERMISSIONS: u128 = 1;

/// The witness struct used to identify and authorize the app.
struct Extension has drop {}

/// Install the Mallbox app into the kiosk and request `place` permission.
public fun add(kiosk: &mut Kiosk, cap: &KioskOwnerCap, ctx: &mut TxContext) {
    kiosk_extension::add(Extension {}, kiosk, cap, PERMISSIONS, ctx)
}
```

### Accessing protected functions

If an app requests and is granted permissions (and isn't disabled), it can access protected functions. The following example shows how to access the `place` function:

```move
module examples::letterbox_ext;
// ...

/// Emitted when trying to place an item without permissions.
const ENotEnoughPermissions: u64 = 1;

/// Place a letter into the kiosk without the `KioskOwnerCap`.
public fun place(kiosk: &mut Kiosk, letter: Letter, policy: &TransferPolicy<T>) {
    assert!(kiosk_extension::can_place<Extension>(kiosk), ENotEnoughPermissions)

    kiosk_extension::place(Extension {}, kiosk, letter, policy)
}
```
Currently, two functions are available:

- `place<Ext, T>(Ext, &mut Kiosk, T, &TransferPolicy<T>)` - similar to place
- `lock<Ext, T>(Ext, &mut Kiosk, T, &TransferPolicy<T>)` - similar to lock

### Checking permissions

Use the `can_place<Ext>(kiosk: &Kiosk): bool` function to check if the app has the `place` permission. Similarly, you can use the `can_lock<Ext>(kiosk: &Kiosk): bool` function to check if the app has the `lock` permission. Both functions make sure that the app is enabled, so you don't need to explicitly check for that.

## App storage

Every app gets its isolated storage as a bag type that only the app module can access (providing the app witness). See [The Move Book](https://move-book.com/programmability/dynamic-collections.html) to learn more about dynamic collections, like bags, available in Move. After you install an app, it can use the storage to store its data. Ideally, the storage should be managed in a way that allows the app to be removed from the kiosk if there are no active trades or other activities happening at the moment.

The storage is always available to the app if it is installed. The owner of a kiosk can't access the storage of the app if the logic for it is not implemented.

### Accessing the storage

An installed app can access the storage mutably or immutably using one of the following functions:

- `storage(_ext: Extension {}, kiosk: &Kiosk): Bag`: returns a reference to the storage of the app. Use the function to read the storage.
- `storage_mut(_ext: Extension {}, kiosk: &mut Kiosk): &mut Bag`: returns a mutable reference to the storage of the app. Use the function to read and write to the storage.

## Disabling and removing

The kiosk owner can disable any app at any time. Doing so revokes all permissions of the app and prevents it from performing any actions in the kiosk. The kiosk owner can also re-enable the app at any time.

Disabling an app does not remove it from the kiosk. An installed app has access to its storage until completely removed from the kiosk.

### Disabling an app

Use the `disable<Ext>(kiosk: &mut Kiosk, cap: &KioskOwnerCap)` function to disable an app. It revokes all permissions of the app and prevents it from performing any protected actions in the kiosk.

**Example PTB**

```javascript
let txb = new TransactionBuilder();
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');

txb.moveCall({
    target: '0x2::kiosk_extension::disable',
    arguments: [ kioskArg, capArg ],
    typeArguments: '<letter_box_package>::letterbox_ext::Extension'
});
```

### Removing an app

You can remove an app only if the storage is empty. Use the `remove<Ext>(kiosk: &mut Kiosk, cap: &KioskOwnerCap)` function to facilitate removal. The function removes the app, unpacks the app storage and configuration and rebates the storage cost to the kiosk owner. Only the kiosk owner can perform this action.

The call fails if the storage is not empty.

**Example PTB**

```javascript
let txb = new TransactionBuilder();
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');

txb.moveCall({
    target: '0x2::kiosk_extension::remove',
    arguments: [ kioskArg, capArg ],
    typeArguments: '<letter_box_package>::letterbox_ext::Extension'
});
```

## Related links

<RelatedLink to="/guides/developer/nft/nft-rental.mdx" />
<RelatedLink href="https://github.com/MystenLabs/sui/tree/main/examples/move/nft-rental" label="NFT Rental repository" desc="GitHub repo that contains the source code for the NFT Rental app." />

>>>> sui/docs/content/standards/kiosk.mdx
---
title: Sui Kiosk
description: Kiosk is a decentralized system for commerce applications on Sui. Kiosk is a part of the Sui framework, native to the system, and available to everyone.
keywords: [kiosk, sui kiosk, create a kiosk, create kiosk with sui cli, kiosk SDK, TypeScript, kiosk owners, placing objects in kiosk, kiosk for buyers, kiosk creators, kiosk for creators, kiosk::take, kiosk::borrow, kiosk::borrow_mut, kiosk::borrow_val, lock item in kiosk, lock kiosk item, list item in kiosk, delist item, remove item from kiosk list, withdraw from kiosk ]
pagination_prev: null
---

Kiosk is a decentralized system for commerce applications on Sui. It consists of `Kiosk` objects - shared objects owned by individual parties that store assets and allow listing them for sale as well as utilize custom trading functionality - for example, an auction. While being highly decentralized, Sui Kiosk provides a set of strong guarantees:

- Kiosk owners retain ownership of their assets to the moment of purchase.
- Creators set custom policies - sets of rules applied to every trade (such as pay royalty fee or do some arbitrary action X).
- Marketplaces can index events the `Kiosk` object emits and subscribe to a single feed for on-chain asset trading.

Practically, Kiosk is a part of the Sui framework, and it is native to the system and available to everyone out of the box.

:::info

See the [Kiosk SDK documentation](https://sdk.mystenlabs.com/kiosk) for examples of working with Kiosk using TypeScript.

:::

## Sui Kiosk owners

Anyone can create a Sui Kiosk. Ownership of a kiosk is determined by the owner of the `KioskOwnerCap`, a special object that grants full access to a single kiosk. As the owner, you can sell any asset with a type (T) that has a shared `TransferPolicy` available, or you can use a kiosk to store assets even without a shared policy. You canâ€™t sell or transfer any assets from your kiosk that do not have an associated transfer policy available.

To sell an item, if there is an existing transfer policy for the type (T), you just add your assets to your kiosk and then list them. You specify an offer amount when you list an item. Anyone can then purchase the item for the amount of SUI specified in the listing. The associated transfer policy determines what the buyer can do with the purchased asset.

A kiosk owner can:

- Place and take items
- List items for sale
- Add and remove Extensions
- Withdraw profits from sales
- Borrow and mutate owned assets
- Access the full set of trading tools, such as auctions, lotteries, and collection bidding

## Sui Kiosk for buyers

A buyer is a party that purchases (or - more generally - receives) items from kiosks, anyone on the network can be a buyer (and, for example, a kiosk owner at the same time).

**Benefits:**

- Buyers get access to global liquidity and can get the best offer
- Buyers can place bids on collections through their kiosks
- Most buyer actions performed in kiosks clean up seller objects, which results in free (gas-less) actions

**Responsibilities:**

- Buyer is the party that pays the fees if they're set in the policy
- Buyer must follow the rules set by creators or a transaction won't succeed

**Guarantees:**

- When using a custom trading logic such as an auction, the items are guaranteed to be unchanged until the trade is complete

## Sui Kiosk for marketplaces

As a marketplace operator, you can implement Sui Kiosk to watch for offers made in a collection of kiosks and display them on a marketplace site. You can also implement a custom system using Kiosk extensions (created by the community or third-parties). For example, marketplaces can use a `TransferPolicyCap` to implement application-specific transfer rules.

## Sui Kiosk for creators

As a creator, Sui Kiosk supports strong enforcement for transfer policies and associated rules to protect assets and enforce asset ownership. Sui Kiosk gives creators more control over their creations, and puts creators and owners in control of how their works can be used.

Creator is a party that creates and controls the TransferPolicy for a single type. For example, the authors of SuiFrens are the Creators of the `SuiFren<Capy>` type and act as creators in the Kiosk ecosystem. Creators set the policy, but they might also be the first sellers of their assets through a kiosk.

**Creators can:**

- Set any rules for trades
- Set multiple ways ("tracks") of rules
- Enable or disable trades at any moment with a policy
- Enforce policies (like royalties) on all trades
- Perform a primary sale of their assets through a kiosk

All of the above is effective immediately and globally.

**Creators cannot:**

- Take or modify items stored in someone else's kiosk
- Restrict taking items from kiosks if the "locking" rule was not set in the policy

## Sui Kiosk guarantees

Sui Kiosk provides a set of guarantees that Sui enforces through smart contracts.
These guarantees include:

- Every trade in Sui Kiosk requires a `TransferPolicy` resolution. This gives creators control over how their assets can be traded.
- True ownership, which means that only a kiosk owner can take, list, borrow, or modify the assets added to their kiosk. This is similar to how single-owner objects work on Sui.
- Strong policy enforcement, for example Royalty policies, that lets creators enable or disable policies at any time that applies to all trades on the platform for objects with that policy attached.
- Changes to a `TransferPolicy` apply instantly and globally.

In practice, these guarantees mean that:

- When you list an item for sale, no one can modify it or take it from the kiosk.
- When you define a `PurchaseCap`, an item remains locked and you canâ€™t modify or take the item from the kiosk unless the trade uses or returns the `PurchaseCap`.
- You can remove any rule at any time (as the owner).
- You can disable any extension at any time (as the owner).
- The state of an extension state is always accessible to the extension.

### Asset states in Sui Kiosk {#asset-states}

Sui Kiosk is a shared object that can store heterogeneous values, such as different sets of asset collectibles. When you add an asset to your kiosk, it has one of the following states:

- PLACED: An item placed in the kiosk using the `kiosk::place` function. The kiosk owner can withdraw it and use it directly, borrow it (mutably or immutably), or list an item for sale.
- LOCKED: An item placed in the kiosk using the `kiosk::lock` function. You canâ€™t withdraw a Locked item from a kiosk, but you can borrow it mutably and list it for sale. Any item placed in a kiosk that has an associated kiosk lock policy have a LOCKED state.
- LISTED: An item in the kiosk that is listed for sale using the `kiosk::list` or `kiosk::place_and_list` functions. You canâ€™t modify an item while listed, but you can borrow it immutably or delist it, which returns it to its previous state.
- LISTED EXCLUSIVELY: An item placed or locked in the kiosk by an extension that calls the `kiosk::list_with_purchase_cap` function. Only the kiosk owner can approve calling the function. The owner can only borrow it immutably. The extension must provide the functionality to delist / unlock the asset, or it might stay locked forever. Given that this action is explicitly performed by the owner - it is the responsibility of the owner to choose verified and audited extensions to use.

When someone purchases an asset from a kiosk, the asset leaves the kiosk and ownership transfers to the buyerâ€™s address.

## Open a Sui Kiosk

To use a Sui Kiosk, you must create one and have the `KioskOwnerCap` that matches the `Kiosk` object. You can create a new kiosk using a single transaction by calling the `kiosk::default` function. The function creates and shares a `Kiosk`, and transfers the `KioskOwnerCap` to your address.

### Create a Sui Kiosk using programmable transaction blocks

```javascript
let tx = new Transaction();
tx.moveCall({
	target: '0x2::kiosk::default',
});
```

### Create a Sui Kiosk using the Sui CLI

<ImportContent source="info-gas-budget.mdx" mode="snippet" />

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function default \
    --gas-budget 1000000000
```

### Create a Sui Kiosk with advanced options

For more advanced use cases, when you want to choose the storage model or perform an action right away, you can use the programmable transaction block (PTB) friendly function `kiosk::new`.
Kiosk is designed to be shared. If you choose a different storage model, such as owned, your kiosk might not function as intended or not be accessible to other users. You can make sure your kiosk works by testing it on Sui Testnet.

### Create a Sui Kiosk with advanced options using programmable transaction blocks

```javascript
let tx = new Transaction();
let [kiosk, kioskOwnerCap] = tx.moveCall({
	target: '0x2::kiosk::new',
});

tx.transferObjects([kioskOwnerCap], sender);
tx.moveCall({
	target: '0x2::transfer::public_share_object',
	arguments: [kiosk],
	typeArguments: '0x2::kiosk::Kiosk',
});
```

### Create a Sui Kiosk with advanced options using the Sui CLI

Sui CLI does not support PTBs and transaction chaining yet. You can use the `kiosk::default` function instead.

## Place items in and take items from your kiosk

As a kiosk owner, you can place any assets into your Sui Kiosk. You can take any item from your kiosk that is not currently listed for sale.

There's no limitations on which assets you can place in your kiosk. However, you canâ€™t necessarily list and trade all of the items you place in your kiosk. The `TransferPolicy` associated with the type for the item determines whether you can trade it. To learn more, see the [Purchase items from a kiosk](#purchase) section.

### Place an item in your kiosk

To place an item to the kiosk, the owner needs to call the `sui::kiosk::place` function on the `Kiosk` object and pass the `KioskOwnerCap` and the `Item` as arguments.

`ITEM_TYPE` in the following examples represents the full type of the item.

### Place an item using programmable transaction blocks

```javascript
let tx = new Transaction();

let itemArg = tx.object('<ID>');
let kioskArg = tx.object('<ID>');
let kioskOwnerCapArg = tx.object('<ID>');

tx.moveCall({
	target: '0x2::kiosk::place',
	arguments: [kioskArg, kioskOwnerCapArg, itemArg],
	typeArguments: ['<ITEM_TYPE>'],
});
```

### Place an item using the Sui CLI

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function place \
    --args "<KIOSK_ID>" "<CAP_ID>" "<ITEM_ID>" \
    --type-args "<ITEM_TYPE>" \
    --gas-budget 1000000000
```

## Take items from a kiosk

To take an item from a kiosk you must be the kiosk owner. As the owner, call the `sui::kiosk::take` function on the `Kiosk` object, and pass the `KioskOwnerCap` and `ID` of the item as arguments.

`ITEM_TYPE` in the following examples represents the full type of the item.

### Take an item from a kiosk using programmable transaction blocks

```javascript
let tx = new Transaction();

let itemId = tx.pure.id('<ITEM_ID>');
let kioskArg = tx.object('<ID>');
let kioskOwnerCapArg = tx.object('<ID>');

let item = tx.moveCall({
	target: '0x2::kiosk::take',
	arguments: [kioskArg, kioskOwnerCapArg, itemId],
	typeArguments: ['<ITEM_TYPE>'],
});
```

### Take an item from a kiosk using the Sui CLI

The `kiosk::take` function is built to be PTB friendly and returns the asset. The Sui CLI does not yet support transaction chaining.

## Lock items in a kiosk

Some policies require that assets never get removed from a kiosk, such as for strong royalty enforcement. To support this, Sui Kiosk provides a locking mechanism. Locking is similar to placing except that you can't take a locked asset out of the kiosk.

To lock an asset in a kiosk, call the `sui::kiosk::lock` function. To ensure that you can later unlock the asset you must associate a `TransferPolicy` with the asset.

:::info

After you lock an asset, you must use `list` or `list_with_purchase_cap` functions to list it.

:::

### Lock an item in a kiosk

When you use the `lock` function, similar to using the `place` function, you specify the `KioskOwnerCap` and the `Item` as arguments. But to lock the item, you must also show the `TransferPolicy`.

`<ITEM_TYPE>` in the following examples represents the full type of the asset.

### Lock an item using programmable transaction blocks

```javascript
const tx = new Transaction();

let kioskArg = tx.object('<ID>');
let kioskOwnerCapArg = tx.object('<ID>');
let itemArg = tx.object('<ID>');
let transferPolicyArg = tx.object('<ID>');

tx.moveCall({
	target: '0x2::kiosk::lock',
	arguments: [kioskArg, kioskOwnerCapArg, transferPolicyArg, itemArg],
	typeArguments: ['<ITEM_TYPE>'],
});
```

### Lock an item using the Sui CLI

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function lock \
    --args "<KIOSK_ID>" "<CAP_ID>" "<TRANSFER_POLICY_ID>" "<ITEM_ID>" \
    --type-args "<ITEM_TYPE>" \
    --gas-budget 1000000000
```

## List and delist items from a kiosk

Sui Kiosk provides basic trading functionality. As a kiosk owner, you can list assets for sale, and buyers can discover and purchase them. Sui Kiosk supports listing items by default with three primary functions:

- `kiosk::list` - list an asset for sale for a fixed price
- `kiosk::delist` - remove an existing listing
- `kiosk::purchase` - purchase an asset listed for sale

Anyone on the network can purchase an item listed from a Sui Kiosk. To learn more about the purchase flow, see the [Purchase section](#purchase). To learn more about asset states and what can be done with a listed item, see the [Asset States](#asset-states) section.

### List an item from a kiosk

As a kiosk owner, you can use the `kiosk::list` function to list any asset you added to your kiosk. Include the item to sell and the list price as arguments. All listings on Sui are in SUI tokens.
When you list an item, Sui emits a `kiosk::ItemListed` event that contains the kiosk ID, item ID, type of the item, and the list price.

### List an item using programmable transaction blocks

```javascript
let tx = new Transaction();

let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');
let itemId = tx.pure.id('<ID>');
let itemType = 'ITEM_TYPE';
let priceArg = tx.pure.u64('<price>'); // in MIST (1 SUI = 10^9 MIST)

tx.moveCall({
	target: '0x2::kiosk::list',
	arguments: [kioskArg, capArg, itemId, priceArg],
	typeArguments: [itemType],
});
```

### List an item using the Sui CLI

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function list \
    --args "<KIOSK_ID>" "<CAP_ID>" "<ITEM_ID>" "<PRICE>" \
    --type-args "ITEM_TYPE" \
    --gas-budget 1000000000
```

### Delist an item

As a kiosk owner you can use the `kiosk::delist` to delist any currently listed asset. Specify the item to delist as an argument.

When you delist an item, Sui returns to the kiosk owner the gas fees charged to list the item.

When you delist an item, Sui emits a `kiosk::ItemDelisted` event that contains the kiosk ID, item ID, and the type of the item.

### Delist an item using the programmable transaction blocks

```javascript
let tx = new Transaction();
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');
let itemId = tx.pure.id('<ID>');
let itemType = 'ITEM_TYPE';

tx.moveCall({
	target: '0x2::kiosk::delist',
	arguments: [kioskArg, capArg, itemId],
	typeArguments: [itemType],
});
```

### Delist an item using the Sui CLI

```sh
$ sui client call \
    --package 0x2 \
    --module kiosk \
    --function delist \
    --args "<KIOSK_ID>" "<CAP_ID>" "<ITEM_ID>" \
    --type-args "ITEM_TYPE" \
    --gas-budget 1000000000
```

## Purchase an item from a kiosk {#purchase}

Anyone that has an address on the Sui network can purchase an item listed from a Sui Kiosk. To purchase an item, you can use the `kiosk::purchase` function. Specify the item to purchase and pay the list price set by the kiosk owner.

You can discover the items listed on the network with the `kiosk::ItemListed` event.

When you use the `kiosk::purchase` function, it returns the purchased asset and the `TransferRequest` for the type associated with the asset. To complete the purchase, you must meet the terms defined in the `TransferPolicy` applied to the asset.

## Borrow an item from a kiosk

As a kiosk owner, you can access an asset placed or locked in a kiosk without taking the asset from the kiosk. You can always borrow the asset immutably. Whether you can mutably borrow an asset depends on the state of the asset. For example, you canâ€™t borrow a listed asset because you canâ€™t modify it while listed. The functions available include:

- `kiosk::borrow`: Returns an immutable reference to the asset
- `kiosk::borrow_mut`: Returns a mutable reference to the asset
- `kiosk::borrow_val`: A PTB-friendly version of `borrow_mut`, which allows you to take an asset and place it back in the same transaction.

### Immutable borrow

You can always borrow an asset from a kiosk immutably. You can use the `kiosk::borrow` function to borrow an asset, however, it is not possible to use references within a programmable transaction block. To access the asset you must use a published module (function).

### Immutably borrow an asset using Sui Move

```move
module examples::immutable_borrow;

use sui::kiosk::{Self, Kiosk, KioskOwnerCap};

public fun immutable_borrow_example<T>(self: &Kiosk, cap: &KioskOwnerCap, item_id: ID): &T {
    self.borrow(cap, item_id)
}
```

### Mutable borrow with borrow_mut

You can mutably borrow an asset from a kiosk if it is not listed. You can use the `kiosk::borrow_mut` function to mutably borrow an asset. However, it is not possible to use references within a PTB, so to access the mutably borrowed asset you must use a published module (function).

### Mutably borrow an asset using Sui Move

```move
module examples::mutable_borrow;

use sui::kiosk::{Self, Kiosk, KioskOwnerCap};

public fun mutable_borrow_example<T>(
    self: &mut Kiosk, cap: &KioskOwnerCap, item_id: ID
): &mut T {
    self.borrow_mut(cap, item_id)
}
```

### Mutable borrow with borrow_val

Use the PTB-friendly `kiosk::borrow_val` function to take an asset and place it back in the same transaction. To make sure the asset is placed back into the kiosk, the function obliges the caller with a Hot Potato. See The Move Book for more information on the [Hot Potato pattern](https://move-book.com/programmability/hot-potato-pattern).

### Mutable borrow with `borrow_val` using programmable transaction blocks

```javascript
let tx = new Transaction();

let itemType = 'ITEM_TYPE';
let itemId = tx.pure.id('<ITEM_ID>');
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');

let [item, promise] = tx.moveCall({
	target: '0x2::kiosk::borrow_val',
	arguments: [kioskArg, capArg, itemId],
	typeArguments: [itemType],
});

// freely mutate or reference the `item`
// any calls are available as long as they take a reference
// `returnValue` must be explicitly called

tx.moveCall({
	target: '0x2::kiosk::return_val',
	arguments: [kioskArg, item, promise],
	typeArguments: [itemType],
});
```

## Withdraw proceeds from a completed sale

When someone purchases an item, Sui stores the proceeds from the sale in the kiosk. As the kiosk owner, you can withdraw the proceeds at any time by calling the `kiosk::withdraw` function. The function is simple, but because it is PTB friendly it is not currently supported in the Sui CLI.

### Withdraw proceeds using programmable transaction blocks

```javascript
let tx = new Transaction();
let kioskArg = tx.object('<ID>');
let capArg = tx.object('<ID>');

// because the function uses an Option<u64> argument,
// constructing is a bit more complex
let amountArg = tx.moveCall({
	target: '0x1::option::some',
	arguments: [tx.pure.u64('<amount>')],
	typeArguments: ['u64'],
});

// alternatively
let withdrawAllArg = tx.moveCall({
	target: '0x1::option::none',
	typeArguments: ['u64'],
});

let coin = tx.moveCall({
	target: '0x2::kiosk::withdraw',
	arguments: [kioskArg, capArg, amountArg],
	typeArguments: ['u64'],
});
```

### Withdraw proceeds using the Sui CLI

This action is not currently supported in the CLI environment.

>>>> sui/docs/content/standards/payment-kit.mdx
---
title: Payment Kit Standard
description: The Sui Payment Kit is a robust, open-source payment processing toolkit that provides secure payment verification, receipt management, and duplicate prevention for applications built on the Sui blockchain.
sidebar_label: Payment Kit
keywords:
  [
    payment processing,
    payment verification,
    payment receipts,
    duplicate prevention,
    payment registry,
    ephemeral payments,
    multi-coin support,
    payment kit,
    payment standard,
    sui payments,
  ]
pagination_prev: null
---

The Sui Payment Kit is a framework for secure, flexible payment processing on Sui. It provides persistent and ephemeral payment options, event-driven architecture, and built-in duplicate prevention.

The Payment Kit standardizes payment processing on Sui, enabling developers to build robust payment flows without reimplementing common payment verification and receipt management logic. Applications using the Payment Kit benefit from battle-tested security patterns and consistent payment handling across the ecosystem.

## Key features

The Payment Kit provides the following core capabilities:

- **Secure payment processing**: Validates payment amounts and transfers coins safely.
- **Payment registries**: Optional persistent storage for payment receipts with duplicate detection.
- **Flexible receipt management**: Generates receipts for payment tracking and verification.
- **Event-driven architecture**: Emits events for off-chain tracking and integration.
- **Multi-coin support**: Works with any Sui coin type.
- **Transaction URIs**: Standardized URI format in order to create encoded links for user friendly payment flows.

## Architecture components

The Payment Kit consists of the following main components:

### Payment processing core

Handles coin transfers, payment validation, and receipt generation. The core validates that:

- Payment amounts match expected values
- Coins have sufficient balance
- Transfers complete successfully
- Receipts contain accurate payment information

### Registry system

Optional persistent storage that tracks payment history and prevents duplicate payments. Registries provide:

- Payment record storage with composite keys
- Configurable expiration policies for payment records
- Withdrawal capabilities for accumulated funds
- Administrative controls via capabilities

## Core concepts

### Payment modes

The Payment Kit supports two payment processing modes:

**1. Registry payments**: Process payments through a `PaymentRegistry` with duplicate prevention and persistent receipts. Use this mode when:

- You need to prevent duplicate payments
- Payment history must be tracked
- Compliance or auditing requires payment records
- Funds should accumulate in a managed registry

**2. Ephemeral payments**: Process one-time payments without persistent storage. Use this mode when:

- Duplicate prevention is not enforced

### Duplicate prevention

Duplicate prevention is enforced when processing payments via a `PaymentRegistry`. The system uses a composite `PaymentKey` derived from:

- **Nonce**: Unique identifier for each payment `(UUIDv4)`.
- **Amount**: Payment value in coin units.
- **Coin type**: The specific coin type.
- **Receiver address**: Destination address for the payment.

This composite key ensures that the same payment cannot be processed twice, even if individual components (like amount or receiver) are reused across different payments.

### Payment receipts

Every processed payment generates a `PaymentReceipt` object containing:

- Payment nonce for reference
- Amount paid
- Coin type used
- Receiver address
- Timestamp of payment
- Registry information (for registry payments; not applicable to ephemeral payments)

Receipts serve as proof of payment and can be used for off-chain verification, accounting, or integration with other systems.

### Payment records

When payments are processed through a `PaymentRegistry`, the system creates and stores `PaymentRecord` objects internally to track payment history and enable duplicate prevention.

Payment records differ from payment receipts in key ways:

**PaymentRecords vs PaymentReceipts:**

- **`PaymentRecords`**: Internal registry storage structures that persist payment metadata for duplicate detection. These are stored within the registry's internal tables and are not directly accessible as objects.
- **`PaymentReceipts`**: User-facing objects returned after payment processing that serve as proof of payment. These can be stored, transferred, or used for off-chain verification.

**`PaymentRecord` lifecycle:**

1. **Creation**: When `process_registry_payment` is called, a `PaymentRecord` is created and stored in the registry using the composite `PaymentKey`.
2. **Storage**: Records persist in the registry's internal table, indexed by their unique payment key.
3. **Expiration**: Records become eligible for deletion after the registry's configured `epoch_expiration_duration` has passed.
4. **Deletion**: Expired records can be removed using `delete_payment_record` to reclaim storage and reduce gas costs.

**`PaymentRecord` expiration:**

A `PaymentRecord` include an expiration epoch calculated at the time of payment creation. This expiration mechanism:

- Prevents indefinite storage growth in registries
- Allows for eventual cleanup of historical payment data
- Balances duplicate prevention needs with storage efficiency
- Can be configured per-registry via `set_config_epoch_expiration_duration`

A `PaymentRecord` cannot be deleted before its expiration epoch, ensuring a minimum retention period for duplicate detection. After expiration, administrators or users can delete records to free storage, though deletion is optional.

## Working with payment registries

### Creating a registry

To create a new payment registry, you need to provide a `name` which is simply an ACSII-based string that is used to derive an address for the registry. In addition to a `name`, the package `Namespace` object must also be provided. `Namespace` provides a higher-order organizational structure for managing multiple payment registries.

```move
module sui::payment_kit;

public fun create_registry(
    namespace: &mut Namespace,
    name: String,
    ctx: &mut TxContext
)
```

This function creates a `PaymentRegistry` and a `RegistryAdminCap` for administrative control. The `RegistryAdminCap` is initially owned by the creator and can be shared or transferred as needed.

#### Namespace objects

```
mainnet: 0xccd3e4c7802921991cd9ce488c4ca0b51334ba75483702744242284ccf3ae7c2
```

```
testnet: 0xa5016862fdccba7cc576b56cc5a391eda6775200aaa03a6b3c97d512312878db
```

### Processing registry payments

Process payments through a registry with duplicate prevention:

```move
module sui::payment_kit;

public fun process_registry_payment<T>(
    registry: &mut PaymentRegistry,
    nonce: String,
    payment_amount: u64,
    coin: Coin<T>,
    receiver: Option<address>,
    clock: &Clock,
    ctx: &mut TxContext
)
```

**Parameters:**

- `registry`: Mutable reference to the payment registry.
- `nonce`: Unique payment identifier (prevents duplicates).
- `payment_amount`: Expected payment amount in coin units.
- `coin`: Payment coin object.
- `receiver`: Optional receiver address (if `None`, funds stay in registry).
- `clock`: Sui clock object for timestamping.
- `ctx`: Transaction context.

The function:

1. Verifies the payment amount matches the coin value
2. Checks for duplicate payments using the composite key
3. Records the payment in the registry
4. Transfers funds to `receiver` or the registry (based on configuration)
5. Generates and returns a `PaymentReceipt`
6. Emits a payment event

**Error conditions:**

- `EDuplicatePayment`: Payment with same composite key already exists.
- `EPaymentAmountMismatch`: Coin value doesn't match expected amount.

### Managing payment records

Delete an expired `PaymentRecord` to free up storage:

```move
module sui::payment_kit;

public fun delete_payment_record<T>(
    registry: &mut PaymentRegistry,
    payment_key: PaymentKey<T>,
    ctx: &mut TxContext
)
```

Records can only be deleted after they expire based on the registry's configured expiration duration. Create a `PaymentKey` using the `create_payment_key` function with the original payment parameters.

### Configuring registries

Registry administrators can update configuration settings using the `RegistryAdminCap`:

**Set expiration duration:**

```move
module sui::payment_kit;

public fun set_config_epoch_expiration_duration(
    registry: &mut PaymentRegistry,
    cap: &RegistryAdminCap,
    epoch_expiration_duration: u64,
    ctx: &mut TxContext
)
```

**Set `PaymentRegistry` to receive funds:**

```move
module sui::payment_kit;

public fun set_config_registry_managed_funds(
    registry: &mut PaymentRegistry,
    cap: &RegistryAdminCap,
    registry_managed_funds: bool,
    ctx: &mut TxContext
)
```

When `registry_managed_funds` is `true`, payments accumulate in the registry for later withdrawal. When `false`, payments transfer immediately to receivers.

### Withdrawing from a registry

If a `PaymentRegistry` is set to manage funds, an administrator can withdraw accumulated funds:

```move
module sui::payment_kit;

public fun withdraw_from_registry<T>(
    registry: &mut PaymentRegistry,
    cap: &RegistryAdminCap,
    ctx: &mut TxContext
)
```

This function requires the `RegistryAdminCap` and returns all accumulated coins of type `T` from the registry. Only use this when the registry is configured to retain funds (controlled by the `registry_managed_funds` configuration setting).

## Processing ephemeral payments

For scenarios that don't require duplicate prevention or persistent records, use ephemeral payments:

```move
module sui::payment_kit;

public fun process_ephemeral_payment<T>(
    nonce: String,
    payment_amount: u64,
    coin: Coin<T>,
    receiver: address,
    clock: &Clock,
    ctx: &mut TxContext
)
```

Ephemeral payments:

- Do not check for duplicates
- Do not store payment records on-chain
- Transfer funds immediately to the receiver
- Generate receipts for the transaction
- Emit payment events for off-chain tracking
- Have lower gas costs than registry payments

This mode is ideal for:

- Duplicate prevention is not required
- Applications with external payment tracking systems

## Transaction URIs

The Payment Kit defines a standard URI format for encoding payment requests. Transaction URIs allow applications to generate payment links that wallets and other clients can parse and execute.

### URI format

Payment Kit Transaction URIs use the following format:

```
sui:<address>
    ?amount=<amount>
    &coinType=<coinType>
    &nonce=<nonce>
    &label=<label>
    &icon=<icon>
    &message=<message>
    &registry=<registry>
```

### URI parameters

#### `address`

The destination address to receive the payment funds. Must be a valid Sui address. There is no pathname for the destination address.

#### `amount`

The `amount` field is a required pathname. The value must be a `u64`. This field represents the native amount of a specified coin type (for example, 100000000 MISTS represents 0.1 SUI).

#### `nonce`

The `nonce` field is a required pathname. This represents a unique ascii based identifier for this payment. Must be unique within the registry to prevent duplicate payments. Recommended format is `UUIDv4`. Cannot exceed 36 characters.

#### `coinType`

The `coinType` field is a required pathname. The full type identifier of the coin to be transferred (for example, `0x2::sui::SUI` or `0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI`).

#### `label`

A human-readable name for the merchant or application receiving payment.

#### `icon`

A URL pointing to an icon image for the merchant or application. Maybe be displayed to users during payment confirmation.

#### `message`

A description or context for the payment. May be displayed to users to explain the purpose of the payment.

#### `registry`

The object ID or ascii represented `name` of the `PaymentRegistry` to use for processing the payment. If provided, the payment is processed through the registry with duplicate prevention. If omitted, the payment is processed as an ephemeral payment.

### Example URIs

**Basic SUI payment:**

```
sui:0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
    ?amount=1000000000 // (1 SUI represented as MISTS)
    &coinType=0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI
    &nonce=550e8400-e29b-41d4-a716-446655440000
```

**Payment with custom coin type:**

```
sui:0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
    ?amount=1000000000 // (1 SUI represented as MISTS)
    &coinType=0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI
    &nonce=550e8400-e29b-41d4-a716-446655440000
```

**Payment with display metadata:**

```
sui:0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
    ?amount=1000000000 // (1 SUI represented as MISTS)
    &coinType=0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI
    &nonce=550e8400-e29b-41d4-a716-446655440000
    &label=Coffee%20Shop
    &icon=https://example.com/icon.png
    &message=Espresso%20and%20croissant
```

**Registry-based payment (registry object ID):**

```
sui:0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
    ?amount=1000000000 // (1 SUI represented as MISTS)
    &coinType=0x0000000000000000000000000000000000000000000000000000000000000002::sui::SUI
    &nonce=550e8400-e29b-41d4-a716-446655440000
    &registry=0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890
```

**Registry-based payment (Registry ACSII Name):**

```
sui:0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
    ?amount=1000000000 // (1 SUI represented as MISTS)
    &nonce=550e8400-e29b-41d4-a716-446655440000
    &registry=default-payment-registry
```

### URI encoding

All parameter values must be properly URL-encoded according to RFC 3986. Special characters in parameter values (such as spaces, colons, slashes) must be percent-encoded. Examples include:

- Space: `%20`
- Colon: `%3A`
- Slash: `%2F`
- Double colon (`::`): `%3A%3A`

### Implementation notes

When implementing transaction URI support:

1. **Validate all parameters**: Ensure addresses are valid Sui addresses, amounts are valid `u64` values, and coin types follow the correct format.
2. **Generate unique nonces**: Use UUIDv4 or another cryptographically secure random identifier to prevent accidental duplicates.
3. **Handle missing optional parameters**: Provide sensible defaults (such as `0x2::sui::SUI` for `coinType`) when optional parameters are omitted.
4. **Display metadata to users**: Show the `label`, `icon`, and `message` parameters to users during payment confirmation to provide context.
5. **Route to correct payment function**: Use `process_registry_payment` when `registry` is provided, otherwise use `process_ephemeral_payment`.

## Key structures

### `Namespace`

Represents the higher-order namespace for organizing payment registries:

```move
public struct Namespace has key, store {
    id: UID,
}
```

### `PaymentRegistry`

Tracks payments and receipts with duplicate prevention:

```move
public struct PaymentRegistry has key {
    id: UID,
    cap_id: ID,
    config: VecMap<String, Value>,
    version: u16,
}
```

### `RegistryAdminCap`

Provides administrative capabilities for a specific registry:

```move
public struct RegistryAdminCap has key, store {
    id: UID,
    registry_id: ID,
}
```

### `PaymentType`

Enum representing the type of payment: Ephemeral (one-time) or Registry (tracked in a registry).

```move
public enum PaymentType has copy, drop, store {
    Ephemeral,
    Registry(ID),
}
```

### `PaymentReceipt`

Contains details of a processed payment:

```move
public struct PaymentReceipt has key, store {
    payment_type: PaymentType,
    nonce: String,
    payment_amount: u64,
    receiver: address,
    coin_type: String,
    timestamp_ms: u64,
}
```

### `PaymentKey`

Unique key for identifying payment records:

```move
public struct PaymentKey<phantom T> has copy, drop, store {
    nonce: String,
    payment_amount: u64,
    receiver: address,
}
```

### `PaymentRecord`

Internal structure storing payment record information:

```move
public struct PaymentRecord has store {
    epoch_at_time_of_record: u64,
}
```

## Events

The Payment Kit emits events for off-chain tracking and integration. Payment processing functions emit events containing:

- Payment nonce
- Payment amount
- Coin type
- Receiver address
- Timestamp
- Registry information (for registry payments)

Use these events to:

- Track payment history off-chain
- Trigger external workflows
- Update application state
- Generate reports and analytics
- Integrate with accounting systems

## Error codes

The Payment Kit defines the following error conditions:

- **Duplicate payment detection**: Payment with the same composite key already processed.
- **Payment amount mismatch**: Coin value doesn't match expected payment amount.
- **Payment record not found**: Attempted to access non-existent payment record.
- **Payment record not expired**: Attempted to delete a record before expiration.
- **Unauthorized admin**: Operation requires `RegistryAdminCap`.
- **Registry already exists**: Attempted to create duplicate registry in namespace.
- **Invalid registry name**: Registry name doesn't meet requirements.

## Source code

- [Move Package](https://github.com/MystenLabs/sui-payment-kit)
- [SDK](https://github.com/MystenLabs/ts-sdks/tree/main/packages/payment-kit)

## Related links

<RelatedLink to="/concepts/sui-move-concepts/derived-objects.mdx" />

>>>> sui/docs/content/standards/wallet-standard.mdx
---
title: Wallet Standard
description: The Wallet Standard defines how dApps can automatically discover and interact with wallets.
keywords: [ mysten/wallet-standard, wallet standards, Wallet Standard, browser extensions, exposing accounts, wallet events, register in window, wallet best practices, efficient transaction execution, wallet data, managing wallets, wallet-standard ]
pagination_prev: null
---

Browser extension wallets built for Sui use the [Wallet Standard](https://github.com/wallet-standard/wallet-standard/). This is a cross-chain standard that defines how dApps can automatically discover and interact with wallets.

If you are building a wallet, the helper library `@mysten/wallet-standard` provides types and utilities to help get started.

## Working with wallets

The Wallet Standard includes features to help build wallets.

### Creating a wallet interface

Create a class that represents your wallet. Use the `Wallet` interface from
`@mysten/wallet-standard` to help ensure your class adheres to the standard.

```tsx
import { SUI_DEVNET_CHAIN, Wallet } from '@mysten/wallet-standard';

class YourWallet implements Wallet {
	get version() {
		// Return the version of the Wallet Standard this implements (in this case, 1.0.0).
		return '1.0.0';
	}

	get name() {
		return 'Wallet Name';
	}

	get icon() {
		return 'some-icon-data-url';
	}

	// Return the Sui chains that your wallet supports.
	get chains() {
		return [SUI_DEVNET_CHAIN];
	}
}
```

### Implementing features

Features are standard methods consumers can use to interact with a wallet. Wallets should implement the following features:

**Core features**
- `standard:connect` - Use to prompt the wallet for account authorization.
- `standard:events` - Use to listen for changes that happen within the wallet, such as accounts
  being added or removed.

**Transaction features**

Libraries built on top of the Wallet Standard (like dApp Kit) require transaction signing capabilities. Implement both current and legacy methods for maximum compatibility:

Current methods:
- `sui:signTransaction` - Use to prompt the user to sign a transaction and return the serialized
  transaction and signature back to the dApp. This method does not submit the transaction for
  execution.
- `sui:signAndExecuteTransaction` - Use to prompt the user to sign a transaction, then submit it
  for execution to the blockchain.

Legacy methods:
- `sui:signTransactionBlock` - The legacy version of `sui:signTransaction`. Many existing dApps still rely on this method.
- `sui:signAndExecuteTransactionBlock` - The legacy version of `sui:signAndExecuteTransaction`. Many existing dApps still rely on this method.

**Personal message signing**
- `sui:signPersonalMessage` - Use to prompt the user to sign a personal message and return the
  message signature back to the dApp. This is essential for user verification flows used by many dApps.

Implement these features in your wallet class under the `features` property:

```tsx
import {
  StandardConnectFeature,
  StandardConnectMethod,
  StandardEventsFeature,
  StandardEventsOnMethod,
  SuiFeatures,
  SuiSignPersonalMessageMethod,
  SuiSignTransactionMethod,
  SuiSignAndExecuteTransactionMethod,
  StandardConnect,
  StandardEvents,
  SuiSignPersonalMessage,
  SuiSignTransaction,
  SuiSignAndExecuteTransaction
} from "@mysten/wallet-standard";

class YourWallet implements Wallet {
	/* ... existing code from above ... */

  get features(): ConnectFeature & EventsFeature & SuiFeatures {
    return {
      [StandardConnect]: {
        version: "1.0.0",
        connect: this.#connect,
      },
      [StandardEvents]: {
        version: "1.0.0",
        on: this.#on,
      },
			[SuiSignPersonalMessage]: {
        version: "1.1.0",
				signPersonalMessage: this.#signPersonalMessage,
			},
      [SuiSignTransaction]: {
        version: "2.0.0",
        signTransaction: this.#signTransaction,
      },
      [SuiSignAndExecuteTransaction]: {
        version: "2.0.0",
        signAndExecuteTransaction: this.#signAndExecuteTransaction,
      },
    };
  };

  #on: EventsOnMethod = () => {
    // Your wallet's events on implementation
  };

  #connect: ConnectMethod = () => {
    // Your wallet's connect implementation
  };

	#signPersonalMessage: SuiSignPersonalMessageMethod = () => {
    // Your wallet's signPersonalMessage implementation
  };

  #signTransaction: SuiSignTransactionMethod = () => {
    // Your wallet's signTransaction implementation
  };

  #signAndExecuteTransaction: SuiSignAndExecuteTransactionMethod = () => {
    // Your wallet's signAndExecuteTransaction implementation
  };
}
```

### Exposing accounts

The last requirement of the wallet interface is to expose an `accounts` interface. Wallets that comply with the Wallet Standard should automatically populate this array with any previously authorized accounts when the wallet loads. This means:

- On first visit: The array will be empty until the user authorizes accounts through `standard:connect`
- On subsequent visits: Previously authorized accounts automatically appear without any dApp action
- After revocation: Accounts that have been revoked won't appear in the array

The accounts use the `ReadonlyWalletAccount` class to construct an account matching the required interface.

```tsx
import { ReadonlyWalletAccount } from '@mysten/wallet-standard';

class YourWallet implements Wallet {
	get accounts() {
		// Assuming we already have some internal representation of accounts:
		return someWalletAccounts.map(
			(walletAccount) =>
				new ReadonlyWalletAccount({
					address: walletAccount.suiAddress,
					publicKey: walletAccount.pubkey,
					// The Sui chains that this account supports. This can be a subset of the wallet's supported chains.
          // These chains must exist on the wallet as well.
					chains: [SUI_DEVNET_CHAIN],
					// The features that this account supports. This can be a subset of the wallet's supported features.
					// These features must exist on the wallet as well.
					features: [
						SuiSignPersonalMessage,
            SuiSignTransaction,
						SuiSignAndExecuteTransaction,
					],
				}),
		);
	}
}
```

### Registering in the window

After you have a compatible interface for your wallet, use the `registerWallet`
function to register it.

```tsx
import { registerWallet } from '@mysten/wallet-standard';

registerWallet(new YourWallet());
```

## Managing wallets

The Wallet Standard includes features to help your apps interact with wallets.

### Wallet data

To query the installed wallets in a user's browser, use the `get` function of `getWallets`.

```tsx
import { getWallets } from '@mysten/wallet-standard';

const availableWallets = getWallets().get();
```

The return from this call (`availableWallets` in the previous code) is an array of `Wallet` types.

Use the `Wallet.icon` and `Wallet.name` attributes to display the wallet details on your web page.

The `Wallet.accounts` is an array of `WalletAccount`s. Each `WalletAccount` type has `address` and `publicKey` properties, which are most useful during development. This data fills and caches after account authorization.

### Features

Both the `Wallet` type and the `WalletAccount` type have a property called `features`. The main wallet functionality is found here. The mandatory features that wallets must implement are listed in the previous code.

Many wallets choose to omit some non-mandatory features or add some custom features, so be sure to check the relevant wallet documentation if you intend to integrate a specific wallet.

### Authorizing wallet accounts

The Wallet Standard uses a persistent authorization model. Despite the "connect" terminology in the API, wallets should automatically restore previously authorized accounts when they load, without any action from the dApp. The `connect()` method is specifically for prompting users to authorize accounts when needed.

**How account authorization works:**

1. **Wallets restore accounts automatically**: When a wallet loads, it should automatically populate its `accounts` array with any previously authorized accounts for the current dApp. This happens without any dApp interaction.

2. **Only prompt when necessary**: Call `connect()` only when:
   - The `accounts` array is empty (first-time user or all accounts were revoked)
   - The current accounts don't meet your requirements (e.g., you need an account on a specific chain)
   - The user explicitly wants to authorize more accounts

```tsx
await wallet.features['standard:connect'].connect();
```

:::info

The `connect()` method has a `silent` parameter that is intended to retrieve previously authorized accounts without user interaction, but this parameter is planned for deprecation in future versions of the Wallet Standard. Wallets should instead automatically populate the `accounts` array on load.

:::

When you do call `connect()`, the wallet will open a pop-up for the user to select and authorize which accounts the dApp can access.

### Revoking account authorization

Similar to the connect (account authorization) feature, the Wallet Standard also includes `standard:disconnect` to revoke a dApp's access to wallet accounts. The following example calls this feature:

```tsx
wallet.features['standard:disconnect'].disconnect();
```

### Transactions - suggested approach

Once the user has authorized accounts from a wallet, your app has the necessary information to execute transactions, such as address and method.

Construct the transaction separately with the `@mysten/sui` library and then sign it with the private key of the user. Use the `sui:signTransaction` feature to achieve this:

```tsx
wallet.features['sui:signTransaction'].signTransaction({
  transaction: <Transaction>,
  account: <WalletAccount>
})
```

Similar to account authorization, this process opens a pop-up dialog for the user to either accept or decline the transaction. Upon accepting, the function returns an object in the form `{bytes: String, signature: Uint8Array}`. The `bytes` value is the `b64` encoding of the transaction and the `signature` value is the transaction signature.

To execute the transaction, use `SuiClient` from `@mysten/sui`:

```tsx
const client: SuiClient
client.executeTransactionBlock({
    transactionBlock: bytes,
    signature: signature,
    options: {}
})
```

### Transactions - abbreviated approach

Many wallets abstract the above flow into one feature: `sui:signAndExecuteTransaction`. The required arguments for this feature are the raw transaction and the options with the desired information to be included in the response:

- `showEffects`: Include the transaction effects.
- `showEvents`: Include the transaction events.
- `showObjectChanges`: Include all the objects that were deleted, created, or mutated.
- `showBalanceChanges`: Include any coin transfer that took place.
- `showInput`: Include the transaction's input.
- `showRawInput`: Same as `showInput` but the format is raw.

### Events wallets emit

The wallet emits events on certain user actions that apps can listen to. These events allow your app to be responsive to user actions on their wallets.

The Wallet Standard only defines the change event that can apply to chains, features, or accounts.

- `chains`: A change event on the chains means the user switched the wallet's active network, such as from Devnet to Testnet.
- `features`: The user added or removed permission for your app to access certain wallet features.
- `accounts`: The user added or removed an account (address) to interact with your app.

To subscribe your apps to events with the following call:

```tsx
const unsubscribe = wallet.features['standard:events'].on('change', callback);
```

This call returns a function that can be called to unsubscribe from listening to the events.

The callback is the handler that contains the logic to perform when the event fires. The input to the callback function is an object with the following type:

```tsx
{
    accounts: WalletAccount[],
    chains: IdentifierArray,
    features: IdentifierRecord<unknown>
}
```

These values are all arrays containing the new or changed items. Consequently, every event populates only one array in most cases, the rest are empty.

### Implementation example

Mysten Labs offers a bare bones scaffold for React-based applications called `@mysten/dapp-kit`. See the [dApp Kit documentation](https://sdk.mystenlabs.com/dapp-kit) for more information.
