>>>> move-book/.github/.github/pull_request_template.md
## Description

Please, make sure to reflect the target in the header of your PR!

## Changes

- [ ] book: ...
- [ ] reference: ...
- [ ] other (specify): ...

>>>> move-book/README.md
# The Move Book

This is the repository for [the Move Book](https://move-book.com) and
[Move Language Reference](https://move-book.com/reference).

## Structure

- Two books are placed in the `book` and `reference` directories. The `book` directory contains the
  main book, and the `reference` directory contains the reference book.
- The `packages` directory contains the code samples used in both books.
- The `site` directory contains [docusaurus](docusaurus.io) configuration and custom plugins for it.

## Running the Books Locally

### Prerequisites

- NodeJS
- `pnpm` (installation is: `npm i -g pnpm`)

### Local Server

> All commands can be run from the root.

```bash
pnpm start
```

_The book will be available at `http://localhost:3000`._

### Production Build Test

```bash
pnpm build
pnpm serve
```

## Archive

For the archive of the old version of the book, see the `archive` branch.

>>>> move-book/book/404.md
# Page not Found

You're looking for a page that doesn't exist, or has been moved. Please check the URL and try again.

> Here are the links you may be looking for:
>
> - [The Move Book](/) - the main page of the book
> - [The Move Reference](/reference) - the Move Language Reference

Recently we updated the structure of the book and some pages have been moved or renamed. If you're
looking for the old version of the book, please, see the
["archive" branch in the repository](https://github.com/MystenLabs/move-book/tree/archive). Though
we highly recommend using [the latest version of the book](/).

>>>> move-book/book/appendix/acknowledgements.md
# Appendix F: Acknowledgements

[The Rust Book](https://doc.rust-lang.org/book) has been a great inspiration for this book. I am
personally grateful to the authors of the book, Steve Klabnik and Carol Nichols, for their work, as
I have learned a lot from it. This book is a small tribute to their work and an attempt to bring a
similar learning experience to the Move community.

>>>> move-book/book/appendix/contributing.md
# Appendix E: Contributing

To contribute to this book, please, submit a pull request to the
[GitHub repository](https://github.com/MystenLabs/move-book). The repository contains the source
files for the book, written in mdBook format.

>>>> move-book/book/appendix/glossary.md
# Appendix A: Glossary

- Fast Path - term used to describe a transaction that does not involve shared objects, and can be
  executed without the need for consensus.
- Parallel Execution - term used to describe the ability of the Sui runtime to execute transactions
  in parallel, including the ones that involve shared objects.
- Internal Type - type that is defined within the module. Fields of this type can not be accessed
  from outside the module, and, in case of "key"-only abilities, can not be used in `public_*`
  transfer functions.

## Abilities

- key - ability that allows the struct to be used as a key in the storage. On Sui, the key ability
  marks an object and requires the first field to be a `id: UID`.
- store - ability that allows the struct to be stored inside other objects. This ability relaxes
  restrictions applied to internal structs, allowing `public_*` transfer functions to accept them as
  arguments. It also enables the object to be stored as a dynamic field.
- copy - ability that allows the struct to be copied. On Sui, the `copy` ability conflicts with the
  `key` ability, and can not be used together with it.
- drop - ability that allows the struct to be ignored or discarded. On Sui, the `drop` ability
  cannot be used together with the `key` ability, as objects are not allowed to be ignored.

>>>> move-book/book/appendix/publications.md
# Appendix D: Publications

This section lists publications related to Move and Sui.

- [The Move Borrow Checker](https://arxiv.org/abs/2205.05181) by Sam Blackshear, John Mitchell, Todd
  Nowacki, Shaz Qadeer.
- [Resources: A Safe Language Abstraction for Money](https://arxiv.org/abs/2004.05106) by Sam
  Blackshear, David L. Dill, Shaz Qadeer, Clark W. Barrett, John C. Mitchell, Oded Padon, Yoni
  Zohar.
- [Robust Safety for Move](https://arxiv.org/abs/2110.05043) by Marco Patrignani, Sam Blackshear

>>>> move-book/book/appendix/reserved-addresses.md
# Appendix B: Reserved Addresses

Reserved addresses are special addresses that have a specific purpose on Sui. They stay the same
between environments and are used for specific native operations.

- `0x1` - address of the [Standard Library](./../move-basics/standard-library.md) (alias `std`)
- `0x2` - address of the [Sui Framework](./../programmability/sui-framework.md) (alias `sui`)
- `0x5` - address of the `SuiSystem` object
- `0x6` - address of the system [`Clock` object](./../programmability/epoch-and-time.md)
- `0x8` - address of the system `Random` object
- `0xc` - address of the system `CoinRegistry` object
- `0x403` - address of the `DenyList` system object

>>>> move-book/book/appendix/transfer-functions.md
# Appendix C: Transfer Functions

## Transfer Functions Comparison

| Function                  | Public Function         | End State     | Permissions               |
| ------------------------- | ----------------------- | ------------- | ------------------------- |
| [`transfer`][transfer]    | `public_transfer`       | Address Owned | Full                      |
| [`share_object`][share]   | `public_share_object`   | Shared        | Ref, Mut Ref, Delete      |
| [`freeze_object`][freeze] | `public_freeze_object`  | Frozen        | Ref                       |
| [`party_transfer`][party] | `public_party_transfer` | Party         | [See Party table](#party) |

## States Comparison

| State         | Description                                               |
| ------------- | --------------------------------------------------------- |
| Address Owned | Object can be accessed fully by an address (or an object) |
| Shared        | Object can be referenced and deleted by anyone            |
| Frozen        | Object can be accessed via immutable reference            |
| Party         | Depends on the Party settings ([see Party table](#party)) |

## Party

| Function       | Description                                  |
| -------------- | -------------------------------------------- |
| `single_owner` | Object has same permissions as Address Owned |

[transfer]: https://docs.sui.io/references/framework/sui_sui/transfer#sui_transfer_transfer
[share]: https://docs.sui.io/references/framework/sui_sui/transfer#sui_transfer_share_object
[freeze]: https://docs.sui.io/references/framework/sui_sui/transfer#sui_transfer_freeze_object
[party]: https://docs.sui.io/references/framework/sui_sui/transfer#sui_transfer_party_transfer

>>>> move-book/book/before-we-begin/ide-support.md
# Set Up Your IDE

There are two most popular IDEs for Move development: VSCode and IntelliJ IDEA. Both of them provide
basic features like syntax highlighting and error messages, though they differ in their additional
features. Whatever IDE you choose, you'll need to use the terminal to run the
[Move CLI](./install-sui.md).

> **IntelliJ Plugin does not support Move 2024 edition, some syntax won't get highlighted.**

## VSCode

- [VSCode](https://code.visualstudio.com/) is a free and open source IDE from Microsoft.
- [Move (Extension)](https://marketplace.visualstudio.com/items?itemName=mysten.move) is a language
  server extension for Move maintained by [Mysten Labs](https://mystenlabs.com).
- [Move Formatter](https://marketplace.visualstudio.com/items?itemName=mysten.prettier-move) - code
  formatter for Move, developed and maintained by [Mysten Labs](https://mystenlabs.com).
- [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax) a simple
  syntax highlighting extension for Move by [Damir Shamanaev](https://github.com/damirka/).

## IntelliJ IDEA

- [IntelliJ IDEA](https://www.jetbrains.com/idea/) is a commercial IDE from JetBrains.
- [Move Language Plugin](https://plugins.jetbrains.com/plugin/23301-sui-move-language) provides a
  Move on Sui language extension for IntelliJ IDEA by [MoveFuns](https://movefuns.org/).

## Emacs

- [Emacs](https://www.gnu.org/software/emacs/) is a free and open source text editor.
- [move-mode](https://github.com/amnn/move-mode) is a Move mode for Emacs by
  [Ashok Menon](https://github.com/amnn).

## Zed

- [Zed](https://zed.dev/) is a next-generation code editor designed for high-performance
  collaboration with humans and AI.
- [Move](https://github.com/Tzal3x/move-zed-extension) is a language server extension for Move
  maintained by [Tzal3x](https://github.com/Tzal3x).

## Github Codespaces

The Web-based IDE from Github can be run right in the browser and provides almost a full-featured
VSCode experience.

- [Github Codespaces](https://github.com/features/codespaces)
- [Move Syntax](https://marketplace.visualstudio.com/items?itemName=damirka.move-syntax) is also
  available in the extensions marketplace.
- [Move Formatter](https://marketplace.visualstudio.com/items?itemName=mysten.prettier-move) is also
  available in the extensions marketplace.

## Other (CLI)

Some of the tools listed above have CLI-supported versions.

- [prettier-plugin-move](https://www.npmjs.com/package/@mysten/prettier-plugin-move) contains the
  TypeScript package for the Prettier@v3 plugin as well as the binary to run it in a terminal

>>>> move-book/book/before-we-begin/index.md
# Before We Begin

Move requires an environment to run and develop applications, and in this small chapter we will
cover the prerequisites for the Move language: how to set up your IDE, how to install the compiler
and what is Move 2024. If you are already familiar with these topics or have a CLI installed, you
can skip this chapter and proceed to [the next one](../your-first-move/hello-world.md).

>>>> move-book/book/before-we-begin/install-move-registry-cli.md
# Install MVR

[Move Registry (MVR)](https://moveregistry.com) is a package manager for Move. It allows anyone to
publish and use published packages in new applications written in Move. Local binary allows
searching packages in the registry as well as installing them as a part of the Sui CLI build
process.

## Installing via suiup

The best way to install MVR is by using [`suiup`](https://github.com/MystenLabs/suiup). Suiup
provides an easy way to update and manage different versions of binaries.

Installation instructions for `suiup` can be found
[in the repository README](https://github.com/MystenLabs/suiup).

To install Move Registry CLI, run the following command:

```bash
suiup install mvr
```

After installation, Move Registry will be available as `mvr`.

## Download Binary

You can download the latest MVR binary from the
[releases page](https://github.com/MystenLabs/mvr/releases). The binary is available for macOS,
Linux and Windows. Unlike [Sui](./install-sui.md), the MVR binary is not changing between
environments and supports both `testnet` and `mainnet`.

## Install Using Cargo

You can install and build MVR locally by using Cargo (requires Rust)

```bash
cargo install --locked --git https://github.com/mystenlabs/mvr --branch release mvr
```

## Troubleshooting

For troubleshooting the installation process, please refer to the
[Install MVR](https://docs.suins.io/move-registry/tooling/mvr-cli#installation) Guide.

>>>> move-book/book/before-we-begin/install-sui.md
# Install Sui

Move is a compiled language, so you need to install a compiler to be able to write and run Move
programs. The compiler is included into the Sui binary, which can be installed or downloaded using
one of the methods below.

## Installing via suiup

The best way to install Sui is by using [`suiup`](https://github.com/MystenLabs/suiup). It provides a simple way to install binaries and to manage different versions of binaries for
different environments (e.g. `testnet` and `mainnet`).

Installation instructions for `suiup` can be found
[in the repository README](https://github.com/MystenLabs/suiup).

To install Sui, run the following command:

```bash
suiup install sui
```

## Download Binary

You can download the latest Sui binary from the
[releases page](https://github.com/MystenLabs/sui/releases). The binary is available for macOS,
Linux and Windows. For education purposes and development, we recommend using the `mainnet` version.

## Install Using Homebrew (MacOS)

You can install Sui using the [Homebrew](https://brew.sh/) package manager.

```bash
brew install sui
```

## Install Using Chocolatey (Windows)

You can install Sui using the [Chocolatey](https://chocolatey.org/install) package manager for
Windows.

```bash
choco install sui
```

## Build Using Cargo (MacOS, Linux)

You can install and build Sui locally by using the Cargo package manager (requires Rust)

```bash
cargo install --git https://github.com/MystenLabs/sui.git sui --branch mainnet
```

Change the branch target here to `testnet` or `devnet` if you are targeting one of those.

Make sure that your system has the latest Rust versions with the command below.

```bash
rustup update stable
```

## Troubleshooting

For troubleshooting the installation process, please refer to the
[Install Sui](https://docs.sui.io/guides/developer/getting-started/sui-install) Guide.

>>>> move-book/book/before-we-begin/move-2024.md
# Move 2024

Move 2024 is the current edition of the Move language maintained by Mysten Labs. All of the examples
in this book are written in Move 2024. If you're used to the pre-2024 version of Move, refer
to the [Move 2024 Migration Guide](./../guides/2024-migration-guide.md) to learn about the changes
and improvements in the new edition.

<!-- Notes ? -->

>>>> move-book/book/concepts/address.md
# Address

<!--

Chapter: Concepts
Goal: explain locations and addresses
Notes:
    - don't talk about the type
    - packages, accounts and objects are identified by addresses
    - addresses are 32 bytes long
    - addresses are unique
    - represented as hex strings (64 characters) prefixed with 0x
    - addresses are case insensitive

Links:
    - address type


- mention what an address is, because it identifies a package
    - address is used for packages, objects, and accounts
    - address is a 32-byte value
    - address is written in hexadecimal notation
    - don't describe the type yet
    - focus on the concept of address on blockchain and on Sui in particular

 -->

Address is a unique identifier of a location on the blockchain. It is used to identify
[packages](./packages), [accounts](./what-is-an-account), and [objects](./../object/object-model).
Address has a fixed size of 32 bytes and is usually represented as a hexadecimal string prefixed
with `0x`. Addresses are case insensitive.

```move
0xe51ff5cd221a81c3d6e22b9e670ddf99004d71de4f769b0312b68c7c4872e2f1
```

The address above is an example of a valid address. It is 64 characters long (32 bytes) and prefixed
with `0x`.

Sui also has reserved addresses that are used to identify standard packages and objects. Reserved
addresses are typically simple values that are easy to remember and type. For example, the address
of the Standard Library is `0x1`. Addresses, shorter than 32 bytes, are padded with zeros to the
left.

```move
0x1 = 0x0000000000000000000000000000000000000000000000000000000000000001
```

Here are some examples of reserved addresses:

- `0x1` - address of the Sui Standard Library (alias `std`)
- `0x2` - address of the Sui Framework (alias `sui`)
- `0x6` - address of the system `Clock` object

> You can find all reserved addresses in the [Appendix B](../appendix/reserved-addresses).

## Further Reading

- [Address type](../move-basics/address) in Move
- [sui::address module](https://docs.sui.io/references/framework/sui/address)

>>>> move-book/book/concepts/index.md
# Concepts

In this chapter you will learn about the basic concepts of Sui and Move. You will learn what is a
package, how to interact with it, what is an account and a transaction, and how data is stored on
Sui. While this chapter is not a complete reference, and you should refer to the
[Sui Documentation](https://docs.sui.io) for that, it will give you a good understanding of the
basic concepts required to write Move programs on Sui.

>>>> move-book/book/concepts/manifest.md
# Package Manifest

The `Move.toml` is a manifest file that describes the [package](./packages) and its dependencies.
It is written in [TOML](https://toml.io/en/) format and contains multiple sections, the most
important of which are `[package]`, `[dependencies]` and `[addresses]`.

```toml
[package]
name = "my_project"
version = "0.0.0"
edition = "2024"

[dependencies]
Example = { git = "https://github.com/example/example.git", subdir = "path/to/package", rev = "framework/testnet" }

[addresses]
std =  "0x1"
alice = "0xA11CE"

[dev-addresses]
alice = "0xB0B"
```

## Sections

### Package

The `[package]` section is used to describe the package. None of the fields in this section are
published on chain, but they are used in tooling and release management; they also specify the Move
edition for the compiler.

- `name` - the name of the package when it is imported;
- `version` - the version of the package, can be used in release management;
- `edition` - the edition of the Move language; currently, the only valid value is `2024`.

<!-- published-at -->

### Dependencies

The `[dependencies]` section is used to specify the dependencies of the project. Each dependency is
specified as a key-value pair, where the key is the name of the dependency, and the value is the
dependency specification. The dependency specification can be a git repository URL or a path to the
local directory.

```toml
# git repository
Example = { git = "https://github.com/example/example.git", subdir = "path/to/package", rev = "framework/testnet" }

# local directory
MyPackage = { local = "../my-package" }
```

Packages also import addresses from other packages. For example, the Sui dependency adds the `std`
and `sui` addresses to the project. These addresses can be used in the code as aliases for the
addresses.

Starting with version 1.45 of the Sui CLI, the Sui system packages (`std`, `sui`, `system`,
`bridge`, and `deepbook`) are automatically added as dependencies if none of them are explicitly
listed.

### Resolving Version Conflicts with Override

Sometimes dependencies have conflicting versions of the same package. For example, if you have two
dependencies that use different versions of the Example package, you can override the dependency in
the `[dependencies]` section. To do so, add the `override` field to the dependency. The version of
the dependency specified in the `[dependencies]` section will be used instead of the one specified
in the dependency itself.

```toml
[dependencies]
Example = { override = true, git = "https://github.com/example/example.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }
```

### Dev-dependencies

It is possible to add `[dev-dependencies]` section to the manifest. It is used to override
dependencies in the dev and test modes. For example, if you want to use a different version of the
Sui package in the dev mode, you can add a custom dependency specification to the
`[dev-dependencies]` section.

### Addresses

The `[addresses]` section is used to add aliases for the addresses. Any address can be specified in
this section, and then used in the code as an alias. For example, if you add `alice = "0xA11CE"` to
this section, you can use `alice` as `0xA11CE` in the code.

### Dev-addresses

The `[dev-addresses]` section is the same as `[addresses]`, but only works for the test and dev
modes. Important to note that it is impossible to introduce new aliases in this section, only
override the existing ones. So in the example above, if you add `alice = "0xB0B"` to this section,
the `alice` address will be `0xB0B` in the test and dev modes, and `0xA11CE` in the regular build.

## TOML Styles

The TOML format supports two styles for tables: inline and multiline. The examples above are using
the inline style, but it is also possible to use the multiline style. You wouldn't want to use it
for the `[package]` section, but it can be useful for the dependencies.

```toml
# Inline style
[dependencies]
Example = { override = true, git = "https://github.com/example/example.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "framework/testnet" }
MyPackage = { local = "../my-package" }
```

```toml
# Multiline style
[dependencies.Example]
override = true
git = "https://github.com/example/example.git"
subdir = "crates/sui-framework/packages/sui-framework"
rev = "framework/testnet"

[dependencies.MyPackage]
local = "../my-package"
```

## Further Reading

- [Packages](./../../reference/packages) in the Move Reference.

>>>> move-book/book/concepts/packages.md
# Package

<!--

    - packages and how they're stored
        - overview of packages and their contents (use a diagram)
        - how a package is created, and what it consists of
        - what is the package manifest
        - describe how "name" field is used
        - mention the "edition" field
        - what are the folders in a package and what are they for
        - how packages are imported (give Sui as an example)
        - what are addresses, and how they identify packages
        - how packages are published
        - leave a note that packages are also *upgradable*

-->

Move is a language for writing smart contracts - programs that are stored and run on the blockchain.
A single program is organized into a package. A package is published on the blockchain and is
identified by an [address](./address). A published package can be interacted with by sending
[transactions](./what-is-a-transaction) calling its functions. It can also act as a dependency for
other packages.

> To create a new package, use the `sui move new` command. To learn more about the command, run
> `sui move new --help`.

Package consists of modules - separate scopes that contain functions, types, and other items.

```
package 0x...
    module a
        struct A1
        fun hello_world()
    module b
        struct B1
        fun hello_package()
```

## Package Structure

Locally, a package is a directory with a `Move.toml` file and a `sources` directory. The `Move.toml`
file - called the "package manifest" - contains metadata about the package, and the `sources`
directory contains the source code for the modules. Package usually looks like this:

```
sources/
    my_module.move
    another_module.move
    ...
tests/
    ...
examples/
    using_my_module.move
Move.toml
```

The `tests` directory is optional and contains tests for the package. Code placed into the `tests`
directory is not published on-chain and is only available in tests. The `examples` directory can be
used for code examples, and is also not published on-chain.

## Published Package

During development, package doesn't have an address and it needs to be set to `0x0`. Once a package
is published, it gets a single unique [address](./address) on the blockchain containing its modules'
bytecode. A published package becomes _immutable_ and can be interacted with by sending
transactions.

```
0x...
    my_module: <bytecode>
    another_module: <bytecode>
```

## Links

- [Package Manifest](./manifest)
- [Address](./address)
- [Packages](./../../reference/packages) in the Move Reference.

>>>> move-book/book/concepts/what-is-a-transaction.md
# Transaction

Transaction is a fundamental concept in the blockchain world. It is a way to interact with a
blockchain. Transactions are used to change the state of the blockchain, and they are the only way
to do so. In Move, transactions are used to call functions in a package, deploy new packages, and
upgrade existing ones.

<!--

- how user interacts with a program
    - mention public functions
    - give a concept of an entry / public function without getting into details
    - mention that functions are called in transactions
    - mention that transactions are sent by accounts
    - every transaction specifies object it operates on

 -->

## Transaction Structure

> Every transaction explicitly specifies the objects it operates on!

Transactions consist of:

- a sender - the [account](./what-is-an-account) that _signs_ the transaction;
- a list (or a chain) of commands - the operations to be executed;
- command inputs - the arguments for the commands: either `pure` - simple values like numbers or
  strings, or `object` - objects that the transaction will access;
- a gas object - the `Coin` object used to pay for the transaction;
- gas price and budget - the cost of the transaction;

## Inputs

Transaction inputs are the arguments for the transaction and are split between 2 types:

- Pure arguments: These are mostly [primitive types](../move-basics/primitive-types) with some extra
  additions. A pure argument can be: - [`bool`](../move-basics/primitive-types#booleans). -
  [unsigned integer](../move-basics/primitive-types#integer-types) (`u8`, `u16`, `u32`, `u64`,
  `u128`, `u256`). - [`address`](../move-basics/address). -
  [`std::string::String`](../move-basics/string), UTF8 strings. -
  [`std::ascii::String`](../move-basics/string#ascii-strings), ASCII strings. -
  [`vector<T>`](../move-basics/vector), where `T` is a pure type. -
  [`std::option::Option<T>`](../move-basics/option), where `T` is a pure type. -
  [`std::object::ID`](../storage/uid-and-id), typically points to an object. See also
  [What is an Object](../object/object-model).
- Object arguments: These are objects or references of objects that the transaction will access. An
  object argument needs to be either a shared object, a frozen object, or an object that the
  transaction sender owns for the transaction to be successful. For more see
  [Object Model](../object).

## Commands

Sui transactions may consist of multiple commands. Each command is a single built-in command (like
publishing a package) or a call to a function in an already published package. The commands are
executed in the order they are listed in the transaction, and they can use the results of the
previous commands, forming a chain. Transaction either succeeds or fails as a whole.

Schematically, a transaction looks like this (in pseudo-code):

```
Inputs:
- sender = 0xa11ce

Commands:
- payment = SplitCoins(Gas, [ 1000 ])
- item = MoveCall(0xAAA::market::purchase, [ payment ])
- TransferObjects(item, sender)
```

In this example, the transaction consists of three commands:

1. `SplitCoins` - a built-in command that splits a new coin from the passed object, in this case,
   the `Gas` object;
2. `MoveCall` - a command that calls a function `purchase` in a package `0xAAA`, module `market`
   with the given arguments - the `payment` object;
3. `TransferObjects` - a built-in command that transfers the object to the recipient.

<!--
> There are multiple different implementations of transaction building, for example
-->

## Transaction Effects

Transaction effects are the changes that a transaction makes to the blockchain state. More
specifically, a transaction can change the state in the following ways:

- use the gas object to pay for the transaction;
- create, update, or delete objects;
- emit events;

The result of the executed transaction consists of different parts:

- Transaction Digest - the hash of the transaction which is used to identify the transaction;
- Transaction Data - the inputs, commands and gas object used in the transaction;
- Transaction Effects - the status and the "effects" of the transaction, more specifically: the
  status of the transaction, updates to objects and their new versions, the gas object used, the gas
  cost of the transaction, and the events emitted by the transaction;
- Events - the custom [events](./../programmability/events) emitted by the transaction;
- Object Changes - the changes made to the objects, including the _change of ownership_;
- Balance Changes - the changes made to the aggregate balances of the account involved in the
  transaction;

>>>> move-book/book/concepts/what-is-an-account.md
# Account

<!--

- user is an account
    - account is identified by an address
    - account is generated from a private key
    - account can own objects
    - account can send transactions
    - every transaction has a sender
    - sender is identified by an address
    - sui cryptographic agility
    - sui account types
    - supported curves: ed25519, secp256k1, zklogin

 -->

An account is a way to identify a user. An account is generated from a private key, and is
identified by an address. An account can own objects, and can send transactions. Every transaction
has a sender, and the sender is identified by an [address](./address).

Sui supports multiple cryptographic algorithms for account generation. The two supported curves are
ed25519, secp256k1, and there is also a special way of generating an account - zklogin. The
cryptographic agility - the unique feature of Sui - allows for flexibility in the account
generation.

<!-- The cryptographic agility allows for flexibility in the account generation -->

## Further Reading

- [Cryptography in Sui](https://blog.sui.io/wallet-cryptography-specifications/) in the
  [Sui Blog](https://blog.sui.io)
- [Keys and Addresses](https://docs.sui.io/concepts/cryptography/transaction-auth/keys-addresses) in
  the [Sui Docs](https://docs.sui.io)
- [Signatures](https://docs.sui.io/concepts/cryptography/transaction-auth/signatures) in the
  [Sui Docs](https://docs.sui.io)

>>>> move-book/book/foreword.md
# Foreword

This book is dedicated to Move, a smart contract language that captures the essence of safe
programming with digital assets. Move is designed around the following values:

1. **Secure by default:** Insecure languages are a serious barrier both to accessible smart contract
   development and to mainstream adoption of digital assets. The first duty of a smart contract
   language is to prevent as many potential safety issues as possible (e.g. re-entrancy, missing
   access control checks, arithmetic overflow, ...) by construction. Any changes to Move should
   preserve or enhance its existing security guarantees.

2. **Expressive by nature:** Move must enable programmers to write any smart contract they can
   imagine. But we care as much about the way it _feels_ to write Move as we do about what Move
   allows you to do - the language should be rich enough that the features needed for a task are
   available, and minimal enough that the choice is obvious. The Move toolchain should be a
   productivity enhancer and a thought partner.

3. **Intuitive for all:** Smart contracts are only one part of a useful application. Move should
   understand the broader context of its usage and design with both the smart contract developer and
   the application developer in mind. It should be easy for developers to learn how to read
   Move-managed state, build Move powered transactions, and write new Move code.

The core technical elements of Move are:

- Safe, familiar, and flexible abstractions for digital assets via programmable _objects_.
- A rich _ability_ system (inspired by linear types) that gives programmers extreme control of how
  values are created, destroyed, stored, copied, and transferred.
- A _module_ system with strong encapsulation features to enable code reuse while maintaining this
  control.
- _Dynamic fields_ for creating hierarchical relationships between objects.
- _Programmable transaction blocks_ (PTBs) to enable atomic client-side composition of Move-powered
  APIs.

Move was born in 2018 as part of Facebook's Libra project. It was publicly revealed in 2019, the
first Move-powered network launched in 2020. As of April 2024, there are numerous Move-powered
chains in production with several more in the works. Move is an embedded language with a
platform-agnostic core, which means it takes on a slightly different personality in each chain that
uses it.

Creating a new programming language and bootstrapping a community around it is an ambitious, long
term project. A language has to be an order of magnitude better than alternatives in relevant ways
to have a chance, but even then the quality of the community matters more than the technical
fundamentals. Move is a young language, but it's off to a good start in terms of both
differentiation and community. A small, but fanatical group of smart contract programmers and core
contributors united by the Move values are pushing the boundaries of what smart contracts can do,
the applications they can enable, and who can (safely) write them. If that inspires you, read on!

— Sam Blackshear, creator of Move

>>>> move-book/book/guides/2024-migration-guide.md
# Move 2024 Migration Guide

Move 2024 is the new edition of the Move language that is maintained by Mysten Labs. This guide is
intended to help you understand the differences between the 2024 edition and the previous version of
the Move language.

> This guide provides a high-level overview of the changes in the new edition. For a more detailed
> and exhaustive list of changes, refer to the
> [Sui Documentation](https://docs.sui.io/guides/developer/advanced/move-2024-migration).

## Using the New Edition

To use the new edition, you need to specify the edition in the `move` file. The edition is specified
in the `move` file using the `edition` keyword. Currently, the only available edition is
`2024.beta`.

```ini
edition = "2024"
# alternatively, for new features:
edition = "2024.beta"
```

## Migration Tool

The Move CLI has a migration tool that updates the code to the new edition. To use the migration
tool, run the following command:

```bash
$ sui move migrate
```

The migration tool will update the code to use the `let mut` syntax, the new `public` modifier for
structs, and the `public(package)` function visibility instead of `friend` declarations.

## Mutable Bindings with `let mut`

Move 2024 introduces `let mut` syntax to declare mutable variables. The `let mut` syntax is used to
declare a mutable variable that can be changed after it is declared.

> `let mut` declaration is now required for mutable variables. Compiler will emit an error if you
> try to reassign a variable without the `mut` keyword.

```move
// Move 2020
let x: u64 = 10;
x = 20;

// Move 2024
let mut x: u64 = 10;
x = 20;
```

Additionally, the `mut` keyword is used in tuple destructuring and function arguments to declare
mutable variables.

```move
// takes by value and mutates
fun takes_by_value_and_mutates(mut v: Value): Value {
    v.field = 10;
    v
}

// `mut` should be placed before the variable name
fun destruct() {
    let (x, y) = point::get_point();
    let (mut x, y) = point::get_point();
    let (mut x, mut y) = point::get_point();
}

// in struct unpack
fun unpack() {
    let Point { x, mut y } = point::get_point();
    let Point { mut x, mut y } = point::get_point();
}
```

## Friends are Deprecated

In Move 2024, the `friend` keyword is deprecated. Instead, you can use the `public(package)`
visibility modifier to make functions visible to other modules in the same package.

```move
// Move 2020
friend book::friend_module;
public(friend) fun protected_function() {}

// Move 2024
public(package) fun protected_function_2024() {}
```

## Struct Visibility

In Move 2024, structs get a visibility modifier. Currently, the only available visibility modifier
is `public`.

```move
// Move 2020
struct Book {}

// Move 2024
public struct Book {}
```

## Method Syntax

In the new edition, functions which have a struct as the first argument are associated with the
struct. This means that the function can be called using the dot notation. Methods defined in the
same module with the type are automatically exported.

> Methods are automatically exported if the type is defined in the same module as the method. It is
> impossible to export methods for types defined in other modules. However, you can create
> [custom aliases](#method-aliases) for methods in the module scope.

```move
public fun count(c: &Counter): u64 { /* ... */ }

fun use_counter() {
    // move 2020
    let count = counter::count(&c);

    // move 2024
    let count = c.count();
}
```

## Methods for Built-in Types

In Move 2024, some of the native and standard types received associated methods. For example, the
`vector` type has a `to_string` method that converts the vector into a UTF8 string.

```move
fun aliases() {
    // vector to string and ascii string
    let str: String = b"Hello, World!".to_string();
    let ascii: ascii::String = b"Hello, World!".to_ascii_string();

    // address to bytes
    let bytes = @0xa11ce.to_bytes();
}
```

For the full list of built-in aliases, refer to the
[Standard Library](./../move-basics/standard-library#source-code) and
[Sui Framework](./../programmability/sui-framework#source-code) source code.

## Borrowing Operator

Some of the built-in types support borrowing operators. The borrowing operator is used to get a
reference to the element at the specified index. The borrowing operator is defined as `[]`.

```move
fun play_vec() {
    let v = vector[1,2,3,4];
    let first = &v[0];         // calls vector::borrow(v, 0)
    let first_mut = &mut v[0]; // calls vector::borrow_mut(v, 0)
    let first_copy = v[0];     // calls *vector::borrow(v, 0)
}
```

Types that support the borrowing operator are:

- `vector`
- `sui::vec_map::VecMap`
- `sui::table::Table`
- `sui::bag::Bag`
- `sui::object_table::ObjectTable`
- `sui::object_bag::ObjectBag`
- `sui::linked_table::LinkedTable`

To implement the borrowing operator for a custom type, you need to add a `#[syntax(index)]`
attribute to the methods.

```move
#[syntax(index)]
public fun borrow(c: &List<T>, key: String): &T { /* ... */ }

#[syntax(index)]
public fun borrow_mut(c: &mut List<T>, key: String): &mut T { /* ... */ }
```

## Method Aliases

In Move 2024, methods can be associated with types. The alias can be defined for any type locally to
the module; or publicly, if the type is defined in the same module.

```move
// my_module.move
// Local: type is foreign to the module
use fun my_custom_function as vector.do_magic;

// sui-framework/kiosk/kiosk.move
// Exported: type is defined in the same module
public use fun kiosk_owner_cap_for as KioskOwnerCap.kiosk;
```

<!-- ## Macros

Macros are introduced in Move 2024. And `assert!` is no longer a built-in function - Instead, it's a macro.

```move
// can be called as for!(0, 10, |i| call(i));
macro fun for($start: u64, $stop: u64, $body: |u64|) {
    let mut i = $start;
    let stop = $stop;
    while (i < stop) {
        $body(i);
        i = i + 1
    }
}
```
 -->

>>>> move-book/book/guides/better-error-handling.md
# Better Error Handling

Whenever execution encounters an abort, transaction fails and abort code is returned to the caller.
Move VM returns the module name that aborted the transaction and the abort code. This behavior is
not fully transparent to the caller of the transaction, especially when a single function contains
multiple calls to the same function which may abort. In this case, the caller will not know which
call aborted the transaction, and it will be hard to debug the issue or provide meaningful error
message to the user.

```move
module book::module_a;

use book::module_b;

public fun do_something() {
    let field_1 = module_b::get_field(1); // may abort with 0
    /* ... a lot of logic ... */
    let field_2 = module_b::get_field(2); // may abort with 0
    /* ... some more logic ... */
    let field_3 = module_b::get_field(3); // may abort with 0
}
```

The example above illustrates the case when a single function contains multiple calls which may
abort. If the caller of the `do_something` function receives an abort code `0`, it will be hard to
understand which call to `module_b::get_field` aborted the transaction. To address this problem,
there are common patterns that can be used to improve error handling.

## Rule 1: Handle All Possible Scenarios

It is considered a good practice to provide a safe "check" function that returns a boolean value
indicating whether an operation can be performed safely. If the `module_b` provides a function
`has_field` that returns a boolean value indicating whether a field exists, the `do_something`
function can be rewritten as follows:

```move
module book::module_a;

use book::module_b;

const ENoField: u64 = 0;

public fun do_something() {
    assert!(module_b::has_field(1), ENoField);
    let field_1 = module_b::get_field(1);
    /* ... */
    assert!(module_b::has_field(2), ENoField);
    let field_2 = module_b::get_field(2);
    /* ... */
    assert!(module_b::has_field(3), ENoField);
    let field_3 = module_b::get_field(3);
}
```

By adding custom checks before each call to `module_b::get_field`, the developer of the `module_a`
takes control over the error handling. And it allows implementing the second rule.

## Rule 2: Abort with Different Codes

The second trick, once the abort codes are handled by the caller module, is to use different abort
codes for different scenarios. This way, the caller module can provide a meaningful error message to
the user. The `module_a` can be rewritten as follows:

```move
module book::module_a;

use book::module_b;

const ENoFieldA: u64 = 0;
const ENoFieldB: u64 = 1;
const ENoFieldC: u64 = 2;

public fun do_something() {
    assert!(module_b::has_field(1), ENoFieldA);
    let field_1 = module_b::get_field(1);
    /* ... */
    assert!(module_b::has_field(2), ENoFieldB);
    let field_2 = module_b::get_field(2);
    /* ... */
    assert!(module_b::has_field(3), ENoFieldC);
    let field_3 = module_b::get_field(3);
}
```

Now, the caller module can provide a meaningful error message to the user. If the caller receives an
abort code `0`, it can be translated to "Field 1 does not exist". If the caller receives an abort
code `1`, it can be translated to "Field 2 does not exist". And so on.

## Rule 3: Return `bool` Instead of `assert`

A developer is often tempted to add a public function that would assert all the conditions and abort
the execution. However, it is a better practice to create a function that returns a boolean value
instead. This way, the caller module can handle the error and provide a meaningful error message to
the user.

```move
module book::some_app_assert;

const ENotAuthorized: u64 = 0;

public fun do_a() {
    assert_is_authorized();
    // ...
}

public fun do_b() {
    assert_is_authorized();
    // ...
}

/// Don't do this
public fun assert_is_authorized() {
    assert!(/* some condition */ true, ENotAuthorized);
}
```

This module can be rewritten as follows:

```move
module book::some_app;

const ENotAuthorized: u64 = 0;

public fun do_a() {
    assert!(is_authorized(), ENotAuthorized);
    // ...
}

public fun do_b() {
    assert!(is_authorized(), ENotAuthorized);
    // ...
}

public fun is_authorized(): bool {
    /* some condition */ true
}

// a private function can still be used to avoid code duplication for a case
// when the same condition with the same abort code is used in multiple places
fun assert_is_authorized() {
    assert!(is_authorized(), ENotAuthorized);
}
```

Utilizing these three rules will make the error handling more transparent to the caller of the
transaction, and it will allow other developers to use custom abort codes in their modules.

>>>> move-book/book/guides/building-against-limits.md
# Building Against Limits

To guarantee the safety and security of the network, Sui has certain limits and restrictions. These
limits are in place to prevent abuse and to ensure that the network remains stable and efficient.
This guide provides an overview of these limits and restrictions, and how to build your application
to work within them.

The limits are defined in the protocol configuration and are enforced by the network. If any of the
limits are exceeded, the transaction will either be rejected or aborted. The limits, being a part of
the protocol, can only be changed through a network upgrade.

## Transaction Size

The size of a transaction is limited to 128KB. This includes the size of the transaction payload,
the size of the transaction signature, and the size of the transaction metadata. If a transaction
exceeds this limit, it will be rejected by the network.

## Object Size

The size of an object is limited to 256KB. This includes the size of the object data. If an object
exceeds this limit, it will be rejected by the network. While a single object cannot bypass this
limit, for more extensive storage options, one could use a combination of a base object with other
attached to it using dynamic fields (eg Bag).

## Single Pure Argument Size

The size of a single pure argument is limited to 16KB. A transaction argument bigger than this limit
will result in execution failure. So in order to create a vector of more than ~500 addresses (given
that a single address is 32 bytes), it needs to be joined dynamically either in Transaction Block or
in a Move function. Standard functions like `vector::append()` can join two vectors of ~16KB
resulting in a ~32KB of data as a single value.

## Maximum Number of Objects (and Dynamic Fields) Created

The maximum number of objects that can be created in a single transaction is 2048. If a transaction
attempts to create more than 2048 objects, it will be rejected by the network. This also affects
[dynamic fields](./../programmability/dynamic-fields.md), as both the key and the value are objects.
So the maximum number of [dynamic fields](./../programmability/dynamic-fields.md) that can be
created in a single transaction is 1000. The limitation applies to dynamic object fields as well.

## Maximum Number of Dynamic Fields Accessed

The maximum number of dynamic fields that can be accessed in a single transaction is 1000. If a
transaction attempts to access more than 1000 dynamic fields, it will be rejected by the network.

## Maximum Number of Events

The maximum number of events that can be emitted in a single transaction is 1024. If a transaction
attempts to emit more than 1024 events, it will be aborted.

>>>> move-book/book/guides/code-quality-checklist.md
# Code Quality Checklist

The rapid evolution of the Move language and its ecosystem has rendered many older practices
outdated. This guide serves as a checklist for developers to review their code and ensure it aligns
with current best practices in Move development. Please read carefully and apply as many
recommendations as possible to your code.

## Code Organization

Some of the issues mentioned in this guide can be fixed by using
[Move Formatter](https://www.npmjs.com/package/@mysten/prettier-plugin-move) either as a CLI tool,
or [as a CI check](https://github.com/marketplace/actions/move-formatter), or
[as a plugin for VSCode (Cursor)](https://marketplace.visualstudio.com/items?itemName=mysten.prettier-move).

## Package Manifest

### Use Right Edition

All of the features in this guide require Move 2024 Edition, and it has to be specified in the
package manifest.

```toml
[package]
name = "my_package"
edition = "2024.beta" # or (just) "2024"
```

### Implicit Framework Dependency

Starting with Sui 1.45 you no longer need to specify framework dependency in the `Move.toml`:

```toml
# old, pre 1.45
[dependencies]
Sui = { ... }

# modern day, Sui, Bridge, MoveStdlib and SuiSystem are imported implicitly!
[dependencies]
```

### Prefix Named Addresses

If your package has a generic name (e.g., `token`) – especially if your project includes multiple
packages – make sure to add a prefix to the named address:

```toml
# bad! not indicative of anything, and can conflict
[addresses]
math = "0x0"

# good! clearly states project, unlikely to conflict
[addresses]
my_protocol_math = "0x0"
```

## Imports, Module and Constants

### Using Module Label

```move
// bad: increases indentation, legacy style
module my_package::my_module {
    public struct A {}
}

// good!
module my_package::my_module;

public struct A {}
```

### No Single `Self` in `use` Statements

```move
// correct, member + self import
use my_package::other::{Self, OtherMember};

// bad! `{Self}` is redundant
use my_package::my_module::{Self};

// good!
use my_package::my_module;
```

### Group `use` Statements with `Self`

```move
// bad!
use my_package::my_module;
use my_package::my_module::OtherMember;

// good!
use my_package::my_module::{Self, OtherMember};
```

### Error Constants are in `EPascalCase`

```move
// bad! all-caps are used for regular constants
const NOT_AUTHORIZED: u64 = 0;

// good! clear indication it's an error constant
const ENotAuthorized: u64 = 0;
```

### Regular Constant are `ALL_CAPS`

```move
// bad! PascalCase is associated with error consts
const MyConstant: vector<u8> = b"my const";

// good! clear indication that it's a constant value
const MY_CONSTANT: vector<u8> = b"my const";
```

## Structs

### Capabilities are Suffixed with `Cap`

```move
// bad! if it's a capability, add a `Cap` suffix
public struct Admin has key, store {
    id: UID,
}

// good! reviewer knows what to expect from type
public struct AdminCap has key, store {
    id: UID,
}
```

### No `Potato` in Names

```move
// bad! it has no abilities, we already know it's a Hot-Potato type
public struct PromisePotato {}

// good!
public struct Promise {}
```

### Events Should Be Named in Past Tense

```move
// bad! not clear what this struct does
public struct RegisterUser has copy, drop { user: address }

// good! clear, it's an event
public struct UserRegistered has copy, drop { user: address }
```

### Use Positional Structs for Dynamic Field Keys + `Key` Suffix

```move
// not as bad, but goes against canonical style
public struct DynamicField has copy, drop, store {}

// good! canonical style, Key suffix
public struct DynamicFieldKey() has copy, drop, store;
```

## Functions

### No `public entry`, Only `public` or `entry`

```move
// bad! entry is not required for a function to be callable in a transaction
public entry fun do_something() { /* ... */ }

// good! public functions are more permissive, can return value
public fun do_something_2(): T { /* ... */ }
```

### Write Composable Functions for PTBs

```move
// bad! not composable, harder to test!
public fun mint_and_transfer(ctx: &mut TxContext) {
    /* ... */
    transfer::transfer(nft, ctx.sender());
}

// good! composable!
public fun mint(ctx: &mut TxContext): NFT { /* ... */ }

// good! intentionally not composable
entry fun mint_and_keep(ctx: &mut TxContext) { /* ... */ }
```

### Objects Go First (Except for Clock)

```move
// bad! hard to read!
public fun call_app(
    value: u8,
    app: &mut App,
    is_smth: bool,
    cap: &AppCap,
    clock: &Clock,
    ctx: &mut TxContext,
) { /* ... */ }

// good!
public fun call_app(
    app: &mut App,
    cap: &AppCap,
    value: u8,
    is_smth: bool,
    clock: &Clock,
    ctx: &mut TxContext,
) { /* ... */ }
```

### Capabilities Go Second

```move
// bad! breaks method associativity
public fun authorize_action(cap: &AdminCap, app: &mut App) { /* ... */ }

// good! keeps Cap visible in the signature and maintains `.calls()`
public fun authorize_action(app: &mut App, cap: &AdminCap) { /* ... */ }
```

### Getters Named After Field + `_mut`

```move
// bad! unnecessary `get_`
public fun get_name(u: &User): String { /* ... */ }

// good! clear that it accesses field `name`
public fun name(u: &User): String { /* ... */ }

// good! for mutable references use `_mut`
public fun details_mut(u: &mut User): &mut Details { /* ... */ }
```

## Function Body: Struct Methods

### Common Coin Operations

```move
// bad! legacy code, hard to read!
let paid = coin::split(&mut payment, amount, ctx);
let balance = coin::into_balance(paid);

// good! struct methods make it easier!
let balance = payment.split(amount, ctx).into_balance();

// even better (in this example - no need to create temporary coin)
let balance = payment.balance_mut().split(amount);

// also can do this!
let coin = balance.into_coin(ctx);
```

### Do Not Import `std::string::utf8`

```move
// bad! unfortunately, very common!
use std::string::utf8;

let str = utf8(b"hello, world!");

// good!
let str = b"hello, world!".to_string();

// also, for ASCII string
let ascii = b"hello, world!".to_ascii_string();
```

### UID has `delete`

```move
// bad!
object::delete(id);

// good!
id.delete();
```

### `ctx` has `sender()`

```move
// bad!
tx_context::sender(ctx);

// good!
ctx.sender()
```

### Vector Has a Literal. And Associated Functions

```move
// bad!
let mut my_vec = vector::empty();
vector::push_back(&mut my_vec, 10);
let first_el = vector::borrow(&my_vec);
assert!(vector::length(&my_vec) == 1);

// good!
let mut my_vec = vector[10];
let first_el = my_vec[0];
assert!(my_vec.length() == 1);
```

### Collections Support Index Syntax

```move
let x: VecMap<u8, String> = /* ... */;

// bad!
x.get(&10);
x.get_mut(&10);

// good!
&x[&10];
&mut x[&10];
```

## Option -> Macros

### Destroy And Call Function

```move
// bad!
if (opt.is_some()) {
    let inner = opt.destroy_some();
    call_function(inner);
};

// good! there's a macro for it!
opt.do!(|value| call_function(value));
```

### Destroy Some With Default

```move
let opt = option::none();

// bad!
let value = if (opt.is_some()) {
    opt.destroy_some()
} else {
    abort EError
};

// good! there's a macro!
let value = opt.destroy_or!(default_value);

// you can even do abort on `none`
let value = opt.destroy_or!(abort ECannotBeEmpty);
```

## Loops -> Macros

### Do Operation N Times

```move
// bad! hard to read!
let mut i = 0;
while (i < 32) {
    do_action();
    i = i + 1;
};

// good! any uint has this macro!
32u8.do!(|_| do_action());
```

### New Vector From Iteration

```move
// harder to read!
let mut i = 0;
let mut elements = vector[];
while (i < 32) {
    elements.push_back(i);
    i = i + 1;
};

// easy to read!
vector::tabulate!(32, |i| i);
```

### Do Operation on Every Element of a Vector

```move
// bad!
let mut i = 0;
while (i < vec.length()) {
    call_function(&vec[i]);
    i = i + 1;
};

// good!
vec.do_ref!(|e| call_function(e));
```

### Destroy a Vector and Call a Function on Each Element

```move
// bad!
while (!vec.is_empty()) {
    call(vec.pop_back());
};

// good!
vec.destroy!(|e| call(e));
```

### Fold Vector Into a Single Value

```move
// bad!
let mut aggregate = 0;
let mut i = 0;

while (i < source.length()) {
    aggregate = aggregate + source[i];
    i = i + 1;
};

// good!
let aggregate = source.fold!(0, |acc, v| {
    acc + v
});
```

### Filter Elements of the Vector

> Note: `T: drop` in the `source` vector

```move
// bad!
let mut filtered = [];
let mut i = 0;
while (i < source.length()) {
    if (source[i] > 10) {
        filtered.push_back(source[i]);
    };
    i = i + 1;
};

// good!
let filtered = source.filter!(|e| e > 10);
```

## Other

### Ignored Values In Unpack Can Be Ignored Altogether

```move
// bad! very sparse!
let MyStruct { id, field_1: _, field_2: _, field_3: _ } = value;
id.delete();

// good! 2024 syntax
let MyStruct { id, .. } = value;
id.delete();
```

## Testing

### Merge `#[test]` and `#[expected_failure(...)]`

```move
// bad!
#[test]
#[expected_failure]
fun value_passes_check() {
    abort
}

// good!
#[test, expected_failure]
fun value_passes_check() {
    abort
}
```

### Do Not Clean Up `expected_failure` Tests

```move
// bad! clean up is not necessary
#[test, expected_failure(abort_code = my_app::EIncorrectValue)]
fun try_take_missing_object_fail() {
    let mut test = test_scenario::begin(@0);
    my_app::call_function(test.ctx());
    test.end();
}

// good! easy to see where test is expected to fail
#[test, expected_failure(abort_code = my_app::EIncorrectValue)]
fun try_take_missing_object_fail() {
    let mut test = test_scenario::begin(@0);
    my_app::call_function(test.ctx());

    abort // will differ from EIncorrectValue
}
```

### Do Not Prefix Tests With `test_` in Testing Modules

```move
// bad! the module is already called _tests
module my_package::my_module_tests;

#[test]
fun test_this_feature() { /* ... */ }

// good! better function name as the result
#[test]
fun this_feature_works() { /* ... */ }
```

### Do Not Use `TestScenario` Where Not Necessary

```move
// bad! no need, only using ctx
let mut test = test_scenario::begin(@0);
let nft = app::mint(test.ctx());
app::destroy(nft);
test.end();

// good! there's a dummy context for simple cases
let ctx = &mut tx_context::dummy();
app::mint(ctx).destroy();
```

### Do Not Use Abort Codes in `assert!` in Tests

```move
// bad! may match application error codes by accident
assert!(is_success, 0);

// good!
assert!(is_success);
```

### Use `assert_eq!` Whenever Possible

```move
// bad! old-style code
assert!(result == b"expected_value", 0);

// good! will print both values if fails
use std::unit_test::assert_eq;

assert_eq!(result, expected_value);
```

### Use "Black Hole" `destroy` Function

```move
// bad!
nft.destroy_for_testing();
app.destroy_for_testing();

// good! - no need to define special functions for cleanup
use sui::test_utils::destroy;

destroy(nft);
destroy(app);
```

## Comments

### Doc Comments Start With `///`

```move
// bad! tooling doesn't support JavaDoc-style comments
/**
 * Cool method
 * @param ...
 */
public fun do_something() { /* ... */ }

// good! will be rendered as a doc comment in docgen and IDE's
/// Cool method!
public fun do_something() { /* ... */ }
```

### Complex Logic? Leave a Comment `//`

Being friendly and helping reviewers understand the code!

```move
// good!
// Note: can underflow if a value is smaller than 10.
// TODO: add an `assert!` here
let value = external_call(value, ctx);
```

>>>> move-book/book/guides/index.md
# Guides

This section contains a collection of guides that cover various aspects of programming on Sui. They
are intended to provide a deeper understanding of Sui blockchain and Move language, while also
aiming at practical challenges and solutions.

>>>> move-book/book/guides/open-sourcing-libraries.md
# Open Sourcing Libraries

Open sourcing libraries is a great way to contribute to the Move ecosystem. This guide will help you
understand how to open source a library, how to write tests, and how to document your library.

## README

TODO: readme

## Named Addresses

TODO: named address

## Generating Documentation

TODO: docgen

## Adding Examples

When publishing a package that is intended to be used (an NFT protocol or a library), it is
important to showcase how this package can be used. This is where examples come in handy. There's no
special functionality for examples in Move, however, there are some conventions that are used to
mark examples. First of all, only sources are included into the package bytecode, so any code placed
in a different directory will not be included, but will be tested!

This is why placing examples into a separate `examples/` directory is a good idea.

```bash
sources/
    protocol.move
    library.move
tests/
    protocol_test.move
examples/
    my_example.move
Move.toml
```

## Tags and Releases (Git)

TODO: tags and releases

## Tricks to allow compatibility with closed source

TODO: compatibility via empty functions with signatures

>>>> move-book/book/guides/upgradeability-practices.md
# Upgradeability Practices

To talk about best practices for upgradeability, we need to first understand what can be upgraded in
a package. The base premise of upgradeability is that an upgrade should not break public
compatibility with the previous version. The parts of the module which can be used in dependent
packages should not change their static signature. This applies to modules - a module can not be
removed from a package, public structs - they can be used in function signatures and public
functions - they can be called from other packages.

```move
// module can not be removed from the package
module book::upgradable;

// dependencies can be changed (if they are not used in public signatures)
use std::string::String;
use sui::event; // can be removed

// public structs can not be removed and can't be changed
public struct Book has key {
    id: UID,
    title: String,
}

// public structs can not be removed and can't be changed
public struct BookCreated has copy, drop {
    /* ... */
}

// public functions can not be removed and their signature can never change
// but the implementation can be changed
public fun create_book(ctx: &mut TxContext): Book {
    create_book_internal(ctx)

    // can be removed and changed
    event::emit(BookCreated {
        /* ... */
    })
}

// package-visibility functions can be removed and changed
public(package) fun create_book_package(ctx: &mut TxContext): Book {
    create_book_internal(ctx)
}

// entry functions can be removed and changed as long as they're not public
entry fun create_book_entry(ctx: &mut TxContext): Book {
    create_book_internal(ctx)
}

// private functions can be removed and changed
fun create_book_internal(ctx: &mut TxContext): Book {
    abort
}
```

<!--
## Using entry and friend functions

TODO: Add a section about entry and friend functions
-->

## Versioning objects

<!-- This practice is for function version locking based on a shared state -->

To discard previous versions of the package, the objects can be versioned. As long as the object
contains a version field, and the code which uses the object expects and asserts a specific version,
the code can be force-migrated to the new version. Normally, after an upgrade, admin functions can
be used to update the version of the shared state, so that the new version of code can be used, and
the old version aborts with a version mismatch.

```move
module book::versioned_state;

const EVersionMismatch: u64 = 0;

const VERSION: u8 = 1;

/// The shared state (can be owned too)
public struct SharedState has key {
    id: UID,
    version: u8,
    /* ... */
}

public fun mutate(state: &mut SharedState) {
    assert!(state.version == VERSION, EVersionMismatch);
    // ...
}
```

## Versioning configuration with dynamic fields

<!-- This practice is for versioning the contents / structure of objects -->

There's a common pattern in Sui which allows changing the stored configuration of an object while
retaining the same object signature. This is done by keeping the base object simple and versioned
and adding an actual configuration object as a dynamic field. Using this _anchor_ pattern, the
configuration can be changed with package upgrades while keeping the same base object signature.

```move
module book::versioned_config;

use sui::vec_map::VecMap;
use std::string::String;

/// The base object
public struct Config has key {
    id: UID,
    version: u16
}

/// The actual configuration
public struct ConfigV1 has store {
    data: Bag,
    metadata: VecMap<String, String>
}

// ...
```

<!-- ## Modular architecture -->

<!-- TODO: add two patterns for modular architecture: object capability (SuiFrens) and witness registry (SuiNS) -->

>>>> move-book/book/index.md
# The Move Book

<!-- TODO: insert author(s) -->

This is The Move Book - a comprehensive guide to the Move programming language and the Sui
blockchain. The book is intended for developers who are interested in learning about Move and
building on Sui.

<div class="warning">

The book is in active development and a work in progress. If you have any feedback or suggestions,
feel free to open an issue or a pull request on the
[GitHub repository](https://github.com/MystenLabs/move-book).

</div>

> If you're looking for The Move Reference, you can find it [here](/reference).

>>>> move-book/book/move-advanced/index.md
# Advanced Move Usage

This chapter covers advanced features of the Move language, including various extended behaviors for
advanced programming. This includes advanced usage of the language itself, plus the package and
build system.

>>>> move-book/book/move-advanced/modes.md
# Modes

Modes let you include **unpublishable** code only when you explicitly opt into a named build `mode`.
Think of them as generalizations of the `#[test_only]` [test annotation](../move-basics/testing) for
any purpose you choose (e.g. `debug`, `benchmark`, `spec`, or any other feature).

Modes at a glance:

* Annotate items with `#[mode(name, ...)]` or use the shorthand `#[test_only]` for the built-in
  `test` mode.
  * The `#[test_only]` attribute is syntactic sugar for `#[mode(test)]`.
* Build with `--mode <name>` (or `--test` for unit testing). Items whose mode list contains a name
  you enabled are compiled in. Items whose mode list does **not** match are compiled **out**.
* Code compiled with any mode enabled is **not publishable**. This keeps debug/test scaffolding from
  ever making it on-chain.
* Items with **no** `#[mode(...)]`/`#[test_only]` annotation are always included.

> Tip: Modes are filters enforced at compile-time—they don’t affect bytecode at runtime. Use them
> for helpers, simulators, and other mock types and functions that should never be published.

## Syntax

Like `#[test_only]`, You can attach a mode attribute to modules and to individual members:

```move
// Entire module is included only when a matching mode is enabled
#[mode(debug)]
module my_pkg::debug_tools {
    public fun dump_state() { /* ... */ }
}

module my_pkg::library {
    // This function exists only in `debug` or `test` builds
    #[mode(debug, test)]
    public fun assert_invariants() { /* ... */ }

    // Test-only helper; equivalent to #[mode(test)]
    #[test_only]
    fun mk_fake() { /* ... */ }
}
```

As we can see here, multiple modes can be listed in a single attribute: `#[mode(name1,name2,...)]`.
This item will be included during compilation if **any** of the listed names is enabled. In
addition, any definition without a mode annotation is always included.

> Tip: The annotation `#[mode(test)]` is equivalent to `#[test_only]`.

## Building with modes

Use the Sui CLI to opt into a mode when building or testing:

```bash
# Build with a custom mode enabled
sui move build --mode debug

# Run tests; includes #[test_only] automatically
sui move test --test

# Combine: run unit tests with extra debug helpers
sui move test --test --mode debug
```

Items annotated with a mode you enabled are compiled **in**; items annotated with a different,
non-enabled mode are compiled **out**. Unannotated items are always compiled in.

> **Publish safety**: Any artifact produced while a mode is enabled (including `--test`) is non-publishable. Always run a clean build **without** `--mode`/`--test` before `sui client publish`.

### Example — `test` mode (unit tests)

`#[test_only]` is the built-in mode for unit testing. It works exactly like a mode named `test`.

```move
#[mode(test)]
module my_pkg::math_tests {
    use my_pkg::math;

    #[modetest]
    fun add_basic() { /* ... */ }

    // Private test helper
    fun mk_case() { /* ... */ }
}
```

To build and run:

```bash
# Includes modules and members marked #[test_only]
sui move test --test
```

As described in the [testing](../move-basics/testing) documentation, this is a great way to
keep test helpers and test-only public functions out of published packages.

### Example 2: Debug testing

Suppose you have a `bank` module with a `transfer` function. You want to add debug logging in test
runs where you can see internal state, but you only want to run that test with those logs during
development (e.g., not during CI, etc). You can use a `debug` mode for this.

```move
module my_pkg::bank {
    use std::error;

    public fun transfer(from: &signer, to: address, amount: u64) {
        // ... production logic ...
    }
}

// Debug-only wrappers & helpers
#[mode(debug)]
module my_pkg::bank_debug {
    use std::debug;
    use my_pkg::bank;

    public fun transfer_debug(from: &signer, to: address, amount: u64) {
        // Perform debugging prints before the real call
        debug::print(&b"[DEBUG] transfer begin".to_vector());
        debug::print(&amount);
        debug::print(&to);
        // Main Call
        bank::transfer(from, to, amount);
        // More debugging prints
        debug::print(&b"[DEBUG] transfer end".to_vector());
    }
}
```

Here, `bank::transfer` is the **only** production entry point, with not printing. The
`#[mode(debug)]` exposes `bank_debug::{transfer_debug, dump_account, ...}`, however, which will
**only** be included in `debug`-mode builds. Now, we can write tests that use this extra visibility
without affecting production code or other tests:

```move
#[test_only]
module my_pkg::bank_tests {
    use my_pkg::bank;

    // Runs in all builds (no mode needed)
    #[test]
    fun transfer_basic() {
        // create signers, call bank::transfer(...)
    }

    // Runs only with `--test --mode debug`
    #[mode(debug)]
    #[test]
    fun transfer_with_logs() {
        use my_pkg::bank_debug; // only exists in debug builds
        // create signers, then:
        bank_debug::transfer_debug(&signer, @bob, 100);
        // assertions same as normal test; plus you see prints
    }
}
```

Now we can execute this test with extra logging by enabling the `debug` mode:

```bash
# Standard tests (no debug helpers compiled in)
sui move test

# Debug tests with extra logging
sui move test --mode debug
```

This allows us to produce production bytecode, continuous integration tests, and debug logging
tests, each at different times, without code duplication or complex branching.

## Publication

Code built with any mode enabled is non-publishable. Always do a clean build without `--mode` or
`--test` before publishing:

```bash
sui move build   # no --mode, no --test
```

## See also

* [Testing basics](../move-basics/testing) in the Move Book.
* [Modes](/reference/modes) in the Move Reference.

>>>> move-book/book/move-basics/abilities-introduction.md
# Abilities: Introduction

Move has a unique type system which allows customizing _type abilities_.
[In the previous section](./struct), we introduced the `struct` definition and how to use it.
However, the instances of the `Artist` and `Record` structs had to be unpacked for the code to
compile. This is default behavior of a struct without _abilities_.

> Throughout the book you will see chapters with name `Ability: <name>`, where `<name>` is the name
> of the ability. These chapters will cover the ability in detail, how it works, and how to use it
> in Move.

## What are Abilities?

Abilities are a way to allow certain behaviors for a type. They are a part of the struct declaration
and define which behaviors are allowed for the instances of the struct.

## Abilities Syntax

Abilities are set in the struct definition using the `has` keyword followed by a list of abilities.
The abilities are separated by commas. Move supports 4 abilities: `copy`, `drop`, `key`, and
`store`. Each ability defines a specific behavior for the struct instances.

```move
/// This struct has the `copy` and `drop` abilities.
public struct VeryAble has copy, drop {
    // field: Type1,
    // field2: Type2,
    // ...
}
```

## Overview

A quick overview of the abilities:

> All of the built-in types except [references](references) have `copy`, `drop`, and `store`
> abilities. References have `copy` and `drop`.

- `copy` - allows the struct to be _copied_. Explained in the [Ability: Copy](./copy-ability)
  chapter.
- `drop` - allows the struct to be _dropped_ or _discarded_. Explained in the
  [Ability: Drop](./drop-ability) chapter.
- `key` - allows the struct to be used as a _key_ in a storage. Explained in the
  [Ability: Key](./../storage/key-ability) chapter.
- `store` - allows the struct to be _stored_ in structs that have the _key_ ability. Explained in
  the [Ability: Store](./../storage/store-ability) chapter.

While it is important to briefly mention them here, we will go into more detail about each ability
in the following chapters and give proper context on how to use them.

## No Abilities

A struct without abilities cannot be discarded, copied, or stored in storage. We call such a struct
a _Hot Potato_. A lighthearted name, but it is a good way to remember that a struct without
abilities is like a hot potato - it can only be passed around and requires special handling. The Hot
Potato is one of the most powerful patterns in Move, and we go into more detail about it in the
[Hot Potato Pattern](./../programmability/hot-potato-pattern) chapter.

## Further Reading

- [Type Abilities](./../../reference/abilities) in the Move Reference.

>>>> move-book/book/move-basics/address.md
# Address Type

<!--

Chapter: Basic Syntax
Goal: Introduce the address type
Notes:
    - a special type
    - named addresses via the Move.toml
    - address literals
    - 0x2 is 0x0000000...02

Links:
    - address concept
    - transaction context
    - Move.toml
    - your first move

 -->

Move uses a special type called [address](./../concepts/address) to represent addresses. It is a
32-byte value that can represent any address on the blockchain. Addresses can be written in two
forms: hexadecimal addresses prefixed with 0x and named addresses.

```move file=packages/samples/sources/move-basics/address.move anchor=address_literal

```

An address literal starts with the `@` symbol followed by a hexadecimal number or an identifier. The
hexadecimal number is interpreted as a 32 byte value. The identifier is looked up in the
[Move.toml](./../concepts/manifest) file and replaced with the corresponding address by the
compiler. If the identifier is not found in the Move.toml file, the compiler will throw an error.

## Conversion

Sui Framework offers a set of helper functions to work with addresses. Given that the address type
is a 32 byte value, it can be converted to a `u256` type and vice versa. It can also be converted to
and from a `vector<u8>` type.

Example: Convert an address to a `u256` type and back.

```move file=packages/samples/sources/move-basics/address.move anchor=to_u256

```

Example: Convert an address to a `vector<u8>` type and back.

```move file=packages/samples/sources/move-basics/address.move anchor=to_bytes

```

Example: Convert an address into a string.

```move file=packages/samples/sources/move-basics/address.move anchor=to_string

```

## Further Reading

- [Address](./../../reference/primitive-types/address) in the Move Reference.
- [sui::address](https://docs.sui.io/references/framework/sui/address) module documentation.

>>>> move-book/book/move-basics/assert-and-abort.md
# Aborting Execution

<!-- Consider "aborting execution" -->

<!--

Chapter: Basic Syntax
Goal: Introduce abort keyword and `assert!` macro.
Notes:
    - previous chapter mentions constants
    - error constants standard ECamelCase
    - `assert!` macro
    - asserts should go before the main logic
    - Move has no catch mechanism
    - abort codes are local to the module
    - there are no error messages emitted
    - error codes should handle all possible scenarios in this module

Links:
    - constants (previous section)
 -->

A transaction can either succeed or fail. Successful execution applies all changes made to objects
and on-chain data, and the transaction is committed to the blockchain. Alternatively, if a
transaction aborts, changes are not applied. Use the `abort` keyword to abort a transaction and
revert any changes that were made.

> It is important to note that there is no catch mechanism in Move. If a transaction aborts, the
> changes made so far are reverted, and the transaction is considered failed.

## Abort

The `abort` keyword is used to abort the execution of a transaction. It is used in combination with
an abort code, which is returned to the caller of the transaction. The abort code is an
[integer](./primitive-types) of type `u64`.

```move file=packages/samples/sources/move-basics/assert-and-abort.move anchor=abort

```

The code above will, of course, abort with abort code `1`.

## assert!

The `assert!` macro is a built-in macro that can be used to assert a condition. If the condition is
false, the transaction will abort with the given abort code. The `assert!` macro is a convenient way
to abort a transaction if a condition is not met. The macro shortens the code otherwise written with
an `if` expression + `abort`. The `code` argument is optional, but has to be a `u64` value or an
`#[error]` (see below for more information).

```move file=packages/samples/sources/move-basics/assert-and-abort.move anchor=assert

```

## Error constants

To make error codes more descriptive, it is a good practice to define
[error constants](./constants). Error constants are defined as `const` declarations and are usually
prefixed with `E` followed by a camel case name. Error constants are similar to other constants and
do not have any special handling. However, they are commonly used to improve code readability and
make abort scenarios easier to understand.

```move file=packages/samples/sources/move-basics/assert-and-abort.move anchor=error_const

```

## Error messages

Move 2024 introduces a special type of error constant, marked with the `#[error]` attribute. This
attribute allows the error constant to be of type `vector<u8>` and can be used to store an error
message.

```move file=packages/samples/sources/move-basics/assert-and-abort.move anchor=error_attribute

```

## Further Reading

- [Abort and Assert](./../../reference/abort-and-assert) in the Move Reference.
- We suggest reading the [Better Error Handling](./../guides/better-error-handling) guide to learn
  about best practices for error handling in Move.

>>>> move-book/book/move-basics/comments.md
# Comments

<!--

Chapter: Basic Syntax
Goal: Introduce comments.
Notes:
    - doc comments are used in docgen
    - only public members are documented
    - doc comments are placed in between attributes and the definition
    - doc comments are allowed for: modules, structs, functions, constants
    - give an example of how doc comments are translated
 -->

Comments are a way to add notes or document your code. They are ignored by the compiler and don't
result in Move bytecode. You can use comments to explain what your code does, add notes to yourself
or other developers, temporarily remove a part of your code, or generate documentation. There are
three types of comments in Move: line comments, block comments, and doc comments.

## Line Comment

You can use a double slash `//` to comment out the rest of the line. Everything after `//` will be
ignored by the compiler.

```move file=packages/samples/sources/move-basics/comments-line.move anchor=main

```

## Block Comment

Block comments are used to comment out a block of code. They start with `/*` and end with `*/`.
Everything between `/*` and `*/` will be ignored by the compiler. You can use block comments to
comment out a single line or multiple lines. You can even use them to comment out a part of a line.

```move file=packages/samples/sources/move-basics/comments-block.move anchor=main

```

This example is a bit extreme, but it shows all the ways that you can use block comments.

## Doc Comment

Documentation comments are special comments that are used to generate documentation for your code.
They are similar to block comments but start with three slashes `///` and are placed before the
definition of the item they document.

```move file=packages/samples/sources/move-basics/comments-doc.move anchor=main

```

## Whitespace

Unlike some languages, whitespace (spaces, tabs, and newlines) have no impact on the meaning of the
program.

<!-- TODO: docgen, which members are in the documentation -->

>>>> move-book/book/move-basics/constants.md
# Constants

<!--

Chapter: Basic Syntax
Goal: Introduce constants.
Notes:
    - constants are immutable
    - constants are private
    - start with a capital letter always
    - stored in the bytecode (but w/o a name)
    - mention standard for naming constants

Links:
    - next section (abort and assert)
    - coding conventions (constants)
    - constants (language reference)

 -->

Constants are immutable values that are defined at the module level. They often serve as a way to
give names to static values that are used throughout a module. For example, if there's a default
price for a product, you might define a constant for it. Constants are stored in the module's
bytecode, and each time they are used, the value is copied.

```move file=packages/samples/sources/move-basics/constants-shop-price.move anchor=shop_price

```

## Naming Convention

Constants must start with a capital letter - this is enforced at the compiler level. For constants
used as a value, the convention is to use all uppercase letters and underscores between words, which
makes constants stand out from other identifiers in the code. An exception is made for
[error constants](./assert-and-abort#error-constants), which are written in ECamelCase.

```move file=packages/samples/sources/move-basics/constants-naming.move anchor=naming

```

## Constants are Immutable

Constants can't be changed and assigned new values. As part of the package bytecode, they are
inherently immutable.

```move
module book::immutable_constants;

const ITEM_PRICE: u64 = 100;

// emits an error
fun change_price() {
    ITEM_PRICE = 200;
}
```

## Using Config Pattern

A common use case for an application is to define a set of constants that are used throughout the
codebase. But due to constants being private to the module, they can't be accessed from other
modules. One way to solve this is to define a "config" module that exports the constants.

```move file=packages/samples/sources/move-basics/constants-config.move anchor=config

```

This way other modules can import and read the constants, and the update process is simplified. If
the constants need to be changed, only the config module needs to be updated during the package
upgrade.

## Links

- [Constants](./../../reference/constants) in the Move Reference
- [Coding conventions for constants](./../guides/code-quality-checklist#regular-constant-are-all_caps)

>>>> move-book/book/move-basics/control-flow.md
# Control Flow

<!--

Chapter: Basic Syntax
Goal: Introduce control flow statements.
Notes:
    - if/else is an expression
    - while () {} loop
    - continue and break
    - loop {}
    - infinite loop is possible but will lead to gas exhaustion
    - return keyword
    - if is an expression and as such requires a semicolon (!!!)

Links:
    - reference (control flow)
    - coding conventions (control flow)

 -->

Control flow statements are used to control the flow of execution in a program. They are used to
make decisions, repeat a block of code, or exit a block of code early. Move includes the following
control flow statements (explained in detail below):

- [`if` and `if-else`](#conditional-statements) - making decisions on whether to execute a block of
  code
- [`loop` and `while` loops](#repeating-statements-with-loops) - repeating a block of code
- [`break` and `continue` statements](#exiting-a-loop-early) - exiting a loop early
- [`return`](#early-return) statement - exiting a function early

## Conditional Statements

The `if` expression is used to make decisions in a program. It evaluates a
[boolean expression](./expression#literals) and executes a block of code if the expression is true.
Paired with `else`, it can execute a different block of code if the expression is false.

The syntax for an `if` expression is:

```move
if (<bool_expression>) <expression>;
if (<bool_expression>) <expression> else <expression>;
```

Just like any other expression, `if` requires a semicolon if there are other expressions following
it. The `else` keyword is optional, except when the resulting value is assigned to a variable, as
all branches must return a value to ensure type safety. Let’s examine how an `if` expression works
in Move with the following example:

```move file=packages/samples/sources/move-basics/control-flow.move anchor=if_condition

```

Let's see how we can use `if` and `else` to assign a value to a variable:

```move file=packages/samples/sources/move-basics/control-flow.move anchor=if_else

```

In this example, the value of the `if` expression is assigned to the variable `y`. If `x` is greater
than 0, `y` is assigned the value 1; otherwise, it is assigned 0. The `else` block is required
because both branches of the `if` expression must return a value of the same type. Omitting the
`else` block would result in a compiler error, as it ensures all possible branches are accounted for
and type safety is maintained.

<!-- TODO: add an error -->

Conditional expressions are among the most important control flow statements in Move. They evaluate
user-provided input or stored data to make decisions. One key use case is in the
[`assert!` macro](./assert-and-abort), which checks if a condition is true and aborts execution if
it is not. We’ll explore this in detail shortly.

## Repeating Statements with Loops

Loops are used to execute a block of code multiple times. Move has two built-in types of loops:
`loop` and `while`. In many cases they can be used interchangeably, but usually `while` is used when
the number of iterations is known in advance, and `loop` is used when the number of iterations is
not known in advance or there are multiple exit points.

Loops are useful for working with collections, such as vectors, or for repeating a block of code
until a specific condition is met. However, take care to avoid infinite loops, which can exhaust gas
limits and cause the transaction to abort.

## The `while` Loop

The `while` statement executes a block of code repeatedly as long as the associated boolean
expression evaluates to true. Just like we've seen with `if`, the boolean expression is evaluated
before each iteration of the loop. Additionally, like conditional statements, the `while` loop is an
expression and requires a semicolon if there are other expressions following it.

The syntax for the `while` loop is:

```move
while (<bool_expression>) { <expressions>; };
```

Here is an example of a `while` loop with a very simple condition:

```move file=packages/samples/sources/move-basics/control-flow.move anchor=while_loop

```

## Infinite `loop`

Now let's imagine a scenario where the boolean expression is always `true`. For example, if we
literally passed `true` to the `while` condition. This is similar to how the `loop` statement
functions, except that `while` evaluates a condition.

```move file=packages/samples/sources/move-basics/control-flow.move anchor=infinite_while

```

An infinite `while` loop, or a `while` loop with an always `true` condition, is equivalent to a
`loop`. The syntax for creating a `loop` is straightforward:

```move
loop { <expressions>; };
```

Let's rewrite the previous example using `loop` instead of `while`:

```move file=packages/samples/sources/move-basics/control-flow.move anchor=infinite_loop

```

Infinite loops are rarely practical in Move, as every operation consumes gas, and an infinite loop
will inevitably lead to gas exhaustion. If you find yourself using a loop, consider whether there
might be a better approach, as many use cases can be handled more efficiently with other control
flow structures. That said, `loop` might be useful when combined with `break` and `continue`
statements to create controlled and flexible looping behavior.

## Exiting a Loop Early

As we already mentioned, infinite loops are rather useless on their own. And that's where we
introduce the `break` and `continue` statements. They are used to exit a loop early, and to skip the
rest of the current iteration, respectively.

Syntax for the `break` statement is (without a semicolon):

```move
break
```

The `break` statement is used to stop the execution of a loop and exit it early. It is often used in
combination with a conditional statement to exit the loop when a certain condition is met. To
illustrate this point, let's turn the infinite `loop` from the previous example into something that
looks and behaves more like a `while` loop:

```move file=packages/samples/sources/move-basics/control-flow.move anchor=break_loop

```

Almost identical to the `while` loop, right? The `break` statement is used to exit the loop when `x`
is 5. If we remove the `break` statement, the loop will run forever, just like in the previous
example.

## Skipping an Iteration

The `continue` statement is used to skip the rest of the current iteration and start the next one.
Similarly to `break`, it is used in combination with a conditional statement to skip the rest of an
iteration when a certain condition is met.

Syntax for the `continue` statement is (without a semicolon):

```move
continue
```

The example below skips odd numbers and prints only even numbers from 0 to 10:

```move file=packages/samples/sources/move-basics/control-flow.move anchor=continue_loop

```

`break` and `continue` statements can be used in both `while` and `loop` loops.

## Early Return

The `return` statement is used to exit a [function](./function) early and return a value. It is
often used in combination with a conditional statement to exit the function when a certain condition
is met. The syntax for the `return` statement is:

```move
return <expression>
```

Here is an example of a function that returns a value when a certain condition is met:

```move file=packages/samples/sources/move-basics/control-flow.move anchor=return_statement

```

Unlike in many other languages, the `return` statement is not required for the last expression in a
function. The last expression in a function block is automatically returned. However, the `return`
statement is useful when we want to exit a function early if a certain condition is met.

## Further Reading

- [Control Flow](./../../reference/control-flow) chapter in the Move Reference.

>>>> move-book/book/move-basics/copy-ability.md
# Abilities: Copy

In Move, the _copy_ ability on a type indicates that the instance or the value of the type can be
copied, or duplicated. While this behavior is provided by default when working with numbers or other
primitive types, it is not the default for custom types. Move is designed to express digital assets
and resources, and controlling the ability to duplicate resources is a key principle of the resource
model. However, the Move type system allows you to add the _copy_ ability to custom types:

```move file=packages/samples/sources/move-basics/copy-ability.move anchor=copyable

```

In the example above, we define a custom type `Copyable` with the _copy_ ability. This means that
instances of `Copyable` can be copied, both implicitly and explicitly.

```move file=packages/samples/sources/move-basics/copy-ability.move anchor=copyable_test

```

In the example above, `a` is copied to `b` implicitly, and then explicitly copied to `c` using the
dereference operator. If `Copyable` did not have the _copy_ ability, the code would not compile, and
the Move compiler would raise an error.

> Note: In Move, destructuring with empty brackets is often used to consume unused variables,
> especially for types without the drop ability. This prevents compiler errors from values going out
> of scope without explicit use. Also, Move requires the type name in destructuring (e.g.,
> `Copyable` in `let Copyable {} = a;`) because it enforces strict typing and ownership rules.

## Copying and Drop

The `copy` ability is closely related to the [`drop` ability](./drop-ability). If a type has the
_copy_ ability, it is very likely that it should have `drop` too. This is because the _drop_ ability
is required to clean up resources when the instance is no longer needed. If a type only has _copy_,
managing its instances gets more complicated, as the instances must be explicitly used or consumed.

```move file=packages/samples/sources/move-basics/copy-ability.move anchor=copy_drop

```

All of the primitive types in Move behave as if they have the _copy_ and _drop_ abilities. This
means that they can be copied and dropped, and the Move compiler will handle the memory management
for them.

## Types with the `copy` Ability

All native types in Move have the `copy` ability. This includes:

- [bool](./../move-basics/primitive-types#booleans)
- [unsigned integers](./../move-basics/primitive-types#integer-types)
- [vector](./../move-basics/vector)
- [address](./../move-basics/address)

All of the types defined in the standard library have the `copy` ability as well. This includes:

- [Option](./../move-basics/option)
- [String](./../move-basics/string)
- [TypeName](./../move-basics/type-reflection)

## Further Reading

- [Type Abilities](./../../reference/abilities) in the Move Reference.

>>>> move-book/book/move-basics/drop-ability.md
# Abilities: Drop

<!-- TODO: reiterate, given that we introduce abilities one by one -->

<!-- TODO:

- introduce abilities first
- mention them all
- then do one by one

consistency: we / I / you ?
who is we? I am alone, there's no one else here


-->

<!--

// Shall we only talk about `drop` ?
// So that we don't explain scopes and `copy` / `move` semantics just yet?

Chapter: Basic Syntax
Goal: Introduce Copy and Drop abilities of Move. Follows the `struct` section
Notes:
    - compare them to primitive types introduces before;
    - what is an ability without drop
    - drop is not necessary for unpacking
    - make a joke about a bacteria pattern in the code
    - mention that a struct with only `drop` ability is called a Witness
    - mention that a struct without abilities is called a Hot Potato
    - mention that there are two more abilities which are covered in a later chapter

Links:
    - language reference (abilities)
    - authorization patterns (or witness)
    - hot potato pattern
    - key and store abilities (later chapter)

 -->

The `drop` ability - the simplest of them - allows the instance of a struct to be _ignored_ or
_discarded_. In many programming languages this behavior is considered default. However, in Move, a
struct without the `drop` ability is not allowed to be ignored. This is a safety feature of the Move
language, which ensures that all assets are properly handled. An attempt to ignore a struct without
the `drop` ability will result in a compilation error.

```move file=packages/samples/sources/move-basics/drop-ability.move anchor=main

```

The `drop` ability is often used on custom collection types to eliminate the need for special
handling of the collection when it is no longer needed. For example, a `vector` type has the `drop`
ability, which allows the vector to be ignored when it is no longer needed. However, the biggest
feature of Move's type system is the ability to not have `drop`. This ensures that the assets are
properly handled and not ignored.

A struct with a single `drop` ability is called a _Witness_. We explain the concept of a _Witness_
in the [Witness and Abstract Implementation](./../programmability/witness-pattern) section.

## Types with the `drop` Ability

All native types in Move have the `drop` ability. This includes:

- [`bool`](./../move-basics/primitive-types#booleans)
- [unsigned integers](./../move-basics/primitive-types#integer-types)
- [`vector<T>`](./../move-basics/vector) when `T` has `drop`
- [`address`](./../move-basics/address)

All of the types defined in the standard library have the `drop` ability as well. This includes:

- [`Option<T>`](./../move-basics/option) when `T` has `drop`
- [`String`](./../move-basics/string)
- [`TypeName`](./../move-basics/type-reflection)

## Further Reading

- [Type Abilities](./../../reference/abilities) in the Move Reference.

>>>> move-book/book/move-basics/enum-and-match.md
# Enums and Match

An enum is a user-defined data structure that, unlike a [struct](./struct), can represent multiple
variants. Each variant can contain primitive types, structs, or other enums. However, recursive enum
definitions — similar to recursive struct definitions — are not allowed.

## Definition

An enum is defined using the `enum` keyword, followed by optional abilities and a block of variant
definitions. Each variant has a tag name and may optionally include either positional values or
named fields. Enum must have at least one variant. The structure of each variant is not flexible,
and the total number of variants can be relatively large - up to 100.

```move file=packages/samples/sources/move-basics/enum-and-match.move anchor=definition

```

In the code sample above we defined a public `Segment` enum, which has the `drop` and `copy`
abilities, and 3 variants:

- `Empty`, which has no fields.
- `String`, which contains a single positional field of type `String`.
- `Special`, which uses named fields: `content` of type `vector<u8>` and `encoding` of type `u8`.

## Instantiating

Enums are _internal_ to the module in which they are defined. This means an enum can only be
constructed, read, and unpacked within the same module.

[Similar to structs](./struct#create-and-use-an-instance), enums are instantiated by specifying the
type, the variant, and the values for any fields defined in that variant.

```move file=packages/samples/sources/move-basics/enum-and-match.move anchor=constructors

```

Depending on the use case, you may want to provide public constructors, or instantiate enums
internally as a part of application logic.

## Using in Type Definitions

The biggest benefit of using enums is the ability to represent varying data structures under a
single type. To demonstrate this, let’s define a struct that contains a vector of `Segment` values:

```move file=packages/samples/sources/move-basics/enum-and-match.move anchor=struct

```

All variants of the Segment enum share the same type – `Segment` – which allows us to create a
homogeneous vector containing instances of different variants. This kind of flexibility is not
achievable with structs, as each struct defines a single, fixed shape.

## Pattern Matching

Unlike structs, enums require special handling when it comes to accessing the inner value or
checking the variant. We simply cannot read the inner fields of an enum using the `.` (dot) syntax,
because we need to make sure that the value we are trying to access is the right one. For that Move
offers _pattern matching_ syntax.

> This chapter doesn't intend to cover all the features of pattern matching in Move. Refer to the
> [Pattern Matching](./../../reference/control-flow/pattern-matching) section in the Move Reference.

Pattern matching allows conditioning the logic based on the _pattern_ of the value. It is performed
using the `match` expression, followed by the matched value in parenthesis and the block of _match
arms_, defining the pattern and expression to be performed if the pattern is right.

Let's extend our example by adding a set of `is_variant`-like functions, so external packages can
check the variant. Starting with `is_empty`.

```move file=packages/samples/sources/move-basics/enum-and-match.move anchor=is_empty

```

The `match` keyword begins the expression, and `s` is the value being tested. Each match arm checks
for a specific variant of the `Segment` enum. If `s` matches `Segment::Empty`, the function returns
`true`; otherwise, it returns `false`.

For variants with fields, we need to bind the inner structure to local variables (even if we don’t
use them, marking unused values with `_` to avoid compiler warnings).

### Trick #1 - _any_ Condition

The Move compiler infers the type of the value used in a `match` expression and ensures that the
_match arms_ are exhaustive – that is, all possible variants or values must be covered.

However, in some cases, such as matching on a primitive value or a collection like a vector, it's
not feasible to list every possible case. For these situations, match supports a wildcard pattern
(`_`), which acts as a default arm. This arm is executed when no other patterns match.

We can demonstrate this by simplifying our `is_empty` function and replacing the non-`Empty`
variants with a wildcard:

```move file=packages/samples/sources/move-basics/enum-and-match.move anchor=is_empty_2
public fun is_empty(s: &Segment): bool {

```

Similarly, we can use the same approach to define `is_special` and `is_string`:

```move file=packages/samples/sources/move-basics/enum-and-match.move anchor=accessors

```

### Trick #2 - `try_into` Helpers

With the addition of `is_variant` functions, we enabled external modules to check which variant an
enum instance represents. However, this is often not enough – external code still cannot access the
inner value of a variant due to enums being internal to their module.

A common pattern for addressing this is to define `try_into` functions. These functions match on the
value and return an `Option` containing the inner contents if the `match` succeeds.

```move file=packages/samples/sources/move-basics/enum-and-match.move anchor=try_into_inner_string

```

This pattern safely exposes internal data in a controlled way, avoiding abort.

### Trick #3 - Matching on Primitive Values

The `match` expression in Move can be used with values of any type – enums, structs, or primitives.
To demonstrate this, let’s implement a `to_string` function that creates a new `String` from a
`Segment`. In the case of the `Special` variant, we will match on the `encoding` field to determine
how to decode the content.

```move file=packages/samples/sources/move-basics/enum-and-match.move anchor=to_string

```

This function demonstrates two key things:

- Nested `match` expressions can be used for deeper logic branching.
- Wildcards are essential for covering all possible values in primitive types like `u8`.

## The Final Test

Now we can finalize the test we started before using the features we have added. Let's create a
scenario where we build enums into a vector.

```move file=packages/samples/sources/move-basics/enum-and-match-2.move anchor=enum_test

```

This test demonstrates the full enum workflow: instantiating different variants, using public
accessors, and performing logic with pattern matching. That should be enough to get you started!

To learn more about enums and pattern matching, refer to the resources listed in the
[further reading](#further-reading) section.

## Summary

- Enums are user-defined types that can represent multiple variants under a single type.
- Each variant can contain different types of data (primitives, structs, or other enums).
- Enums are internal to their defining module and require pattern matching for access.
- Pattern matching is done using the `match` expression, which:
  - Works with enums, structs, and primitive values;
  - Must handle all possible cases (be exhaustive);
  - Supports the `_` wildcard pattern for remaining cases;
  - Can return values and be used in expressions;
- Common patterns for enums include `is_variant` checks and `try_into` helper functions.

## Further Reading

- [Enums](./../../reference/enums) in the Move Reference
- [Pattern Matching](/reference/control-flow/pattern-matching) in the Move Reference

>>>> move-book/book/move-basics/expression.md
# Expression

In programming languages, an expression is a unit of code that returns a value. In Move, almost
everything is an expression, with the sole exception of the `let` statement, which is a declaration.
In this section, we cover the types of expressions and introduce the concept of scope.

> Expressions are sequenced with semicolons `;`. If there's "no expression" after the semicolon, the
> compiler will insert a `unit ()`, which represents an empty expression.

## Literals

In the [Primitive types](./primitive-types) section, we introduced the basic types of Move. And to
illustrate them, we used literals. A literal is a notation for representing a fixed value in source
code. Literals can be used to initialize variables or directly pass fixed values as arguments to
functions. Move has the following literals:

- Boolean values: `true` and `false`
- Integer values: `0`, `1`, `123123`
- Hexadecimal values: Numbers prefixed with 0x to represent integers, such as `0x0`, `0x1`, `0x123`
- Byte vector values: Prefixed with `b`, such as `b"bytes_vector"`
- Byte values: Hexadecimal literals prefixed with `x`, such as `x"0A"`

```move file=packages/samples/sources/move-basics/expression.move anchor=literals

```

## Operators

Arithmetic, logical, and bitwise operators are used to perform operations on values. Since these
operations produce values, they are considered expressions.

```move file=packages/samples/sources/move-basics/expression.move anchor=operators

```

## Blocks

A block is a sequence of statements and expressions enclosed in curly braces `{}`. It returns the
value of the last expression in the block (note that this final expression must not have an ending
semicolon). A block is an expression, so it can be used anywhere an expression is expected.

```move file=packages/samples/sources/move-basics/expression.move anchor=block

```

## Function Calls

We go into detail about functions in the [Functions](./function) section. However, we have already
used function calls in previous sections, so it's worth mentioning them here. A function call is an
expression that calls a function and returns the value of the last expression in the function body,
provided the last expression does not have a terminating semi-colon.

```move file=packages/samples/sources/move-basics/expression.move anchor=fun_call

```

## Control Flow Expressions

Control flow expressions are used to control the flow of the program. They are also expressions, so
they return a value. We cover control flow expressions in the [Control Flow](./control-flow)
section. Here's a very brief overview:

```move file=packages/samples/sources/move-basics/expression.move anchor=control_flow

```

>>>> move-book/book/move-basics/function.md
# Functions

Functions are the building blocks of Move programs. They are called from
[user transactions](./../concepts/what-is-a-transaction) and from other functions and group
executable code into reusable units. Functions can take arguments and return a value. They are
declared with the `fun` keyword at the module level. Just like any other module member, by default
they're private and can only be accessed from within the module.

```move file=packages/samples/sources/move-basics/function.move anchor=math

```

In this example, we define a function `add` that takes two arguments of type `u64` and returns their
sum. The `test_add` function, located in the same module, is a test function that calls `add`. The
test uses the `assert!` macro to compare the result of `add` with the expected value. If the
condition inside `assert!` evaluates to false, the execution is aborted automatically.

## Function declaration

> In Move, functions are typically named using the `snake_case` convention. This means function
> names should be all lowercase, with words separated by underscores. Examples include
> `do_something`, `add`, `get_balance`, `is_authorized`, and so on.

A function is declared with the `fun` keyword followed by the function name (a valid Move
identifier), a list of arguments in parentheses, and a return type. The function body is a block of
code that contains a sequence of statements and expressions. The last expression the function body
is the return value of the function.

```move file=packages/samples/sources/move-basics/function.move anchor=return_nothing

```

## Accessing functions

Just like other module members, functions can be imported and accessed using a path. The path
consists of the module path and the function name, separated by ::. For example, if you have a
function named `add` in the `math` module within the `book` package, its full path would be
`book::math::add`. If the module has already been imported, you can access it directly as
`math::add` as in the following example:

```move file=packages/samples/sources/move-basics/function_use.move anchor=use_math

```

## Multiple return values

Move functions can return multiple values, which is particularly useful when you need to return more
than one piece of data from a function. The return type is specified as a tuple of types, and the
return value is provided as a tuple of expressions:

```move file=packages/samples/sources/move-basics/function.move anchor=tuple_return

```

The result of a function call with a tuple return has to be unpacked into variables via the
`let (tuple)` syntax:

```move file=packages/samples/sources/move-basics/function.move anchor=tuple_return_imm

```

If any of the declared values need to be declared as mutable, the `mut` keyword is placed before the
variable name:

```move file=packages/samples/sources/move-basics/function.move anchor=tuple_return_mut

```

If some of the arguments are not used, they can be ignored with the `_` symbol:

```move file=packages/samples/sources/move-basics/function.move anchor=tuple_return_ignore

```

## Further Reading

- [Functions](./../../reference/functions) in the Move Reference.

>>>> move-book/book/move-basics/generics.md
# Generics

Generics are a way to define a type or function that can work with any type. This is useful when you
want to write a function which can be used with different types, or when you want to define a type
that can hold any other type. Generics are the foundation of many advanced features in Move
including collections, abstract implementations, and more.

## In the Standard Library

In this chapter we already mentioned the [vector](./vector) type, which is a generic type that can
hold any other type. Another example of a generic type in the standard library is the
[Option](./option) type, which is used to represent a value that may or may not be present.

## Generic Syntax

To define a generic type or function, a type signature needs to have a list of generic parameters
enclosed in angle brackets (`<` and `>`). The generic parameters are separated by commas.

```move file=packages/samples/sources/move-basics/generics.move anchor=container

```

In the example above, `Container` is a generic type with a single type parameter `T`, the `value`
field of the container stores the `T`. The `new` function is a generic function with a single type
parameter `T`, and it returns a `Container` with the given value. Generic types must be initialized
with a concrete type, and generic functions must be called with a concrete type, although in some
cases the Move compiler can infer the correct type.

```move file=packages/samples/sources/move-basics/generics.move anchor=test_container

```

In the test function `test_container`, we demonstrate three equivalent ways to create a new
`Container` with a `u8` value. Because numeric constants have ambiguous types, we must specify the
type of the number literal somewhere (in the type of the container, the parameter to `new`, or the
number literal itself); once we specify one of these the compiler can infer the others.

## Multiple Type Parameters

You can define a type or function with multiple type parameters. The type parameters are separated
by commas.

```move file=packages/samples/sources/move-basics/generics.move anchor=pair

```

In the example above, `Pair` is a generic type with two type parameters `T` and `U`, and the
`new_pair` function is a generic function with two type parameters `T` and `U`. The function returns
a `Pair` with the given values. The order of the type parameters is important, and should match the
order of the type parameters in the type signature.

```move file=packages/samples/sources/move-basics/generics.move anchor=test_pair

```

If we added another instance where we swapped type parameters in the `new_pair` function, and tried
to compare two types, we'd see that the type signatures are different, and cannot be compared.

```move file=packages/samples/sources/move-basics/generics.move anchor=test_pair_swap

```

Since the types for `pair1` and `pair2` are different, the comparison `pair1 == pair2` will not
compile.

## Why Generics?

In the examples above we focused on instantiating generic types and calling generic functions to
create instances of these types. However, the real power of generics lies in their ability to define
shared behavior for the base, generic type, and then use it independently of the concrete types.
This is especially useful when working with collections, abstract implementations, and other
advanced features in Move.

```move file=packages/samples/sources/move-basics/generics.move anchor=user

```

In the example above, `User` is a generic type with a single type parameter `T`, with shared fields
`name`, `age`, and the generic `metadata` field, which can store any type. No matter what `metadata`
is, all instances of `User` will contain the same fields and methods.

```move file=packages/samples/sources/move-basics/generics.move anchor=update_user

```

## Phantom Type Parameters

In some cases, you may want to define a generic type with a type parameter that is not used in the
fields or methods of the type. This is called a _phantom type parameter_. Phantom type parameters
are useful when you want to define a type that can hold any other type, but you want to enforce some
constraints on the type parameter.

```move file=packages/samples/sources/move-basics/generics.move anchor=phantom

```

The `Coin` type here does not contain any fields or methods that use the type parameter `T`. It is
used to differentiate between different types of coins, and to enforce some constraints on the type
parameter `T`.

```move file=packages/samples/sources/move-basics/generics.move anchor=test_phantom

```

In the example above, we demonstrate how to create two different instances of `Coin` with different
phantom type parameters `USD` and `EUR`. The type parameter `T` is not used in the fields or methods
of the `Coin` type, but it is used to differentiate between different types of coins. This helps
ensure that the `USD` and `EUR` coins are not mistakenly mixed up.

## Constraints on Type Parameters

Type parameters can be constrained to have certain abilities. This is useful when you need the inner
type to allow certain behaviors, such as _copy_ or _drop_. The syntax for constraining a type
parameter is `T: <ability> + <ability>`.

```move file=packages/samples/sources/move-basics/generics.move anchor=constraints

```

The Move Compiler will enforce that the type parameter `T` has the specified abilities. If the type
parameter does not have the specified abilities, the code will not compile.

<!-- TODO: failure case -->

```move file=packages/samples/sources/move-basics/generics.move anchor=test_constraints

```

## Further Reading

- [Generics](./../../reference/generics) in the Move Reference.

>>>> move-book/book/move-basics/importing-modules.md
# Importing Modules

<!--
    TODO: create a better example for:
        1. Importing a module in general
        2. Importing a member
        3. Importing multiple members
        4. Grouping imports
        5. Self keyword for groups
-->

<!--

Goals:
    - Show the import syntax
    - Local dependencies
    - External dependencies
    - Importing modules from other packages

 -->

Move achieves high modularity and code reuse by allowing module imports. Modules within the same
package can import each other, and a new package can depend on already existing packages and use
their modules too. This section will cover the basics of importing modules and how to use them in
your own code.

## Importing a Module

Modules defined in the same package can import each other. The `use` keyword is followed by the
module path, which consists of the package address (or alias) and the module name separated by `::`.

```move title="File: sources/module_one.move" file=packages/samples/sources/move-basics/importing-modules.move anchor=module_one

```

Another module defined in the same package can import the first module using the `use` keyword.

```move title="File: sources/module_two.move" file=packages/samples/sources/move-basics/importing-modules-two.move anchor=module_two

```

> Note: Any item (struct, function, constant, etc.) that you want to import from another module must
> be marked with the `public` (or `public(package)` - see [visibility modifiers](./visibility))
> keyword to make it accessible outside its defining module. For example, the `Character` struct and
> the `new` function in `module_one` are marked public so they can be used in `module_two`.

## Importing Members

You can also import specific members from a module. This is useful when you only need a single
function or a single type from a module. The syntax is the same as for importing a module, but you
add the member name after the module path.

```move file=packages/samples/sources/move-basics/importing-modules-members.move anchor=members

```

## Grouping Imports

Imports can be grouped into a single `use` statement using curly braces `{}`. This allows for
cleaner and more organized code when importing multiple members from the same module or package.

```move file=packages/samples/sources/move-basics/importing-modules-grouped.move anchor=grouped

```

Importing function names is less common in Move, since the function names can overlap and cause
confusion. A recommended practice is to import the entire module and use the module path to access
the function. Types have unique names and should be imported individually.

To import members and the module itself in the group import, you can use the `Self` keyword. The
`Self` keyword refers to the module itself and can be used to import the module and its members.

```move file=packages/samples/sources/move-basics/importing-modules-self.move anchor=self

```

## Resolving Name Conflicts

When importing multiple members from different modules, it is possible to have name conflicts. For
example, if you import two modules that both have a function with the same name, you will need to
use the module path to access the function. It is also possible to have modules with the same name
in different packages. To resolve the conflict and avoid ambiguity, Move offers the `as` keyword to
rename the imported member.

```move file=packages/samples/sources/move-basics/importing-modules-conflict-resolution.move anchor=conflict

```

## Adding an External Dependency

Move packages can depend on other packages; the dependencies are listed in the
[Package Manifest](./../concepts/manifest) file called `Move.toml`.

Package dependencies are defined in the [Package Manifest](./../concepts/manifest) as follows:

```ini title="Move.toml"
[dependencies]
Example = { git = "https://github.com/Example/example.git", subdir = "path/to/package", rev = "v1.2.3" }
Local = { local = "../my_other_package" }
```

The `dependencies` section contains an entry for each package dependency. The key of the entry is
the name of the package (`Example` or `Local` in the example), and the value is either a git import
table or a local path. The git import contains the URL of the package, the subdirectory where the
package is located, and the revision of the package. The local path is a relative path to the qa
package directory.

If you add a dependency, all of its dependencies also become available to your package.

If a dependency is added to the `Move.toml` file, the compiler will automatically fetch (and later
refetch) the dependencies when building the package.

> Starting with version 1.45 of the sui CLI, the system packages are automatically included as
> dependencies for all packages if they are not present in `Move.toml`. Therefore, `MoveStdlib`,
> `Sui`, `System`, `Bridge`, and `Deepbook` are all available without an explicit import.

## Importing a Module from Another Package

Normally, packages define their addresses in the `[addresses]` section. You can use aliases instead
of full addresses. For example, instead of using `0x2::coin` to reference the Sui `coin` module, you
can use `sui::coin`. The `sui` alias is defined in the Sui Framework package's manifest. Similarly,
the `std` alias is defined in the Standard Library package and can be used instead of `0x1` to
access standard library modules.

To import a module from another package, use the `use` keyword followed by the module path. The
module path consists of the package address (or alias) and the module name, separated by `::`.

```move file=packages/samples/sources/move-basics/importing-modules-external.move anchor=external

```

> Note: Module address names come from the `[addresses]` section of the manifest file (`Move.toml`),
> not the names used in the `[dependencies]` section.

>>>> move-book/book/move-basics/index.md
# Move Basics

This chapter is all about the basic syntax of the Move language. It covers the basics of the
language, such as types, modules, functions, and control flow. It focuses on the language without a
storage model or a blockchain, and explains the essential concepts of the language. To learn
features specific to Sui, such as storage functions and abilities, refer to the
[Using Objects](./../storage/) chapter, however, it is recommended to start with this chapter first.

<!-- TODO: cross link with Reference -->

>>>> move-book/book/move-basics/module.md
# Module

<!--

Chapter: Base Syntax
Goal: Introduce module keyword.
Notes:
    - modules are the base unit of code organization
    - module members are private by default
    - types internal to the module have special access rules
    - only module can pack and unpack its types

 -->

A module is the base unit of code organization in Move. Modules are used to group and isolate code,
and all members of the module are private to the module by default. In this section you will learn
how to define a module, declare its members, and access it from other modules.

## Module Declaration

Modules are declared using the `module` keyword followed by the package address, module name,
semicolon, and the module body. The module name should be in `snake_case` - all lowercase letters
with underscores between words. Modules names must be unique in the package.

Usually, a single file in the `sources/` folder contains a single module. The file name should match
the module name - for example, a `donut_shop` module should be stored in the `donut_shop.move` file.
You can read more about coding conventions in the
[Coding Conventions](./../guides/code-quality-checklist) section.

> If you need to declare more than one module in a file, you must use [Module Block](#module-block)
> syntax.

```move file=packages/samples/sources/move-basics/module-label.move anchor=module

```

Structs, functions, constants and imports all part of the module:

- [Structs](./struct)
- [Functions](./function)
- [Constants](./constants)
- [Imports](./importing-modules)
- [Struct Methods](./struct-methods)

## Address and Named Address

The module address can be specified as both: an address _literal_ (does not require the `@` prefix)
or a named address specified in the [Package Manifest](./../concepts/manifest). In the example
below, both are identical because there's a `book = "0x0"` record in the `[addresses]` section of
the `Move.toml`.

```move file=packages/samples/sources/move-basics/module.move anchor=address_literal

```

Addresses section in the Move.toml:

```toml
# Move.toml
[addresses]
book = "0x0"
```

## Module Members

Module members are declared inside the module body. To illustrate that, let's define a simple module
with a struct, a function and a constant:

```move file=packages/samples/sources/move-basics/module-members.move anchor=members

```

## Module Block

The pre-2024 edition of Move required the body of the module to be a _module block_ - the contents
of the module needed to be surrounded by curly braces `{}`. The main reason to use block syntax and
not _label_ syntax is if you need to define more than one module in a file. However, using module
blocks is not recommended practice.

```move file=packages/samples/sources/move-basics/module.move anchor=members

```

## Further Reading

- [Modules](./../../reference/modules) in the Move Reference.

>>>> move-book/book/move-basics/option.md
# Option

`Option` is a type that represents an optional value which may or may not exist. The concept of
`Option` in Move is borrowed from Rust, and it is a very useful primitive in Move. `Option` is
defined in the [Standard Library](./standard-library), and is defined as follows:

```move
module std::option;

/// Abstraction of a value that may or may not be present.
public struct Option<Element> has copy, drop, store {
    vec: vector<Element>
}
```

_See [full documentation for std::option][option-stdlib] module._

> The 'std::option' module is implicitly imported in every module, so you don't need to add an
> explicit import.

The `Option` type is a generic type with an `Element` type parameter. It contains a single field,
`vec`, which is a `vector` of `Element`. The vector can have a length of 0 or 1, representing the
absence or presence of a value, respectively.

> Note: You might be surprised that `Option` is a `struct` containing a `vector` instead of an
> [enum][enum-reference]. This is for historical reasons: `Option` was added to Move before it had
> support for enums.

The `Option` type has two variants: `Some` and `None`. The `Some` variant contains a value, while
the `None` variant represents the absence of a value. The `Option` type is used to represent the
absence of a value in a type-safe way, avoiding the need for empty or `undefined` values.

## In Practice

To showcase why the `Option` type is necessary, let's look at an example. Consider an application
which takes a user input and stores it in a variable. Some fields are required, and some are
optional. For example, a user's middle name is optional. While we could use an empty string to
represent the absence of a middle name, it would require extra checks to differentiate between an
empty string and a missing middle name. Instead, we can use the `Option` type to represent the
middle name.

```move file=packages/samples/sources/move-basics/option.move anchor=registry

```

In the previous example, the `middle_name` field is of type `Option<String>`. This means that the
`middle_name` field can either contain a String value, wrapped in Some, or be explicitly empty,
represented by None. Using the `Option` type makes the optional nature of the field clear, avoiding
ambiguity and the need for extra checks to differentiate between an empty string and a missing
middle name.

## Creating and Using Option values

The `Option` type, along with the `std::option` module, is implicitly imported in Move. This means
you can use the `Option` type directly without needing a `use` statement.

To create a value of the `Option` type, you can use the `option::some` or `option::none` methods.
`Option` values also support several operations (borrowing will be discussed in the
[references](references#references-1) chapter):

```move file=packages/samples/sources/move-basics/option.move anchor=usage

```

## Further Reading

- [std::option][option-stdlib] in the standard library

[enum-reference]: ./../../reference/enums
[option-stdlib]: https://docs.sui.io/references/framework/std/option

>>>> move-book/book/move-basics/ownership-and-scope.md
# Ownership and Scope

Every variable in Move has a scope and an owner. The scope is the range of code where the variable
is valid, and the owner is the scope that this variable belongs to. Once the owner scope ends, the
variable is dropped. This is a fundamental concept in Move, and it is important to understand how it
works.

<!--

- Borrow Checker
- Mention Rust's borrow checker
- Borrowing / References intro

-->

## Ownership

A variable defined in a function scope is owned by this scope. The runtime goes through the function
scope and executes every expression and statement. After the function scope ends, the variables
defined in it are dropped or deallocated.

```move
module book::ownership;

public fun owner() {
    let a = 1; // a is owned by the `owner` function
} // a is dropped here

public fun other() {
    let b = 2; // b is owned by the `other` function
} // b is dropped here

#[test]
fun test_owner() {
    owner();
    other();
    // a & b are not valid here
}
```

In the example above, the variable `a` is owned by the `owner` function, and the variable `b` is
owned by the `other` function. When each of these functions are called, the variables are defined,
and when the function ends, the variables are discarded.

## Returning a Value

If we changed the `owner` function to return the variable `a`, then the ownership of `a` would be
transferred to the caller of the function.

```move
module book::ownership;

public fun owner(): u8 {
    let a = 1; // a defined here
    a // scope ends, a is returned
}

#[test]
fun test_owner() {
    let a = owner();
    // a is valid here
} // a is dropped here
```

## Passing by Value

Additionally, if we passed the variable `a` to another function, the ownership of `a` would be
transferred to this function. When performing this operation, we _move_ the value from one scope to
another. This is also called _move semantics_.

```move
module book::ownership;

public fun owner(): u8 {
    let a = 10;
    a
} // a is returned

public fun take_ownership(v: u8) {
    // v is owned by `take_ownership`
} // v is dropped here

#[test]
fun test_owner() {
    let a = owner();
    // `u8` is copyable, pass `move a` when calling the function to force the transfer of its ownership
    take_ownership(move a);
    // a is not valid here
}
```

## Scopes with Blocks

Each function has a main scope, and it can also have sub-scopes via the use of blocks. A block is a
sequence of statements and expressions, and it has its own scope. Variables defined in a block are
owned by this block, and when the block ends, the variables are dropped.

```move
module book::ownership;

public fun owner() {
    let a = 1; // a is owned by the `owner` function's scope
    {
        let b = 2; // the block that declares b owns it
        {
            let c = 3; // the block that declares c owns it
        }; // c is dropped here
    }; // b is dropped here
    // a = b; // error: b is not valid here
    // a = c; // error: c is not valid here
} // a is dropped here
```

However, if we return a value from a block, the ownership of the variable is transferred to the
caller of the block.

```move
module book::ownership;

public fun owner(): u8 {
    let a = 1; // a is owned by the `owner` function's scope
    let b = {
        let c = 2; // the block that declares c owns it
        c // c is returned from the block and transferred to b
    };
    a + b // both a and b are valid here
}
```

## Copyable Types

Some types in Move are _copyable_, which means that they can be copied without transferring
ownership. This is useful for types that are small and cheap to copy, such as integers and booleans.
The Move compiler will automatically copy these types when they are passed to or returned from a
function, or when they're _moved_ to another scope and then accessed in their original scope.

## Further Reading

- [Local Variables and Scopes](./../../reference/variables) in the Move Reference.

>>>> move-book/book/move-basics/primitive-types.md
# Primitive Types

<!-- TODO: Shall we split this into two pages? Maybe give an overview and focus more on specifics? -->

For simple values, Move has a number of built-in primitive types. They're the foundation for all
other types. The primitive types are:

- [Booleans](#booleans)
- [Unsigned Integers](#integer-types)
- [Addresses](./address) - covered in the next section

Before we get to the primitive types, let's first take a look at how to declare and assign variables
in Move.

## Variables and Assignment

Variables are declared using the `let` keyword. They are immutable by default, but can be made
mutable by adding the `mut` keyword:

```
let <variable_name>[: <type>]  = <expression>;
let mut <variable_name>[: <type>] = <expression>;
```

Where:

- `<variable_name>` - the name of the variable
- `<type>` - the type of the variable, optional
- `<expression>` - the value to be assigned to the variable

```move file=packages/samples/sources/move-basics/primitive-types.move anchor=variables_and_assignment

```

A mutable variable can be reassigned using the `=` operator.

```move
y = 43;
```

Variables can also be shadowed by re-declaring them.

```move file=packages/samples/sources/move-basics/primitive-types.move anchor=shadowing

```

## Booleans

The `bool` type represents a boolean value - yes or no, true or false. It has two possible values:
`true` and `false`, which are keywords in Move. For booleans, the compiler can always infer the type
from the value, so there is no need to explicitly specify it.

```move file=packages/samples/sources/move-basics/primitive-types.move anchor=boolean

```

Booleans are often used to store flags and to control the flow of the program. Please refer to the
[Control Flow](./control-flow) section for more information.

## Integer Types

Move supports unsigned integers of various sizes, from 8-bit to 256-bit. The integer types are:

- `u8` - 8-bit
- `u16` - 16-bit
- `u32` - 32-bit
- `u64` - 64-bit
- `u128` - 128-bit
- `u256` - 256-bit

```move file=packages/samples/sources/move-basics/primitive-types.move anchor=integers

```

While boolean literals like `true` and `false` are clearly booleans, an integer literal like `42`
could be any of the integer types. In most of the cases, the compiler will infer the type from the
value, usually defaulting to `u64`. However, sometimes the compiler is unable to infer the type and
will require an explicit type annotation. It can either be provided during assignment or by using a
type suffix.

```move file=packages/samples/sources/move-basics/primitive-types.move anchor=integer_explicit_type

```

### Operations

Move supports the standard arithmetic operations for integers: addition, subtraction,
multiplication, division, and modulus (remainder). The syntax for these operations is:

| Syntax | Operation           | Aborts If                                |
| ------ | ------------------- | ---------------------------------------- |
| +      | addition            | Result is too large for the integer type |
| -      | subtraction         | Result is less than zero                 |
| \*     | multiplication      | Result is too large for the integer type |
| %      | modulus (remainder) | The divisor is 0                         |
| /      | truncating division | The divisor is 0                         |

> For more operations, including bitwise operations, please refer to the
> [Move Reference](./../../reference/primitive-types/integers#bitwise).

The types of the operands _must match_, or the compiler will raise an error. The result of the
operation will be of the same type as the operands. To perform operations on different types, the
operands need to be cast to the same type.

<!-- TODO: add examples + parentheses for arithmetic operations -->
<!-- TODO: add bitwise operators -->

### Casting with `as`

Move supports explicit casting between integer types. The syntax is as follows:

```move
<expression> as <type>
```

Note that parentheses around the expression may be required to prevent ambiguity:

```move file=packages/samples/sources/move-basics/primitive-types.move anchor=cast_as

```

A more complex example, preventing overflow:

```move file=packages/samples/sources/move-basics/primitive-types.move anchor=overflow

```

### Overflow

Move does not support overflow / underflow; an operation that results in a value outside the range
of the type will raise a runtime error. This is a safety feature to prevent unexpected behavior.

```move
let x = 255u8;
let y = 1u8;

// This will raise an error
let z = x + y;
```

## Further Reading

- [Bool](./../../reference/primitive-types/bool) in the Move Reference.
- [Integer](./../../reference/primitive-types/integers) in the Move Reference.

>>>> move-book/book/move-basics/references.md
# References

<!--

Chapter: Basic Syntax
Goal: Show what the borrow checker is and how it works.
Notes:
    - give the metro pass example
    - show why passing by reference is useful
    - mention that reference comparison is faster
    - references can be both mutable and immutable
    - immutable access to shared objects is faster
    - implicit copy
    - moving the value
    - unpacking a reference (mutable and immutable)

 -->

In the [Ownership and Scope](./ownership-and-scope) section, we explained that when a value is
passed to a function, it is _moved_ to the function's scope. This means that the function becomes
the owner of the value, and the original scope (owner) can no longer use it. This is an important
concept in Move, as it ensures that the value is not used in multiple places at the same time.
However, there are use cases when we want to pass a value to a function but retain ownership. This
is where references come into play.

To illustrate this, let's consider a simple example - an application for a metro (subway) pass. We
will look at 4 different scenarios where a card can be:

1. Purchased at a kiosk for a fixed price
2. Shown to an inspector to prove that the passenger has a valid pass
3. Used at the turnstile to enter the metro, and purchase a ride
4. Recycled after it's empty

## Layout

The initial layout of the metro pass application is simple. We define the `Card` type and the `USES`
[constant](./constants) that represents the number of rides on a single card. We also add
[error constants](./assert-and-abort#error-constants) for the case when the card is empty and when the card is not empty.

```move file=packages/samples/sources/move-basics/references.move anchor=header_new
module book::metro_pass;


```

<!-- In [the previous section](./ownership-and-scope) we explained the ownership and scope in Move. We showed how the value is *moved* to a new scope, and how it changes the owner. In this section, we will explain how to *borrow* a reference to a value to avoid moving it, and how Move's *borrow checker* ensures that the references are used correctly. -->

## References

References are a way to _show_ a value to a function without giving up ownership. In our case, when
we show the Card to the inspector, we don't want to give up ownership of it, and we don't allow the
inspector to use up any of our rides. We just want to allow the _reading_ of the value of our Card
and to prove its ownership.

To do so, in the function signature, we use the `&` symbol to indicate that we are passing a
_reference_ to the value, not the value itself.

```move file=packages/samples/sources/move-basics/references.move anchor=immutable

```

Because the function does not take ownership of the Card, it can _read_ its data but cannot _write_
to it, meaning it cannot modify the number of rides. Additionally, the function signature ensures
that it cannot be called without a Card instance. This is an important property that allows the
[Capability Pattern](./../programmability/capability), which we will cover in the next chapters.

Creating a reference to a value is often referred to as "borrowing" the value. For example, the
method to get a reference to the value wrapped by an `Option` is called `borrow`.

## Mutable Reference

In some cases, we want to allow the function to modify the Card. For example, when using the Card at
a turnstile, we need to deduct a ride. To achieve this, we use the `&mut` keyword in the function
signature.

```move file=packages/samples/sources/move-basics/references.move anchor=mutable

```

As you can see in the function body, the `&mut` reference allows mutating the value, and the
function can spend rides.

## Passing by Value

Lastly, let's illustrate what happens when we pass the value itself to the function. In this case,
the function takes the ownership of the value, making it inaccessible in the original scope. The
owner of the Card can recycle it and thereby relinquish ownership to the function.

```move file=packages/samples/sources/move-basics/references.move anchor=move

```

In the `recycle` function, the Card is passed by value, transferring ownership to the function. This
allows it to be unpacked and destroyed.

> Note: In Move, `_` is a wildcard pattern used in destructuring to ignore a field while still
> consuming the value. Destructuring must match all fields in a struct type. If a struct has fields,
> you must list all of them explicitly or use `_` to ignore unwanted fields.

## Full Example

To illustrate the full flow of the application, let's put all the pieces together in a test.

```move file=packages/samples/sources/move-basics/references.move anchor=move_2024

```

## Further Reading

- [References](/reference/primitive-types/references) in the Move
  Reference.

<!-- ## Dereference and Copy -->

<!-- TODO: defer and copy, *& -->

<!-- ## Notes -->

<!--
    Move 2024 is great but it's better to show the example with explicit &t and &mut t
    ...and then say that the example could be rewritten with the new syntax


-->

<!-- ## Move 2024

Here's the test from this page written with the Move 2024 syntax:

```move file=packages/samples/sources/move-basics/references.move anchor=move_2024
```
-->

>>>> move-book/book/move-basics/standard-library.md
# Standard Library

<!-- The Move standard library provides a set of modules  -->

The Move Standard Library provides functionality for native types and operations. It is a standard
collection of modules that do not interact with storage, but provide basic tools for working with
and manipulating data. It is the only dependency of the
[Sui Framework](./../programmability/sui-framework), and is imported together with it.

## Most Common Modules

In this book we go into detail about most of the modules in the Standard Library, however, it is
also helpful to give an overview of the features, so that you can get a sense of what is available
and which module implements it.

<!-- Custom CSS addition in the theme/custom.css  -->
<div class="modules-table">

| Module                                                                           | Description                                                                | Chapter                              |
| -------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | ------------------------------------ |
| [std::string](https://docs.sui.io/references/framework/std/string)               | Provides basic string operations                                           | [String](./string)                   |
| [std::ascii](https://docs.sui.io/references/framework/std/ascii)                 | Provides basic ASCII operations                                            | -                                    |
| [std::option](https://docs.sui.io/references/framework/std/option)               | Implements `Option<T>`                                                     | [Option](./option)                   |
| [std::vector](https://docs.sui.io/references/framework/std/vector)               | Native operations on the vector type                                       | [Vector](./vector)                   |
| [std::bcs](https://docs.sui.io/references/framework/std/bcs)                     | Contains the `bcs::to_bytes()` function                                    | [BCS](./../programmability/bcs)      |
| [std::address](https://docs.sui.io/references/framework/std/address)             | Contains a single `address::length` function                               | [Address](./address)                 |
| [std::type_name](https://docs.sui.io/references/framework/std/type_name)         | Allows runtime _type reflection_                                           | [Type Reflection](./type-reflection) |
| [std::hash](https://docs.sui.io/references/framework/std/hash)                   | Hashing functions: `sha2_256` and `sha3_256`                               | -                                    |
| [std::debug](https://docs.sui.io/references/framework/std/debug)                 | Contains debugging functions, which are available in only in **test** mode | -                                    |
| [std::bit_vector](https://docs.sui.io/references/framework/std/bit_vector)       | Provides operations on bit vectors                                         | -                                    |
| [std::fixed_point32](https://docs.sui.io/references/framework/std/fixed_point32) | Provides the `FixedPoint32` type                                           | -                                    |

</div>

## Integer Modules

The Move Standard Library provides a set of functions associated with integer types. These functions
are split into multiple modules, each associated with a specific integer type. The modules should
not be imported directly, as their functions are available on every integer value.

> All of the modules provide the same set of functions. Namely, `max`, `diff`,
> `divide_and_round_up`, `sqrt` and `pow`.

<!-- Custom CSS addition in the theme/custom.css  -->
<div class="modules-table">

| Module                                                         | Description                   |
| -------------------------------------------------------------- | ----------------------------- |
| [std::u8](https://docs.sui.io/references/framework/std/u8)     | Functions for the `u8` type   |
| [std::u16](https://docs.sui.io/references/framework/std/u16)   | Functions for the `u16` type  |
| [std::u32](https://docs.sui.io/references/framework/std/u32)   | Functions for the `u32` type  |
| [std::u64](https://docs.sui.io/references/framework/std/u64)   | Functions for the `u64` type  |
| [std::u128](https://docs.sui.io/references/framework/std/u128) | Functions for the `u128` type |
| [std::u256](https://docs.sui.io/references/framework/std/u256) | Functions for the `u256` type |

</div>

## Exported Addresses

The Standard Library exports a single named address - `std = 0x1`. Note the alias `std` is defined
here.

```toml
[addresses]
std = "0x1"
```

## Implicit Imports

Some modules are imported implicitly and are available in the module without the explicit `use`
import. For the Standard Library, these modules and types include:

- std::vector
- std::option
- std::option::Option

## Importing std without Sui Framework

The Move Standard Library can be imported to the package directly. However, `std` alone is not
enough to build a meaningful application, as it does not provide any storage capabilities and can't
interact with the on-chain state.

```toml
MoveStdlib = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/move-stdlib", rev = "framework/mainnet" }
```

## Source Code

The source code of the Move Standard Library is available in the
[Sui repository](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/move-stdlib/sources).

>>>> move-book/book/move-basics/string.md
# String

While Move does not have a built-in type to represent strings, it does have two standard
implementations for strings in the [Standard Library](./standard-library). The `std::string` module
defines a `String` type and methods for UTF-8 encoded strings, and the second module, `std::ascii`,
provides an ASCII `String` type and its methods.

> The Sui execution environment automatically converts bytevector into `String` in transaction
> inputs. As a result, in many cases, constructing a String directly within the
> [Transaction Block](./../concepts/what-is-a-transaction) is unnecessary.

<!--

## Bytestring Literal

TODO:

- reference vector
- reference literals - [Expression](./expression#literals)

-->

## Strings are bytes

No matter which type of string you use, it is important to know that strings are just bytes. The
wrappers provided by the `string` and `ascii` modules are just that: wrappers. They do provide
safety checks and methods to work with strings, but at the end of the day, they are just vectors of
bytes.

```move file=packages/samples/sources/move-basics/string.move anchor=custom

```

## Working with UTF-8 Strings

While there are two types of strings (`string` and `ascii`) in the standard library, the `string`
module should be considered the default. It has native implementations of many common operations,
leveraging low-level, optimized runtime code for superior performance. In contrast, the `ascii`
module is fully implemented in Move, relying on higher-level abstractions and making it less
suitable for performance-critical tasks.

### Definition

The `String` type in the `std::string` module is defined as follows:

```move
module std::string;

/// A `String` holds a sequence of bytes which is guaranteed to be in utf8 format.
public struct String has copy, drop, store {
    bytes: vector<u8>,
}
```

_See [full documentation for std::string][string-stdlib] module._

### Creating a String

To create a new UTF-8 `String` instance, you can use the `string::utf8` method. The
[Standard Library](./standard-library) provides an alias `.to_string()` on the `vector<u8>` for
convenience.

```move file=packages/samples/sources/move-basics/string.move anchor=utf8

```

### Common Operations

UTF8 String provides a number of methods to work with strings. The most common operations on strings
are: concatenation, slicing, and getting the length. Additionally, for custom string operations, the
`bytes()` method can be used to get the underlying byte vector.

```move
let mut str = b"Hello,".to_string();
let another = b" World!".to_string();

// append(String) adds the content to the end of the string
str.append(another);

// `sub_string(start, end)` copies a slice of the string
str.sub_string(0, 5); // "Hello"

// `length()` returns the number of bytes in the string
str.length(); // 12 (bytes)

// methods can also be chained! Get a length of a substring
str.sub_string(0, 5).length(); // 5 (bytes)

// whether the string is empty
str.is_empty(); // false

// get the underlying byte vector for custom operations
let bytes: &vector<u8> = str.bytes();
```

### Safe UTF-8 Operations

The default `utf8` method may abort if the bytes passed into it are not valid UTF-8. If you are not
sure that the bytes you are passing are valid, you should use the `try_utf8` method instead. It
returns an `Option<String>`, which contains no value if the bytes are not valid UTF-8, and a string
otherwise.

> Hint: Functions with names starting with `try_*` typically return an `Option`. If the operation
> succeeds, the result is wrapped in `Some`. If it fails, the function returns `None`. This naming
> convention, commonly used in Move, is inspired by Rust.

```move file=packages/samples/sources/move-basics/string.move anchor=safe_utf8

```

### UTF-8 Limitations

The `string` module does not provide a way to access individual characters in a string. This is
because UTF-8 is a variable-length encoding, and the length of a character can be anywhere from 1 to
4 bytes. Similarly, the `length()` method returns the number of bytes in the string, not the number
of characters.

However, methods like `sub_string` and `insert` validate character boundaries and abort if the
specified index falls within the middle of a character.

## ASCII Strings

This section is coming soon!

## Further Reading

- [std::string][string-stdlib] module documentation.
- [std::ascii][ascii-stdlib] module documentation.

[enum-reference]: /reference/enums.html
[string-stdlib]: https://docs.sui.io/references/framework/std/string
[ascii-stdlib]: https://docs.sui.io/references/framework/std/ascii

>>>> move-book/book/move-basics/struct-methods.md
# Struct Methods

Move Compiler supports _receiver syntax_ `e.f()`, which allows defining methods which can be called
on instances of a struct. The term "receiver" specifically refers to the instance that receives the
method call. This is like the method syntax in other programming languages. It is a convenient way
to define functions that operate on the fields of a struct, providing direct access to the struct's
fields and creating cleaner, more intuitive code than passing the struct as a parameter.

## Method syntax

If the first argument of a function is a struct internal to the module that defines the function,
then the function can be called using the `.` operator. However, if the type of the first argument
is defined in another module, then method won't be associated with the struct by default. In this
case, the `.` operator syntax is not available, and the function must be called using standard
function call syntax.

When a module is imported, its methods are automatically associated with the struct.

```move file=packages/samples/sources/move-basics/struct-methods.move anchor=hero

```

## Method Aliases

Method aliases help avoid name conflicts when modules define multiple structs and their methods.
They can also provide more descriptive method names for structs.

Here's the syntax:

```move
// for local method association
use fun function_path as Type.method_name;

// exported alias
public use fun function_path as Type.method_name;
```

> Public aliases are only allowed for structs defined in the same module. For structs defined in
> other modules, aliases can still be created but cannot be made public.

In the example below, we changed the `hero` module and added another type - `Villain`. Both `Hero`
and `Villain` have similar field names and methods. To avoid name conflicts, we prefixed methods
with `hero_` and `villain_` respectively. However, using aliases allows these methods to be called
on struct instances without the prefix:

```move file=packages/samples/sources/move-basics/struct-methods-2.move anchor=hero_and_villain

```

In the test function, the `health` method is called directly on the `Hero` and `Villain` instances
without the prefix, as the compiler automatically associates the methods with their respective
structs.

> Note: In the test function, `hero.health()` is calling the aliased method, not directly accessing
> the private `health` field. While the `Hero` and `Villain` structs are public, their fields remain
> private to the module. The method call `hero.health()` uses the public alias defined by
> `public use fun hero_health as Hero.health`, which provides controlled access to the private
> field.

<!-- ## Aliasing an external module's method

It is also possible to associate a function defined in another module with a struct from the current
module. Following the same approach, we can create an alias for the method defined in another
module. Let's use the `bcs::to_bytes` method from the [Standard Library](./standard-library) and
associate it with the `Hero` struct. It will allow serializing the `Hero` struct to a vector of
bytes.

```move file=packages/samples/sources/move-basics/struct-methods-3.move anchor=hero_to_bytes
``` -->

## Further Reading

- [Method Syntax](./../../reference/method-syntax) in the Move Reference.

>>>> move-book/book/move-basics/struct.md
# Custom Types with Struct

Move's type system shines when it comes to defining custom types. User defined types can be custom
tailored to the specific needs of the application, not only on the data level, but also in its
behavior. In this section we introduce the struct definition and how to use it.

## Struct

To define a custom type, you can use the `struct` keyword followed by the name of the type. After
the name, you can define the fields of the struct. Each field is defined with the
`field_name: field_type` syntax. Field definitions must be separated by commas. The fields can be of
any type, including other structs.

> Move does not support recursive structs, meaning a struct cannot contain itself as a field.

```move file=packages/samples/sources/move-basics/struct.move anchor=def

```

In the example above, we define a `Record` struct with five fields. The `title` field is of type
`String`, the `artist` field is of type `Artist`, the `year` field is of type `u16`, the `is_debut`
field is of type `bool`, and the `edition` field is of type `Option<u16>`. The `edition` field is of
type `Option<u16>` to represent that the edition is optional.

Structs are private by default, meaning they cannot be imported and used outside of the module they
are defined in. Their fields are also private and can't be accessed from outside the module. See
[visibility](./visibility) for more information on different visibility modifiers.

> Fields of a struct are private and can only be accessed by the module defining the struct. Reading
> and writing the fields of a struct in other modules is only possible if the module defining the
> struct provides public functions to access the fields.

## Create and use an instance

We described the _definition_ of a struct. Now let's see how to initialize a struct and use it. A
struct can be initialized using the `struct_name { field1: value1, field2: value2, ... }` syntax.
The fields can be initialized in any order, and all of the required fields must be set.

```move file=packages/samples/sources/move-basics/struct.move anchor=pack

```

In the example above, we create an instance of the `Artist` struct and set the `name` field to a
string "The Beatles".

To access the fields of a struct, you can use the `.` operator followed by the field name.

```move file=packages/samples/sources/move-basics/struct.move anchor=access

```

Only the module defining the struct can access its fields (both mutably and immutably). So the above
code should be in the same module as the `Artist` struct.

<!-- ## Accessing Fields

Struct fields are private and can be accessed only by the module defining the struct. To access the fields of a struct, you can use the `.` operator followed by the field name.

```move
# anchor: access file=packages/samples/sources/move-basics/struct.move anchor=access
```
-->

## Unpacking a struct

Structs are non-discardable by default, meaning that the initialized struct value must be used,
either by storing it or unpacking it. Unpacking a struct means deconstructing it into its fields.
This is done using the `let` keyword followed by the struct name and the field names.

```move file=packages/samples/sources/move-basics/struct.move anchor=unpack

```

In the example above we unpack the `Artist` struct and create a new variable `name` with the value
of the `name` field. Because the variable is not used, the compiler will raise a warning. To
suppress the warning, you can use the underscore `_` to indicate that the variable is intentionally
unused.

```move file=packages/samples/sources/move-basics/struct.move anchor=unpack_ignore

```

## Further Reading

- [Structs](./../../reference/structs) in the Move Reference.

>>>> move-book/book/move-basics/testing.md
# Testing

Testing is a crucial aspect of software development, especially in blockchain applications where
security and correctness are paramount. In this section, we will cover the fundamentals of testing
in Move, including how to write and organize tests effectively.

## The `#[test]` Attribute

Tests in Move are functions marked with the `#[test]` attribute. This attribute tells the compiler
that the function is a test function and should be run when tests are executed. Test functions are
regular functions, but they must take no arguments and have no return value. They are excluded from
the bytecode and are never published.

```move
module book::testing;

#[test_only]
use std::unit_test::assert_eq;

// The test attribute is placed before the `fun` keyword (can be both above or
// right before the `fun` keyword, as in `#[test] fun my_test() { ... }`)
// The name of the test in this case would be `book::testing::simple_test`.
#[test]
fun simple_test() {
    let sum = 2 + 2;
    assert_eq!(sum, 4);
}

// The name of this test would be `book::testing::more_advanced_test`.
#[test] fun more_advanced_test() {
    let sum = 2 + 2 + 2;
    assert_eq!(sum, 4);
}
```

## Running Tests

To run tests, you can use the `sui move test` command. This command will first build the package in
_test mode_ and then run all tests found in the package. In test mode, modules from both `sources/`
and `tests/` directories are processed and their tests executed.

```bash
$ sui move test
> UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
> INCLUDING DEPENDENCY Bridge
> INCLUDING DEPENDENCY DeepBook
> INCLUDING DEPENDENCY SuiSystem
> INCLUDING DEPENDENCY Sui
> INCLUDING DEPENDENCY MoveStdlib
> BUILDING book
> Running Move unit tests
> ...
```

<!-- TODO: fill output -->

## Test Fail Cases with `#[expected_failure]`

Tests for fail cases can be marked with `#[expected_failure]`. This attribute, when added to a
`#[test]` function, tells the compiler that the test is expected to fail. This is useful when you
want to test that a function fails when a certain condition is met.

> Note: This attribute can only be added to a `#[test]` function.

The attribute can take an argument specifying the expected abort code that should be returned if the
test fails. If the test returns an abort code different from the one specified in the argument, it
will fail. Likewise, if execution does not result in an abort, the test will also fail.

```move
module book::testing_failure;

const EInvalidArgument: u64 = 1;

#[test]
#[expected_failure(abort_code = 0)]
fun test_fail() {
    abort 0 // aborts with code 0
}

// attributes can be grouped together
#[test, expected_failure(abort_code = EInvalidArgument)]
fun test_fail_1() {
    abort EInvalidArgument // aborts with code EInvalidArgument
}
```

The `abort_code` argument can use constants defined in the tests module as well as imported from
other modules. This is the only case where constants can be used and "accessed" in other modules.

## Utilities with `#[test_only]`

In some cases, it is helpful to give the test environment access to some internal functions or
features. This simplifies the testing process and allows for more thorough testing. However, it is
important to remember that these functions should not be included in the final package. This is
where the `#[test_only]` attribute comes in handy.

```move
module book::testing;

#[test_only]
use std::unit_test::assert_eq;

// Public function which uses the `secret` function.
public fun multiply_by_secret(x: u64): u64 {
    x * secret()
}

/// Private function which is not available to the public.
fun secret(): u64 { 100 }

#[test_only]
/// This function is only available for testing purposes in tests and other
/// test-only functions. Mind the visibility - for `#[test_only]` it is
/// common to use `public` visibility.
public fun secret_for_testing(): u64 {
    secret()
}

#[test]
// In the test environment we have access to the `secret_for_testing` function.
fun test_multiply_by_secret() {
    let expected = secret_for_testing() * 2;
    assert_eq!(multiply_by_secret(2), expected);
}
```

Functions marked with the `#[test_only]` will be available to the test environment, and to the other
modules if their visibility is set to `public`.

## Further Reading

- [Unit Testing](/reference/unit-testing) in the Move Reference.

>>>> move-book/book/move-basics/type-reflection.md
# Type Reflection

In programming languages, _reflection_ is the ability of a program to examine and modify its own
structure and behavior. Move supports a limited form of reflection that lets you inspect the type of
a value at runtime. This is handy when you need to store type information in a homogeneous
collection, or when you want to check if a type comes from a particular package.

Type reflection is implemented in the [Standard Library](./standard-library) module
[`std::type_name`][type-name-stdlib]. It provides a set of functions, main of which are
`with_defining_ids` and `with_original_ids`.

```move
let defining_type_name: TypeName = type_name::with_defining_ids<T>();
let original_type_name: TypeName = type_name::with_original_ids<T>();

// Returns only "ID" of the package.
let defining_package: address = type_name::defining_id<T>();
let original_package: address = type_name::original_id<T>();
```

## Defining IDs vs. Original IDs

It is important to understand the difference between _defining ID_ and _original ID_.

- Original ID is the first published ID of the package (before the first upgrade).
- Defining ID is the package ID which introduced the reflected type, this property becomes crucial
  when new types are introduced in package upgrades.

For example, suppose the first version of a package was published at `0xA` and introduced the type
`Version1`. Later, in an upgrade, the package moved to address `0xB` and introduced a new type
`Version2`. For `Version1`, the defining ID and original ID are the same. For `Version2`, however,
they differ: the original ID is `0xA`, while the defining ID is `0xB`.

```move
// Note: values `0xA` and `0xB` are used for illustration purposes only!
// Don't attempt to run this code, as it will inevitably fail.
module book::upgrade;

// Introduced in initial version.
// Defining ID: 0xA
// Original ID: 0xA
//
// With Defining IDs: 0xA::upgrade::Version1
// With Original IDs: 0xA::upgrade::Version1
public struct Version1 has drop {}

// Introduced in a package upgrade.
// Defining ID: 0xB
// highlight-important
// Original ID: 0xA
//
// With Defining IDs: 0xB::upgrade::Version2
// highlight-important
// With Original IDs: 0xA::upgrade::Version2
public struct Version2 has drop {}
```

## In practice

The module is straightforward, and operations allowed on the result are limited to getting a string
representation and extracting the module and address of the type.

```move file=packages/samples/sources/move-basics/type-reflection.move anchor=main

```

## Further Reading

- [std::type_name][type-name-stdlib] module documentation.

[type-name-stdlib]: https://docs.sui.io/references/framework/std/type_name

>>>> move-book/book/move-basics/vector.md
# Vector

Vectors are a native way to store collections of elements in Move. They are similar to arrays in
other programming languages, but with a few differences. In this section, we introduce the `vector`
type and its operations.

## Vector syntax

The `vector` type is written using the `vector` keyword followed by the type of the elements in
angle brackets. The type of the elements can be any valid Move type, including other vectors.

Move has a vector literal syntax that allows you to create vectors using the `vector` keyword
followed by square brackets containing the elements (or no elements for an empty vector).

```move file=packages/samples/sources/move-basics/vector.move anchor=literal

```

The `vector` type is a built-in type in Move, and does not need to be imported from a module.
Vector operations are defined in the `std::vector` module, which is implicitly imported
and can be used directly without explicit `use` import.

## Vector operations

The standard library provides methods to manipulate vectors. The following are some of the most
commonly used operations:

- `push_back`: Adds an element to the end of the vector.
- `pop_back`: Removes the last element from the vector.
- `length`: Returns the number of elements in the vector.
- `is_empty`: Returns true if the vector is empty.
- `remove`: Removes an element at a given index.

```move file=packages/samples/sources/move-basics/vector.move anchor=methods

```

## Destroying a Vector of non-droppable types

A vector of non-droppable types cannot be discarded. If you define a vector of types without the
`drop` ability, the vector value cannot be ignored. If the vector is empty, the compiler requires an
explicit call to the `destroy_empty` function.

```move file=packages/samples/sources/move-basics/vector.move anchor=no_drop

```

The `destroy_empty` function will fail at runtime if you call it on a non-empty vector.

## Further Reading

- [Vector](./../../reference/primitive-types/vector) in the Move Reference.
- [std::vector](https://docs.sui.io/references/framework/std/vector) module documentation.

>>>> move-book/book/move-basics/visibility.md
# Visibility Modifiers

Every module member has a visibility. By default, all module members are _private_ - meaning they
are only accessible within the module they are defined in. However, you can add a visibility
modifier to make a module member _public_ - visible outside the module, or _public(package)_ -
visible in the modules within the same package, or _entry_ - can be called from a transaction but
can't be called from other modules.

## Internal Visibility

A function or a struct defined in a module which has no visibility modifier is _private_ to the
module. It can't be called from other modules.

```move
module book::internal_visibility;

// This function can be called from other functions in the same module
fun internal() { /* ... */ }

// Same module -> can call internal()
fun call_internal() {
    internal();
}
```

The following code will not compile:

<!-- TODO: add failure flag to example -->

```move
module book::try_calling_internal;

use book::internal_visibility;

// Different module -> can't call internal()
fun try_calling_internal() {
    internal_visibility::internal();
}
```

Note that just because a struct field is not visible from Move does not mean that its value is kept
confidential &mdash; it is always possible to read the contents of an on-chain object from outside
of Move. You should never store unencrypted secrets inside of objects.

## Public Visibility

A struct or a function can be made _public_ by adding the `public` keyword before the `fun` or
`struct` keyword.

```move
module book::public_visibility;

// This function can be called from other modules
public fun public_fun() { /* ... */ }
```

A public function can be imported and called from other modules. The following code will compile:

```move
module book::try_calling_public;

use book::public_visibility;

// Different module -> can call public_fun()
fun try_calling_public() {
    public_visibility::public_fun();
}
```

Unlike some languages, struct fields cannot be made public.

## Package Visibility

A function with _package_ visibility can be called from any module within the same package, but not
from modules in other packages. In other words, it is _internal_ to the package.

```move
module book::package_visibility;

public(package) fun package_only() { /* ... */ }
```

A package function can be called from any module within the same package:

```move
module book::try_calling_package;

use book::package_visibility;

// Same package `book` -> can call package_only()
fun try_calling_package() {
    package_visibility::package_only();
}
```

## Native Functions

Some functions in the [framework](./../programmability/sui-framework) and
[standard library](./standard-library) are marked with the `native` modifier. These functions are
natively provided by the Move VM and do not have a body in Move source code. To learn more about the
native modifier, refer to the
[Move Reference](./../../reference/functions?highlight=native#native-functions).

```move
module std::type_name;

public native fun get<T>(): TypeName;
```

This is an example from `std::type_name`, learn more about this module in the
[reflection chapter](./type-reflection).

## Further Reading

- [Visibility](./../../reference/functions#visibility) in the Move Reference.

>>>> move-book/book/object/digital-assets.md
# Move - Language for Digital Assets

Smart-contract programming languages have historically focused on defining and managing digital
assets. For example, the ERC-20 standard in Ethereum pioneered a set of standards to interact with
digital currency tokens, establishing a blueprint for creating and managing digital currencies on
the blockchain. Subsequently, the introduction of the ERC-721 standard marked a significant
evolution, popularizing the concept of non-fungible tokens (NFTs), which represent unique,
indivisible assets. These standards laid the groundwork for the complex digital assets we see today.

<!-- ## Move and Digital Assets -->

<!-- note: consider "native" -> "fine-grained" -->

However, Ethereum's programming model lacked a native representation of assets. In other words,
externally, a Smart Contract behaved like an asset, but the language itself did not have a way to
inherently represent assets. From the start, Move aimed to provide a first-class abstraction for
assets, opening up new avenues for thinking about and programming assets.

<!-- Move was initially created in 2018 as part of the Libra project. The language was designed to address shortcomings in existing smart contract languages, especially in handling assets and access control. The Move language aims to provide first-class abstractions for these concepts, improving the safety and productivity of smart contract programming. -->

It is important to highlight which properties are essential for an asset:

- **Ownership:** Every asset is associated with an owner(s), mirroring the straightforward concept
  of ownership in the physical world—just as you own a car, you can own a digital asset. Move
  enforces ownership in such a way that once an asset is _moved_, the previous owner completely
  loses any control over it. This mechanism ensures a clear and secure change of ownership.

- **Non-copyable:** In the real world, unique items cannot be duplicated effortlessly. Move applies
  this principle to digital assets, ensuring they cannot be arbitrarily copied within the program.
  This property is crucial for maintaining the scarcity and uniqueness of digital assets, mirroring
  the intrinsic value of physical assets.

- **Non-discardable:** Just as you cannot accidentally lose a house or a car without a trace, Move
  ensures that no asset can be discarded or lost in a program. Instead, assets must be explicitly
  transferred or destroyed. This property guarantees the deliberate handling of digital assets,
  preventing accidental loss and ensuring accountability in asset management.

Move managed to encapsulate these properties in its design, becoming an ideal language for digital
assets.

## Summary

- Move was designed to provide a first-class abstraction for digital assets, enabling developers to
  create and manage assets natively.
- Essential properties of digital assets include ownership, non-copyability, and non-discardability,
  which Move enforces in its design.
- Move's asset model mirrors real-world asset management, ensuring secure and accountable asset
  ownership and transfer.

## Further Reading

- [Move: A Language With Programmable Resources (pdf)](https://developers.diem.com/papers/diem-move-a-language-with-programmable-resources/2019-06-18.pdf)
  by Sam Blackshear, Evan Cheng, David L. Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott,
  Shaz Qadeer, Rain, Dario Russi, Stephane Sezer, Tim Zakian, Runtian Zhou\*

>>>> move-book/book/object/evolution-of-move.md
# Evolution of Move

While Move was created to manage digital assets, its initial storage model was bulky and not
well-suited for many use cases. For instance, if Alice wanted to transfer an asset X to Bob, Bob had
to create a new "empty" resource, and then Alice could transfer asset X to Bob. This process was not
intuitive and presented implementation challenges, partly due to the restrictive design of
[Diem](https://www.diem.com/en-us). Another drawback of the original design was the lack of built-in
support for a "transfer" operation, requiring every module to implement its own storage transfer
logic. Additionally, managing heterogeneous collections of assets in a single account was
particularly challenging.

Sui addressed these challenges by redesigning the storage and ownership model of objects to more
closely resemble real-world object interactions. With a native concept of ownership and _transfer_,
Alice can directly transfer asset X to Bob. Furthermore, Bob can maintain a collection of different
assets without any preparatory steps. These improvements laid the foundation for the Object Model in
Sui.

## Summary

- Move's initial storage model was not well-suited for managing digital assets, requiring complex
  and restrictive transfer operations.
- Sui introduced the Object Model, which provides a native concept of ownership, simplifying asset
  management and enabling heterogeneous collections.

## Further Reading

- [Why We Created Sui Move](https://blog.sui.io/why-we-created-sui-move/) by Sam Blackshear

>>>> move-book/book/object/fast-path-and-consensus.md
# Fast Path & Consensus

The Object Model allows for variable transaction execution paths, depending on the object's
ownership type. The transaction execution path determines how the transaction is processed and
validated by the network. In this section, we'll explore the different transaction execution paths
in Sui and how they interact with the consensus mechanism.

## Concurrency Challenge

At its core, blockchain technology faces a fundamental concurrency challenge: multiple parties may
try to modify or access the same data simultaneously in a decentralized environment. This requires a
system for sequencing and validating transactions to support the network's consistency. Sui
addresses this challenge through a consensus mechanism, ensuring all nodes agree on the
transactions' sequence and state.

Consider a marketplace scenario where Alice and Bob simultaneously attempt to purchase the same
asset. The network must resolve this conflict to prevent double-spending, ensuring that at most one
transaction succeeds while the other is rightfully rejected.

## Fast Path

However, not all transactions require the same level of validation and consensus. For example, if
Alice wants to transfer an object that she owns to Bob, the network can process this transaction
without sequencing it with respect to all other transactions in the network, as only Alice has the
authority to access the object. This is known as the _fast path_ execution, where transactions
accessing account-owned objects are processed quickly without the need for extensive consensus. No
concurrent data access -> simpler challenge -> fast path.

Another ownership model that allows for fast path execution is the _immutable state_. Since
immutable objects cannot change, transactions involving them can be processed quickly without the
need to sequence them.

## Consensus Path

Transactions that do access shared state - on Sui it is represented with shared objects - require
sequencing to ensure that the state is updated and consistent across all nodes. This is known as the
execution through _consensus_, where transactions accessing shared objects are subject to the
agreement process to maintain network consistency.

<!-- On Sui consensus is per-object - mention!!! -->

## Objects owned by Objects

Lastly, it is important to mention that objects owned by other objects are subject to the same rules
as the parent object. If the parent object is _shared_, the child object is also transitively
shared. If the parent object is immutable, the child object is also immutable.

## Summary

- **Fast Path:** Transactions involving account-owned objects or immutable shared state are
  processed quickly without the need for extensive consensus.
- **Consensus Path:** Transactions involving shared objects require sequencing and consensus to
  ensure network integrity.
- **Objects owned by Objects:** Child objects inherit the ownership model of the parent object.

>>>> move-book/book/object/index.md
# Object Model

This chapter describes the Object Model of Sui. It focuses on the theory and concepts behind the
Object Model, preparing you for a practical dive into Sui Storage operations and resource ownership.
For convenience and easier lookup, we split the chapter into several sections, each covering a
specific aspect of the Object Model.

<div class="warning">

In no way should this chapter be considered a comprehensive guide to the Object Model. It is only a
high-level overview of the concepts and principles behind the Object Model.

For a more detailed description, refer to the
[Sui Documentation](https://docs.sui.io/concepts/object-model).

</div>

>>>> move-book/book/object/object-model.md
# What is an Object?

The Object Model in Sui can be viewed as a high-level abstraction representing digital assets as
_objects_. These objects have their own type and associated behaviors, a unique identifier, and
support native storage operations like _transfer_ and _share_. Designed to be intuitive and easy to
use, the Object Model enables a wide range of use cases to be implemented with ease.

Objects in Sui have the following properties:

- **Type:** Every object has a type, defining the structure and behavior of the object. Objects of
  different types cannot be mixed or used interchangeably, ensuring objects are used correctly
  according to their type system.

- **Unique ID:** Each object has a unique identifier, distinguishing it from other objects. This ID
  is generated upon the object's creation and is immutable. It's used to track and identify objects
  within the system.

<!-- Note: consider "shared across many entities" -->

- **Owner:** Every object is associated with an owner, who has control over changes to the object.
  Ownership on Sui can be exclusive to an account, shared across the network, or frozen, allowing
  read-only access without modification or transfer capabilities. We will discuss ownership in more
  detail in the following sections.

  Note that ownership does not control the confidentiality of an object &mdash; it is always
  possible to read the contents of an on-chain object from outside of Move. You should never store
  unencrypted secrets inside of objects.

- **Data:** Objects encapsulate their data, simplifying management and manipulation. The data
  structure and operations are defined by the object's type.

- **Version:** The transition from accounts to objects is facilitated by object versioning.
  Traditionally, blockchains use a _nonce_ to prevent replay attacks. In Sui, the object's version
  acts as a nonce, preventing replay attacks for each object.

- **Digest:** Every object has a digest, which is a hash of the object's data. The digest is used to
  cryptographically verify the integrity of the object's data and ensures that it has not been
  tampered with. The digest is calculated when the object is created and is updated whenever the
  object's data changes.

## Summary

- Objects in Sui are high-level abstractions representing digital assets.
- Objects have a type, unique ID, owner, data, version, and digest.
- The Object Model simplifies asset management and enables a wide range of use cases.

## Further Reading

- [Object Model](https://docs.sui.io/concepts/object-model) in Sui Documentation.

>>>> move-book/book/object/ownership.md
# Ownership

Sui introduces four distinct ownership types for objects: single owner, shared state, immutable
shared state, and object-owner. Each model offers unique characteristics and suits different use
cases, enhancing flexibility and control in object management.

Note that ownership does not control the confidentiality of an object &mdash; it is always possible
to read the contents of an on-chain object from outside of Move. You should never store unencrypted
secrets inside of objects.

See the [Storage Functions](../storage/storage-functions.md) chapter for details on how to change
the owner or ownership type of an object.

## Account Owner (or Single Owner)

The account owner, also known as the _single owner_ model, is the foundational ownership type in
Sui. Here, an object is owned by a single account, granting that account exclusive control over the
object within the behaviors associated with its type. This model embodies the concept of _true
ownership_, where the account possesses complete authority over the object, making it inaccessible
to others for modification or transfer. This level of ownership clarity is a significant advantage
over other blockchain systems, where ownership definitions can be more ambiguous, and smart
contracts may have the ability to alter or transfer assets without the owner's consent.

Just like your private mobile phone, you own it, you can easily unlock and operate it, but others cannot.
Sui is designed to prevent things like cracking someone else's phone password (bypassing permission
checks to use objects that do not belong to others). Therefore, no one can use your assets unless
authorized by you.

## Shared State

Single owner model has its limitations: for example, it is very tricky to implement a marketplace
for digital assets without a shared state. For a generic marketplace scenario, imagine that Alice
owns an asset X, and she wants to sell it by putting it into a shared marketplace. Then Bob can come
and buy the asset directly from the marketplace. The reason why this is tricky is that it is
impossible to write a smart contract that would "lock" the asset in Alice's account and take it out
when Bob buys it. First, it will be a violation of the single owner model, and second, it requires a
shared access to the asset.

To facilitate a problem of shared data access, Sui has introduced a shared ownership model. In this
model, an object can be shared with the network. Shared objects can be read and modified by any
account on the network, and the rules of interaction are defined by the implementation of the
object. Typical uses for shared objects are: marketplaces, shared resources, escrows, and other
scenarios where multiple accounts need access to the same state.

## Immutable (Frozen) State

Sui also offers the _frozen object_ model, where an object becomes permanently read-only. These
immutable objects, while readable, cannot be modified or moved, providing a stable and constant
state accessible to all network participants. Frozen objects are ideal for public data, reference
materials, and other use cases where the state permanence is desirable.

## Object Owner

The last ownership model in Sui is the _object owner_. In this model, an object is owned by another
object. This feature allows creating complex relationships between objects, storing large
heterogeneous collections, and implementing extensible and modular systems. Practically speaking,
since the transactions are initiated by accounts, the transaction still accesses the parent object,
but it can then access the child objects through the parent object.

A use case we love to mention is a game character. Alice can own the Hero object from a game, and
the Hero can own items: also represented as objects, like a "Map", or a "Compass". Alice may take
the "Map" from the "Hero" object, and then send it to Bob, or sell it on a marketplace. With object
owner, it becomes very natural to imagine how the assets can be structured and managed in relation
to each other.

## Summary

- **Single Owner:** Objects are owned by a single account, granting exclusive control over the
  object.
- **Shared State:** Objects can be shared with the network, allowing multiple accounts to read and
  modify the object.
- **Immutable State:** Objects become permanently read-only, providing a stable and constant state.
- **Object Owner:** Objects can own other objects, enabling complex relationships and modular
  systems.

## Next Steps

In the next section we will talk about transaction execution paths in Sui, and how the ownership
models affect the transaction execution.

>>>> move-book/book/programmability/authorization-patterns.md
# Authorization Patterns

>>>> move-book/book/programmability/balance-and-coin.md
# Balance & Coin

>>>> move-book/book/programmability/bcs.md
# Binary Canonical Serialization

Binary Canonical Serialization (BCS) is a binary encoding format for structured data. It was
originally designed in Diem, and became the standard serialization format for Move. BCS is simple,
efficient, deterministic, and easy to implement in any programming language.

> The full format specification is available in the
> [BCS repository](https://github.com/zefchain/bcs).

## Format

BCS is a binary format that supports unsigned integers up to 256 bits, options, booleans, unit
(empty value), fixed and variable-length sequences, and maps. The format is designed to be
deterministic, meaning that the same data will always be serialized to the same bytes.

> "BCS is not a self-describing format. As such, in order to deserialize a message, one must know
> the message type and layout ahead of time" from the [README](https://github.com/zefchain/bcs)

Integers are stored in little-endian format, and variable-length integers are encoded using a
variable-length encoding scheme. Sequences are prefixed with their length as ULEB128, enumerations
are stored as the index of the variant followed by the data, and maps are stored as an ordered
sequence of key-value pairs.

Structs are treated as a sequence of fields, and the fields are serialized in the order they are
defined in the struct. The fields are serialized using the same rules as the top-level data.

## Using BCS

The [Sui Framework](./sui-framework) includes the [`sui::bcs`][sui-bcs] module for encoding and
decoding data. Encoding functions are native to the VM, and decoding functions are implemented in
Move.

## Encoding

To encode data, use the `bcs::to_bytes` function, which converts data references into byte vectors.
This function supports encoding any types, including structs.

```move
module std::bcs;

public native fun to_bytes<T>(t: &T): vector<u8>;
```

The following example shows how to encode a struct using BCS. The `to_bytes` function can take any
value and encode it as a vector of bytes.

```move file=packages/samples/sources/programmability/bcs.move anchor=encode

```

### Encoding a Struct

Structs encode similarly to simple types. Here is how to encode a struct using BCS:

```move file=packages/samples/sources/programmability/bcs.move anchor=encode_struct

```

## Decoding

Because BCS is not a self-describing format, decoding requires prior knowledge of the data type. The
[`sui::bcs`][sui-bcs] module provides various functions to assist with this process.

### Wrapper API

BCS is implemented as a wrapper in Move. The decoder takes the bytes by value, and then allows the
caller to _peel off_ the data by calling different decoding functions, prefixed with `peel_*`. The
data is extracted from the bytes, and the remaining bytes are kept in the wrapper until the
`into_remainder_bytes` function is called.

```move file=packages/samples/sources/programmability/bcs.move anchor=decode

```

There is a common practice to use multiple variables in a single `let` statement during decoding. It
makes code a little bit more readable and helps to avoid unnecessary copying of the data.

```move file=packages/samples/sources/programmability/bcs.move anchor=chain_decode

```

### Decoding Vectors

While most of the primitive types have a dedicated decoding function, vectors need special handling,
which depends on the type of the elements. For vectors, first you need to decode the length of the
vector, and then decode each element in a loop.

```move file=packages/samples/sources/programmability/bcs.move anchor=decode_vector

```

This functionality is provided by the library as a macro `peel_vec!`. It calls the inner expression
as many times as the vector length and aggregates the result into a single vector.

```move
let u64_vec = bcs.peel_vec!(|bcs| bcs.peel_u64());
let address_vec = bcs.peel_vec!(|bcs| bcs.peel_address());

// Caution: this is only possible if `MyStruct` is defined in the current module!
let my_struct = bcs.peel_vec!(|bcs| MyStruct {
    user_addr: bcs.peel_address(),
    age: bcs.peel_u8(),
});
```

### Decoding Option

<!--
> Coincidentally, Option, being a vector in Move, overlaps with the representation of an enum with a
> single variant in BCS, and makes Option in Rust fully compatible with the one in Move.
-->

[Option](./../move-basics/option) in Move is represented as a vector of either 0 or 1 element. To
read an option, you would treat it like a vector and check its length (first byte - either 1 or 0).

```move file=packages/samples/sources/programmability/bcs.move anchor=decode_option

```

Like with [vector](#decoding-vectors), there is a wrapper macro `peel_option!` which checks the
variant index and evaluates the expression if the underlying value is _some_.

```move
let u8_opt = bcs.peel_option!(|bcs| bcs.peel_u8());
let bool_opt = bcs.peel_option!(|bcs| bcs.peel_bool());
```

### Decoding Structs

Structs are decoded field by field, and there is no way to automatically decode bytes into a Move
struct. To parse bytes into a struct, you need to decode each field and instantiate the type.

```move file=packages/samples/sources/programmability/bcs.move anchor=decode_struct

```

## Summary

Binary Canonical Serialization is an efficient binary format for structured data, ensuring
consistent serialization across platforms. The Sui Framework provides comprehensive tools for
working with BCS, allowing extensive functionality through built-in functions.

[sui-bcs]: https://docs.sui.io/references/framework/sui_sui/bcs

>>>> move-book/book/programmability/capability.md
# Pattern: Capability

In programming, a _capability_ is a token that gives the owner the right to perform a specific
action. It is a pattern that is used to control access to resources and operations. A simple example
of a capability is a key to a door. If you have the key, you can open the door. If you don't have
the key, you can't open the door. A more practical example is an Admin Capability which allows the
owner to perform administrative operations, which regular users cannot.

## Capability is an Object

In the [Sui Object Model](./../object/), capabilities are represented as objects. An owner of an
object can pass this object to a function to prove that they have the right to perform a specific
action. Due to strict typing, the function taking a capability as an argument can only be called
with the correct capability.

> There's a convention to name capabilities with the `Cap` suffix, for example, `AdminCap` or
> `KioskOwnerCap`.

```move file=packages/samples/sources/programmability/capability.move anchor=main

```

## Using `init` for Admin Capability

A very common practice is to create a single `AdminCap` object on package publish. This way, the
application can have a setup phase where the admin account prepares the state of the application.

```move file=packages/samples/sources/programmability/capability-2.move anchor=admin_cap

```

## Address Check vs Capability

Utilizing objects as capabilities is a relatively new concept in blockchain programming. And in
other smart-contract languages, authorization is often performed by checking the address of the
sender. This pattern is still viable on Sui, however, overall recommendation is to use capabilities
for better security, discoverability, and code organization.

Let's look at how the `new` function that creates a user would look like if it was using the address
check:

```move file=packages/samples/sources/programmability/capability-3.move anchor=with_address

```

And now, let's see how the same function would look like with the capability:

```move file=packages/samples/sources/programmability/capability-4.move anchor=with_capability

```

Using capabilities has several advantages over the address check:

- Migration of admin rights is easier with capabilities due to them being objects. In case of
  address, if the admin address changes, all the functions that check the address need to be
  updated - hence, require a package upgrade.
- Function signatures are more descriptive with capabilities. It is clear that the `new` function
  requires the `AdminCap` to be passed as an argument. And this function can't be called without it.
- Object Capabilities don't require extra checks in the function body, and hence, decrease the
  chance of a developer mistake.
- An owned Capability also serves in discovery. The owner of the AdminCap can see the object in
  their account (via a Wallet or Explorer), and know that they have the admin rights. This is less
  transparent with the address check.

However, the address approach has its own advantages. For example, if an address is multisig, and
transaction building gets more complex, it might be easier to check the address. Also, if there's a
central object of the application that is used in every function, it can store the admin address,
and this would simplify migration. The central object approach is also valuable for revocable
capabilities, where the admin can revoke the capability from the user.

>>>> move-book/book/programmability/collections.md
# Collections

Collection types are a fundamental part of any programming language. They are used to store a
collection of data, such as a list of items. The `vector` type has already been covered in the
[vector section](./../move-basics/vector), and in this chapter we will cover the vector-based
collection types offered by the [Sui Framework](./sui-framework).

## Vector

While we have previously covered the `vector` type in the [vector section](./../move-basics/vector),
it is worth going over it again in a new context. This time we will cover the usage of the `vector`
type in objects and how it can be used in an application.

```move file=packages/samples/sources/programmability/collections.move anchor=vector

```

## VecSet

`VecSet` is a collection type that stores a set of unique items. It is similar to a `vector`, but it
does not allow duplicate items. This property makes it useful for storing a collection of unique
items, such as a list of IDs or addresses.

```move file=packages/samples/sources/programmability/collections-2.move anchor=vec_set

```

VecSet will fail on attempt to insert an item that already exists in the set.

## VecMap

`VecMap` is a collection type that stores a map of key-value pairs. It is similar to a `VecSet`, but
it allows you to associate a value with each item in the set. This makes it useful for storing a
collection of key-value pairs, such as a list of addresses and their balances, or a list of user IDs
and their associated data.

Keys in a `VecMap` are unique, and each key can only be associated with a single value. If you try
to insert a key-value pair with a key that already exists in the map, the old value will be replaced
with the new value.

```move file=packages/samples/sources/programmability/collections-3.move anchor=vec_map

```

## Limitations

Standard collection types are a great way to store typed data with guaranteed safety and
consistency. However, they are limited by the type of data they can store - the type system won't
allow you to store a wrong type in a collection; and they're limited in size - by the object size
limit. They will work for relatively small-sized sets and lists, but for larger collections you may
need to use a different approach.

Another limitations on collection types is inability to compare them. Because the order of insertion
is not guaranteed, an attempt to compare a `VecSet` to another `VecSet` may not yield the expected
results.

> This behavior is caught by the linter and will emit a warning: _Comparing collections of type
> 'sui::vec_set::VecSet' may yield unexpected result_

```move file=packages/samples/sources/programmability/collections-4.move anchor=vec_set_comparison

```

In the example above, the comparison will fail because the order of insertion is not guaranteed, and
the two `VecSet` instances may have different orders of elements. And the comparison will fail even
if the two `VecSet` instances contain the same elements.

## Summary

- Vector is a native type that allows storing a list of items.
- VecSet is built on top of vector and allows storing sets of unique items.
- VecMap is used to store key-value pairs in a map-like structure.
- Vector-based collections are strictly typed and limited by the object size limit and are best
  suited for small-sized sets and lists.

## Next Steps

In the next section we will cover the [Wrapper Type Pattern](./wrapper-type-pattern) - a design
pattern often used with collection types to extend or restrict their behavior.

>>>> move-book/book/programmability/cryptography-and-hashing.md
# Cryptography and Hashing

>>>> move-book/book/programmability/display.md
# Object Display

Objects on Sui are explicit in their structure and behavior and can be displayed in an
understandable way. However, to support richer metadata for clients, there's a standard and
efficient way of "describing" them to the client - the `Display` object defined in the
[Sui Framework](./sui-framework).

## Background

Historically, there were different attempts to agree on a standard structure of an object so it can
be displayed in a user interface. One of the approaches was to define certain fields in the object
struct which, when present, would be used in the UI. This approach was not flexible enough and
required developers to define the same fields in every object, and sometimes the fields did not make
sense for the object.

```move file=packages/samples/sources/programmability/display.move anchor=background

```

If any of the fields contained static data, it would be duplicated in every object. And, since Move
does not have interfaces, it is not possible to know if an object has a specific field without
"manually" checking the object's type, which makes the client fetching more complex.

## Object Display

To address these issues, Sui introduces a standard way of describing an object for display. Instead
of defining fields in the object struct, the display metadata is stored in a separate object, which
is associated with the type. This way, the display metadata is not duplicated, and it is easy to
extend and maintain.

Another important feature of Sui Display is the ability to define templates and use object fields in
those templates. Not only it allows for a more flexible display, but it also frees the developer
from the need to define the same fields with the same names and types in every object.

> The Object Display is natively supported by the
> [Sui Full Node](https://docs.sui.io/guides/operator/sui-full-node), and the client can fetch the
> display metadata for any object if the object type has a Display associated with it.

```move file=packages/samples/sources/programmability/display.move anchor=hero

```

## Creator Privilege

While the objects can be owned by accounts and may be a subject to
[True Ownership](./../object/ownership#account-owner-or-single-owner), the Display can be owned by
the creator of the object. This way, the creator can update the display metadata and apply the
changes globally without the need to update every object. The creator can also transfer Display to
another account or even build an application around the object with custom functionality to manage
the metadata.

## Standard Fields

The fields that are supported most widely are:

- `name` - A name for the object. The name is displayed when users view the object.
- `description` - A description for the object. The description is displayed when users view the
  object.
- `link` - A link to the object to use in an application.
- `image_url` - A URL or a blob with the image for the object.
- `thumbnail_url` - A URL to a smaller image to use in wallets, explorers, and other products as a
  preview.
- `project_url` - A link to a website associated with the object or creator.
- `creator` - A string that indicates the object creator.

> Please, refer to the [Sui Documentation](https://docs.sui.io/standards/display) for the most
> up-to-date list of supported fields.

While there's a standard set of fields, the Display object does not enforce them. The developer can
define any fields they need, and the client can use them as they see fit. Some applications may
require additional fields, and omit other, and the Display is flexible enough to support them.

## Working with Display

The `Display` object is defined in the `sui::display` module. It is a generic struct that takes a
phantom type as a parameter. The phantom type is used to associate the `Display` object with the
type it describes. The `fields` of the `Display` object are a `VecMap` of key-value pairs, where the
key is the field name and the value is the field value. The `version` field is used to version the
display metadata, and is updated on the `update_display` call.

```move
module sui::display;

public struct Display<phantom T: key> has key, store {
    id: UID,
    /// Contains fields for display. Currently supported
    /// fields are: name, link, image and description.
    fields: VecMap<String, String>,
    /// Version that can only be updated manually by the Publisher.
    version: u16
}
```

The [Publisher](./publisher) object is required to a new Display, since it serves as the proof of
ownership of type.

## Template Syntax

Currently, Display supports simple string interpolation and can use struct fields (and paths) in its
templates. The syntax is trivial - `{path}` is replaced with the value of the field at the path. The
path is a dot-separated list of field names, starting from the root object in case of nested fields.

```move file=packages/samples/sources/programmability/display.move anchor=nested

```

The Display for the type `LittlePony` above could be defined as follows:

```json
{
  "name": "Just a pony",
  "image_url": "{image_url}",
  "description": "{metadata.description}"
}
```

## Multiple Display Objects

There's no restriction to how many `Display<T>` objects can be created for a specific `T`. However,
the most recently updated `Display<T>` will be used by the full node.

## Further Reading

- [Sui Object Display](https://docs.sui.io/standards/display) is Sui Documentation
- [Publisher](./publisher) - the representation of the creator

>>>> move-book/book/programmability/dynamic-collections.md
# Dynamic Collections

[Sui Framework](./sui-framework) offers a variety of collection types that build on the
[dynamic fields](./dynamic-fields) and [dynamic object fields](./dynamic-object-fields) concepts.
These collections are designed to be a safer and more understandable way to store and manage dynamic
fields and objects.

For each collection type we will specify the primitive they use, and the specific features they
offer.

> Unlike dynamic (object) fields which operate on UID, collection types have their own type and
> allow calling [associated functions](./../move-basics/struct-methods).

## Common Concepts

All of the collection types share the same set of methods, which are:

- `add` - adds a field to the collection
- `remove` - removes a field from the collection
- `borrow` - borrows a field from the collection
- `borrow_mut` - borrows a mutable reference to a field from the collection
- `contains` - checks if a field exists in the collection
- `length` - returns the number of fields in the collection
- `is_empty` - checks if the `length` is 0

All collection types support index syntax for `borrow` and `borrow_mut` methods. If you see square
brackets in the examples, they are translated into `borrow` and `borrow_mut` calls.

```move
let hat: &Hat = &bag[b"key"];
let hat_mut: &mut Hat = &mut bag[b"key"];

// is equivalent to
let hat: &Hat = bag.borrow(b"key");
let hat_mut: &mut Hat = bag.borrow_mut(b"key");
```

In the examples we won't focus on these functions, but rather on the differences between the
collection types.

## Bag

Bag, as the name suggests, acts as a "bag" of heterogeneous values. It is a simple, non-generic type
that can store any data. Bag will never allow orphaned fields, as it tracks the number of fields and
can't be destroyed if it's not empty.

```move
module sui::bag;

public struct Bag has key, store {
    /// the ID of this bag
    id: UID,
    /// the number of key-value pairs in the bag
    size: u64,
}
```

_See [full documentation for sui::bag][bag-framework] module._

Due to Bag storing any types, the extra methods it offers is:

- `contains_with_type` - checks if a field exists with a specific type

Used as a struct field:

```move file=packages/samples/sources/programmability/dynamic-collections.move anchor=bag_struct

```

Using the Bag:

```move file=packages/samples/sources/programmability/dynamic-collections.move anchor=bag_usage

```

## ObjectBag

Defined in the `sui::object_bag` module. Identical to [Bag](#bag), but uses
[dynamic object fields](./dynamic-object-fields) internally. Can only store objects as values.

_See [full documentation for sui::object_bag][object-bag-framework] module._

## Table

Table is a typed dynamic collection that has a fixed type for keys and values. It is defined in the
`sui::table` module.

```move
module sui::table;

public struct Table<phantom K: copy + drop + store, phantom V: store> has key, store {
    /// the ID of this table
    id: UID,
    /// the number of key-value pairs in the table
    size: u64,
}
```

_See [full documentation for sui::table][table-framework] module._

Used as a struct field:

```move file=packages/samples/sources/programmability/dynamic-collections.move anchor=table_struct

```

Using the Table:

```move file=packages/samples/sources/programmability/dynamic-collections.move anchor=table_usage

```

## ObjectTable

Defined in the `sui::object_table` module. Identical to [Table](#table), but uses
[dynamic object fields](./dynamic-object-fields) internally. Can only store objects as values.

_See [full documentation for sui::object_table][object-table-framework] module._

## LinkedTable

It is defined in the `sui::linked_table` module, similar to [Table](#table) but the values are linked together,
allowing for ordered insertion and removal.

```move
module sui::linked_table;

public struct LinkedTable<K: copy + drop + store, phantom V: store> has key, store {
    /// the ID of this table
    id: UID,
    /// the number of key-value pairs in the table
    size: u64,
    /// the front of the table, i.e. the key of the first entry
    head: Option<K>,
    /// the back of the table, i.e. the key of the last entry
    tail: Option<K>,
}
```

_See [full documentation for sui::linked_table][linked-table-framework] module._

Since the values stored in LinkedTable are linked together, it has unique methods for adding and deleting.

- `push_front` - inserts a key-value pair at the front of the table
- `push_back` - inserts a key-value pair at the back of the table
- `remove` - removes a key-value pair by key and returns the value
- `pop_front` - removes the front of the table, returns the key and value
- `pop_back` - removes the back of the table, returns the key and value

Used as a struct field:

```move file=packages/samples/sources/programmability/dynamic-collections.move anchor=linked_table_struct

```

Using the LinkedTable:

```move file=packages/samples/sources/programmability/dynamic-collections.move anchor=linked_table_usage

```

## Summary

- [Bag](#bag) - a simple collection that can store any type of data.
- [ObjectBag](#objectbag) - a collection that can store only objects.
- [Table](#table) - a typed dynamic collection that has a fixed type for keys and values.
- [ObjectTable](#objecttable) - same as Table, but can only store objects.
- [LinkedTable](#linkedtable) - similar to Table but the values are linked together.

## Further Reading

- [sui::table][table-framework] module documentation.
- [sui::object_table][object-table-framework] module documentation.
- [sui::linked_table][linked-table-framework] module documentation.
- [sui::bag][bag-framework] module documentation.
- [sui::object_bag][object-bag-framework] module documentation.

[table-framework]: https://docs.sui.io/references/framework/sui/table
[object-table-framework]: https://docs.sui.io/references/framework/sui/object_table
[linked-table-framework]: https://docs.sui.io/references/framework/sui/linked_table
[bag-framework]: https://docs.sui.io/references/framework/sui/bag
[object-bag-framework]: https://docs.sui.io/references/framework/sui/object_bag

<!-- TODO! -->

<!-- ## Choosing a Collection Type

Depending on the needs of your project, you may choose to -->

>>>> move-book/book/programmability/dynamic-fields.md
# Dynamic Fields

Sui Object model allows objects to be attached to other objects as _dynamic fields_. The behavior is
similar to how a `Map` works in other programming languages. However, unlike a `Map` which in Move
would be strictly typed (we have covered it in the [Collections](./collections) section), dynamic
fields allow attaching objects of any type. A similar approach from the world of frontend
development would be a JavaScript Object type which allows storing any type of data dynamically.

> There's no limit to the number of dynamic fields that can be attached to an object. Thus, dynamic
> fields can be used to store large amounts of data that don't fit into the object limit size.

Dynamic Fields allow for a wide range of applications, from splitting data into smaller parts to
avoid [object size limit](./../guides/building-against-limits) to attaching objects as a part of
application logic.

## Definition

Dynamic Fields are defined in the `sui::dynamic_field` module of the
[Sui Framework](./sui-framework). They are attached to object's `UID` via a _name_, and can be
accessed using that name. There can be only one field with a given name attached to an object.

```move
module sui::dynamic_field;

/// Internal object used for storing the field and value
public struct Field<Name: copy + drop + store, Value: store> has key {
    /// Determined by the hash of the object ID, the field name
    /// value and it's type, i.e. hash(parent.id || name || Name)
    id: UID,
    /// The value for the name of this field
    name: Name,
    /// The value bound to this field
    value: Value,
}
```

As the definition shows, dynamic fields are stored in an internal `Field` object, which has the
`UID` generated in a deterministic way based on the object ID, the field name, and the field type.
The `Field` object contains the field name and the value bound to it. The constraints on the `Name`
and `Value` type parameters define the abilities that the key and value must have.

## Usage

The methods available for dynamic fields are straightforward: a field can be added with `add`,
removed with `remove`, and read with `borrow` and `borrow_mut`. Additionally, the `exists_` method
can be used to check if a field exists (for stricter checks with type, there is an
`exists_with_type` method).

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=usage

```

In the example above, we define a `Character` object and two different types of accessories that
could never be put together in a vector. However, dynamic fields allow us to store them together in
a single object. Both objects are attached to the `Character` via a `vector<u8>` (bytestring
literal), and can be accessed using their respective names.

As you can see, when we attached the accessories to the Character, we passed them _by value_. In
other words, both values were moved to a new scope, and their ownership was transferred to the
`Character` object. If we changed the ownership of `Character` object, the accessories would have
been moved with it.

And the last important property of dynamic fields we should highlight is that they are _accessed
through their parent_. This means that the `Hat` and `Mustache` objects are not directly accessible
and follow the same rules as the parent object.

## Foreign Types as Dynamic Fields

Dynamic fields allow objects to carry data of any type, including those defined in other modules.
This is possible due to their generic nature and relatively weak constraints on the type parameters.
Let's illustrate this by attaching a few different values to a `Character` object.

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=foreign_types

```

In this example we showed how different types can be used for both _name_ and the _value_ of a
dynamic field. The `String` is attached via a `vector<u8>` name, the `u64` is attached via a `u32`
name, and the `bool` is attached via a `bool` name. Anything is possible with dynamic fields!

## Orphaned Dynamic Fields

> To prevent orphaned dynamic fields, please, use [Dynamic Collection Types](./dynamic-collections)
> such as `Bag` as they track the dynamic fields and won't allow unpacking if there are attached
> fields.

The `object::delete()` function, which is used to delete a UID, does not track the dynamic fields,
and cannot prevent dynamic fields from becoming orphaned. Once the parent UID is deleted, the
dynamic fields are not automatically deleted, and they become orphaned. This means that the dynamic
fields are still stored in the blockchain, but they will never become accessible again.

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=orphan_fields

```

Orphaned objects are not a subject to storage rebate, and the storage fees will remain unclaimed.
One way to avoid orphaned dynamic fields during unpacking of an object is to return the `UID` and
store it somewhere temporarily until the dynamic fields are removed and handled properly.

## Custom Type as a Field Name

In the examples above, we used primitive types as field names since they have the required set of
abilities. But dynamic fields get even more interesting when we use custom types as field names.
This allows for a more structured way of storing data, and also allows for protecting the field
names from being accessed by other modules.

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=custom_type

```

Two field names that we defined above are `AccessoryKey` and `MetadataKey`. The `AccessoryKey` has a
`String` field in it, hence it can be used multiple times with different `name` values. The
`MetadataKey` is an empty key, and can be attached only once.

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=custom_type_usage

```

As you can see, custom types do work as field names but as long as they can be _constructed_ by the
module, in other words - if they are _internal_ to the module and defined in it. This limitation on
struct packing can open up new ways in the design of the application.

This approach is used in the Object Capability<!--[]](./object-capability)--> pattern, where an
application can authorize a foreign object to perform operations in it while not exposing the
capabilities to other modules.

## Exposing UID

<div class="warning">

Mutable access to `UID` is a security risk. Exposing `UID` of your type as a mutable reference can
lead to unwanted modifications or removal of the object's dynamic fields. Additionally, it affects
the Transfer to Object<!--[](./../storage/transfer-to-object)--> and
[Dynamic Object Fields](./dynamic-object-fields). Make sure to understand the implications before
exposing the `UID` as a mutable reference.

</div>

Because dynamic fields are attached to `UID`s, their usage in other modules depends on whether the
`UID` can be accessed. By default struct visibility protects the `id` field and won't let other
modules access it directly. However, if there's a public accessor method that returns a reference to
`UID`, dynamic fields can be read in other modules.

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=exposed_uid

```

In the example above, we show how to expose the `UID` of a `Character` object. This solution may
work for some applications, however, it is important to remember that exposed `UID` allows reading
_any_ dynamic field attached to the object.

If you need to expose the `UID` only within the package, use a restrictive visibility, like
`public(package)`, or even better - use more specific accessor methods that would allow only reading
specific fields.

```move file=packages/samples/sources/programmability/dynamic-fields.move anchor=exposed_uid_measures

```

## Dynamic Fields vs Fields

Dynamic Fields are more expensive than regular fields, as they require additional storage and costs
for accessing them. Their flexibility comes at a price, and it is important to understand the
implications when making a decision between using dynamic fields and regular fields.

## Limits

Dynamic Fields are not subject to the [object size limit](./../guides/building-against-limits), and
can be used to store large amounts of data. However, they are still subject to the
[dynamic fields created limit](./../guides/building-against-limits), which is set to 1000 fields per
transaction.

## Applications

Dynamic Fields can play a crucial role in applications of any complexity. They open up a variety of
different use cases, from storing heterogeneous data to attaching objects as part of the application
logic. They allow for certain [upgradeability practices](./../guides/upgradeability-practices) based
on the ability to define them _later_ and change the type of the field.

## Next Steps

In the next section we will cover [Dynamic Object Fields](./dynamic-object-fields) and explain how
they differ from dynamic fields, and what are the implications of using them.

>>>> move-book/book/programmability/dynamic-object-fields.md
# Dynamic Object Fields

> This section expands on the [Dynamic Fields](./dynamic-fields). Please, read it first to
> understand the basics of dynamic fields.

Another variation of dynamic fields is _dynamic object fields_, which have certain differences from
regular dynamic fields. In this section, we will cover the specifics of dynamic object fields and
explain how they differ from regular dynamic fields.

> General recommendation is to avoid using dynamic object fields in favor of (just) dynamic fields,
> especially if there's no need for direct discovery through the ID. The extra costs of dynamic
> object fields may not be justified by the benefits they provide.

## Definition

Dynamic Object Fields are defined in the `sui::dynamic_object_fields` module in the
[Sui Framework](./sui-framework). They are similar to dynamic fields in many ways, but unlike them,
dynamic object fields have an extra constraint on the `Value` type. The `Value` must have a
combination of `key` and `store`, not just `store` as in the case of dynamic fields.

They're less explicit in their framework definition, as the concept itself is more abstract:

```move
module sui::dynamic_object_field;

/// Internal object used for storing the field and the name associated with the
/// value. The separate type is necessary to prevent key collision with direct
/// usage of dynamic_field
public struct Wrapper<Name> has copy, drop, store {
    name: Name,
}
```

Unlike `Field` type in the [Dynamic Fields](./dynamic-fields#definition) section, the `Wrapper` type
only stores the name of the field. The value is the object itself, and is _not wrapped_.

The constraints on the `Value` type become visible in the methods available for dynamic object
fields. Here's the signature for the `add` function:

```move
/// Adds a dynamic object field to the object `object: &mut UID` at field
/// specified by `name: Name`. Aborts with `EFieldAlreadyExists` if the object
/// already has that field with that name.
public fun add<Name: copy + drop + store, Value: key + store>(
    // we use &mut UID in several spots for access control
    object: &mut UID,
    name: Name,
    value: Value,
) { /* implementation omitted */ }
```

The rest of the methods which are identical to the ones in the
[Dynamic Fields](./dynamic-fields#usage) section have the same constraints on the `Value` type.
Let's list them for reference:

- `add` - adds a dynamic object field to the object
- `remove` - removes a dynamic object field from the object
- `borrow` - borrows a dynamic object field from the object
- `borrow_mut` - borrows a mutable reference to a dynamic object field from the object
- `exists_` - checks if a dynamic object field exists
- `exists_with_type` - checks if a dynamic object field exists with a specific type

Additionally, there is an `id` method which returns the `ID` of the `Value` object without
specifying its type.

## Usage & Differences with Dynamic Fields

The main difference between dynamic fields and dynamic object fields is that the latter allows
storing _only objects_ as values. This means that you can't store primitive types like `u64` or
`bool`. It may be considered a limitation, if not for the fact that dynamic object fields are _not
wrapped_ into a separate object.

> The relaxed requirement for wrapping keeps the object available for off-chain discovery via its
> ID. However, this property may not be outstanding if wrapped object indexing is implemented,
> making the dynamic object fields a redundant feature.

```move file=packages/samples/sources/programmability/dynamic-object-fields.move anchor=usage

```

## Pricing Differences

Dynamic Object Fields come a little more expensive than dynamic fields. Because of their internal
structure, they require 2 objects: the Wrapper for Name and the Value. Because of this, the cost of
adding and accessing object fields (loading 2 objects compared to 1 for dynamic fields) is higher.

## Next Steps

Both dynamic field and dynamic object fields are powerful features which allow for innovative
solutions in applications. However, they are relatively low-level and require careful handling to
avoid orphaned fields. In the next section, we will introduce a higher-level abstraction -
[Dynamic Collections](./dynamic-collections) - which can help with managing dynamic fields and
objects more effectively.

>>>> move-book/book/programmability/epoch-and-time.md
# Epoch and Time

Sui has two ways of accessing the current time: `Epoch` and `Time`. The former represents
operational periods in the system and changed roughly every 24 hours. The latter represents the
current time in milliseconds since the Unix Epoch. Both can be accessed freely in the program.

## Epoch

Epochs are used to separate the system into operational periods. During an epoch the validator set
is fixed, however, at the epoch boundary, the validator set can be changed. Epochs play a crucial
role in the consensus algorithm and are used to determine the current validator set. They are also
used as measurement in the staking mechanism.

Epoch can be read from the [transaction context](./transaction-context):

```move file=packages/samples/sources/programmability/epoch-and-time.move anchor=epoch

```

It is also possible to get the unix timestamp of the epoch start:

```move file=packages/samples/sources/programmability/epoch-and-time.move anchor=epoch_start

```

Normally, epochs are used in staking and system operations, however, in custom scenarios they can be
used to emulate 24h periods. They are critical if an application relies on the staking logic or
needs to know the current validator set.

## Time

For a more precise time measurement, Sui provides the `Clock` object. It is a system object that is
updated during checkpoints by the system, which stores the current time in milliseconds since the
Unix Epoch. The `Clock` object is defined in the `sui::clock` module and has a reserved address
`0x6`.

Clock is a shared object, but a transaction attempting to access it mutably will fail. This
limitation allows parallel access to the `Clock` object, which is important for maintaining
performance.

```move
module sui::clock;

/// Singleton shared object that exposes time to Move calls.  This
/// object is found at address 0x6, and can only be read (accessed
/// via an immutable reference) by entry functions.
///
/// Entry Functions that attempt to accept `Clock` by mutable
/// reference or value will fail to verify, and honest validators
/// will not sign or execute transactions that use `Clock` as an
/// input parameter, unless it is passed by immutable reference.
public struct Clock has key {
    id: UID,
    /// The clock's timestamp, which is set automatically by a
    /// system transaction every time consensus commits a
    /// schedule, or by `sui::clock::increment_for_testing` during
    /// testing.
    timestamp_ms: u64,
}
```

There is only one public function available in the `Clock` module - `timestamp_ms`. It returns the
current time in milliseconds since the Unix Epoch.

```move file=packages/samples/sources/programmability/epoch-and-time.move anchor=clock

```

## Testing

The `Clock` module provides a number of methods for use in testing.

```move file=packages/samples/sources/programmability/epoch-and-time.move anchor=test

```
>>>> move-book/book/programmability/events.md
# Events

Events are a way to notify off-chain listeners about on-chain events. They are used to emit
additional information about the transaction that is not stored - and, hence, can't be accessed -
on-chain. Events are emitted by the `sui::event` module located in the
[Sui Framework](./sui-framework).

> Any custom type with the [copy](./../move-basics/copy-ability) and
> [drop](./../move-basics/drop-ability) abilities can be emitted as an event. Sui Verifier requires
> the type to be internal to the module.

```move
module sui::event;

/// Emit a custom Move event, sending the data off-chain.
///
/// Used for creating custom indexes and tracking on-chain
/// activity in a way that suits a specific application the most.
///
/// The type `T` is the main way to index the event, and can contain
/// phantom parameters, eg `emit(MyEvent<phantom T>)`.
public native fun emit<T: copy + drop>(event: T);
```

## Emitting Events

Events are emitted using the `emit` function in the `sui::event` module. The function takes a single
argument - the event to be emitted. The event data is passed by value,

```move file=packages/samples/sources/programmability/events.move anchor=emit

```

The Sui Verifier requires the type passed to the `emit` function to be _internal to the module_. So
emitting a type from another module will result in a compilation error. Primitive types, although
they match the _copy_ and _drop_ requirement, are not allowed to be emitted as events.

## Event Structure

Events are a part of the transaction result and are stored in the _transaction effects_. As such,
they natively have the `sender` field which is the address which sent the transaction. So adding a
"sender" field to the event is not necessary. Similarly, event metadata contains the timestamp. But
it is important to note that the timestamp is relative to the node and may vary a little from node
to node.

<!-- ## Reliability -->

>>>> move-book/book/programmability/fast-path.md
# Fast Path

Due to the object model and the data organization model of Sui, some operations can be performed in
a more efficient and parallelized way. This is called the **fast path**. Transaction that touches
shared state requires consensus because it can be accessed by multiple parties at the same time.
However, if the transaction only touches the private state (owned objects), there is no need for
consensus. This is the fast path.

We have a favorite example for this: a coffee machine and a coffee cup. The coffee machine placed in
the office is a shared resource - everyone can use it, but there can be only one user at a time. The
coffee cup, on the other hand, is a private resource - it belongs to a specific person, and only
that person can use it. To make coffee, one needs to use the coffee machine and wait if there's
someone else using it. However, once the coffee is made and poured into the cup, the person can take
the cup and drink the coffee without waiting for anyone else.

The same principle applies to Sui. If a transaction only touches the private state (the cup with
coffee), it can be executed without consensus. If it touches the shared state (the coffee machine),
it requires consensus. This is the fast path.

## Frozen objects

Consensus is only required for mutating the shared state. If the object is immutable, it is treated
as a "constant" and can be accessed in parallel. Frozen objects can be used to share unchangeable
data between multiple parties without requiring consensus.

## In Practice

```move file=packages/samples/sources/programmability/fast-path.move anchor=main

```

## Special Case: Clock

The `Clock` object with the reserved address `0x6` is a special case of a shared object which cannot
be passed by a mutable reference in a regular transaction. An attempt to do so will not succeed, and
the transaction will be rejected. Because of this limitation, the `Clock` object can only be
accessed immutably, which allows executing transactions in parallel without consensus.

<!-- Add more on why and how -->

>>>> move-book/book/programmability/hot-potato-pattern.md
# Pattern: Hot Potato

A case in the abilities system - a struct without any abilities - is called _hot potato_. It cannot
be stored (not as [an object](./../storage/key-ability) nor as
[a field in another struct](./../storage/store-ability)), it cannot be
[copied](./../move-basics/copy-ability) or [discarded](./../move-basics/drop-ability). Hence, once
constructed, it must be gracefully [unpacked by its module](./../move-basics/struct), or the
transaction will abort due to unused value without drop.

> If you're familiar with languages that support _callbacks_, you can think of a hot potato as an
> obligation to call a callback function. If you don't call it, the transaction will abort.

The name comes from the children's game where a ball is passed quickly between players, and none of
the players want to be the last one holding it when the music stops, or they are out of the game.
This is the best illustration of the pattern - the instance of a hot-potato struct is passed between
calls, and none of the modules can keep it.

## Defining a Hot Potato

A hot potato can be any struct with no abilities. For example, the following struct is a hot potato:

```move file=packages/samples/sources/programmability/hot-potato-pattern.move anchor=definition

```

Because the `Request` has no abilities and cannot be stored or ignored, the module must provide a
function to unpack it. For example:

```move file=packages/samples/sources/programmability/hot-potato-pattern.move anchor=new_request

```

## Example Usage

In the following example, the `Promise` hot potato is used to ensure that the borrowed value, when
taken from the container, is returned back to it. The `Promise` struct contains the ID of the
borrowed object, and the ID of the container, ensuring that the borrowed value was not swapped for
another and is returned to the correct container.

```move file=packages/samples/sources/programmability/hot-potato-pattern.move anchor=container_borrow

```

## Applications

Below we list some of the common use cases for the hot potato pattern.

### Borrowing

As shown in the [example above](#example-usage), the hot potato is very effective for borrowing with
a guarantee that the borrowed value is returned to the correct container. While the example focuses
on a value stored inside an `Option`, the same pattern can be applied to any other storage type, say
a [dynamic field](./dynamic-fields).

### Flash Loans

Canonical example of the hot potato pattern is flash loans. A flash loan is a loan that is borrowed
and repaid in the same transaction. The borrowed funds are used to perform some operations, and the
repaid funds are returned to the lender. The hot potato pattern ensures that the borrowed funds are
returned to the lender.

An example usage of this pattern may look like this:

```move
// Borrow the funds from the lender.
let (asset_a, potato) = lender.borrow(amount);

// Perform some operations with the borrowed funds.
let asset_b = dex.trade(loan);
let proceeds = another_contract::do_something(asset_b);

// Keep the commission and return the rest to the lender.
let pay_back = proceeds.split(amount, ctx);
lender.repay(pay_back, potato);
transfer::public_transfer(proceeds, ctx.sender());
```

### Variable-path Execution

The hot potato pattern can be used to introduce variation in the execution path. For example, if
there is a module which allows purchasing a `Phone` for some "Bonus Points" or for USD, the hot
potato can be used to decouple the purchase from the payment. The approach is very similar to how
some shops work - you take the item from the shelf, and then you go to the cashier to pay for it.

```move file=packages/samples/sources/programmability/hot-potato-pattern.move anchor=phone_shop

```

This decoupling technique allows separating the purchase logic from the payment logic, making the
code more modular and easier to maintain. The `Ticket` could be split into its own module, providing
a basic interface for the payment, and the shop implementation could be extended to support other
goods without changing the payment logic.

### Compositional Patterns

Hot potato can be used to link together different modules in a compositional way. Its module may
define ways to interact with the hot potato, for example, stamp it with a type signature, or to
extract some information from it. This way, the hot potato can be passed between different modules,
and even different packages within the same transaction.

<!-- TODO: add [Request Pattern](./request-pattern)

The most important compositional pattern is the Request Pattern, which we will cover in the next
section. -->

### Usage in the Sui Framework

The pattern is used in various forms in the Sui Framework. Here are some examples:

- [sui::borrow][borrow-framework] - uses hot potato to ensure that the borrowed value is returned to
  the correct container.
- [sui::transfer_policy][transfer-policy-framework] - defines a `TransferRequest` - a hot potato
  which can only be consumed if all conditions are met.
- [sui::token][token-framework] - in the Closed Loop Token system, an `ActionRequest` carries the
  information about the performed action and collects approvals similarly to `TransferRequest`.

[borrow-framework]: https://docs.sui.io/references/framework/sui-framework/borrow
[transfer-policy-framework]: https://docs.sui.io/references/framework/sui-framework/transfer_policy
[token-framework]: https://docs.sui.io/references/framework/sui-framework/token

## Summary

- A hot potato is a struct without abilities, it must come with a way to create and destroy it.
- Hot potatoes are used to ensure that some action is taken before the transaction ends, similar to
  a callback.
- Most common use cases for hot potato are borrowing, flash loans, variable-path execution, and
  compositional patterns.

>>>> move-book/book/programmability/index.md
# Advanced Programmability

In previous chapters we've covered [the basics of Move](./../move-basics) and
[Sui Storage Model](./../storage). Now it's time to dive deeper into the advanced topics of Sui
programmability.

This chapter introduces more complex concepts, practices and features of Move and Sui that are
essential for building more sophisticated applications. It is intended for developers who are
already familiar with the basics of Move and Sui, and are looking to expand their knowledge and
skills.

>>>> move-book/book/programmability/module-initializer.md
# Module Initializer

A common use case in many applications is to run certain code just once when the package is
published. Imagine a simple store module that needs to create the main Store object upon its
publication. In Sui, this is achieved by defining an `init` function within the module. This
function will automatically be called when the module is published.

> All of the modules' `init` functions are called during the publishing process. Currently, this
> behavior is limited to the publish command and does not extend to package upgrades.
>
> <!-- [package upgrades]() -->

```move file=packages/samples/sources/programmability/module-initializer.move anchor=main

```

In the same package, another module can have its own `init` function, encapsulating distinct logic.

```move file=packages/samples/sources/programmability/module-initializer-2.move anchor=other

```

## `init` Features

The function is called on publish, if it is present in the module and follows the rules:

- The function has to be named `init`, be private and have no return values.
- Takes one or two arguments: [One Time Witness](./one-time-witness) (optional) and
  [TxContext](./transaction-context). With `TxContext` always being the last argument.

```move
fun init(ctx: &mut TxContext) { /* ... */}
fun init(otw: OTW, ctx: &mut TxContext) { /* ... */ }
```

TxContext can also be passed as immutable reference: `&TxContext`. However, practically speaking, it
should always be `&mut TxContext` since the `init` function can't access the on-chain state and to
create new objects it requires the mutable reference to the context.

```move
fun init(ctx: &TxContext) { /* ... */}
fun init(otw: OTW, ctx: &TxContext) { /* ... */ }
```

## Trust and Security

While `init` function can be used to create sensitive objects once, it is important to know that the
same object (e.g. `StoreOwnerCap` from the first example) can still be created in another function.
Especially given that new functions can be added to the module during an upgrade. So the `init`
function is a good place to set up the initial state of the module, but it is not a security measure
on its own.

There are ways to guarantee that the object was created only once, such as the
[One Time Witness](./one-time-witness). And there are ways to limit or disable the upgrade of the
module, which we will cover in the Package Upgrades chapter.

## Next Steps

As follows from the definition, the `init` function is guaranteed to be called only once when the
module is published. So it is a good place to put the code that initializes module's objects and
sets up the environment and configuration.

For example, if there's a [Capability](./capability) which is required for certain actions, it
should be created in the `init` function. In the next chapter we will talk about the `Capability`
pattern in more detail.

>>>> move-book/book/programmability/object-capability.md
# Object Capability

<!-- TBD -->

>>>> move-book/book/programmability/one-time-witness.md
# One Time Witness

While regular [Witness](./witness-pattern) is a great way to statically prove the ownership of a
type, there are cases where we need to ensure that a Witness is instantiated only once. And this is
the purpose of the One Time Witness (OTW).

<!--
Notes to self:
  - background first or definition first - which one is better?
  - why would someone read this section?
  - if we removed the OTW from docs, then we should give definition first.
-->

## Definition

The OTW is a special type of Witness that can be used only once. It cannot be manually created and
it is guaranteed to be unique per module. Sui Adapter treats a type as an OTW if it follows these
rules:

1. Has only `drop` ability.
2. Has no fields.
3. Is not a generic type.
4. Named after the module with all uppercase letters.

Here is an example of an OTW:

```move file=packages/samples/sources/programmability/one-time-witness.move anchor=definition

```

The OTW cannot be constructed manually, and any code attempting to do so will result in a
compilation error. The OTW can be received as the first argument in the
[module initializer](./module-initializer). And because the `init` function is called only once per
module, the OTW is guaranteed to be instantiated only once.

## Enforcing the OTW

To check if a type is an OTW, `sui::types` module of the [Sui Framework](./sui-framework) offers a
special function `is_one_time_witness` that can be used to check if the type is an OTW.

```move file=packages/samples/sources/programmability/one-time-witness.move anchor=usage

```

<!-- ## Background

Before we get to actual definition of the OTW, let's consider a simple example. We want to build a generic implementation of a Coin type, which can be initialized with a witness. A instance of a witness `T` is used to create a new `TreasuryCap<T>` which is then used to mint a new `Coin<T>`.

```move
module book::simple_coin {

    /// Controls the supply of the Coin.
    public struct TreasuryCap<phantom T> has key, store {
        id: UID,
        total_supply: u64,
    }

    /// The Coin type where the `T` is a witness.
    public struct Coin<phantom T> has key, store {
        id: UID,
        value: u64,
    }

    /// Create a new TreasuryCap with a witness.
    /// Vulnerable: we can create multiple TreasuryCap<T> with the same witness.
    public fun new<T: drop>(_: T, ctx: &mut TxContext): TreasuryCap<T> {
        TreasuryCap { id: object::new(ctx), total_supply: 0 }
    }

    /// We use a regular witness to authorize the minting.
    public fun mint<T>(
        treasury: &mut TreasuryCap<T>,
        value: u64,
        ctx: &mut TxContext
    ) {
        treasury.total_supply = treasury.total_supply + value;
        Coin { id: object::new(ctx), value }
    }
}
```

A dishonest developer would be able to create multiple `TreasuryCap`s with the same witness, and mint more `Coin`s than expected. Here is an example of such a malicious module:

```move
module book::simple_coin_cheater {
    /// The Coin witness.
    public struct Move has drop {}

    /// Initialize the TreasuryCap with the Move witness.
    /// ...and do it twice! >_<
    fun init(ctx: &mut TxContext) {
        let treasury_cap = book::simple_coin::new(Move {}, ctx);
        let secret_treasury = book::simple_coin::new(Move {}, ctx);

        transfer::public_transfer(treasury_cap, ctx.sender())
        transfer::public_transfer(secret_treasury, ctx.sender())
    }
}

```

The example above has no protection against issuing multiple `TreasuryCap`s with the same witness, and in real-world application, this creates a problem of trust. If it was a human decision to support a Coin based on this implementation, they would have to make sure that:

- there is only one `TreasuryCap` for a given `T`.
- the module cannot be upgraded to issue more `TreasuryCap`s.
- the module code does not contain any backdoors to issue more `TreasuryCap`s.

However, it is not possible to check any of these conditions inside the Move code. And to prevent the need for trust, Sui introduces the OTW pattern.

## Solving the Coin Problem

To solve the case of multiple `TreasuryCap`s, we can use the OTW pattern. By defining the `COIN_OTW` type as an OTW, we can ensure that the `COIN_OTW` is used only once. The `COIN_OTW` is then used to create a new `TreasuryCap` and mint a new `Coin`.

```move

With

```move
module book::coin_otw {

    /// The OTW for the `book::coin_otw` module.
    struct COIN_OTW has drop {}

    /// Receive the instance of `COIN_OTW` as the first argument.
    fun init(otw: COIN_OTW, ctx: &mut TxContext) {
        let treasury_cap = book::simple_coin::new(COIN_OTW {}, ctx);
        transfer::public_transfer(treasury_cap, ctx.sender())
    }
}
```


 -->

<!-- ## Case Study: Coin

TODO: add a story behind TreasuryCap and Coin

-->

## Summary

The OTW pattern is a great way to ensure that a type is used only once. Most of the developers
should understand how to define and receive the OTW, while the OTW checks and enforcement is mostly
needed in libraries and frameworks. For example, the `sui::coin` module requires an OTW in the
`coin::create_currency` method, therefore enforcing that the `coin::TreasuryCap` is created only
once.

OTW is a powerful tool that lays the foundation for the [Publisher](./publisher) object, which we
will cover in the next section.

<!--

## Questions
- What other ways could be used to prevent multiple `TreasuryCap`s?
- Are there any other ways to use the OTW?

 -->

>>>> move-book/book/programmability/publisher.md
# Publisher Authority

In application design and development, it is often needed to prove publisher authority. This is
especially important in the context of digital assets, where the publisher may enable or disable
certain features for their assets. The Publisher Object is an object, defined in the
[Sui Framework](./sui-framework), that allows the publisher to prove their _authority over a type_.

## Definition

The Publisher object is defined in the `sui::package` module of the Sui Framework. It is a very
simple, non-generic object that can be initialized once per module (and multiple times per package)
and is used to prove the authority of the publisher over a type. To claim a Publisher object, the
publisher must present a [One Time Witness](./one-time-witness) to the `package::claim` function.

```move
module sui::package;

public struct Publisher has key, store {
    id: UID,
    package: String,
    module_name: String,
}
```

> If you're not familiar with the One Time Witness, you can read more about it
> [here](./one-time-witness).

Here's a simple example of claiming a `Publisher` object in a module:

```move file=packages/samples/sources/programmability/publisher.move anchor=publisher

```

## Usage

The Publisher object has two functions associated with it which are used to prove the publisher's
authority over a type:

```move file=packages/samples/sources/programmability/publisher.move anchor=use_publisher

```

## Publisher as Admin Role

For small applications or simple use cases, the Publisher object can be used as an admin
[capability](./capability). While in the broader context, the Publisher object has control over
system configurations, it can also be used to manage the application's state.

```move file=packages/samples/sources/programmability/publisher.move anchor=publisher_as_admin

```

However, Publisher misses some native properties of [Capabilities](./capability), such as type
safety and expressiveness. The signature for the `admin_action` is not very explicit, can be called
by anyone else. And due to `Publisher` object being standard, there is now a risk of unauthorized
access if the `from_module` check is not performed. So it's important to be cautious when using the
`Publisher` object as an admin role.

## Role on Sui

Publisher is required for certain features on Sui. [Object Display](./display) can be created only
by the Publisher, and TransferPolicy - an important component of the Kiosk system - also requires
the Publisher object to prove ownership of the type.

## Next Steps

In the next chapter we will cover the first feature that requires the Publisher object - Object
Display - a way to describe objects for clients, and standardize metadata. A must-have for
user-friendly applications.

>>>> move-book/book/programmability/randomness.md
# Randomness

<!--

- Every consensus commit a new random value is generated.
- Beginning of an epoch, validators create a global random value.
- One value is used to derive unique random value per transaction.
- Pseudo-random generator from a seed that is created once per epoch.

Qs:

- How does it work with consensus / parallel execution / fast path? works like a Clock
- Does it lose its unpredictability closer to the end of the epoch. no
- What is the UID of the Random object? 0x8
- 0x8 - Random - 8 is a lucky number
- Do we protect &mut access to 0x8

---

- RandomInner is updated.
- Every consensus commit the value inside is updated

---

- Developers call `new_generator` and pass in the global random object.
- ...which creates the RandomGenerator from the global seed with a fresh object ID.
- The RandomGenerator uses unknown unpredictable random bytes + fresh object UID from a transaction.

- then they use `generate_bytes` or `generate_u64` or any other integer. Or a value in a range.
- random shuffle of a vector.

Notes: pretty dope utility!

---

- 8 ball is a random number generator.


Difficulties:

- If you know the seed, then you can predict the random number.
- Random should not be used in a public function - predictable.
- Random failure is more expensive than a success scenario.
    - one way out is to first calculate randomness and then do a separate expensive operation.
    - they can set a limit to gas for failure scenarios, so the failure never happens.
    -

> `public entry` -> `entry` call
> there is a PTB attack on the Random object.

 -->

>>>> move-book/book/programmability/sui-framework.md
# Sui Framework

Sui Framework is a default dependency set in the [Package Manifest](./../concepts/manifest). It
depends on the [Standard Library](./../move-basics/standard-library) and provides Sui-specific
features, including the interaction with the storage, and Sui-specific native types and modules.

_For convenience, we grouped the modules in the Sui Framework into multiple categories. But they're
still part of the same framework._

## Core

<!-- Custom CSS addition in the theme/custom.css  -->
<div class="modules-table">

| Module                                                                                         | Description                                                             | Chapter                                                     |
| ---------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------- | ----------------------------------------------------------- |
| [sui::address](https://docs.sui.io/references/framework/sui/address)                           | Adds conversion methods to the [address type](./../move-basics/address) | [Address](./../move-basics/address)                         |
| [sui::transfer](https://docs.sui.io/references/framework/sui/transfer)                         | Implements the storage operations for Objects                           | [Storage Functions](./../storage/storage-functions.md)      |
| [sui::tx_context](https://docs.sui.io/references/framework/sui/tx_context)                     | Contains the `TxContext` struct and methods to read it                  | [Transaction Context](./transaction-context)                |
| [sui::object](https://docs.sui.io/references/framework/sui/object)                             | Defines the `UID` and `ID` type, required for creating objects          | [UID and ID](./../storage/uid-and-id.md)                    |
| [sui::derived_object](https://docs.sui.io/references/framework/sui/derived_object)             | Allows `UID` generation through key derivation                          | [UID Derivation](./../storage/uid-and-id.md#uid-derivation) |
| [sui::clock](https://docs.sui.io/references/framework/sui/clock)                               | Defines the `Clock` type and its methods                                | [Epoch and Time](./epoch-and-time)                          |
| [sui::dynamic_field](https://docs.sui.io/references/framework/sui/dynamic_field)               | Implements methods to add, use and remove dynamic fields                | [Dynamic Fields](./dynamic-fields)                          |
| [sui::dynamic_object_field](https://docs.sui.io/references/framework/sui/dynamic_object_field) | Implements methods to add, use and remove dynamic object fields         | [Dynamic Object Fields](./dynamic-object-fields)            |
| [sui::event](https://docs.sui.io/references/framework/sui/event)                               | Allows emitting events for off-chain listeners                          | [Events](./events)                                          |
| [sui::package](https://docs.sui.io/references/framework/sui/package)                           | Defines the `Publisher` type and package upgrade methods                | [Publisher](./publisher), Package Upgrades                  |
| [sui::display](https://docs.sui.io/references/framework/sui/display)                           | Implements the `Display` object and ways to create and update it        | [Display](./display)                                        |

</div>

## Collections

<div class="modules-table">

| Module                                                                         | Description                                                       | Chapter                                      |
| ------------------------------------------------------------------------------ | ----------------------------------------------------------------- | -------------------------------------------- |
| [sui::vec_set](https://docs.sui.io/references/framework/sui/vec_set)           | Implements a set type                                             | [Collections](./collections)                 |
| [sui::vec_map](https://docs.sui.io/references/framework/sui/vec_map)           | Implements a map with vector keys                                 | [Collections](./collections)                 |
| [sui::table](https://docs.sui.io/references/framework/sui/table)               | Implements the `Table` type and methods to interact with it       | [Dynamic Collections](./dynamic-collections) |
| [sui::linked_table](https://docs.sui.io/references/framework/sui/linked_table) | Implements the `LinkedTable` type and methods to interact with it | [Dynamic Collections](./dynamic-collections) |
| [sui::bag](https://docs.sui.io/references/framework/sui/bag)                   | Implements the `Bag` type and methods to interact with it         | [Dynamic Collections](./dynamic-collections) |
| [sui::object_table](https://docs.sui.io/references/framework/sui/object_table) | Implements the `ObjectTable` type and methods to interact with it | [Dynamic Collections](./dynamic-collections) |
| [sui::object_bag](https://docs.sui.io/references/framework/sui/object_bag)     | Implements the `ObjectBag` type and methods to interact with it   | [Dynamic Collections](./dynamic-collections) |

</div>

## Utilities

<div class="modules-table">

| Module                                                             | Description                                                | Chapter                                 |
| ------------------------------------------------------------------ | ---------------------------------------------------------- | --------------------------------------- |
| [sui::bcs](https://docs.sui.io/references/framework/sui/bcs)       | Implements the BCS encoding and decoding functions         | [Binary Canonical Serialization](./bcs) |
| [sui::borrow](https://docs.sui.io/references/framework/sui/borrow) | Implements the borrowing mechanic for borrowing by _value_ | [Hot Potato](./hot-potato-pattern)      |
| [sui::hex](https://docs.sui.io/references/framework/sui/hex)       | Implements the hex encoding and decoding functions         | -                                       |
| [sui::types](https://docs.sui.io/references/framework/sui/types)   | Provides a way to check if the type is a One-Time-Witness  | [One Time Witness](./one-time-witness)  |

</div>

## Exported Addresses

Sui Framework exports two named addresses: `sui = 0x2` and `std = 0x1` from the std dependency.

```toml
[addresses]
sui = "0x2"

# Exported from the MoveStdlib dependency
std = "0x1"
```

## Implicit Imports

Just like with [Standard Library](./../move-basics/standard-library#implicit-imports), some of the
modules and types are imported implicitly in the Sui Framework. This is the list of modules and
types that are available without explicit `use` import:

- sui::object
- sui::object::ID
- sui::object::UID
- sui::tx_context
- sui::tx_context::TxContext
- sui::transfer

## Source Code

The source code of the Sui Framework is available in the
[Sui repository](https://github.com/MystenLabs/sui/tree/main/crates/sui-framework/packages/sui-framework/sources).

<!--

Modules:

Coins:
- sui::pay
- sui::sui
- sui::coin
- sui::token
- sui::balance
- sui::deny_list

Commerce:
- sui::kiosk
- sui::display
- sui::kiosk_extension
- sui::transfer_policy


Utilities:
+ sui::bcs
+ sui::hex
- sui::math (deprecated)
+ sui::types
+ sui::borrow


- sui::authenticator

- sui::priority_queue
- sui::table_vec

- sui::url
- sui::versioned

- sui::prover
- sui::random

- sui::bls12381
- sui::ecdsa_k1
- sui::ecdsa_r1
- sui::ecvrf
- sui::ed25519
(also mention verifier 16 growth)
- sui::group_ops
- sui::hash
- sui::hmac
- sui::poseidon
- sui::zklogin_verified_id
- sui::zklogin_verified_issuer

 -->

>>>> move-book/book/programmability/transaction-context.md
# Transaction Context

Every transaction has the execution context. The context is a set of predefined variables that are
available to the program during execution. For example, every transaction has a sender address, and
the transaction context contains a variable that holds the sender address.

The transaction context is available to the program through the `TxContext` struct. The struct is
defined in the [`sui::tx_context`][tx-context-framework] module and contains the following fields:

[tx-context-framework]: https://docs.sui.io/references/framework/sui/tx_context

```move
module sui::tx_context;

/// Information about the transaction currently being executed.
/// This cannot be constructed by a transaction--it is a privileged object created by
/// the VM and passed in to the entrypoint of the transaction as `&mut TxContext`.
public struct TxContext has drop {
    /// The address of the user that signed the current transaction
    sender: address,
    /// Hash of the current transaction
    tx_hash: vector<u8>,
    /// The current epoch number
    epoch: u64,
    /// Timestamp that the epoch started at
    epoch_timestamp_ms: u64,
    /// Counter recording the number of fresh id's created while executing
    /// this transaction. Always 0 at the start of a transaction
    ids_created: u64
}
```

Transaction context cannot be constructed manually or directly modified. It is created by the system
and passed to the function as a reference in a transaction. Any function called in a
[Transaction](./../concepts/what-is-a-transaction) has access to the context and can pass it into
the nested calls.

> `TxContext` has to be the last argument in the function signature.

## Reading the Transaction Context

With only exception of the `ids_created`, all of the fields in the `TxContext` have getters. The
getters are defined in the `sui::tx_context` module and are available to the program. The getters
don't require `&mut` because they don't modify the context.

```move file=packages/samples/sources/programmability/transaction-context.move anchor=reading

```

## Mutability

The `TxContext` is required to create new objects (or just `UID`s) in the system. New UIDs are
derived from the transaction digest, and for the digest to be unique, there needs to be a changing
parameter. Sui uses the `ids_created` field for that. Every time a new UID is created, the
`ids_created` field is incremented by one. This way, the digest is always unique.

Internally, it is represented as the `derive_id` function:

```move
native fun derive_id(tx_hash: vector<u8>, ids_created: u64): address;
```

## Generating Unique Addresses

The underlying `derive_id` function can also be utilized in your program to generate unique
addresses. The function itself is not exposed, but a wrapper function `fresh_object_address` is
available in the `sui::tx_context` module. It may be useful if you need to generate a unique
identifier in your program.

```move
module sui::tx_context;

/// Create an `address` that has not been used. As it is an object address, it will never
/// occur as the address for a user.
/// In other words, the generated address is a globally unique object ID.
public fun fresh_object_address(ctx: &mut TxContext): address {
    let ids_created = ctx.ids_created;
    let id = derive_id(*&ctx.tx_hash, ids_created);
    ctx.ids_created = ids_created + 1;
    id
}
```

>>>> move-book/book/programmability/witness-pattern.md
# Pattern: Witness

Witness is a pattern of proving an existence by constructing a proof. In the context of programming,
witness is a way to prove a certain property of a system by providing a value that can only be
constructed if the property holds.

## Witness in Move

In the [Struct](./../move-basics/struct) section we have shown that a struct can only be created -
or _packed_ - by the module defining it. Hence, in Move, a module proves ownership of the type by
constructing it. This is one of the most important patterns in Move, and it is widely used for
generic type instantiation and authorization.

Practically speaking, for the witness to be used, there has to be a function that expects a witness
as an argument. In the example below it is the `new` function that expects a witness of the `T` type
to create a `Instance<T>` instance.

> It is often the case that the witness struct is not stored, and for that the function may require
> the [Drop](./../move-basics/drop-ability) ability for the type.

```move
module book::witness;

/// A struct that requires a witness to be created.
public struct Instance<T> { t: T }

/// Create a new instance of `Instance<T>` with the provided T.
public fun new<T>(witness: T): Instance<T> {
    Instance { t: witness }
}
```

The only way to construct an `Instance<T>` is to call the `new` function with an instance of the
type `T`. This is a basic example of the witness pattern in Move. A module providing a witness often
has a matching implementation, like the module `book::witness_source` below:

```move
module book::witness_source;

use book::witness::{Self, Instance};

/// A struct used as a witness.
public struct W {}

/// Create a new instance of `Instance<W>`.
public fun new_instance(): Instance<W> {
    witness::new(W {})
}
```

The instance of the struct `W` is passed into the `new_instance` function to create an
`Instance<W>`, thereby proving that the module `book::witness_source` owns the type `W`.

## Instantiating a Generic Type

Witness allows generic types to be instantiated with a concrete type. This is useful for inheriting
associated behaviors from the type with an option to extend them, if the module provides the ability
to do so.

```move
module sui::balance;

/// A Supply of T. Used for minting and burning.
public struct Supply<phantom T> has store {
    value: u64,
}

/// Create a new supply for type T with the provided witness.
public fun create_supply<T: drop>(_w: T): Supply<T> {
    Supply { value: 0 }
}

/// Get the `Supply` value.
public fun supply_value<T>(supply: &Supply<T>): u64 {
    supply.value
}
```

In the example above, which is borrowed from the [`balance` module][balance-framework] of the
[Sui Framework](./sui-framework), the `Supply` is a generic struct that can be constructed only by
supplying a witness of the type `T`. The witness is taken by value and _discarded_ - hence the `T`
must have the [drop](./../move-basics/drop-ability) ability.

[balance-framework]: https://docs.sui.io/references/framework/sui/balance

The instantiated `Supply<T>` can then be used to mint new `Balance<T>`'s, where `T` is the type of
the supply.

```move
module sui::balance;

const EOverflow: u64 = 0;

/// Storable balance.
public struct Balance<phantom T> has store {
    value: u64,
}

/// Increase supply by `value` and create a new `Balance<T>` with this value.
public fun increase_supply<T>(self: &mut Supply<T>, value: u64): Balance<T> {
    assert!(value < (std::u64::max_value!() - self.value), EOverflow);
    self.value = self.value + value;
    Balance { value }
}
```

## One Time Witness

While a struct can be created any number of times, there are cases where a struct should be
guaranteed to be created only once. For this purpose, Sui provides the "One-Time Witness" - a
special witness that can only be used once. We explain it in more detail in the
[next section](./one-time-witness).

## Summary

- Witness is a pattern of proving a certain property by constructing a proof.
- In Move, a module proves ownership of a type by constructing it.
- Witness is often used for generic type instantiation and authorization.

## Next Steps

In the next section, we will learn about the [One Time Witness](./one-time-witness) pattern.

>>>> move-book/book/programmability/wrapper-type-pattern.md
# Pattern: Wrapper type

Sometimes, there’s a need to create a new type that behaves similarly to an existing type but with
certain modifications or restrictions. For example, you might want to create a
[collection type](./collections) that behaves like a vector but doesn’t allow modifying the elements
after they’ve been inserted. The wrapper type pattern is an effective way to achieve this.

## Definition

The wrapper type pattern is a design pattern in which you create a new type that wraps an existing
type. The wrapper type is distinct from the original but can be converted to and from it.

Often, it is implemented as a positional struct with a single field.

```move file=packages/samples/sources/programmability/wrapper-type-pattern.move anchor=main

```

## Common Practices

In cases where the goal is to extend the behavior of an existing type, it is common to provide
accessors for the wrapped type. This approach allows users to access the underlying type directly
when needed. For example, in the following code, we provide the `inner()`, `inner_mut()`, and
`into_inner()` methods for the Stack type.

```move file=packages/samples/sources/programmability/wrapper-type-pattern.move anchor=common

```

## Advantages

The wrapper type pattern offers several benefits:

- Custom Functions: It allows you to define custom functions for an existing type.
- Robust Function Signatures: It constrains function signatures to the new type, thereby making the
  code more robust.
- Improved Readability: It often increases the readability of the code by providing a more
  descriptive type name.

## Disadvantages

The wrapper type pattern is powerful in two scenarios—when you want to limit the behavior of an
existing type while providing a custom interface to the same data structure, and when you want to
extend the behavior of an existing type. However, it does have some limitations:

- Verbosity: It can be verbose to implement, especially if you want to expose all the methods of the
  wrapped type.
- Sparse Implementation: The implementation can be quite minimal, as it often just forwards calls to
  the wrapped type.

## Next Steps

The wrapper type pattern is very useful, particularly when used in conjunction with collection
types, as demonstrated in the previous section. In the next section, we will cover
[Dynamic Fields](./dynamic-fields) — an important primitive that enables
[Dynamic Collections](./dynamic-collections), a way to store large collections of data in a more
flexible, albeit more expensive, way.

>>>> move-book/book/storage/index.md
# Using Objects

In the [Object Model][object-model] chapter, we introduced the shift in the Move language from an
account-based model to an object-based one. This chapter takes a closer look at that model. You’ll
learn how objects work and how to put them to use in your Sui applications.

If you haven’t read the [Object Model][object-model] chapter yet, we recommend starting there before
continuing.

[object-model]: ./../object

<!-- Mention what Sui Verifier is! Bytecode level verification. -->

>>>> move-book/book/storage/internal-constraint.md
# Sui Verifier: Internal Constraint

The Sui Bytecode Verifier enforces a set of rules on Move bytecode to ensure the safety of critical
storage operations. One of these rules is the _internal constraint_. It requires that the caller of
a function with a type parameter `T` must be the _defining module_ of that type. In other words, T
must be _internal_ to the module making the call.

This rule is not (yet) part of the Move language itself, which can make it feel opaque. Still, it’s
an important rule to understand, especially when working with storage-related operations on Sui.

Let’s look at an example from the [Sui Framework][sui-framework]. The emit function in the
[`sui::event`][event] module requires its type parameter `T` to be _internal_ to the caller:

```move
// An actual example of a function that enforces `internal` on `T`.
module sui::event;

// Sui Verifier will emit an error at compilation if this function is
// called from a module that does not define `T`.
public native fun emit<T: copy + drop>(event: T);
```

Here’s a correct call to `emit`. The type `A` is defined inside the module `exercise_internal`, so
it’s internal and valid:

```move
// Defines type `A`.
module book::exercise_internal;

use sui::event;

/// Type defined in this module, so it's internal here.
public struct A has copy, drop {}

// This works because `A` is defined locally.
public fun call_internal() {
    event::emit(A {})
}
```

But if you try to call `emit` with a type defined elsewhere, the verifier rejects it. For example,
this function, when added to the same module, fails because it tries to use the `TypeName` type from
the [Standard Library][move-stdlib]:

```move
// This one fails!
public fun call_foreign_fail() {
    use std::type_name;

    event::emit(type_name::get<A>());
    // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ Invalid event.
    // Error: `sui::event::emit` must be called with a type
    // defined in the current module.
}
```

Internal constraints only apply to certain functions in the [Sui Framework][sui-framework]. We’ll
return to this concept several times throughout the book.

[sui-framework]: ./../programmability/sui-framework.md
[move-stdlib]: ./../move-basics/standard-library.md
[event]: ./../programmability/events.md
[reflection]: ./../move-basics/type-reflection.md

>>>> move-book/book/storage/key-ability.md
# Ability: Key

In the [Basic Syntax][basic-syntax] chapter, we already covered two out of four abilities:
[Drop][drop-ability] and [Copy][copy-ability]. They affect the behavior of a value in a scope and
are not directly related to storage. Now it is time to cover the `key` ability, which allows a
struct to be _stored_.

Historically, the `key` ability was created to mark a type as a _key in storage_. A type with the
`key` ability could be stored at the top level in global storage and could be _owned_ by an account
or address. With the introduction of the [Object Model][object-model], the `key` ability became the
defining ability for _objects_.

> Later in the book, we will refer to any struct with the `key` ability as an Object.

## Object Definition

A struct with the `key` ability is considered _an object_ and can be used in storage functions. The
Sui Verifier requires the first field of the struct to be named `id` and to have the type `UID`.
Additionally, it requires all fields to have the `store` ability — we’ll explore it in detail [on
the next page][store-ability].

```move
/// `User` object definition.
public struct User has key {
    id: UID, // required by Sui Bytecode Verifier
    name: String, // field types must have `store`
}

/// Creates a new instance of the `User` type.
/// Uses the special struct `TxContext` to derive a Unique ID (UID).
public fun new(name: String, ctx: &mut TxContext): User {
    User {
        id: object::new(ctx), // creates a new UID
        name,
    }
}
```

## Relation to `copy` and `drop`

`UID` is a type that does not have the [`drop`][drop-ability] or [`copy`][copy-ability] abilities.
Since it is required as a field of any type with the `key` ability, this means that types with `key`
can never have `drop` or `copy`.

This property can be leveraged in [ability constraints][generics]: requiring `drop` or `copy`
automatically excludes `key`, and conversely, requiring `key` excludes types with `drop` or `copy`.

## Types with the `key` Ability

Due to the `UID` requirement for types with `key`, none of the native types in Move can have the
`key` ability, nor can any of the types in the [Standard Library][standard-library]. The `key`
ability is present only in some [Sui Framework][sui-framework] types and in custom types.

## Summary

- The `key` ability defines an object
- The first field of an object must be `id` with type `UID`
- Fields of a `key` type must the have [`store`][store-ability] ability
- Objects cannot have [`drop`][drop-ability] or [`copy`][copy-ability]

## Next Steps

The `key` ability defines objects in Move and forces the fields to have `store`. In the next section
we cover the `store` ability to later explain how [storage operations](./storage-functions.md) work.

## Further Reading

- [Type Abilities](./../../reference/abilities) in the Move Reference.

[drop-ability]: ./../move-basics/drop-ability
[copy-ability]: ./../move-basics/copy-ability
[store-ability]: ./store-ability.md
[generics]: ./../move-basics/generics#constraints-on-type-parameters
[sui-framework]: ./../programmability/sui-framework
[standard-library]: ./../move-basics/standard-library
[object-model]: ./../object
[basic-syntax]: ./../move-basics

>>>> move-book/book/storage/storage-functions.md
# Storage Functions

The module that defines main storage operations is `sui::transfer`. It is implicitly imported in all
packages that depend on the [Sui Framework](./../programmability/sui-framework), so, like other
implicitly imported modules (e.g. `std::option` or `std::vector`), it does not require adding a use
statement.

> For quick reference, [Appendix C: Transfer Functions](./../appendix/transfer-functions.md)
> contains a list of all storage functions and object states.

## Overview

The `transfer` module provides functions to perform storage operations for each of the
[ownership types](./../object/ownership).

1. [Transfer](#transfer) - send an object to an address, put it into _address owned_ state;
2. [Freeze](#freeze) - put an object into _immutable_ state, so it becomes a _public constant_ and
   can never change.
3. [Share](#share) - put an object into a _shared_ state, so it is available to everyone;

The `transfer` module is a go-to for most of the storage operations, except a special case with
[Dynamic Fields](./../programmability/dynamic-fields) which are covered in the next chapter.

## Ownership and References: a Quick Recap

In the [Ownership and Scope](./../move-basics/ownership-and-scope) and
[References](./../move-basics/references) chapters, we covered the basics of ownership and
references in Move. It is important that you understand these concepts when using storage functions.
Here is a quick recap of the most important points:

- The _move_ semantics in Move means that the value is _moved_ from one scope to another. In other
  words, if an instance of a type is passed to a function _by value_, it is _moved_ to the function
  scope and can't be accessed in the caller scope anymore.
- To maintain the ownership of the value, you can pass it _by reference_. Either by _immutable
  reference_ `&T` or _mutable reference_ `&mut T`. Then the value is _borrowed_ and can be accessed
  in the callee scope, however the owner stays the same.

```move
/// Moved by value
public fun take<T>(value: T) { /* value is moved here! */ abort }

/// For immutable reference, value stays in parent scope.
public fun borrow<T>(value: &T) { /* value is borrowed here! can be read */ abort }

/// For mutable reference, value stays in parent scope but can be mutated.
public fun borrow_mut<T>(value: &mut T) { /* value is mutably borrowed here! */ abort }
```

<!-- TODO part on:
    - object does not have an associated storage type
    - the same type of object can be stored differently
    - the objects must be specified in the transaction by their ID
 -->

## Internal Rule in Transfer Functions

Storage operations can only be performed on objects, and come in two forms: _internal_ and _public_.
Internal, or sometimes called _restricted_, transfer functions can be performed on [`key`][key]-only
types, and - comes with the name - enforce [internal constraint](./internal-constraint.md). Public
versions can be called on any object that has `key` and [`store`][store]. Hence, `key`-only types'
storage is fully governed by their defining module, and `store` allows calling public transfer
functions in other modules.

```move
/// T: internal, can be called only in the module which defines the `T`.
public fun transfer<T: key>(obj: T, recipient: address);

/// No requirement for `T` to be internal to the caller, but requires `store`.
public fun public_transfer<T: key + store>(obj: T, recipient: address);
```

In the example above, the `transfer` function can only be called from the module that defines the
`T`, and has a type constraint `T: key`. While `public_transfer` - clearly indicated in the name -
can be called from any module, but requires `T` to have `key` and `store`.

Knowing this rule is critical for understanding application design in Move. Choice between making
object publicly transferable (`key` and `store`) and keeping it internal (`key`-only) may
drastically affect application logic and further development.

## Transfer

The `transfer::transfer` function is a function used to transfer an object to an address. Its
signature is as follows, only accepts a type with the [`key` ability](./key-ability.md) and an
[address](./../move-basics/address.md) of the recipient. Note that the object is passed into the
function _by value_, therefore it is _moved_ to the function scope and then moved to the recipient
address.

```move
module sui::transfer;

// Transfer `obj` to `recipient`.
public fun transfer<T: key>(obj: T, recipient: address);

// Public version of the `transfer` function.
public fun public_transfer<T: key + store>(obj: T, recipient: address);
```

### Transfer Example

In the following example, you can see how it can be used in a module that defines and sends an
object to the transaction sender.

```move
module book::transfer_to_sender;

/// A struct with `key` is an object. The first field is `id: UID`!
public struct AdminCap has key { id: UID }

/// `init` function is a special function that is called when the module
/// is published. It is a good place to do a setup for an application.
fun init(ctx: &mut TxContext) {
    // Create a new `AdminCap` object, in this scope.
    let admin_cap = AdminCap { id: object::new(ctx) };

    // Transfer the object to the transaction sender.
    transfer::transfer(admin_cap, ctx.sender());
}

/// Transfers the `AdminCap` object to the `recipient`. Thus, the recipient
/// becomes the owner of the object, and only they can access it.
public fun transfer_admin_cap(cap: AdminCap, recipient: address) {
    transfer::transfer(cap, recipient);
}
```

When the module is published, the `init` function will get called, and the `AdminCap` object which
we created in it will be _transferred_ to the transaction sender. The `ctx.sender()` function
returns the sender address for the current transaction.

Once the `AdminCap` has been transferred to the sender, for example, to `0xa11ce`, the sender, and
only the sender, will be able to access the object. This type of ownership is called _address
ownership_.

> Address owned objects are a subject to _true ownership_ - only owner address can access them. This
> is a fundamental concept in the Sui storage model.

### Public Transfer

Let's extend the example with a function that uses `AdminCap` to authorize a mint of a new object
and its transfer to an address:

```move
/// Some `Gift` object that the admin can `mint_and_transfer` to an address.
public struct Gift has key, store { id: UID }

/// Creates a new `Gift` object and transfers it to the `recipient`.
public fun mint_and_transfer(
    _: &AdminCap, recipient: address, ctx: &mut TxContext
) {
    let gift = Gift { id: object::new(ctx) };
    transfer::public_transfer(gift, recipient);
}
```

The `mint_and_transfer` function is a _public_ function that "could" be called by anyone, but it
requires a reference to an `AdminCap` as the first argument. Without it, the function will not be
callable. This is a simple and very explicit way to restrict access to privileged functions called
_[Capability](./../programmability/capability)_. Because the `AdminCap` object is _address owned_,
only `0xa11ce` will be able to call the `mint_and_transfer` function.

Unlike `AdminCap` where we restricted transferability as well as usability by adding only `key`
ability, `Gift` has a `key` and `store` combination, which means, that whoever owns a `Gift` can
freely call `transfer::public_transfer` and send it to anyone else. Without `store`, in our current
implementation, `Gift` would've been _"soulbound"_ meaning that the happy owner of the `Gift` would
not be able to do anything with it.

### Quick Recap

- `transfer` function is used to send an object to an address;
- The object becomes _address owned_ and can only be accessed by the recipient;
- _Address owned_ object can be used by reference or by value, including being transferred to
  another address;
- _Public_ version of it is `public_transfer` and requires `store`
- Functions can be gated by requiring an object to be passed as an argument, creating a
  _capability_.

## Freeze

The `transfer::freeze_object` function is a function that is used to put an object into an
_immutable_ state. Once an object is _frozen_, it can never change, and it can be accessed by anyone
by immutable reference.

The function signature is as follows, only accepts a type with the [`key` ability](./key-ability).
Just like all other storage functions, it takes the object _by value_. The public version of this
function is `public_freeze_object`, and requires `T` to have `store`.

```move
module sui::transfer;

// Make object immutable and allow anyone to read it.
public fun freeze_object<T: key>(obj: T);

// Public version of the `freeze_object` function.
public fun public_freeze_object<T: key + store>(obj: T);
```

Let's extend the previous example and add a function that allows the admin to create a `Config`
object and freeze it:

```move
/// Some `Config` object that the admin can `create_and_freeze`.
public struct Config has key {
    id: UID,
    message: String
}

/// Creates a new `Config` object and freezes it.
public fun create_and_freeze(
    _: &AdminCap,
    message: String,
    ctx: &mut TxContext
) {
    let config = Config {
        id: object::new(ctx),
        message
    };

    // Freeze the object so it becomes immutable.
    transfer::freeze_object(config);
}

/// Returns the message from the `Config` object.
/// Can access the object by immutable reference!
public fun message(c: &Config): String { c.message }
```

Config is an object that has a `message` field, and the `create_and_freeze` function creates a new
`Config` and freezes it. Once the object is frozen, it can be accessed by anyone by immutable
reference. The `message` function is a public function that returns the message from the `Config`
object. Config is now publicly available by its ID, and the message can be read by anyone.

> Function definitions are not connected to object's state. It is possible to define a function that
> takes a mutable reference to a type that is always frozen. However, it will not be callable on a
> frozen object.

The `message` function in the example above can be called on an immutable `Config` object. However,
two functions shown below are not callable on a frozen object:

```move
// === These can't be called on a frozen object! ===

/// The function can be defined, but it won't be callable on a frozen object.
/// Only immutable references are allowed.
public fun message_mut(c: &mut Config): &mut String { &mut c.message }

/// Deletes the `Config` object, takes it by value.
/// Can't be called on a frozen object!
public fun delete_config(c: Config) {
    let Config { id, message: _ } = c;
    id.delete()
}
```

To summarize:

- `transfer::freeze_object` function is used to put an object into an _immutable_ state;
- Once an object is _frozen_, it can never be changed, deleted or transferred, and it can be
  accessed by anyone by immutable reference;
- _Public_ version of the `freeze_object` function is `public_freeze_object` and requires the `T` to
  have `store`.

## Owned -> Frozen

Since the `transfer::freeze_object` signature accepts any type with the `key` ability, it can take
an object that was created in the same scope, but it can also take an object that was owned by an
account. This means that the `freeze_object` function can be used to _freeze_ an object that was
_transferred_ to the sender. For security concerns, we would not want to freeze the `AdminCap`
object - it would be a security risk, since anyone would be able to access it. However, we can
freeze the `Gift` object that was minted and transferred to the recipient:

> Single Owner -> Immutable conversion is possible!

```move
/// Freezes the `Gift` object so it becomes immutable.
/// Gift has `key` and `store`, so `public_freeze_object` can be used!
public fun freeze_gift(gift: Gift) {
    transfer::public_freeze_object(gift);
}
```

## Share

The `transfer::share_object` function is a function used to put an object into a _shared_ state.
Once an object is _shared_, it can be accessed by anyone by a mutable reference (hence, immutable
too). The function signature is as follows, only accepts a type with the
[`key` ability](./key-ability):

```move
module sui::transfer;

/// Put an object to a Shared state - can be accessed mutably and immutably.
public fun share_object<T: key>(obj: T);

/// Public version of `share_object` function.
public fun public_share_object<T: key + store>(obj: T);
```

Like other transfer functions, `share_object` has its _public_ version which requires `T` to have
`store`.

Once an object is _shared_, it is publicly available as a mutable reference.

## Special Case: Shared Object Deletion

While the shared object can't normally be taken by value, there is one special case where it can -
if the function that takes it deletes the object. This is a special case in the Sui storage model,
and it is used to allow the deletion of shared objects. To show how it works, we will create a
function that creates and shares a Config object and then another one that deletes it:

```move
/// Creates a new `Config` object and shares it.
public fun create_and_share(message: String, ctx: &mut TxContext) {
    let config = Config {
        id: object::new(ctx),
        message
    };

    // Share the object so it becomes shared.
    transfer::share_object(config);
}
```

The `create_and_share` function creates a new `Config` object and shares it. The object is now
publicly available as a mutable reference. Let's create a function that deletes the shared object:

```move
/// Deletes the `Config` object, takes it by value.
/// Can be called on a shared object!
public fun delete_config(c: Config) {
    let Config { id, message: _ } = c;
    id.delete()
}
```

The `delete_config` function takes the `Config` object by value and deletes it, and the Sui Verifier
would allow this call. However, if the function returned the `Config` object back or attempted to
`freeze` or `transfer` it, the Sui Verifier would reject the transaction.

```move
// Won't work!
public fun transfer_shared(c: Config, to: address) {
    transfer::transfer(c, to);
}
```

To summarize:

- `share_object` function is used to put an object into a _shared_ state;
- Once an object is _shared_, it can be accessed by anyone by a mutable reference;
- Shared objects can be deleted, but they can't be transferred or frozen;
- _Public_ version of the `share_object` function is `public_share_object` and requires the `T` to
  have `store`.

## Next Steps

Now that you know main features of the `transfer` module, you can start building more complex
applications on Sui that involve storage operations. In the next chapter, we will cover the
[Store Ability](./store-ability) which allows storing data inside objects and relaxes transfer
restrictions which we barely touched on here. And after that we will cover the
[UID and ID](./uid-and-id) types which are the most important types in the Sui storage model.

[key]: ./key-ability.md
[store]: ./store-ability.md

>>>> move-book/book/storage/store-ability.md
# Ability: Store

The [`key` ability][key-ability] requires all fields to have `store`, which defines what the `store`
ability means: it is the ability to serve as a field of an Object. A struct with
[`copy`][copy-ability] or [`drop`][drop-ability] but without `store` can never be _stored_. A type
with `key` but without `store` cannot be wrapped - used as a field—in another object, and is
constrained to always remain at the top level.

## Definition

The `store` ability allows a type to be used as a field in a struct with the `key` ability.

```move
// hidden-block-start
use std::string::String;

// hidden-block-end
/// Extra metadata with `store`; all fields must have `store` as well!
public struct Metadata has store {
    bio: String,
}

/// An object for a single user record.
public struct User has key {
    id: UID,
    name: String,       // String has `store`
    age: u8,            // All integers have `store`
    metadata: Metadata, // Another type with the `store` ability
}
```

## Relation to `copy` and `drop`

All three non-`key` abilities can be used in any combination.

## Relation to `key`

An object with the `store` ability can be _stored_ in other objects.

> While not a language or verifier feature, `store` acts as a _public_ modifier on a struct,
> allowing calling _public_ [transfer functions](./storage-functions.md) which do not have an
> [internal constraint](./internal-constraint.md).

## Types with the `store` Ability

All native types (except references) in Move have the `store` ability. This includes:

- [bool](./../move-basics/primitive-types.md#booleans)
- [unsigned integers](./../move-basics/primitive-types.md#integer-types)
- [vector](./../move-basics/vector.md)
- [address](./../move-basics/address.md)

All of the types defined in the standard library have the `store` ability as well. This includes:

- [Option](./../move-basics/option.md)
- [String](./../move-basics/string.md) and [ASCII String](./../move-basics/string.md)
- [TypeName](./../move-basics/type-reflection.md)

## Further Reading

- [Type Abilities](./../../reference/abilities) in the Move Reference.

[key-ability]: ./key-ability.md
[drop-ability]: ./../move-basics/drop-ability.md
[copy-ability]: ./../move-basics/copy-ability.md

>>>> move-book/book/storage/transfer-restrictions.md
---
draft: true
---

<!-- This page is deprecated. Saving content for now, but should redirect to storage-functions -->

# Restricted and Public Transfer

Storage Operations that we described in the [previous sections](./storage-functions) are restricted
by default - they can only be called in the module defining the object. In other terms, the type
must be _internal_ to the module to be used in storage operations. This restriction is implemented
in the Sui Verifier and is enforced at the bytecode level.

However, to allow objects to be transferred and stored in other modules, these restrictions can be
relaxed. The `sui::transfer` module offers a set of _public\_\*_ functions that allow calling
storage operations in other modules. The functions are prefixed with `public_` and are available to
all modules and transactions.

## Public Storage Operations

The `sui::transfer` module provides the following public functions. They are almost identical to the
ones we already covered, but can be called from any module.

```move
module sui::transfer;

/// Public version of the `transfer` function.
public fun public_transfer<T: key + store>(object: T, to: address) {}

/// Public version of the `share_object` function.
public fun public_share_object<T: key + store>(object: T) {}

/// Public version of the `freeze_object` function.
public fun public_freeze_object<T: key + store>(object: T) {}
```

To illustrate the usage of these functions, consider the following example: module A defines an
ObjectK with `key` and ObjectKS with `key + store` abilities, and module B tries to implement a
`transfer` function for these objects.

> In this example we use `transfer::transfer`, but the behavior is identical for `share_object` and
> `freeze_object` functions.

```move
/// Defines `ObjectK` and `ObjectKS` with `key` and `key + store`
/// abilities respectively
module book::transfer_a;

public struct ObjectK has key { id: UID }
public struct ObjectKS has key, store { id: UID }
```

```move
/// Imports the `ObjectK` and `ObjectKS` types from `transfer_a` and attempts
/// to implement different `transfer` functions for them
module book::transfer_b;

// types are not internal to this module
use book::transfer_a::{ObjectK, ObjectKS};

// Fails! ObjectK is not `store`, and ObjectK is not internal to this module
public fun transfer_k(k: ObjectK, to: address) {
    transfer::transfer(k, to);
}

// Fails! ObjectKS has `store` but the function is not public
public fun transfer_ks(ks: ObjectKS, to: address) {
    transfer::transfer(ks, to);
}

// Fails! ObjectK is not `store`, `public_transfer` requires `store`
public fun public_transfer_k(k: ObjectK, to: address) {
    transfer::public_transfer(k, to);
}

// Works! ObjectKS has `store` and the function is public
public fun public_transfer_ks(ks: ObjectKS, to: address) {
    transfer::public_transfer(ks, to);
}
```

To expand on the example above:

- ❌ `transfer_k` fails because ObjectK is not internal to module `transfer_b`
- ❌ `transfer_ks` fails because ObjectKS is not internal to module `transfer_b`
- ❌ `public_transfer_k` fails because ObjectK does not have the `store` ability
- ✅ `public_transfer_ks` works because ObjectKS has the `store` ability and the transfer is public

## Implications of `store`

The decision on whether to add the `store` ability to a type should be made carefully. On one hand,
it is de-facto a requirement for the type to be _usable_ by other applications. On the other hand,
it allows _wrapping_ and changing the intended storage model. For example, a character may be
intended to be owned by accounts, but with the `store` ability it can be frozen (cannot be shared -
this transition is restricted).

>>>> move-book/book/storage/transfer-to-object.md
# Receiving as Object

[Address owned](./storage-functions.md#transfer) Object state supports two types of owners: an
account and another Object. If an object was transferred to another object, Sui provides a way to
_receive_ this object through its owner's [`UID`][uid].

> This feature is also known as _"Transfer to Object"_ or TTO.

## Definition

Receiving functionality is implemented in the [`sui::transfer`][transfer] module. It consists of a
special type `Receiving` which is instantiated through a special transaction argument, and the
`receive` function which takes a [`UID`][uid] of the parent.

> Currently, `T` in the `transfer::receive` is a subject to [Internal Constraint][internal]. Public
> version of `receive` is called `public_receive`, and like other [storage functions][storage-funs]
> it requires `T` to have [`store`][store].

```move
module sui::transfer;

// An ephemeral wrapper around `Receiving` argument. Provided as a special input
// in a Transaction Block.
// Note: this type should be explicitly imported to be used!
public struct Receiving<phantom T: key> has drop {
    id: ID,
    version: u64,
}

/// Receive `T` from parent `UID` through special type `Receiving`.
public fun receive<T: key>(parent: &mut UID, to_receive: Receiving<T>): T;
```

Due to the `UID` type requirement, receiving cannot be performed on an arbitrary object that does
not provide access or special receiving implementation. This feature should be used be used with
caution and in a controlled setting.

## Example

As an illustration for _transfer_ and _receive_ consider an example: `PostOffice` allows registering
Post Boxes and sending to accounts' post boxes.

```move file=packages/samples/sources/storage/transfer-to-object.move anchor=main

```

## Use Cases

Transferring to objects is a powerful feature which allows objects to act as owners of other
objects. One of the reasons to use it is the extra authorization performed upon receiving, eg the
`PostOffice` in the example above could charge a receiving fee.

- Allows parallel execution of transfers to multiple objects without referencing them in the
  transaction;
- Parent objects can also be transferred, acting as a container;
- PostBox-like applications, where user gets assets only after activating their account;
- Account abstraction-like applications where an object is mocking an account.

## Links

- [Transfer to Object](https://docs.sui.io/concepts/transfers/transfer-to-object) in Sui
  Documentation
- [`sui::transfer`][transfer] module documentation

[transfer]: https://docs.sui.io/references/framework/sui_sui/transfer
[key]: ./key-ability.md
[store]: ./store-ability.md
[uid]: ./uid-and-id.md
[internal]: ./internal-constraint.md

>>>> move-book/book/storage/uid-and-id.md
# UID and ID

The use of the `UID` type is required by the Sui Verifier on all types that have the
[`key`](./key-ability.md) ability. Here we go deeper into `UID` and its usage.

## Definition

The `UID` type is defined in the `sui::object` module and is a wrapper around an `ID` which, in
turn, wraps the `address` type. The UIDs on Sui are guaranteed to be unique, and can't be reused
after the object was deleted.

```move
module sui::object;

/// UID is a unique identifier of an object
public struct UID has store {
    id: ID
}

/// ID is a wrapper around an address
public struct ID has store, drop {
    bytes: address
}
```

## Fresh UID Generation

- `UID` is _derived_ from the `tx_hash` and an `index` which is incremented for each new UID.
- The `derive_id` function is implemented in the `sui::tx_context` module, and that is why
  [TxContext](./../programmability/transaction-context.md) is required for `UID` generation.
- Sui Verifier will not allow using a UID that wasn't created in the same function. That prevents
  UIDs from being pre-generated or reused after the object was unpacked.

New UID is created with the `object::new` function. It takes a mutable reference to `TxContext`, and
returns a new `UID`.

```move
public fun uid(ctx: &mut TxContext) {
  let id = object::new(ctx); // Create a fresh UID from TxContext.
  id.delete(); // Delete the UID.
}
```

`UID` acts as a representation of an object, and allows defining behaviors and features of an
object. One of the key features - [Dynamic Fields](./../programmability/dynamic-fields) - is
possible because of the `UID` type being explicit. Additionally, it allows receiving objects sent to
other objects. This feature is called [Transfer to Object (TTO)](./transfer-to-object.md), and we
will explain later in this chapter.

## UID Derivation

Sui allows deriving UID's from other UIDs using _derivation keys_. This functionality is implemented
in the [`sui::derived_object`][derived-object] module and allows generating predictable and
deterministic `UIDs` for easier off-chain discovery. UID for each pair of parent + key can be
generated only once!

```move
use sui::derived_object;

/// Some central application object.
public struct Base has key { id: UID }

/// Derived Object.
public struct Derived has key { id: UID }

/// Create and share a new Derived object using `address` as a `key`.
public fun derive(base: &mut Base, key: address) {
    let id = derived_object::claim(&mut base.id, key);
    transfer::share_object(Derived { id })
}
```

Derived addresses reduce the load on off-chain indexers, since it is enough to store the ID of the
parent object and get derived IDs using a derivation function. ID derivation function is part of the
most SDKs, and also present in Move:

```move
module sui::derived_object;

/// Checks if a UID was derived with `key` at `parent`.
public fun exists<K: copy + drop + store>(parent: &UID, key: K): bool;

/// Derive inner `address` of a UID, regardless of whether it was created.
public fun derive_address<K: copy + drop + store>(parent: ID, key: K): address;
```

The same derivation functionality is used to generate UIDs for
[dynamic fields](./../programmability/dynamic-fields.md).

## UID Lifecycle

The `UID` type is created with the `object::new` function, and deleted with the `object::delete`
function. The `object::delete` consumes the UID _by value_, hence, it is only possible to delete
object's UID after the object [was unpacked](./../move-basics/struct.md#unpacking-a-struct).

```move
public struct Character has key { id: UID }

public fun character(ctx: &mut TxContext) {
    // Instantiate `Character` object.
    let char = Character { id: object::new(ctx) };

    // Unpack object to get its UID.
    let Character { id } = char;

    // Delete the UID.
    id.delete();
}
```

## Keeping the UID

The `UID` does not need to be deleted immediately after the object struct is unpacked. Sometimes it
may carry [Dynamic Fields](./../programmability/dynamic-fields) or objects transferred to it via
[Transfer To Object](./transfer-to-object.md). In such cases, the UID may be kept and stored in a
separate object.

## Proof of Deletion

The ability to return the UID of an object may be utilized in pattern called _proof of deletion_. It
is a rarely used technique, but it may be useful in some cases, for example, the creator or an
application may incentivize the deletion of an object by exchanging the deleted IDs for some reward.

In framework development this method could be used to ignore / bypass certain restrictions on
"taking" the object. If there's a container that enforces certain logic on transfers, like Kiosk
does, there could be a special scenario of skipping the checks by providing a proof of deletion.

This is one of the open topics for exploration and research, and it may be used in various ways.

## ID

When talking about `UID` we should also mention the `ID` type. It is a wrapper around the `address`
type, and is used to represent an address-pointer. Usually, `ID` is used to point at an object,
however, there is no restriction, and no guarantee that the `ID` points to an existing object.

> ID can be received as a transaction argument in a
> [Transaction Block](./../concepts/what-is-a-transaction). Alternatively, ID can be created from an
> `address` value using `to_id()` function.

```move
public fun conversion_methods(ctx: &mut TxContext) {
    let uid: UID = object::new(ctx);
    let id: ID = uid.to_inner();

    let addr_from_uid: address = uid.to_address();
    let addr_from_id: address = id.to_address();

    uid.delete();
}
```

This example demonstrates different conversion methods: `UID.to_inner` creates a copy of underlying
`ID`, and `UID.to_address` returns inner address. Another often useful method `ID.to_address` copies
inner value from the `ID` type.

## Fresh Object Address

[`TxContext`](./../programmability/transaction-context.md) provides the `fresh_object_address`
function which can be utilized to create unique addresses and `ID` - it may be useful in some
application that assign unique identifiers to user actions - for example, an order_id in a
marketplace.

## Links

- [`sui::object`][object] module documentation
- [`sui::derived_object`][derived-object] module documentation
- [Derived Objects](https://docs.sui.io/concepts/sui-move-concepts/derived-objects) in Sui
  Documentation

[object]: https://docs.sui.io/references/framework/sui_sui/object
[derived-object]: https://docs.sui.io/references/framework/sui_sui/derived_object

>>>> move-book/book/your-first-move/hello-sui.md
# Hello, Sui!

In the [previous section](./hello-world) we created a new package and demonstrated the basic flow
of creating, building, and testing a Move package. In this section, we will write a simple
application that uses the storage model and can be interacted with. To do this, we will create a
simple todo list application.

## Create a New Package

Following the same flow as in [Hello, World!](./hello-world), we will create a new package called
`todo_list`.

```bash
$ sui move new todo_list
```

## Add the Code

To speed things up and focus on the application logic, we will provide the code for the todo list
application. Replace the contents of the _sources/todo_list.move_ file with the following code:

> Note: while the contents may seem overwhelming at first, we will break it down in the following
> sections. Try to focus on what's at hand right now.

```move file=packages/todo_list/sources/todo_list.move anchor=all

```

## Build the Package

To make sure that we did everything correctly, let's build the package by running the
`sui move build` command. If everything is correct, you should see the output similar to the
following:

```bash
$ sui move build
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING todo_list
```

If there are no errors following this output, you have successfully built the package. If there are
errors, make sure that:

- The code is copied correctly
- The file name and the package name is correct

There are not many other reasons for the code to fail at this stage. But if you are still having
issues, try looking up the structure of the package in
[this location](https://github.com/MystenLabs/move-book/tree/main/packages/todo_list).

## Set Up an Account

> If you already have an account set up, you can skip this step.

To publish and interact with the package, we need to set up an account. While developing, the best
option for doing so is to run your own
[Local Network](https://docs.sui.io/guides/developer/getting-started/local-network). For now you
just need to run `RUST_LOG="off,sui_node=info" sui start --with-faucet --force-regenesis`. The Sui
Local Network will run on port 9000 of your machine, so make sure that the port isn’t being used by
any other application.

If you are doing it for the first time, you will need to create a new account. To do this, run the
`sui client` command, then the CLI will prompt you with multiple questions. The answers are marked
below with `>`:

```bash
$ sui client
Config file ["/path/to/home/.sui/sui_config/client.yaml"] doesn't exist, do you want to connect to a Sui Full node server [y/N]?
> y
Sui Full node server URL (Defaults to Sui Testnet if not specified) :
> http://127.0.0.1:9000
Environment alias for [http://127.0.0.1:9000] :
> localnet
Select key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2: for secp256r1):
> 0
```

After you have answered the questions, the CLI will generate a new keypair and save it to the
configuration file. You can now use this account to interact with the network.

To check that we have the account set up correctly, run the `sui client active-address` command:

```bash
$ sui client active-address
0x....
```

The command will output the address of your account, it starts with `0x` followed by 64 characters.

## Requesting Coins

In _devnet_ and _testnet_ environments, the CLI provides a way to request coins to your account, so
you can interact with the network. To request coins, run the `sui client faucet` command:

```bash
$ sui client faucet
Request successful. It can take up to 1 minute to get the coin. Run sui client gas to check your gas coins.
```

After waiting a little bit, you can check that the Coin object was sent to your account by running
the `sui client balance` command:

```bash
$ sui client balance
╭────────────────────────────────────────╮
│ Balance of coins owned by this address │
├────────────────────────────────────────┤
│ ╭──────────────────────────────────╮   │
│ │ coin  balance (raw)  balance     │   │
│ ├──────────────────────────────────┤   │
│ │ Sui   1000000000    1.00 SUI     │   │
│ ╰──────────────────────────────────╯   │
╰────────────────────────────────────────╯
```

Alternatively, you can query _objects_ owned by your account, by running the `sui client objects`
command. The actual output will be different, because the object ID is unique, and so is digest, but
the structure will be similar:

```bash
$ sui client objects
╭───────────────────────────────────────────────────────────────────────────────────────╮
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de  │ │
│ │ version    │  4                                                                   │ │
│ │ digest     │  nA68oa8gab/CdIRw+240wze8u0P+sRe4vcisbENcR4U=                        │ │
│ │ objectType │  0x0000..0002::coin::Coin                                            │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
╰───────────────────────────────────────────────────────────────────────────────────────╯
```

Now that we have the account set up and the coins in the account, we can interact with the network.
We will start by publishing the package to the network.

## Publish

To publish the package to the network, we will use the `sui client publish` command. The command
will automatically build the package and use its bytecode to publish in a single transaction.

> We are using the `--gas-budget` argument during publishing. It specifies how much gas we are
> willing to spend on the transaction. We won't touch on this topic in this section, but it's
> important to know that every transaction in Sui costs gas, and the gas is paid in SUI coins.
> It is worth noting that `--gas-budget` is not a required parameter. When you do not set it,
> there will be a default consumption limit.

The `gas-budget` is specified in _MISTs_. 1 SUI equals 10^9 MISTs. For the sake of demonstration, we
will use 100,000,000 MISTs, which is 0.1 SUI.

```bash
# run this from the `todo_list` folder
$ sui client publish --gas-budget 100000000

# alternatively, you can specify path to the package
$ sui client publish --gas-budget 100000000 todo_list
```

The output of the publish command is rather lengthy, so we will show and explain it in parts.

```bash
$ sui client publish --gas-budget 100000000
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING todo_list
Successfully verified dependencies on-chain against source.
Transaction Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW
```

As you can see, when we run the `publish` command, the CLI first builds the package, then verifies
the dependencies on-chain, and finally publishes the package. The output of the command is the
transaction digest, which is a unique identifier of the transaction and can be used to query the
transaction status.

### Transaction Data

The section titled `TransactionData` contains the information about the transaction we just sent. It
features fields like `sender`, which is your address, the `gas_budget` set with the `--gas-budget`
argument, and the Coin we used for payment. It also prints the Commands that were run by the CLI. In
this example, the commands `Publish` and `TransferObject` were run - the latter transfers a special
object `UpgradeCap` to the sender.

```plaintext
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                             │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │
│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │
│ Gas Budget: 100000000 MIST                                                                                   │
│ Gas Price: 1000 MIST                                                                                         │
│ Gas Payment:                                                                                                 │
│  ┌──                                                                                                         │
│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                                    │
│  │ Version: 7                                                                                                │
│  │ Digest: AXYPnups8A5J6pkvLa6RekX2ye3qur66EZ88mEbaUDQ1                                                      │
│  └──                                                                                                         │
│                                                                                                              │
│ Transaction Kind: Programmable                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Input Objects                                                                                            │ │
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │
│ │ 0   Pure Arg: Type: address, Value: "0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1" │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│ ╭─────────────────────────────────────────────────────────────────────────╮                                  │
│ │ Commands                                                                │                                  │
│ ├─────────────────────────────────────────────────────────────────────────┤                                  │
│ │ 0  Publish:                                                             │                                  │
│ │  ┌                                                                      │                                  │
│ │  │ Dependencies:                                                        │                                  │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000001 │                                  │
│ │  │   0x0000000000000000000000000000000000000000000000000000000000000002 │                                  │
│ │  └                                                                      │                                  │
│ │                                                                         │                                  │
│ │ 1  TransferObjects:                                                     │                                  │
│ │  ┌                                                                      │                                  │
│ │  │ Arguments:                                                           │                                  │
│ │  │   Result 0                                                           │                                  │
│ │  │ Address: Input  0                                                    │                                  │
│ │  └                                                                      │                                  │
│ ╰─────────────────────────────────────────────────────────────────────────╯                                  │
│                                                                                                              │
│ Signatures:                                                                                                  │
│    gebjSbVwZwTkizfYg2XIuzdx+d66VxFz8EmVaisVFiV3GkDay6L+hQG3n2CQ1hrWphP6ZLc7bd1WRq4ss+hQAQ==                  │
│                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Transaction Effects

Transaction Effects contains the status of the transaction, the changes that the transaction made to
the state of the network and the objects involved in the transaction.

```plaintext
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: GpcDV6JjjGQMRwHpEz582qsd5MpCYgSwrDAq1JXcpFjW                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 411                                                                               │
│                                                                                                   │
│ Created Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 8                                                                                     │
│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                           │
│  └──                                                                                              │
│  ┌──                                                                                              │
│  │ ID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                         │
│  │ Owner: Immutable                                                                               │
│  │ Version: 1                                                                                     │
│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                           │
│  └──                                                                                              │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 8                                                                                     │
│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 8                                                                                     │
│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 10404400 MIST                                                                    │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 978120 MIST                                                                    │
│    Non-refundable Storage Fee: 9880 MIST                                                          │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    7Ukrc5GqdFqTA41wvWgreCdHn2vRLfgQ3YMFkdks72Vk                                                   │
│    7d4amuHGhjtYKujEs9YkJARzNEn4mRbWWv3fn4cdKdyh                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Events

If there were any _events_ emitted, you would see them in this section. Our package does not use
events, so the section is empty.

```plaintext
╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯
```

### Object Changes

These are the changes to _objects_ that transaction has made. In our case, we have _created_ a new
`UpgradeCap` object which is a special object that allows the sender to upgrade the package in the
future, _mutated_ the Gas object, and _published_ a new package. Packages are also objects on Sui.

```plaintext
╭──────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                   │
├──────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x160f7856e13b27e5a025112f361370f4efc2c2659cb0023f1e99a8a84d1652f3                  │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │
│  │ ObjectType: 0x2::package::UpgradeCap                                                          │
│  │ Version: 8                                                                                    │
│  │ Digest: 8y6bhwvQrGJHDckUZmj2HDAjfkyVqHohhvY1Fvzyj7ec                                          │
│  └──                                                                                             │
│ Mutated Objects:                                                                                 │
│  ┌──                                                                                             │
│  │ ObjectID: 0x4ea1303e4f5e2f65fc3709bc0fb70a3035fdd2d53dbcff33e026a50a742ce0de                  │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                    │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 ) │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                    │
│  │ Version: 8                                                                                    │
│  │ Digest: 7ydahjaM47Gyb33PB4qnW2ZAGqZvDuWScV6sWPiv7LTc                                          │
│  └──                                                                                             │
│ Published Objects:                                                                               │
│  ┌──                                                                                             │
│  │ PackageID: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe                 │
│  │ Version: 1                                                                                    │
│  │ Digest: Ein91NF2hc3qC4XYoMUFMfin9U23xQmDAdEMSHLae7MK                                          │
│  │ Modules: todo_list                                                                            │
│  └──                                                                                             │
╰──────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Balance Changes

This last section contains changes to SUI Coins, in our case, we have _spent_ around 0.015 SUI,
which in MIST is 10,500,000. You can see it under the _amount_ field in the output.

```plaintext
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: -10426280                                                                              │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

### Alternative Output

It is possible to specify the `--json` flag during publishing to get the output in JSON format. This
is useful if you want to parse the output programmatically or store it for later use.

```bash
$ sui client publish --gas-budget 100000000 --json
```

### Using the Results

After the package is published on chain, we can interact with it. To do this, we need to find the
address (object ID) of the package. It's under the `Published Objects` section of the
`Object Changes` output. The address is unique for each package, so you will need to copy it from
the output.

In this example, the address is:

```plaintext
0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe
```

Now that we have the address, we can interact with the package. In the next section, we will show
how to interact with the package by sending transactions.

## Sending Transactions

To demonstrate the interaction with the `todo_list` package, we will send a transaction to create a
new list and add an item to it. Transactions are sent via the `sui client ptb` command, it allows
using the [Transaction Blocks](./../concepts/what-is-a-transaction) at full capacity. The command
may look big and complex, but we go through it step by step.

### Prepare the Variables

Before we construct the command, let's store the values we will use in the transaction. Replace the
`0x4....` with the address of the package you have published. And `MY_ADDRESS` variable will be
automatically set to your address from the CLI output.

```bash
$ export PACKAGE_ID=0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe
$ export MY_ADDRESS=$(sui client active-address)
```

### Building the Transaction in CLI

Now to building an actual transaction. The transaction will consist of two parts: we will call the
`new` function in the `todo_list` package to create a new list, and then we will transfer the list
object to our account. The transaction will look like this:

```bash
$ sui client ptb \
--gas-budget 100000000 \
--assign sender @$MY_ADDRESS \
--move-call $PACKAGE_ID::todo_list::new \
--assign list \
--transfer-objects "[list]" sender
```

In this command, we are using the `ptb` subcommand to build a transaction. Parameters that follow it
define the actual commands and actions that the transaction will perform. The first two calls we
make are utility calls to set the sender address to the command inputs and set the gas budget for
the transaction.

```bash
# sets the gas budget for the transaction
--gas-budget 100000000 \n
# registers a variable "sender=@..."
--assign sender @$MY_ADDRESS \n
```

Then we perform the actual call to a function in the package. We use the `--move-call` followed by
the package ID, the module name, and the function name. In this case, we are calling the `new`
function in the `todo_list` package.

```bash
# calls the "new" function in the "todo_list" package under the $PACKAGE_ID address
--move-call $PACKAGE_ID::todo_list::new
```

The function that we defined actually returns a value, which we want to store. We use the
`--assign` command to give a name to the returned value. In this case, we are calling it `list`. And
then we transfer the object to our account.

```bash
--move-call $PACKAGE_ID::todo_list::new \
# assigns the result of the "new" function to the "list" variable (from the previous step)
--assign list \
# transfers the object to the sender
--transfer-objects "[list]" sender
```

Once the command is constructed, you can run it in the terminal. If everything is correct, you
should see the output similar to the one we had in previous sections. The output will contain the
transaction digest, the transaction data, and the transaction effects.

<details>
<summary><a>Spoiler: Full transaction output</a></summary>

```bash
Transaction Digest: BJwYEnuuMzU4Y8cTwMoJbbQA6cLwPmwxvsRpSmvThoK8
╭──────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Data                                                                                             │
├──────────────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                   │
│ Gas Owner: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                                │
│ Gas Budget: 100000000 MIST                                                                                  │
│ Gas Price: 1000 MIST                                                                                         │
│ Gas Payment:                                                                                                 │
│  ┌──                                                                                                         │
│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                                    │
│  │ Version: 22                                                                                               │
│  │ Digest: DiBrBMshDiD9cThpaEgpcYSF76uV4hCoE1qRyQ3rnYCB                                                      │
│  └──                                                                                                         │
│                                                                                                              │
│ Transaction Kind: Programmable                                                                               │
│ ╭──────────────────────────────────────────────────────────────────────────────────────────────────────────╮ │
│ │ Input Objects                                                                                            │ │
│ ├──────────────────────────────────────────────────────────────────────────────────────────────────────────┤ │
│ │ 0   Pure Arg: Type: address, Value: "0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1" │ │
│ ╰──────────────────────────────────────────────────────────────────────────────────────────────────────────╯ │
│ ╭──────────────────────────────────────────────────────────────────────────────────╮                         │
│ │ Commands                                                                         │                         │
│ ├──────────────────────────────────────────────────────────────────────────────────┤                         │
│ │ 0  MoveCall:                                                                     │                         │
│ │  ┌                                                                               │                         │
│ │  │ Function:  new                                                                │                         │
│ │  │ Module:    todo_list                                                          │                         │
│ │  │ Package:   0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe │                         │
│ │  └                                                                               │                         │
│ │                                                                                  │                         │
│ │ 1  TransferObjects:                                                              │                         │
│ │  ┌                                                                               │                         │
│ │  │ Arguments:                                                                    │                         │
│ │  │   Result 0                                                                    │                         │
│ │  │ Address: Input  0                                                             │                         │
│ │  └                                                                               │                         │
│ ╰──────────────────────────────────────────────────────────────────────────────────╯                         │
│                                                                                                              │
│ Signatures:                                                                                                  │
│    C5Lie4dtP5d3OkKzFBa+xM0BiNoB/A4ItthDCRTRBUrEE+jXeNs7mP4AuGwi3nzfTskh29+R1j1Kba4Wdy3QDA==                  │
│                                                                                                              │
╰──────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Transaction Effects                                                                               │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Digest: BJwYEnuuMzU4Y8cTwMoJbbQA6cLwPmwxvsRpSmvThoK8                                              │
│ Status: Success                                                                                   │
│ Executed Epoch: 1213                                                                              │
│                                                                                                   │
│ Created Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0x74973c4ea2e78dc409f60481e23761cee68a48156df93a93fbcceb77d1cacdf6                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 23                                                                                    │
│  │ Digest: DuHTozDHMsuA7cFnWRQ1Gb8FQghAEBaj3inasJxqYq1c                                           │
│  └──                                                                                              │
│ Mutated Objects:                                                                                  │
│  ┌──                                                                                              │
│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 23                                                                                    │
│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                           │
│  └──                                                                                              │
│ Gas Object:                                                                                       │
│  ┌──                                                                                              │
│  │ ID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ Version: 23                                                                                    │
│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                           │
│  └──                                                                                              │
│ Gas Cost Summary:                                                                                 │
│    Storage Cost: 2318000 MIST                                                                     │
│    Computation Cost: 1000000 MIST                                                                 │
│    Storage Rebate: 978120 MIST                                                                    │
│    Non-refundable Storage Fee: 9880 MIST                                                          │
│                                                                                                   │
│ Transaction Dependencies:                                                                         │
│    FSz2fYXmKqTf77mFXNq5JK7cKY8agWja7V5yDKEgL8c3                                                   │
│    GgMZKTt482DYApbAZkPDtdssGHZLbxgjm2uMXhzJax8Q                                                   │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
╭─────────────────────────────╮
│ No transaction block events │
╰─────────────────────────────╯

╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                        │
├───────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                      │
│  ┌──                                                                                                  │
│  │ ObjectID: 0x74973c4ea2e78dc409f60481e23761cee68a48156df93a93fbcceb77d1cacdf6                       │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │
│  │ ObjectType: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │
│  │ Version: 23                                                                                        │
│  │ Digest: DuHTozDHMsuA7cFnWRQ1Gb8FQghAEBaj3inasJxqYq1c                                               │
│  └──                                                                                                  │
│ Mutated Objects:                                                                                      │
│  ┌──                                                                                                  │
│  │ ObjectID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                       │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                         │
│  │ Version: 23                                                                                        │
│  │ Digest: 82fwKarGuDhtomr5oS6ZGNvZNw9QVXLSbPdQu6jQgNV7                                               │
│  └──                                                                                                  │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯
╭───────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Balance Changes                                                                                   │
├───────────────────────────────────────────────────────────────────────────────────────────────────┤
│  ┌──                                                                                              │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )  │
│  │ CoinType: 0x2::sui::SUI                                                                        │
│  │ Amount: -2339880                                                                               │
│  └──                                                                                              │
╰───────────────────────────────────────────────────────────────────────────────────────────────────╯
```

</details>

The section that we want to focus on is the "Object Changes". More specifically, the "Created
Objects" part of it. It contains the object ID, the type and the version of the `TodoList` that you
have created. We will use this object ID to interact with the list.

```bash
╭───────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ Object Changes                                                                                        │
├───────────────────────────────────────────────────────────────────────────────────────────────────────┤
│ Created Objects:                                                                                      │
│  ┌──                                                                                                  │
│  │ ObjectID: 0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                       │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │
│  │ ObjectType: 0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │
│  │ Version: 22                                                                                        │
│  │ Digest: HyWdUpjuhjLY38dLpg6KPHQ3bt4BqQAbdF5gB8HQdEqG                                               │
│  └──                                                                                                  │
│ Mutated Objects:                                                                                      │
│  ┌──                                                                                                  │
│  │ ObjectID: 0xe5ddeb874a8d7ead328e9f2dd2ad8d25383ab40781a5f1aefa75600973b02bc4                       │
│  │ Sender: 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1                         │
│  │ Owner: Account Address ( 0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1 )      │
│  │ ObjectType: 0x2::coin::Coin<0x2::sui::SUI>                                                         │
│  │ Version: 22                                                                                        │
│  │ Digest: DiBrBMshDiD9cThpaEgpcYSF76uV4hCoE1qRyQ3rnYCB                                               │
│  └──                                                                                                  │
╰───────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

In this example the object ID is
`0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553`. And the owner should be your
account address. We achieved this by transferring the object to the sender in the last command of
the transaction.

Another way to test that you have successfully created the list is to check the account objects.

```bash
$ sui client objects
```

It should have an object that looks similar to this:

```plaintext
╭  ...                                                                                  ╮
│ ╭────────────┬──────────────────────────────────────────────────────────────────────╮ │
│ │ objectId   │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │
│ │ version    │  22                                                                  │ │
│ │ digest     │  /DUEiCLkaNSgzpZSq2vSV0auQQEQhyH9occq9grMBZM=                        │ │
│ │ objectType │  0x468d..29fe::todo_list::TodoList                                   │ │
│ ╰────────────┴──────────────────────────────────────────────────────────────────────╯ │
|  ...                                                                                  |
```

### Passing Objects to Functions

The TodoList that we created in the previous step is an object that you can interact with as its
owner. You can call functions defined in the `todo_list` module on this object. To demonstrate this,
we will add an item to the list. First, we will add just one item, and in the second transaction we
will add 3 and remove another one.

Double check that you have variables set up [from the previous step](#prepare-the-variables), and
then add one more variable for the list object.

```bash
$ export LIST_ID=0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553
```

Now we can construct the transaction to add an item to the list. The command will look like this:

```bash
$ sui client ptb \
--gas-budget 100000000 \
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID "'Finish the Hello, Sui chapter'"
```

In this command, we are calling the `add` function in the `todo_list` package. The function takes
two arguments: the list object and the item to add. The item is a string, so we need to wrap it in
single quotes. The command will add the item to the list.

If everything is correct, you should see the output similar to the one we had in previous sections.
Now you can check the list object to see if the item was added.

```bash
$ sui client object $LIST_ID
```

The output should contain the item that you have added.

```plaintext
╭───────────────┬───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╮
│ objectId      │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553                                               │
│ version       │  24                                                                                                               │
│ digest        │  FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ                                                                     │
│ objType       │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList                          │
│ owner         │ ╭──────────────┬──────────────────────────────────────────────────────────────────────╮                           │
│               │ │ AddressOwner │  0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1  │                           │
│               │ ╰──────────────┴──────────────────────────────────────────────────────────────────────╯                           │
│ prevTx        │  EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1                                                                     │
│ storageRebate │  1558000                                                                                                          │
│ content       │ ╭───────────────────┬───────────────────────────────────────────────────────────────────────────────────────────╮ │
│               │ │ dataType          │  moveObject                                                                               │ │
│               │ │ type              │  0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList  │ │
│               │ │ hasPublicTransfer │  true                                                                                     │ │
│               │ │ fields            │ ╭───────┬───────────────────────────────────────────────────────────────────────────────╮ │ │
│               │ │                   │ │ id    │ ╭────┬──────────────────────────────────────────────────────────────────────╮ │ │ │
│               │ │                   │ │       │ │ id │  0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553  │ │ │ │
│               │ │                   │ │       │ ╰────┴──────────────────────────────────────────────────────────────────────╯ │ │ │
│               │ │                   │ │ items │ ╭─────────────────────────────────╮                                           │ │ │
│               │ │                   │ │       │ │  finish the Hello, Sui chapter  │                                           │ │ │
│               │ │                   │ │       │ ╰─────────────────────────────────╯                                           │ │ │
│               │ │                   │ ╰───────┴───────────────────────────────────────────────────────────────────────────────╯ │ │
│               │ ╰───────────────────┴───────────────────────────────────────────────────────────────────────────────────────────╯ │
╰───────────────┴───────────────────────────────────────────────────────────────────────────────────────────────────────────────────╯
```

A JSON representation of the object can be obtained by adding the `--json` flag to the command.

```bash
$ sui client object $LIST_ID --json
```

```json
{
  "objectId": "0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553",
  "version": "24",
  "digest": "FGcXH8MGpMs5BdTnC62CQ3VLAwwexYg2id5DKU7Jr9aQ",
  "type": "0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList",
  "owner": {
    "AddressOwner": "0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1"
  },
  "previousTransaction": "EJVK6FEHtfTdCuGkNsU1HcrmUBEN6H6jshfcptnw8Yt1",
  "storageRebate": "1558000",
  "content": {
    "dataType": "moveObject",
    "type": "0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList",
    "hasPublicTransfer": true,
    "fields": {
      "id": {
        "id": "0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553"
      },
      "items": ["Finish the Hello, Sui chapter"]
    }
  }
}
```

### Chaining Commands

You can chain multiple commands in a single transaction. This shows the power of Transaction Blocks!
Using the same list object, we will add three more items and remove one. The command will look like
this:

```bash
$ sui client ptb \
--gas-budget 100000000 \
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID "'Finish Concepts chapter'" \
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID "'Read the Move Basics chapter'" \
--move-call $PACKAGE_ID::todo_list::add @$LIST_ID "'Learn about Object Model'" \
--move-call $PACKAGE_ID::todo_list::remove @$LIST_ID 0
```

If previous commands were successful, this one should not be any different. You can check the list
object to see if the items were added and removed. The JSON representation is a bit more readable!

```bash
sui client object $LIST_ID --json
```

```json
{
  "objectId": "0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553",
  "version": "25",
  "digest": "EDTXDsteqPGAGu4zFAj5bbQGTkucWk4hhuUquk39enGA",
  "type": "0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList",
  "owner": {
    "AddressOwner": "0x091ef55506ad814920adcef32045f9078f2f6e9a72f4cf253a1e6274157380a1"
  },
  "previousTransaction": "7SXLGBSh31jv8G7okQ9mEgnw5MnTfvzzHEHpWf3Sa9gY",
  "storageRebate": "1922800",
  "content": {
    "dataType": "moveObject",
    "type": "0x468daa33dfcb3e17162bbc8928f6ec73744bb08d838d1b6eb94eac99269b29fe::todo_list::TodoList",
    "hasPublicTransfer": true,
    "fields": {
      "id": {
        "id": "0x20e0bede16de8a728ab25e228816b9059b45ebea49c8ad384e044580b2d3e553"
      },
      "items": [
        "Finish Concepts chapter",
        "Read the Move Basics chapter",
        "Learn about Object Model"
      ]
    }
  }
}
```

Commands don't have to be in the same package or operate on the same object. Within a single
transaction block, you can interact with multiple packages and objects. This is a powerful feature
that allows you to build complex interactions on-chain!

## Conclusion

In this guide, we have shown how to publish a package on the Move blockchain and interact with it
using the Sui CLI. We have demonstrated how to create a new list object, add items to it, and remove
them. We have also shown how to chain multiple commands in a single transaction block. This guide
should give you a good starting point for building your own applications on the Sui blockchain!

>>>> move-book/book/your-first-move/hello-world.md
# Hello, World!

In this chapter, you will learn how to create a new package, write a simple module, compile it, and
run tests with the Move CLI. Make sure you have [installed Sui](./../before-we-begin/install-sui.md)
and set up your [IDE environment](./../before-we-begin/ide-support.md). Run the command below to test
if Sui has been installed correctly.

```bash
# It should print the client version. E.g. sui-client 1.22.0-036299745.
sui client --version
```

> Move CLI is a command-line interface for the Move language; it is built into the Sui binary and
> provides a set of commands to manage packages, compile and test code.

The structure of the chapter is as follows:

- [Create a New Package](#create-a-new-package)
- [Directory Structure](#directory-structure)
- [Compiling the Package](#compiling-the-package)
- [Running Tests](#running-tests)

## Create a New Package

To create a new program, we will use the `sui move new` command followed by the name of the
application. Our first program will be called `hello_world`.

> Note: In this and other chapters, if you see code blocks with lines starting with `$` (dollar
> sign), it means that the following command should be run in a terminal. The sign should not be
> included. It's a common way of showing commands in terminal environments.

```bash
$ sui move new hello_world
```

The `sui move` command gives access to the Move CLI - a built-in compiler, test runner and a utility
for all things Move. The `new` command followed by the name of the package will create a new package
in a new folder. In our case, the folder name is "hello_world".

We can view the contents of the folder to see that the package was created successfully.

```bash
$ ls -l hello_world
Move.toml
sources
tests
```

## Directory Structure

Move CLI will create a scaffold of the application and pre-create the directory structure and all
necessary files. Let's see what's inside.

```plaintext
hello_world
├── Move.toml
├── sources
│   └── hello_world.move
└── tests
    └── hello_world_tests.move
```

### Manifest

The `Move.toml` file, known as the [package manifest](./../concepts/manifest.md), contains definitions
and configuration settings for the package. It is used by the Move Compiler to manage package
metadata, fetch dependencies, and register named addresses. We will explain it in detail in the
[Concepts](./../concepts/index.md) chapter.

> By default, the package features one named address - the name of the package.

```toml
[addresses]
hello_world = "0x0"
```

### Sources

The `sources/` directory contains the source files. Move source files have _.move_ extension, and
are typically named after the module defined in the file. For example, in our case, the file name is
_hello_world.move_ and the Move CLI has already placed commented out code inside:

```move
/*
/// Module: hello_world
module hello_world::hello_world;
*/
```

> The `/*` and `*/` are the comment delimiters in Move. Everything in between is ignored by the
> compiler and can be used for documentation or notes. We explain all ways to comment the code in
> the [Basic Syntax](./../move-basics/comments.md).

The commented out code is a module definition, it starts with the keyword `module` followed by a
named address (or an address literal), and the module name. The module name is a unique identifier
for the module and has to be unique within the package. The module name is used to reference the
module from other modules or transactions.

<!-- And the module name has to be a valid Move identifier: alphanumeric with underscores to separate words. A common convention is to call modules (and functions) in snake_case - all lowercase, with underscores. Coding conventions are important for readability and maintainability of the code, we summarize them in the Coding Conventions section. -->

### Tests

The `tests/` directory contains package tests. The compiler excludes these files in the regular
build process but uses them in _test_ and _dev_ modes. The tests are written in Move and are marked
with the `#[test]` attribute. Tests can be grouped in a separate module (then it's usually called
_module_name_tests.move_), or inside the module they're testing.

Modules, imports, constants and functions can be annotated with `#[test_only]`. This attribute is
used to exclude modules, functions or imports from the build process. This is useful when you want
to add helpers for your tests without including them in the code that will be published on chain.

The _hello_world_tests.move_ file contains a commented out test module template:

```move
/*
#[test_only]
module hello_world::hello_world_tests;
// uncomment this line to import the module
// use hello_world::hello_world;

const ENotImplemented: u64 = 0;

#[test]
fun test_hello_world() {
    // pass
}

#[test, expected_failure(abort_code = hello_world::hello_world_tests::ENotImplemented)]
fun test_hello_world_fail() {
    abort ENotImplemented
}
*/
```

### Other Folders

Additionally, Move CLI supports the `examples/` folder. The files there are treated similarly to the
ones placed under the `tests/` folder - they're only built in the _test_ and _dev_ modes. They are
to be examples of how to use the package or how to integrate it with other packages. The most
popular use case is for documentation purposes and library packages.

## Compiling the Package

Move is a compiled language, and as such, it requires the compilation of source files into Move
Bytecode. It contains only necessary information about the module, its members, and types, and
excludes comments and some identifiers (for example, for constants).

To demonstrate these features, let's replace the contents of the _sources/hello_world.move_ file
with the following:

```move file=packages/hello_world/sources/hello_world.move anchor=source
```

During compilation, the code is built, but not run. A compiled package only includes functions that
can be called by other modules or in a transaction. We will explain these concepts in the
[Concepts](./../concepts/index.md) chapter. But now, let's see what happens when we run the _sui move build_.

```bash
# run from the `hello_world` folder
$ sui move build

# alternatively, if you didn't `cd` into it
$ sui move build --path hello_world
```

It should output the following message on your console.

```plaintext
UPDATING GIT DEPENDENCY https://github.com/MystenLabs/sui.git
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING hello_world
```

During the compilation, Move Compiler automatically creates a build folder where it places all
fetched and compiled dependencies as well as the bytecode for the modules of the current package.

> If you're using a versioning system, such as Git, build folder should be ignored. For example, you
> should use a `.gitignore` file and add `build` to it.

## Running Tests

Before we get to testing, we should add a test. Move Compiler supports tests written in Move and
provides the execution environment. The tests can be placed in both the source files and in the
`tests/` folder. Tests are marked with the `#[test]` attribute and are automatically discovered by
the compiler. We explain tests in depth in the [Testing](./../move-basics/testing.md) section.

Replace the contents of the `tests/hello_world_tests.move` with the following content:

```move file=packages/hello_world/tests/hello_world_tests.move anchor=test
```

Here we import the `hello_world` module, and call its `hello_world` function to test that the output
is indeed the string "Hello, World!". Now, that we have tests in place, let's compile the package in
the test mode and run tests. Move CLI has the `test` command for this:

```bash
$ sui move test
```

The output should be similar to the following:

```plaintext
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING hello_world
Running Move unit tests
[ PASS    ] 0x0::hello_world_tests::test_hello_world
Test result: OK. Total tests: 1; passed: 1; failed: 0
```

If you're running the tests outside of the package folder, you can specify the path to the package:

```bash
$ sui move test --path hello_world
```

You can also run a single or multiple tests at once by specifying a string. All the tests names
containing the string will be run:

```bash
$ sui move test test_hello
```

## Next Steps

In this section, we explained the basics of a Move package: its structure, the manifest, the build,
and test flows. [On the next page](./hello-sui), we will write an application and see how the code
is structured and what the language can do.

## Further Reading

- [Package Manifest](./../concepts/manifest.md) section
- Package in [The Move Reference](./../../reference/packages)

>>>> move-book/packages/samples/sources/README.md
# Managing Samples

For every page in the book (under the `src/` directory), there is a `samples/` directory which contains the code samples for that page. The `samples/` directory is organized in the same way as the `src/` directory, with the same directory structure and file names.

## Rules

1. There's one Move file per page in the book.
2. The file name is the same as the page name (or similar for keywords).
3. The file can hold multiple modules.
4. The modules are named after the sub-sections of the page.
5. Anchors should be used to point to the specific code snippets in the Move file.

## Example

For example, the `src/basic-syntax/address.md` page has a corresponding `samples/guides/address.move` file. The file contains the code samples for the page, organized in modules named after the sub-sections of the page.

```bash
samples/
    basic-syntax/
        address.move
```

>>>> move-book/packages/samples/sources/hello-sui/README.md
# Hello Sui

This tutorial is packed as a separate package which you can find in the root of this repository.

>>>> move-book/reference/abilities.md
---
title: 'Abilities | Reference'
description: ''
---

# Abilities

Abilities are a typing feature in Move that control what actions are permissible for values of a
given type. This system grants fine grained control over the "linear" typing behavior of values, as
well as if and how values are used in storage (as defined by the specific deployment of Move, e.g.
the notion of storage for the blockchain). This is implemented by gating access to certain bytecode
instructions so that for a value to be used with the bytecode instruction, it must have the ability
required (if one is required at all—not every instruction is gated by an ability).

For Sui, `key` is used to signify an [object](./abilities/object). Objects are the basic unit of
storage where each object has a unique, 32-byte ID. `store` is then used to both indicate what data
can be stored inside of an object, and is also used to indicate what types can be transferred
outside of their defining module.

<!-- TODO future section on detailed walk through maybe. We have some examples at the end but it might be helpful to explain why we have precisely this set of abilities

If you are already somewhat familiar with abilities from writing Move programs, but are still confused as to what is going on, it might be helpful to skip to the [motivating walkthrough](#motivating-walkthrough) section to get an idea of what the system is setup in the way that it is. -->

## The Four Abilities

The four abilities are:

- [`copy`](#copy)
  - Allows values of types with this ability to be copied.
- [`drop`](#drop)
  - Allows values of types with this ability to be popped/dropped.
- [`store`](#store)
  - Allows values of types with this ability to exist inside a value in storage.
  - For Sui, `store` controls what data can be stored inside of an [object](./abilities/object).
    `store` also controls what types can be transferred outside of their defining module.
- [`key`](#key)
  - Allows the type to serve as a "key" for storage. Ostensibly this means the value can be a
    top-level value in storage; in other words, it does not need to be contained in another value to
    be in storage.
  - For Sui, `key` is used to signify an [object](./abilities/object).

### `copy`

The `copy` ability allows values of types with that ability to be copied. It gates the ability to
copy values out of local variables with the [`copy`](./variables#move-and-copy) operator and to copy
values via references with
[dereference `*e`](./primitive-types/references#reading-and-writing-through-references).

If a value has `copy`, all values contained inside of that value have `copy`.

### `drop`

The `drop` ability allows values of types with that ability to be dropped. By dropped, we mean that
value is not transferred and is effectively destroyed as the Move program executes. As such, this
ability gates the ability to ignore values in a multitude of locations, including:

- not using the value in a local variable or parameter
- not using the value in a [sequence via `;`](./variables#expression-blocks)
- overwriting values in variables in [assignments](./variables#assignments)
- overwriting values via references when
  [writing `*e1 = e2`](./primitive-types/references#reading-and-writing-through-references).

If a value has `drop`, all values contained inside of that value have `drop`.

### `store`

The `store` ability allows values of types with this ability to exist inside of a value in storage,
_but_ not necessarily as a top-level value in storage. This is the only ability that does not
directly gate an operation. Instead it gates the existence in storage when used in tandem with
`key`.

If a value has `store`, all values contained inside of that value have `store`.

For Sui, `store` serves double duty. It controls what values can appear inside of an
[object](/storage/store-ability), and what objects can be
[transferred](./abilities/object#transfer-rules) outside of their defining module.

### `key`

The `key` ability allows the type to serve as a key for storage operations as defined by the
deployment of Move. While it is specific per Move instance, it serves to gates all storage
operations, so in order for a type to be used with storage primitives, the type must have the `key`
ability.

If a value has `key`, all values contained inside of that value have `store`. This is the only
ability with this sort of asymmetry.

For Sui, `key` is used to signify an [object](./abilities/object).

## Builtin Types

All primitive, builtin types have `copy`, `drop`, and `store`.

- `bool`, `u8`, `u16`, `u32`, `u64`, `u128`, `u256`, and `address` all have `copy`, `drop`, and
  `store`.
- `vector<T>` may have `copy`, `drop`, and `store` depending on the abilities of `T`.
  - See [Conditional Abilities and Generic Types](#conditional-abilities-and-generic-types) for more
    details.
- Immutable references `&` and mutable references `&mut` both have `copy` and `drop`.
  - This refers to copying and dropping the reference itself, not what they refer to.
  - References cannot appear in global storage, hence they do not have `store`.

Note that none of the primitive types have `key`, meaning none of them can be used directly with
storage operations.

## Annotating Structs and Enums

To declare that a `struct` or `enum` has an ability, it is declared with `has <ability>` after the
datatype name and either before or after the fields/variants. For example:

```move file=packages/reference/sources/abilities.move anchor=annotating_datatypes

```

In this case: `Ignorable*` has the `drop` ability. `Pair*` and `MyVec*` both have `copy`, `drop`,
and `store`.

All of these abilities have strong guarantees over these gated operations. The operation can be
performed on the value only if it has that ability; even if the value is deeply nested inside of
some other collection!

As such: when declaring a struct’s abilities, certain requirements are placed on the fields. All
fields must satisfy these constraints. These rules are necessary so that structs satisfy the
reachability rules for the abilities given above. If a struct is declared with the ability...

- `copy`, all fields must have `copy`.
- `drop`, all fields must have `drop`.
- `store`, all fields must have `store`.
- `key`, all fields must have `store`.
  - `key` is the only ability currently that doesn’t require itself.

An enum can have any of these abilities with the exception of `key`, which enums cannot have because
they cannot be top-level values (objects) in storage. The same rules apply to fields of enum
variants as they do for struct fields though. In particular, if an enum is declared with the
ability...

- `copy`, all fields of all variants must have `copy`.
- `drop`, all fields of all variants must have `drop`.
- `store`, all fields of all variants must have `store`.
- `key`, is not allowed on enums as previously mentioned.

For example:

```move
// A struct without any abilities
public struct NoAbilities {}

public struct WantsCopy has copy {
    f: NoAbilities, // ERROR 'NoAbilities' does not have 'copy'
}

public enum WantsCopyEnum has copy {
    Variant1
    Variant2(NoAbilities), // ERROR 'NoAbilities' does not have 'copy'
}
```

and similarly:

```move
// A struct without any abilities
public struct NoAbilities {}

public struct MyData has key {
    f: NoAbilities, // Error 'NoAbilities' does not have 'store'
}

public struct MyDataEnum has store {
    Variant1,
    Variant2(NoAbilities), // Error 'NoAbilities' does not have 'store'
}
```

## Conditional Abilities and Generic Types

When abilities are annotated on a generic type, not all instances of that type are guaranteed to
have that ability. Consider this struct declaration:

<!-- file=packages/reference/sources/abilities.move anchor=conditional_abilities -->

```move
public struct Cup<T> has copy, drop, store, key { item: T }
```

It might be very helpful if `Cup` could hold any type, regardless of its abilities. The type system
can _see_ the type parameter, so it should be able to remove abilities from `Cup` if it _sees_ a
type parameter that would violate the guarantees for that ability.

This behavior might sound a bit confusing at first, but it might be more understandable if we think
about collection types. We could consider the builtin type `vector` to have the following type
declaration:

```move
vector<T> has copy, drop, store;
```

We want `vector`s to work with any type. We don't want separate `vector` types for different
abilities. So what are the rules we would want? Precisely the same that we would want with the field
rules above. So, it would be safe to copy a `vector` value only if the inner elements can be copied.
It would be safe to ignore a `vector` value only if the inner elements can be ignored/dropped. And,
it would be safe to put a `vector` in storage only if the inner elements can be in storage.

To have this extra expressiveness, a type might not have all the abilities it was declared with
depending on the instantiation of that type; instead, the abilities a type will have depends on both
its declaration **and** its type arguments. For any type, type parameters are pessimistically
assumed to be used inside of the struct, so the abilities are only granted if the type parameters
meet the requirements described above for fields. Taking `Cup` from above as an example:

- `Cup` has the ability `copy` only if `T` has `copy`.
- It has `drop` only if `T` has `drop`.
- It has `store` only if `T` has `store`.
- It has `key` only if `T` has `store`.

Here are examples for this conditional system for each ability:

### Example: conditional `copy`

```move
public struct NoAbilities {}
public struct S has copy, drop { f: bool }
public struct Cup<T> has copy, drop, store { item: T }

fun example(c_x: Cup<u64>, c_s: Cup<S>) {
    // Valid, 'Cup<u64>' has 'copy' because 'u64' has 'copy'
    let c_x2 = copy c_x;
    // Valid, 'Cup<S>' has 'copy' because 'S' has 'copy'
    let c_s2 = copy c_s;
}

fun invalid(c_account: Cup<signer>, c_n: Cup<NoAbilities>) {
    // Invalid, 'Cup<signer>' does not have 'copy'.
    // Even though 'Cup' was declared with copy, the instance does not have 'copy'
    // because 'signer' does not have 'copy'
    let c_account2 = copy c_account;
    // Invalid, 'Cup<NoAbilities>' does not have 'copy'
    // because 'NoAbilities' does not have 'copy'
    let c_n2 = copy c_n;
}
```

### Example: conditional `drop`

```move
public struct NoAbilities {}
public struct S has copy, drop { f: bool }
public struct Cup<T> has copy, drop, store { item: T }

fun unused() {
    Cup<bool> { item: true }; // Valid, 'Cup<bool>' has 'drop'
    Cup<S> { item: S { f: false }}; // Valid, 'Cup<S>' has 'drop'
}

fun left_in_local(c_account: Cup<signer>): u64 {
    let c_b = Cup<bool> { item: true };
    let c_s = Cup<S> { item: S { f: false }};
    // Valid return: 'c_account', 'c_b', and 'c_s' have values
    // but 'Cup<signer>', 'Cup<bool>', and 'Cup<S>' have 'drop'
    0
}

fun invalid_unused() {
    // Invalid, Cannot ignore 'Cup<NoAbilities>' because it does not have 'drop'.
    // Even though 'Cup' was declared with 'drop', the instance does not have 'drop'
    // because 'NoAbilities' does not have 'drop'
    Cup<NoAbilities> { item: NoAbilities {} };
}

fun invalid_left_in_local(): u64 {
    let n = Cup<NoAbilities> { item: NoAbilities {} };
    // Invalid return: 'c_n' has a value
    // and 'Cup<NoAbilities>' does not have 'drop'
    0
}
```

### Example: conditional `store`

```move
public struct Cup<T> has copy, drop, store { item: T }

// 'MyInnerData is declared with 'store' so all fields need 'store'
struct MyInnerData has store {
    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'
    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'
}

// 'MyData' is declared with 'key' so all fields need 'store'
struct MyData has key {
    yes: Cup<u64>, // Valid, 'Cup<u64>' has 'store'
    inner: Cup<MyInnerData>, // Valid, 'Cup<MyInnerData>' has 'store'
    // no: Cup<signer>, Invalid, 'Cup<signer>' does not have 'store'
}
```

### Example: conditional `key`

```move
public struct NoAbilities {}
public struct MyData<T> has key { f: T }

fun valid(addr: address) acquires MyData {
    // Valid, 'MyData<u64>' has 'key'
    transfer(addr, MyData<u64> { f: 0 });
}

fun invalid(addr: address) {
   // Invalid, 'MyData<NoAbilities>' does not have 'key'
   transfer(addr, MyData<NoAbilities> { f: NoAbilities {} })
   // Invalid, 'MyData<NoAbilities>' does not have 'key'
   borrow<NoAbilities>(addr);
   // Invalid, 'MyData<NoAbilities>' does not have 'key'
   borrow_mut<NoAbilities>(addr);
}

// Mock storage operation
native public fun transfer<T: key>(addr: address, value: T);
```

>>>> move-book/reference/abilities/object.md
---
title: 'Sui Object | Reference'
---

# Sui Objects

For Sui, `key` is used to signify an _object_. Objects the only way to store data in Sui--allowing
the data to persist between transactions.

For more details, see the Sui documentation on

- [The Object Model](https://docs.sui.io/concepts/object-model)
- [Move Rules for Objects](https://docs.sui.io/concepts/sui-move-concepts#global-unique)
- [Transferring Objects](https://docs.sui.io/concepts/transfers)

## Object Rules

An object is a [`struct`](../structs.md) with the [`key`](../abilities.md#key) ability. The first
field of the struct must be `id: sui::object::UID`. This 32-byte field (a strongly typed wrapper
around an [`address`](../primitive-types/address.md)) is then used to uniquely identify the object.

Note that since `sui::object::UID` has only the `store` ability (it does not have `copy` or `drop`),
no object has `copy` or `drop`.

## Transfer Rules

Objects can be have their ownership changed and transferred in the `sui::transfer` module. Many
functions in the module have "public" and "private" variant, where the "private" variant can only be
called inside of the module that defines the object's type. The "public" variants can be called only
if the object has `store`.

For example if we had two objects `A` and `B` defined in the module `my_module`:

```move
module a::my_module;

public struct A has key {
    id: sui::object::UID,
}

public struct B has key, store {
    id: sui::object::UID,
}
```

`A` can only be transferred using the `sui::transfer::transfer` inside of `a::my_module`, while `B`
can be transferred anywhere using `sui::transfer::public_transfer`. These rules are enforced by a
custom type system (bytecode verifier) rule in Sui.

>>>> move-book/reference/abort-and-assert.md
---
title: 'Abort and Assert | Reference'
description: ''
---

# Abort and Assert

[`return`](./functions) and `abort` are two control flow constructs that end execution, one for the
current function and one for the entire transaction.

More information on [`return` can be found in the linked section](./functions#return-expression)

## `abort`

`abort` is an expression that takes either takes no arguments, or just one - an **abort code** of
type `u64`. For example:

```move
abort
abort 42
```

The `abort` expression halts execution the current function and reverts all changes made to state by
the current transaction (note though that this guarantee must be upheld by the adapter of the
specific deployment of Move). There is no mechanism for "catching" or otherwise handling an `abort`.

Luckily, in Move transactions are all or nothing, meaning any changes to storage are made all at
once only if the transaction succeeds. For Sui, this means no objects are modified.

Because of this transactional commitment of changes, after an abort there is no need to worry about
backing out changes. While this approach is lacking in flexibility, it is incredibly simple and
predictable.

Similar to [`return`](./functions), `abort` is useful for exiting control flow when some condition
cannot be met.

In this example, the function will pop two items off of the vector, but will abort early if the
vector does not have two items

<!-- {{#include ../../packages/reference/sources/abort-and-assert.move}} -->

```move
fun pop_twice<T>(v: &mut vector<T>): (T, T) {
    if (v.length() < 2) abort 42;
    (v.pop_back(), v.pop_back())
}
```

This is even more useful deep inside a control-flow construct. For example, this function checks
that all numbers in the vector are less than the specified `bound`. And aborts otherwise

```move
fun check_vec(v: &vector<u64>, bound: u64) {
    let mut i = 0;
    let n = v.length();
    while (i < n) {
        let cur = v[i];
        if (cur > bound) abort 42;
        i = i + 1;
    }
}
```

> Combine `macro` with `abort`:

```move
fun check_vec(v: &vector<u64>, bound: u64) {
    v.do_ref!(|num| if (*num > bound) abort 42);
}
```

### `assert`

`assert` is a builtin, macro operation provided by the Move compiler. It takes two arguments, a
condition of type `bool` and a code of type `u64`

```move
assert!(condition: bool, code: u64)
```

Since the operation is a macro, it must be invoked with the `!`. This is to convey that the
arguments to `assert` are call-by-expression. In other words, `assert` is not a normal function and
does not exist at the bytecode level. It is replaced inside the compiler with

```move
if (condition) () else abort code
```

`assert` is more commonly used than just `abort` by itself. The `abort` examples above can be
rewritten using `assert`

```move
fun pop_twice<T>(v: &mut vector<T>): (T, T) {
    assert!(v.length() >= 2, 42); // Now uses 'assert'
    (v.pop_back(), v.pop_back())
}
```

and

```move
fun check_vec(v: &vector<u64>, bound: u64) {
    let mut i = 0;
    let n = v.length();
    while (i < n) {
        let cur = v[i];
        assert!(cur <= bound, 42); // Now uses 'assert'
        i = i + 1;
    }
}
```

> Combine `macro` with `assert`:

```move
fun check_vec(v: &vector<u64>, bound: u64) {
    v.do_ref!(|num| assert!(*num <= bound, 42));
}
```

Note that because the operation is replaced with this `if-else`, the argument for the `code` is not
always evaluated. For example:

```move
assert!(true, 1 / 0)
```

Will not result in an arithmetic error, it is equivalent to

```move
if (true) () else abort (1 / 0)
```

So the arithmetic expression is never evaluated!

### Abort codes in the Move VM

When using `abort`, it is important to understand how the `u64` code will be used by the VM.

Normally, after successful execution, the Move VM, and the adapter for the specific deployment,
determine the changes made to storage.

If an `abort` is reached, the VM will instead indicate an error. Included in that error will be two
pieces of information:

- The module that produced the abort (package/address value and module name)
- The abort code.

For example

```move
module 0x2::example {
    public fun aborts() {
        abort 42
    }
}

module 0x3::invoker {
    public fun always_aborts() {
        0x2::example::aborts()
    }
}
```

If a transaction, such as the function `always_aborts` above, calls `0x2::example::aborts`, the VM
would produce an error that indicated the module `0x2::example` and the code `42`.

This can be useful for having multiple aborts being grouped together inside a module.

In this example, the module has two separate error codes used in multiple functions

```move
module 0::example;

use std::vector;

const EEmptyVector: u64 = 0;
const EIndexOutOfBounds: u64 = 1;

// move i to j, move j to k, move k to i
public fun rotate_three<T>(v: &mut vector<T>, i: u64, j: u64, k: u64) {
    let n = v.length();
    assert!(n > 0, EEmptyVector);
    assert!(i < n, EIndexOutOfBounds);
    assert!(j < n, EIndexOutOfBounds);
    assert!(k < n, EIndexOutOfBounds);

    v.swap(i, k);
    v.swap(j, k);
}

public fun remove_twice<T>(v: &mut vector<T>, i: u64, j: u64): (T, T) {
    let n = v.length();
    assert!(n > 0, EEmptyVector);
    assert!(i < n, EIndexOutOfBounds);
    assert!(j < n, EIndexOutOfBounds);
    assert!(i > j, EIndexOutOfBounds);

    (v.remove(i), v.remove(j))
}
```

## The type of `abort`

The `abort i` expression can have any type! This is because both constructs break from the normal
control flow, so they never need to evaluate to the value of that type.

The following are not useful, but they will type check

```move
let y: address = abort 0;
```

This behavior can be helpful in situations where you have a branching instruction that produces a
value on some branches, but not all. For example:

```move
let b =
    if (x == 0) false
    else if (x == 1) true
    else abort 42;
//       ^^^^^^^^ `abort 42` has type `bool`
```

>>>> move-book/reference/abort-and-assert/clever-errors.md
---
title: 'Clever Errors | Reference'
description:
  Clever errors are a feature that allows for more informative error messages when an assertion
  fails or an abort is raised
---

# Clever Errors

Clever errors are a feature that allows for more informative error messages when an assertion fails
or an abort is raised. They are a source feature and compile to a `u64` abort code value that
contains the information needed to access the line number, constant name, and constant value given
the clever error code and the module that the clever error constant was declared in. Because of this
compilation, post-processing is required to go from the `u64` abort code value to a human-readable
error message. The post-processing is automatically performed by the Sui GraphQL server, as well as
the Sui CLI. If you want to manually decode a clever abort code, you can use the process outlined in
[Inflating Clever Abort Codes](#inflating-clever-abort-codes) to do so.

> Clever errors include source line information amongst other data. Because of this their value may
> change due to any changes in the source file (e.g., due to auto-formatting, adding a new module
> member, or adding a newline).

## Clever Abort Codes

Clever abort codes allow you to use non-u64 constants as abort codes as long as the constants are
annotated with the `#[error]` attribute. They can be used both in assertions, and as codes to
`abort`.

```move
module 0x42::a_module;

#[error]
const EIsThree: vector<u8> = b"The value is three";

// Will abort with `EIsThree` if `x` is 3
public fun double_except_three(x: u64): u64 {
    assert!(x != 3, EIsThree);
    x * x
}

// Will always abort with `EIsThree`
public fun clever_abort() {
    abort EIsThree
}
```

In this example, the `EIsThree` constant is a `vector<u8>`, which is not a `u64`. However, the
`#[error]` attribute allows the constant to be used as an abort code, and will at runtime produce a
`u64` abort code value that holds:

1. A set tag-bit that indicates that the abort code is a clever abort code.
2. The line number of where the abort occurred in the source file (e.g., 7).
3. The index in the module's identifier table for the constant's name (e.g., `EIsThree`).
4. The index of the constant's value in the module's constant table (e.g., `b"The value is three"`).

In hex, if `double_except_three(3)` is called, it will abort with a `u64` abort code as follows:

```
0x8000_0007_0001_0000
  ^       ^    ^    ^
  |       |    |    |
  |       |    |    |
  |       |    |    +-- Constant value index = 0 (b"The value is three")
  |       |    +-- Constant name index = 1 (EIsThree)
  |       +-- Line number = 7 (line of the assertion)
  +-- Tag bit = 0b1000_0000_0000_0000
```

And could be rendered as a human-readable error message as (e.g.)

```
Error from '0x42::a_module::double_except_three' (line 7), abort 'EIsThree': "The value is three"
```

The exact formatting of this message may vary depending on the tooling used to decode the clever
error however all of the information needed to generate a human-readable error message like the
above is present in the `u64` abort code when coupled with the module where the error occurred.

> Clever abort code values do _not_ need to be a `vector<u8>` -- it can be any valid constant type
> in Move.

## Assertions with no Abort Codes

Assertions and `abort` statements without an abort code will automatically derive an abort code from
the source line number and will be encoded in the clever error format with the constant name and
constant value information will be filled with sentinel values of `0xffff` each. E.g.,

```move
module 0x42::a_module;

#[test]
fun assert_false(x: bool) {
    assert!(false);
}

#[test]
fun abort_no_code() {
    abort
}
```

Both of these will produce a `u64` abort code value that holds:

1. A set tag-bit that indicates that the abort code is a clever abort code.
2. The line number of where the abort occurred in the source file (e.g., 6).
3. A sentinel value of `0xffff` for the index into the module's identifier table for the constant's
   name.
4. A sentinel value of `0xffff` for the index of the constant's value in the module's constant
   table.

In hex, if `assert_false(3)` is called, it will abort with a `u64` abort code as follows:

```
0x8000_0004_ffff_ffff
  ^       ^    ^    ^
  |       |    |    |
  |       |    |    |
  |       |    |    +-- Constant value index = 0xffff (sentinel value)
  |       |    +-- Constant name index = 0xffff (sentinel value)
  |       +-- Line number = 4 (link of the assertion)
  +-- Tag bit = 0b1000_0000_0000_0000
```

## Clever Errors and Macros

The line number information in clever abort codes are derived from the source file at the location
where the abort occurs. In particular, for a function this will be the line number within in the
function, however for macros, this will be the location where the macro is invoked. This can be
quite useful when writing macros as it provides a way for users to use macros that may raise abort
conditions and still get useful error messages.

```move
module 0x42::macro_exporter;

public macro fun assert_false() {
    assert!(false);
}

public macro fun abort_always() {
    abort
}

public fun assert_false_fun() {
    assert!(false); // Will always abort with the line number of this invocation
}

public fun abort_always_fun() {
    abort // Will always abort with the line number of this invocation
}
```

Then in a module that uses these macros:

```move
module 0x42::user_module;

use 0x42::macro_exporter::{
    assert_false,
    abort_always,
    assert_false_fun,
    abort_always_fun
};

fun invoke_assert_false() {
    assert_false!(); // Will abort with the line number of this invocation
}

fun invoke_abort_always() {
    abort_always!(); // Will abort with the line number of this invocation
}

fun invoke_assert_false_fun() {
    assert_false_fun(); // Will abort with the line number of the assertion in `assert_false_fun`
}

fun invoke_abort_always_fun() {
    abort_always_fun(); // Will abort with the line number of the `abort` in `abort_always_fun`
}
```

## Inflating Clever Abort Codes

Precisely, the layout of a clever abort code is as follows:

```

|<tagbit>|<reserved>|<source line number>|<module identifier index>|<module constant index>|
+--------+----------+--------------------+-------------------------+-----------------------+
| 1-bit  | 15-bits  |       16-bits      |     16-bits             |        16-bits        |

```

Note that the Move abort will come with some additional information -- importantly in our case the
module where the error occurred. This is important because the identifier index, and constant index
are relative to the module's identifier and constant tables (if not set the sentinel values).

> To decode a clever abort code, you will need to know the module where the error occurred if either
> the identifier index or constant index are not set to the sentinel value of `0xffff`.

In pseudo-code, you can decode a clever abort code as follows:

```rust
// Information available in the MoveAbort
let clever_abort_code: u64 = ...;
let (package_id, module_name): (PackageStorageId, ModuleName) = ...;

let is_clever_abort = (clever_abort_code & 0x8000_0000_0000_0000) != 0;

if is_clever_abort {
    // Get line number, identifier index, and constant index
    // Identifier and constant index are sentinel values if set to '0xffff'
    let line_number = ((clever_abort_code & 0x0000_ffff_0000_0000) >> 32) as u16;
    let identifier_index = ((clever_abort_code & 0x0000_0000_ffff_0000) >> 16) as u16;
    let constant_index = ((clever_abort_code & 0x0000_0000_0000_ffff)) as u16;

    // Print the line error message
    print!("Error from '{}::{}' (line {})", package_id, module_name, line_number);

    // No need to print anything or load the module if both are sentinel values
    if identifier_index == 0xffff && constant_index == 0xffff {
        return;
    }

    // Only needed if constant name and value are not 0xffff
    let module: CompiledModule = fetch_module(package_id, module_name);

    // Print the constant name (if any)
    if identifier_index != 0xffff {
        let constant_name = module.get_identifier_at_table_index(identifier_index);
        print!(", '{}'", constant_name);
    }

    // Print the constant value (if any)
    if constant_index != 0xffff {
        let constant_value = module
            .get_constant_at_table_index(constant_index)
            .deserialize_on_constant_type()
            .to_string();

        print!(": {}", constant_value);
    }

    return;
}
```

>>>> move-book/reference/coding-conventions.md
---
title: 'Coding Conventions | Reference'
description: ''
---

# Coding Conventions

See [Sui's Coding Conventions for Move](https://docs.sui.io/concepts/sui-move-concepts/conventions)

>>>> move-book/reference/constants.md
---
title: 'Constants | Reference'
description: ''
---

# Constants

Constants are a way of giving a name to shared, static values inside of a `module`.

The constant's value must be known at compilation. The constant's value is stored in the compiled
module. And each time the constant is used, a new copy of that value is made.

## Declaration

Constant declarations begin with the `const` keyword, followed by a name, a type, and a value.

```text
const <name>: <type> = <expression>;
```

For example

```move
module a::example;

const MY_ADDRESS: address = @a;

public fun permissioned(addr: address) {
    assert!(addr == MY_ADDRESS, 0);
}
```

## Naming

Constants must start with a capital letter `A` to `Z`. After the first letter, constant names can
contain underscores `_`, letters `a` to `z`, letters `A` to `Z`, or digits `0` to `9`.

```move
const FLAG: bool = false;
const EMyErrorCode: u64 = 0;
const ADDRESS_42: address = @0x42;
```

Even though you can use letters `a` to `z` in a constant. The
[general style guidelines](./coding-conventions) are to use just uppercase letters `A` to `Z`, with
underscores `_` between each word. For error codes, we use `E` as a prefix and then upper camel case
(also known as Pascal case) for the rest of the name, as seen in `EMyErrorCode`.

The current naming restriction of starting with `A` to `Z` is in place to give room for future
language features.

## Visibility

`public` or `public(package)` constants are not currently supported. `const` values can be used only
in the declaring module. However, as a convenience, they can be used across modules in
[unit tests attributes](./unit-testing).

## Valid Expressions

Currently, constants are limited to the primitive types `bool`, `u8`, `u16`, `u32`, `u64`, `u128`,
`u256`, `address`, and `vector<T>`, where `T` is the valid type for a constant.

### Values

Commonly, `const`s are assigned a simple value, or literal, of their type. For example

```move
const MY_BOOL: bool = false;
const MY_ADDRESS: address = @0x70DD;
const BYTES: vector<u8> = b"hello world";
const HEX_BYTES: vector<u8> = x"DEADBEEF";
```

### Complex Expressions

In addition to literals, constants can include more complex expressions, as long as the compiler is
able to reduce the expression to a value at compile time.

Currently, equality operations, all boolean operations, all bitwise operations, and all arithmetic
operations can be used.

```move
const RULE: bool = true && false;
const CAP: u64 = 10 * 100 + 1;
const SHIFTY: u8 = {
    (1 << 1) * (1 << 2) * (1 << 3) * (1 << 4)
};
const HALF_MAX: u128 = 340282366920938463463374607431768211455 / 2;
const REM: u256 =
    57896044618658097711785492504343953926634992332820282019728792003956564819968 % 654321;
const EQUAL: bool = 1 == 1;
```

If the operation would result in a runtime exception, the compiler will give an error that it is
unable to generate the constant's value

```move
const DIV_BY_ZERO: u64 = 1 / 0; // ERROR!
const SHIFT_BY_A_LOT: u64 = 1 << 100; // ERROR!
const NEGATIVE_U64: u64 = 0 - 1; // ERROR!
```

Additionally, constants can refer to other constants within the same module.

```move
const BASE: u8 = 4;
const SQUARE: u8 = BASE * BASE;
```

Note though, that any cycle in the constant definitions results in an error.

```move
const A: u16 = B + 1;
const B: u16 = A + 1; // ERROR!
```

>>>> move-book/reference/control-flow.md
---
title: 'Control Flow | Reference'
description: ''
---

# Control Flow

Move offers multiple constructs for control flow based on
[boolean expressions](./primitive-types/bool), including common programming constructs such as `if`
expressions and `while` and `for` loops, along with advanced control flow structures including
labels for loops and escapable named blocks. It also supports more complex constructs based on
structural pattern matching.

- [Conditional Expressions](./control-flow/conditionals)
- [Pattern Matching](./control-flow/pattern-matching)
- [Loops](./control-flow/loops)
- [Labeled Control FLow](./control-flow/labeled-control-flow)

>>>> move-book/reference/control-flow/conditionals.md
---
title: 'Conditional Expressions | Reference'
description: ''
---

# Conditional `if` Expressions

An `if` expression specifies that some code should only be evaluated if a certain condition is true.
For example:

```move
if (x > 5) x = x - 5
```

The condition must be an expression of type `bool`.

An `if` expression can optionally include an `else` clause to specify another expression to evaluate
when the condition is false.

```move
if (y <= 10) y = y + 1 else y = 10
```

Either the "true" branch or the "false" branch will be evaluated, but not both. Either branch can be
a single expression or an expression block.

The conditional expressions may produce values so that the `if` expression has a result.

```move
let z = if (x < 100) x else 100;
```

If the `else` clause is not specified, the false branch defaults to the unit value. The following
are equivalent:

```move
if (condition) true_branch // implied default: else ()
if (condition) true_branch else ()
```

The expressions in the true and false branches must have compatible types. For example:

```move
// x and y must be u64 integers
let maximum: u64 = if (x > y) x else y;

// highlight-error-start
// ERROR! branches different types
let z = if (maximum < 10) 10u8 else 100u64;

// ERROR! branches different types, as default false-branch is () not u64
let y = if (maximum >= 10) maximum;
// highlight-error-end
```

Commonly, `if` expressions are used in conjunction with
[expression blocks](./../variables#expression-blocks).

```move
let maximum = if (x > y) x else y;
if (maximum < 10) {
    x = x + 10;
    y = y + 10;
} else if (x >= 10 && y >= 10) {
    x = x - 10;
    y = y - 10;
}
```

## Grammar for Conditionals

> _if-expression_ → **if (** _expression_ **)** _expression_ _else-clause_<sub>_opt_</sub> >
> _else-clause_ → **else** _expression_

>>>> move-book/reference/control-flow/labeled-control-flow.md
---
title: 'Labeled Control Flow | Reference'
description: ''
---

# Labeled Control Flow

Move supports labeled control flow when writing both loops and blocks of code, allowing you
to `break` and `continue` loops and `return` from blocks (which can be particularly helpful in the
presence of macros).

## Loops

Loops allow you to define and transfer control to specific labels in a function. For example, we can
nest two loops and use `break` and `continue` with those labels to precisely specify control flow.
You can prefix any `loop` or `while` form with a `'label:` form to allow breaking or continuing
directly there.

To demonstrate this behavior, consider a function that takes nested vectors of numbers (i.e.,
`vector<vector<u64>>`) to sum against some threshold, which behaves as follows:

- If the sum of all the numbers are under the threshold, return that sum.
- If adding a number to the current sum would surpass the threshold, return the current sum.

We can write this by iterating over the vector of vectors as nested loops and labelling the outer
one. If any addition in the inner loop would push us over the threshold, we can use `break` with the
outer label to escape both loops at once:

```move
fun sum_until_threshold(input: &vector<vector<u64>>, threshold: u64): u64 {
    let mut sum = 0;
    let mut i = 0;
    let input_size = input.length();

    'outer: loop {
        // breaks to outer since it is the closest enclosing loop
        if (i >= input_size) break sum;

        let vec = &input[i];
        let size = vec.length();
        let mut j = 0;

        while (j < size) {
            let v_entry = vec[j];
            if (sum + v_entry < threshold) {
                sum = sum + v_entry;
            } else {
                // the next element we saw would break the threshold,
                // so we return the current sum
                break 'outer sum
            };
            j = j + 1;
        };
        i = i + 1;
    }
}
```

These sorts of labels can also be used with a nested loop form, providing precise control in larger
bodies of code. For example, if we were processing a large table where each entry required iteration
that might see us continuing the inner or outer loop, we could express that code using labels:

```move
let x = 'outer: loop {
    ...
    'inner: while (cond) {
        ...
        if (cond0) { break 'outer value };
        ...
        if (cond1) { continue 'inner }
        else if (cond2) { continue 'outer }
        ...
    }
        ...
};
```

> It's a better way to use Macros instead of Loops, similarly, use `return` to control the flow.
> Just like above function `sum_until_threshold`, can use `macro` to rewrite it:
```move
fun sum_until_threshold(input: &vector<vector<u64>>, threshold: u64): u64 {
    'outer: {
        (*input).fold!(0, |sum, inner_vec| {
            inner_vec.fold!(sum, |sum, num| if (sum + num < threshold) sum + num else return 'outer sum)
        })
    }
}
```

## Labeled Blocks

Labeled blocks allow you to write Move programs that contain intra-function non-local control flow,
including inside of macro lambdas and returning values:

```move
fun named_return(n: u64): vector<u8> {
    let x = 'a: {
        if (n % 2 == 0) {
            return 'a b"even"
        };
        b"odd"
    };
    x
}
```

In this simple example, the program checks if the input `n` is even. If it is, the program leaves
the block labeled `'a:` with the value `b"even"`. If not, the code continues, ending the block
labeled `'a:` with the value `b"odd"`. At the end, we set `x` to the value and then return it.

This control flow feature works across macro bodies as well. For example, suppose we wanted to write
a function to find the first even number in a vector, and that we have some macro `for_ref` that
iterates the vector elements in a loop:

```move
macro fun for_ref<$T>($vs: &vector<$T>, $f: |&$T|) {
    let vs = $vs;
    let mut i = 0;
    let end = vs.length();
    while (i < end) {
        $f(vs.borrow(i));
        i = i + 1;
    }
}
```

Using `for_ref` and a label, we can write a lambda expression to pass `for_ref` that will escape the
loop, returning the first even number it finds:

```move
fun find_first_even(vs: vector<u64>): Option<u64> {
    'result: {
        for_ref!(&vs, |n| if (*n % 2 == 0) { return 'result option::some(*n)});
        option::none()
    }
}
```

This function will iterate `vs` until it finds an even number, and return that (or return
`option::none()` if no even number exists). This makes named labels a powerful tool for interacting
with control flow macros such as `for!`, allowing you to customize iteration behavior in those
contexts.

## Restrictions

To clarify program behavior, you may only use `break` and `continue` with loop labels, while
`return` will only work with block labels. To this end, the following programs produce errors:

```move
fun bad_loop() {
    'name: loop {
        return 'name 5
            // ^^^^^ Invalid usage of 'return' with a loop block label
    }
}

fun bad_block() {
    'name: {
        continue 'name;
              // ^^^^^ Invalid usage of 'break' with a loop block label
        break 'name;
           // ^^^^^ Invalid usage of 'break' with a loop block label
    }
}
```

>>>> move-book/reference/control-flow/loops.md
---
title: 'Loops | Reference'
description: ''
---

# Loop Constructs in Move

Many programs require iteration over values, and Move provides `while` and `loop` forms to allow you
to write code in these situations. In addition, you can also modify control flow of these loops
during execution by using `break` (to exit the loop) and `continue` (to skip the remainder of this
iteration and return to the top of the control flow structure).

## `while` Loops

The `while` construct repeats the body (an expression of type unit) until the condition (an
expression of type `bool`) evaluates to `false`.

Here is an example of simple `while` loop that computes the sum of the numbers from `1` to `n`:

```move
fun sum(n: u64): u64 {
    let mut sum = 0;
    let mut i = 1;
    while (i <= n) {
        sum = sum + i;
        i = i + 1
    };

    sum
}
```

Infinite `while` loops are also allowed:

```move
fun foo() {
    while (true) { }
}
```

> It's a better way to use Macros instead of Loops to achieve a more concise and readable purpose.
> This article only takes the above function `sum` as an example to experience the charm of macro functions:
```move
fun sum(n: u64): u64 {
    vector::tabulate!(n, |i| i + 1).fold!(0, |sum, num| sum + num)
}
```

### Using `break` Inside of `while` Loops

In Move, `while` loops can use `break` to exit early. For example, suppose we were looking for the
position of a value in a vector, and would like to `break` if we find it:

```move
fun find_position(values: &vector<u64>, target_value: u64): Option<u64> {
    let size = values.length();
    let mut i = 0;
    let mut found = false;

    while (i < size) {
        if (values[i] == target_value) {
            found = true;
            break
        };
        i = i + 1
    };

    if (found) {
        option::some(i)
    } else {
        option::none<u64>()
    }
}
```

Here, if the borrowed vector value is equal to our target value, we set the `found` flag to `true`
and then call `break`, which will cause the program to exit the loop.

Finally, note that `break` for `while` loops cannot take a value: `while` loops always return the
unit type `()` and thus `break` does, too.

### Using `continue` Inside of `while` Loops

Similar to `break`, Move's `while` loops can invoke `continue` to skip over part of the loop body.
This allows us to skip part of a computation if a condition is not met, such as in the following
example:

```move
fun sum_even(values: &vector<u64>): u64 {
    let size = values.length();
    let mut i = 0;
    let mut even_sum = 0;

    while (i < size) {
        let number = values[i];
        i = i + 1;
        if (number % 2 == 1) continue;
        even_sum = even_sum + number;
    };
    even_sum
}
```

This code will iterate over the provided vector. For each entry, if that entry is an even number, it
will add it to the `even_sum`. If it is not, however, it will call `continue`, skipping the sum
operation and returning to the `while` loop conditional check.

## `loop` Expressions

The `loop` expression repeats the loop body (an expression with type `()`) until it hits a `break`:

```move
fun sum(n: u64): u64 {
    let mut sum = 0;
    let mut i = 1;

    loop {
       i = i + 1;
       if (i >= n) break;
       sum = sum + i;
    };

    sum
}
```

Without a `break`, the loop will continue forever. In the example below, the program will run
forever because the `loop` does not have a `break`:

```move
fun foo() {
    let mut i = 0;
    loop { i = i + 1 }
}
```

### Using `break` with Values in `loop`

Unlike `while` loops, which always return `()`, a `loop` may return a value using `break`. In doing
so, the overall `loop` expression evaluates to a value of that type. For example, we can rewrite
`find_position` from above using `loop` and `break`, immediately returning the index if we find it:

```move
fun find_position(values: &vector<u64>, target_value: u64): Option<u64> {
    let size = values.length();
    let mut i = 0;

    loop {
        if (values[i] == target_value) {
            break option::some(i)
        } else if (i >= size) {
            break option::none()
        };
        i = i + 1;
    }
}
```

This loop will break with an option result, and, as the last expression in the function body, will
produce that value as the final function result.

### Using `continue` Inside of `loop` Expressions

As you might expect, `continue` can also be used inside a `loop`. Here is the previous `sum_even`
function rewritten using `loop` with `break `and` continue` instead of `while`.

```move
fun sum_even(values: &vector<u64>): u64 {
    let size = values.length();
    let mut i = 0;
    let mut even_sum = 0;

    loop {
        if (i >= size) break;
        let number = values[i];
        i = i + 1;
        if (number % 2 == 1) continue;
        even_sum = even_sum + number;
    };
    even_sum
}
```

## The Type of `while` and `loop`

In Move, loops are typed expressions. A `while` expression always has type `()`.

```move
let () = while (i < 10) { i = i + 1 };
```

If a `loop` contains a `break`, the expression has the type of the break. A break with no value has
the unit type `()`.

```move
(loop { if (i < 10) i = i + 1 else break }: ());
let () = loop { if (i < 10) i = i + 1 else break };

let x: u64 = loop { if (i < 10) i = i + 1 else break 5 };
let x: u64 = loop { if (i < 10) { i = i + 1; continue} else break 5 };
```

In addition, if a loop contains multiple breaks, they must all return the same type:

```move
// invalid -- first break returns (), second returns 5
let x: u64 = loop { if (i < 10) break else break 5 };
```

If `loop` does not have a `break`, `loop` can have any type much like `return`, `abort`, `break`,
and `continue`.

```move
(loop (): u64);
(loop (): address);
(loop (): &vector<vector<u8>>);
```

If you need even more-precise control flow, such as breaking out of nested loops, the next chapter
presents the use of labeled control flow in Move.

>>>> move-book/reference/control-flow/pattern-matching.md
---
title: 'Pattern Matching | Reference'
description: ''
---

# Pattern Matching

A `match` expression is a powerful control structure that allows you to compare a value against a
series of patterns and then execute code based on which pattern matches first. Patterns can be
anything from simple literals to complex, nested struct and enum definitions. As opposed to `if`
expressions, which change control flow based on a `bool`-typed test expression, a `match` expression
operates over a value of any type and selects one of many arms.

A `match` expression can match Move values as well as mutable or immutable references, binding
sub-patterns accordingly.

For example:

```move
fun run(x: u64): u64 {
    match (x) {
        1 => 2,
        2 => 3,
        x => x,
    }
}

run(1); // returns 2
run(2); // returns 3
run(3); // returns 3
run(0); // returns 0
```

## `match` Syntax

A `match` takes an expression and a non-empty series of _match arms_ delimited by commas.

Each match arm consists of a pattern (`p`), an optional guard (`if (g)` where `g` is an expression
of type `bool`), an arrow (`=>`), and an arm expression (`e`) to execute when the pattern matches.
For example,

```move
match (expression) {
    pattern1 if (guard_expression) => expression1,
    pattern2 => expression2,
    pattern3 => { expression3, expression4, ... },
}
```

Match arms are checked in order from top to bottom, and the first pattern that matches (with a guard
expression, if present, that evaluates to `true`) will be executed.

Note that the series of match arms within a `match` must be exhaustive, meaning that every possible
value of the type being matched must be covered by one of the patterns in the `match`. If the series
of match arms is not exhaustive, the compiler will raise an error.

## Pattern Syntax

A pattern is matched by a value if the value is equal to the pattern, and where variables and
wildcards (e.g., `x`, `y`, `_`, or `..`) are "equal" to anything.

Patterns are used to match values. Patterns can be

| Pattern              | Description                                                            |
| -------------------- | ---------------------------------------------------------------------- |
| Literal              | A literal value, such as `1`, `true`, `@0x1`                           |
| Constant             | A constant value, e.g., `MyConstant`                                   |
| Variable             | A variable, e.g., `x`, `y`, `z`                                        |
| Wildcard             | A wildcard, e.g., `_`                                                  |
| Constructor          | A constructor pattern, e.g., `MyStruct { x, y }`, `MyEnum::Variant(x)` |
| At-pattern           | An at-pattern, e.g., `x @ MyEnum::Variant(..)`                         |
| Or-pattern           | An or-pattern, e.g., `MyEnum::Variant(..) \| MyEnum::OtherVariant(..)` |
| Multi-arity wildcard | A multi-arity wildcard, e.g., `MyEnum::Variant(..)`                    |
| Mutable-binding      | A mutable-binding pattern, e.g., `mut x`                               |

Patterns in Move have the following grammar:

```bnf
pattern = <literal>
        | <constant>
        | <variable>
        | _
        | C { <variable> : inner-pattern ["," <variable> : inner-pattern]* } // where C is a struct or enum variant
        | C ( inner-pattern ["," inner-pattern]* ... )                       // where C is a struct or enum variant
        | C                                                                  // where C is an enum variant
        | <variable> @ top-level-pattern
        | pattern | pattern
        | mut <variable>
inner-pattern = pattern
              | ..     // multi-arity wildcard
```

Some examples of patterns are:

```move
// literal pattern
1

// constant pattern
MyConstant

// variable pattern
x

// wildcard pattern
_

// constructor pattern that matches `MyEnum::Variant` with the fields `1` and `true`
MyEnum::Variant(1, true)

// constructor pattern that matches `MyEnum::Variant` with the fields `1` and binds the second field's value to `x`
MyEnum::Variant(1, x)

// multi-arity wildcard pattern that matches multiple fields within the `MyEnum::Variant` variant
MyEnum::Variant(..)

// constructor pattern that matches the `x` field of `MyStruct` and binds the `y` field to `other_variable`
MyStruct { x, y: other_variable }

// at-pattern that matches `MyEnum::Variant` and binds the entire value to `x`
x @ MyEnum::Variant(..)

// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant`
MyEnum::Variant(..) | MyEnum::OtherVariant(..)

// same as the above or-pattern, but with explicit wildcards
MyEnum::Variant(_, _) | MyEnum::OtherVariant(_, _)

// or-pattern that matches either `MyEnum::Variant` or `MyEnum::OtherVariant` and binds the u64 field to `x`
MyEnum::Variant(x, _) | MyEnum::OtherVariant(_, x)

// constructor pattern that matches `OtherEnum::V` and if the inner `MyEnum` is `MyEnum::Variant`
OtherEnum::V(MyEnum::Variant(..))
```

### Patterns and Variables

Patterns that contain variables bind them to the match subject or subject subcomponent being
matched. These variables can then be used either in any match guard expressions, or on the
right-hand side of the match arm. For example:

```move
public struct Wrapper(u64)

fun add_under_wrapper_unless_equal(wrapper: Wrapper, x: u64): Wrapper {
    match (wrapper) {
        Wrapper(y) if (y == x) => Wrapper(y),
        Wrapper(y) => Wrapper(y + x),
    }
}
add_under_wrapper_unless_equal(Wrapper(1), 2); // returns Wrapper(3)
add_under_wrapper_unless_equal(Wrapper(2), 3); // returns Wrapper(5)
add_under_wrapper_unless_equal(Wrapper(3), 3); // returns Wrapper(3)
```

### Combining Patterns

Patterns can be nested, but patterns can also be combined using the or operator (`|`). For example,
`p1 | p2` succeeds if either pattern `p1` or `p2` matches the subject. This pattern can occur
anywhere -- either as a top-level pattern or a sub-pattern within another pattern.

```move
public enum MyEnum has drop {
    Variant(u64, bool),
    OtherVariant(bool, u64),
}

fun test_or_pattern(x: u64): u64 {
    match (x) {
        MyEnum::Variant(1 | 2 | 3, true) | MyEnum::OtherVariant(true, 1 | 2 | 3) => 1,
        MyEnum::Variant(8, true) | MyEnum::OtherVariant(_, 6 | 7) => 2,
        _ => 3,
    }
}

test_or_pattern(MyEnum::Variant(3, true)); // returns 1
test_or_pattern(MyEnum::OtherVariant(true, 2)); // returns 1
test_or_pattern(MyEnum::Variant(8, true)); // returns 2
test_or_pattern(MyEnum::OtherVariant(false, 7)); // returns 2
test_or_pattern(MyEnum::OtherVariant(false, 80)); // returns 3
```

### Restrictions on Some Patterns

The `mut` and `..` patterns also have specific conditions placed on when, where, and how they can be
used, as detailed in [Limitations on Specific Patterns](#limitations-on-specific-patterns). At a
high level, the `mut` modifier can only be used on variable patterns, and the `..` pattern can only
be used once within a constructor pattern -- and not as a top-level pattern.

The following is an _invalid_ usage of the `..` pattern because it is used as a top-level pattern:

```move
match (x) {
    .. => 1,
    // ERROR: `..` pattern can only be used within a constructor pattern
}

match (x) {
    MyStruct(.., ..) => 1,
    // ERROR:    ^^  `..` pattern can only be used once within a constructor pattern
}
```

### Pattern Typing

Patterns are not expressions, but they are nevertheless typed. This means that the type of a pattern
must match the type of the value it matches. For example, the pattern `1` has an integer type, the
pattern `MyEnum::Variant(1, true)` has type `MyEnum`, the pattern `MyStruct { x, y }` has type
`MyStruct`, and `OtherStruct<bool> { x: true, y: 1}` has type `OtherStruct<bool>`. If you try to
match on an expression that differs from the type of the pattern in the match, this will result in a
type error. For example:

```move
match (1) {
    // The `true` literal pattern is of type `bool` so this is a type error.
    true => 1,
    // TYPE ERROR: expected type u64, found bool
    _ => 2,
}
```

Similarly, the following would also result in a type error because `MyEnum` and `MyStruct` are
different types:

```move
match (MyStruct { x: 0, y: 0 }) {
    MyEnum::Variant(..) => 1,
    // TYPE ERROR: expected type MyEnum, found MyStruct
}
```

## Matching

Prior to delving into the specifics of pattern matching and what it means for a value to "match" a
pattern, let's examine a few examples to provide an intuition for the concept.

```move
fun test_lit(x: u64): u8 {
    match (x) {
        1 => 2,
        2 => 3,
        _ => 4,
    }
}
test_lit(1); // returns 2
test_lit(2); // returns 3
test_lit(3); // returns 4
test_lit(10); // returns 4

fun test_var(x: u64): u64 {
    match (x) {
        y => y,
    }
}
test_var(1); // returns 1
test_var(2); // returns 2
test_var(3); // returns 3
...

const MyConstant: u64 = 10;
fun test_constant(x: u64): u64 {
    match (x) {
        MyConstant => 1,
        _ => 2,
    }
}
test_constant(MyConstant); // returns 1
test_constant(10); // returns 1
test_constant(20); // returns 2

fun test_or_pattern(x: u64): u64 {
    match (x) {
        1 | 2 | 3 => 1,
        4 | 5 | 6 => 2,
        _ => 3,
    }
}
test_or_pattern(3); // returns 1
test_or_pattern(5); // returns 2
test_or_pattern(70); // returns 3

fun test_or_at_pattern(x: u64): u64 {
    match (x) {
        x @ (1 | 2 | 3) => x + 1,
        y @ (4 | 5 | 6) => y + 2,
        z => z + 3,
    }
}
test_or_pattern(2); // returns 3
test_or_pattern(5); // returns 7
test_or_pattern(70); // returns 73
```

The most important thing to note from these examples is that a pattern matches a value if the value
is equal to the pattern, and wildcard/variable patterns match anything. This is true for literals,
variables, and constants. For example, in the `test_lit` function, the value `1` matches the pattern
`1`, the value `2` matches the pattern `2`, and the value `3` matches the wildcard `_`. Similarly,
in the `test_var` function, both the value `1` and the value `2` matches the pattern `y`.

A variable `x` matches (or "equals") any value, and a wildcard `_` matches any value (but only one
value). Or-patterns are like a logical OR, where a value matches the pattern if it matches any of
patterns in the or-pattern so `p1 | p2 | p3` should be read "matches p1, or p2, or p3".

### Matching Constructors

Pattern matching includes the concept of constructor patterns. These patterns allow you to inspect
and access deep within both structs and enums, and are one of the most powerful parts of pattern
matching. Constructor patterns, coupled with variable bindings, allow you to match on values by
their structure, and pull out the parts of the value you care about for usage on the right-hand side
of the match arm.

Take the following:

```move
fun f(x: MyEnum): u64 {
    match (x) {
        MyEnum::Variant(1, true) => 1,
        MyEnum::OtherVariant(_, 3) => 2,
        MyEnum::Variant(..) => 3,
        MyEnum::OtherVariant(..) => 4,
    }
}
f(MyEnum::Variant(1, true)); // returns 1
f(MyEnum::Variant(2, true)); // returns 3
f(MyEnum::OtherVariant(false, 3)); // returns 2
f(MyEnum::OtherVariant(true, 3)); // returns 2
f(MyEnum::OtherVariant(true, 2)); // returns 4
```

This is saying that "if `x` is `MyEnum::Variant` with the fields `1` and `true`, then return `1`. If
it is `MyEnum::OtherVariant` with any value for the first field, and `3` for the second, then return
`2`. If it is `MyEnum::Variant` with any fields, then return `3`. Finally, if it is
`MyEnum::OtherVariant` with any fields, then return `4`".

You can also nest patterns. So, if you wanted to match either 1, 2, or 10, instead of just matching
1 in the previous `MyEnum::Variant`, you could do so with an or-pattern:

```move
fun f(x: MyEnum): u64 {
    match (x) {
        MyEnum::Variant(1 | 2 | 10, true) => 1,
        MyEnum::OtherVariant(_, 3) => 2,
        MyEnum::Variant(..) => 3,
        MyEnum::OtherVariant(..) => 4,
    }
}
f(MyEnum::Variant(1, true)); // returns 1
f(MyEnum::Variant(2, true)); // returns 1
f(MyEnum::Variant(10, true)); // returns 1
f(MyEnum::Variant(10, false)); // returns 3
```

### Ability Constraints

Additionally, match bindings are subject to the same ability restrictions as other aspects of Move.
In particular, the compiler will signal an error if you try to match a value (not-reference) without
`drop` using a wildcard, as the wildcard expects to drop the value. Similarly, if you bind a
non-`drop` value using a binder, it must be used in the right-hand side of the match arm. In
addition, if you fully destruct that value, you have unpacked it, matching the semantics of
[non-`drop` struct unpacking](./../structs#destroying-structs-via-pattern-matching). See the
[abilities section on `drop`](./../abilities#drop) for more details about the `drop` capability.

```move
public struct NonDrop(u64)

fun drop_nondrop(x: NonDrop): u64 {
    match (x) {
        NonDrop(1) => 1,
        _ => 2
        // ERROR: cannot wildcard match on a non-droppable value
    }
}

fun destructure_nondrop(x: NonDrop): u64 {
    match (x) {
        NonDrop(1) => 1,
        NonDrop(_) => 2
        // OK!
    }
}

fun use_nondrop(x: NonDrop): NonDrop {
    match (x) {
        NonDrop(1) => NonDrop(8),
        x => x
    }
}
```

## Exhaustiveness

The `match` expression in Move must be _exhaustive_: every possible value of the type being matched
must be covered by one of the patterns in one of the match's arms. If the series of match arms is
not exhaustive, the compiler will raise an error. Note that any arm with a guard expression does not
contribute to match exhaustion, as it might fail to match at runtime.

As an example, a match on a `u8` is exhaustive only if it matches on _every_ number from 0 to 255
inclusive, unless there is a wildcard or variable pattern present. Similarly, a match on a `bool`
would need to match on both `true` and `false`, unless there is a wildcard or variable pattern
present.

For structs, because there is only one type of constructor for the type, only one constructor needs
to be matched, but the fields within the struct need to be matched exhaustively as well. Conversely,
enums may define multiple variants, and each variant must be matched (including any sub-fields) for
the match to be considered exhaustive.

Because underscores and variables are wildcards that match anything, they count as matching all
values of the type they are matching on in that position. Additionally, the multi-arity wildcard
pattern `..` can be used to match on multiple values within a struct or enum variant.

To see some examples of _non-exhaustive_ matches, consider the following:

```move
public enum MyEnum {
    Variant(u64, bool),
    OtherVariant(bool, u64),
}

public struct Pair<T>(T, T)

fun f(x: MyEnum): u8 {
    match (x) {
        MyEnum::Variant(1, true) => 1,
        MyEnum::Variant(_, _) => 1,
        MyEnum::OtherVariant(_, 3) => 2,
        // ERROR: not exhaustive as the value `MyEnum::OtherVariant(_, 4)` is not matched.
    }
}

fun match_pair_bool(x: Pair<bool>): u8 {
    match (x) {
        Pair(true, true) => 1,
        Pair(true, false) => 1,
        Pair(false, false) => 1,
        // ERROR: not exhaustive as the value `Pair(false, true)` is not matched.
    }
}
```

These examples can then be made exhaustive by adding a wildcard pattern to the end of the match arm,
or by fully matching on the remaining values:

```move
fun f(x: MyEnum): u8 {
    match (x) {
        MyEnum::Variant(1, true) => 1,
        MyEnum::Variant(_, _) => 1,
        MyEnum::OtherVariant(_, 3) => 2,
        // Now exhaustive since this will match all values of MyEnum::OtherVariant
        MyEnum::OtherVariant(..) => 2,

    }
}

fun match_pair_bool(x: Pair<bool>): u8 {
    match (x) {
        Pair(true, true) => 1,
        Pair(true, false) => 1,
        Pair(false, false) => 1,
        // Now exhaustive since this will match all values of Pair<bool>
        Pair(false, true) => 1,
    }
}
```

## Guards

As previously mentioned, you can add a guard to a match arm by adding an `if` clause after the
pattern. This guard will run _after_ the pattern has been matched but _before_ the expression on the
right hand side of the arrow is evaluated. If the guard expression evaluates to `true` then the
expression on the right hand side of the arrow will be evaluated, if it evaluates to `false` then it
will be considered a failed match and the next match arm in the `match` expression will be checked.

```move
fun match_with_guard(x: u64): u64 {
    match (x) {
        1 if (false) => 1,
        1 => 2,
        _ => 3,
    }
}

match_with_guard(1); // returns 2
match_with_guard(0); // returns 3
```

Guard expressions can reference variables bound in the pattern during evaluation. However, note that
_variables are only available as immutable reference in guards_ regardless of the pattern being
matched -- even if there are mutability specifiers on the variable or if the pattern is being
matched by value.

```move
fun incr(x: &mut u64) {
    *x = *x + 1;
}

fun match_with_guard_incr(x: u64): u64 {
    match (x) {
        x if ({ incr(&mut x); x == 1 }) => 1,
        // ERROR:    ^^^ invalid borrow of immutable value
        _ => 2,
    }
}

fun match_with_guard_incr2(x: &mut u64): u64 {
    match (x) {
        x if ({ incr(&mut x); x == 1 }) => 1,
        // ERROR:    ^^^ invalid borrow of immutable value
        _ => 2,
    }
}
```

Additionally, it is important to note any match arms that have guard expressions will not be
considered either for exhaustivity purposes because the compiler has no way of evaluating the guard
expression statically.

## Limitations on Specific Patterns

There are some restrictions on when the `..` and `mut` pattern modifiers can be used in a pattern.

### Mutability Usage

A `mut` modifier can be placed on a variable pattern to specify that the _variable_ is to be mutated
in the right-hand expression of the match arm. Note that since the `mut` modifier only signifies
that the variable is to be mutated, not the underlying data, this can be used on all types of match
(by value, immutable reference, and mutable reference).

Note that the `mut` modifier can only be applied to variables, and not other types of patterns.

```move
public struct MyStruct(u64)

fun top_level_mut(x: MyStruct): u64 {
    match (x) {
        mut MyStruct(y) => 1,
        // ERROR: cannot use mut on a non-variable pattern
    }
}

fun mut_on_immut(x: &MyStruct): u64 {
    match (x) {
        MyStruct(mut y) => {
            y = &(*y + 1);
            *y
        }
    }
}

fun mut_on_value(x: MyStruct): u64 {
    match (x) {
        MyStruct(mut y) => {
            *y = *y + 1;
            *y
        },
    }
}

fun mut_on_mut(x: &mut MyStruct): u64 {
    match (x) {
        MyStruct(mut y) => {
            *y = *y + 1;
            *y
        },
    }
}

let mut x = MyStruct(1);

mut_on_mut(&mut x); // returns 2
x.0; // returns 2

mut_on_immut(&x); // returns 3
x.0; // returns 2

mut_on_value(x); // returns 3
```

### `..` Usage

The `..` pattern can only be used within a constructor pattern as a wildcard that matches any number
of fields -- the compiler expands the `..` to inserting `_` in any missing fields in the
constructor pattern (if any). So `MyStruct(_, _, _)` is the same as `MyStruct(..)`,
`MyStruct(1, _, _)` is the same as `MyStruct(1, ..)`. Because of this, there are some restrictions
on how, and where the `..` pattern can be used:

- It can only be used **once** within the constructor pattern;
- In positional arguments it can be used at the beginning, middle, or end of the patterns within the
  constructor;
- In named arguments it can only be used at the end of the patterns within the constructor;

```move
public struct MyStruct(u64, u64, u64, u64) has drop;

public struct MyStruct2 {
    x: u64,
    y: u64,
    z: u64,
    w: u64,
}

fun wild_match(x: MyStruct): u64 {
    match (x) {
        MyStruct(.., 1) => 1,
        // OK! The `..` pattern can be used at the beginning of the constructor pattern
        MyStruct(1, ..) => 2,
        // OK! The `..` pattern can be used at the end of the constructor pattern
        MyStruct(1, .., 1) => 3,
        // OK! The `..` pattern can be used at the middle of the constructor pattern
        MyStruct(1, .., 1, 1) => 4,
        MyStruct(..) => 5,
    }
}

fun wild_match2(x: MyStruct2): u64 {
    match (x) {
        MyStruct2 { x: 1, .. } => 1,
        MyStruct2 { x: 1, w: 2 .. } => 2,
        MyStruct2 { .. } => 3,
    }
}
```

>>>> move-book/reference/enums.md
---
title: 'Enumerations | Reference'
description: ''
---

# Enumerations

An _enum_ is a user-defined data structure containing one or more _variants_. Each variant can
optionally contain typed fields. The number, and types of these fields can differ for each variant
in the enumeration. Fields in enums can store any non-reference, non-tuple type, including other
structs or enums.

As a simple example, consider the following enum definition in Move:

```move
public enum Action {
    Stop,
    Pause { duration: u32 },
    MoveTo { x: u64, y: u64 },
    Jump(u64),
}
```

This declares an enum `Action` that represents different actions that can be taken by a game -- you
can `Stop`, `Pause` for a given duration, `MoveTo` a specific location, or `Jump` to a specific
height.

Similar to structs, enums can have [abilities](./abilities) that control what operations can be
performed on them. It is important to note however that enums cannot have the `key` ability since
they cannot be top-level objects.

## Defining Enums

Enums must be defined in a module, an enum must contain at least one variant, and each variant of an
enum can either have no fields, positional fields, or named fields. Here are some examples of each:

```move
module a::m;

public enum Foo has drop {
    VariantWithNoFields,
    //                 ^ note: it is fine to have a trailing comma after variant declarations
}
public enum Bar has copy, drop {
    VariantWithPositionalFields(u64, bool),
}
public enum Baz has drop {
    VariantWithNamedFields { x: u64, y: bool, z: Bar },
}
```

Enums cannot be recursive in any of their variants, so the following definitions of an enum are not
allowed because they would be recursive in at least one variant.

Incorrect:

```move
module a::m;

public enum Foo {
    Recursive(Foo),
    //        ^ error: recursive enum variant
}
public enum List {
    Nil,
    Cons { head: u64, tail: List },
    //                      ^ error: recursive enum variant
}
public enum BTree<T> {
    Leaf(T),
    Node { left: BTree<T>, right: BTree<T> },
    //           ^ error: recursive enum variant
}

// Mutually recursive enums are also not allowed
public enum MutuallyRecursiveA {
    Base,
    Other(MutuallyRecursiveB),
    //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant
}

public enum MutuallyRecursiveB {
    Base,
    Other(MutuallyRecursiveA),
    //    ^^^^^^^^^^^^^^^^^^ error: recursive enum variant
}
```

## Visibility

All enums are declared as `public`. This means that the type of the enum can be referred to from any
other module. However, the variants of the enum, the fields within each variant, and the ability to
create or destroy variants of the enum are internal to the module that defines the enum.

### Abilities

Just like with structs, by default an enum declaration is linear and ephemeral. To use an enum value
in a non-linear or non-ephemeral way -- i.e., copied, dropped, or stored in an
[object](./abilities/object) -- you need to grant it additional [abilities](./abilities) by
annotating them with `has <ability>`:

```move
module a::m;

public enum Foo has copy, drop {
    VariantWithNoFields,
}
```

The ability declaration can occur either before or after the enum's variants, however only one or
the other can be used, and not both. If declared after the variants, the ability declaration must be
terminated with a semicolon:

```move
module a::m;

public enum PreNamedAbilities has copy, drop { Variant }
public enum PostNamedAbilities { Variant } has copy, drop;
public enum PostNamedAbilitiesInvalid { Variant } has copy, drop
//                                                              ^ ERROR! missing semicolon

public enum NamedInvalidAbilities has copy { Variant } has drop;
//                                                     ^ ERROR! duplicate ability declaration
```

For more details, see the section on
[annotating abilities](./abilities#annotating-structs-and-enums).

## Naming

Enums and variants within enums must start with a capital letter `A` to `Z`. After the first letter,
enum names can contain underscores `_`, lowercase letters `a` to `z`, uppercase letters `A` to `Z`,
or digits `0` to `9`.

```move
public enum Foo { Variant }
public enum BAR { Variant }
public enum B_a_z_4_2 { V_a_riant_0 }
```

This naming restriction of starting with `A` to `Z` is in place to give room for future language
features.

## Using Enums

### Creating Enum Variants

Values of an enum type can be created (or "packed") by indicating a variant of the enum, followed by
a value for each field in the variant. The variant name must always be qualified by the enum's name.

Similarly to structs, for a variant with named fields, the order of the fields does not matter but
the field names need to be provided. For a variant with positional fields, the order of the fields
matters and the order of the fields must match the order in the variant declaration. It must also be
created using `()` instead of `{}`. If the variant has no fields, the variant name is sufficient and
no `()` or `{}` needs to be used.

```move
module a::m;

public enum Action has drop {
    Stop,
    Pause { duration: u32 },
    MoveTo { x: u64, y: u64 },
    Jump(u64),
}
public enum Other has drop {
    Stop(u64),
}

fun example() {
    // Note: The `Stop` variant of `Action` doesn't have fields so no parentheses or curlies are needed.
    let stop = Action::Stop;
    let pause = Action::Pause { duration: 10 };
    let move_to = Action::MoveTo { x: 10, y: 20 };
    let jump = Action::Jump(10);
    // Note: The `Stop` variant of `Other` does have positional fields so we need to supply them.
    let other_stop = Other::Stop(10);
}
```

For variants with named fields you can also use the shorthand syntax that you might be familiar with
from structs to create the variant:

```move
let duration = 10;

let pause = Action::Pause { duration: duration };
// is equivalent to
let pause = Action::Pause { duration };
```

### Pattern Matching Enum Variants and Destructuring

Since enum values can take on different shapes, dot access to fields of variants is not allowed like
it is for struct fields. Instead, to access fields within a variant -- either by value, or immutable
or mutable reference -- you must use pattern matching.

You can pattern match on Move values by value, immutable reference, and mutable reference. When
pattern matching by value, the value is moved into the match arm. When pattern matching by
reference, the value is borrowed into the match arm (either immutably or mutably). We'll go through
a brief description of pattern matching using `match` here, but for more information on pattern
matching using `match` in Move see the [Pattern Matching](./control-flow/pattern-matching) section.

A `match` statement is used to pattern match on a Move value and consists of a number of _match
arms_. Each match arm consists of a pattern, an arrow `=>`, and an expression, followed by a comma
`,`. The pattern can be a struct, enum variant, binding (`x`, `y`), wildcard (`_` or `..`), constant
(`ConstValue`), or literal value (`true`, `42`, and so on). The value is matched against each
pattern from the top-down, and will match the first pattern that structurally matches the value.
Once the value is matched, the expression on the right hand side of the `=>` is executed.

Additionally, match arms can have optional _guards_ that are checked after the pattern matches but
_before_ the expression is executed. Guards are specified by the `if` keyword followed by an
expression that must evaluate to a boolean value before the `=>`.

```move
module a::m;

public enum Action has drop {
    Stop,
    Pause { duration: u32 },
    MoveTo { x: u64, y: u64 },
    Jump(u64),
}

public struct GameState {
    // Fields containing a game state
    character_x: u64,
    character_y: u64,
    character_height: u64,
    // ...
}

fun perform_action(stat: &mut GameState, action: Action) {
    match (action) {
        // Handle the `Stop` variant
        Action::Stop => state.stop(),
        // Handle the `Pause` variant
        // If the duration is 0, do nothing
        Action::Pause { duration: 0 } => (),
        Action::Pause { duration } => state.pause(duration),
        // Handle the `MoveTo` variant
        Action::MoveTo { x, y } => state.move_to(x, y),
        // Handle the `Jump` variant
        // if the game disallows jumps then do nothing
        Action::Jump(_) if (state.jumps_not_allowed()) => (),
        // otherwise, jump to the specified height
        Action::Jump(height) => state.jump(height),
    }
}
```

To see how to pattern match on an enum to update values within it mutably, let's take the following
example of a simple enum that has two variants, each with a single field. We can then write two
functions, one that only increments the value of the first variant, and another that only increments
the value of the second variant:

```move
module a::m;

public enum SimpleEnum {
    Variant1(u64),
    Variant2(u64),
}

public fun incr_enum_variant1(simple_enum: &mut SimpleEnum) {
    match (simple_enum) {
        SimpleEnum::Variant1(mut value) => *value += 1,
        _ => (),
    }
}

public fun incr_enum_variant2(simple_enum: &mut SimpleEnum) {
    match (simple_enum) {
        SimpleEnum::Variant2(mut value) => *value += 1,
        _ => (),
    }
}
```

Now, if we have a value of `SimpleEnum` we can use the functions to increment the value of this
variant:

```move
let mut x = SimpleEnum::Variant1(10);
incr_enum_variant1(&mut x);
assert!(x == SimpleEnum::Variant1(11));
// Doesn't increment since it increments a different variant
incr_enum_variant2(&mut x);
assert!(x == SimpleEnum::Variant1(11));
```

When pattern matching on a Move value that does not have the `drop` ability, the value must be
consumed or destructured in each match arm. If the value is not consumed or destructured in a match
arm, the compiler will raise an error. This is to ensure that all possible values are handled in the
match statement.

As an example, consider the following code:

```move
module a::m;

public enum X { Variant { x: u64 } }

public fun bad(x: X) {
    match (x) {
        _ => (),
    // ^ ERROR! value of type `X` is not consumed or destructured in this match arm
    }
}
```

To properly handle this, you will need to destructure `X` and all its variants in the match's
arm(s):

```move
module a::m;

public enum X { Variant { x: u64 } }

public fun good(x: X) {
    match (x) {
        // OK! Compiles since the value is destructured
        X::Variant { x: _ } => (),
    }
}
```

### Overwriting to Enum Values

As long as the enum has the `drop` ability, you can overwrite the value of an enum with a new value
of the same type just as you might with other values in Move.

```move
module a::m;

public enum X has drop {
    A(u64),
    B(u64),
}

public fun overwrite_enum(x: &mut X) {
    *x = X::A(10);
}
```

```move
let mut x = X::B(20);
overwrite_enum(&mut x);
assert!(x == X::A(10));
```

>>>> move-book/reference/equality.md
---
title: 'Equality | Reference'
description: ''
---

# Equality

Move supports two equality operations `==` and `!=`

## Operations

| Syntax | Operation | Description                                                                 |
| ------ | --------- | --------------------------------------------------------------------------- |
| `==`   | equal     | Returns `true` if the two operands have the same value, `false` otherwise   |
| `!=`   | not equal | Returns `true` if the two operands have different values, `false` otherwise |

### Typing

Both the equal (`==`) and not-equal (`!=`) operations only work if both operands are the same type

```move
0 == 0; // `true`
1u128 == 2u128; // `false`
b"hello" != x"00"; // `true`
```

Equality and non-equality also work over _all_ user defined types!

```move
module 0::example;

public struct S has copy, drop { f: u64, s: vector<u8> }

fun always_true(): bool {
    let s = S { f: 0, s: b"" };
    s == s
}

fun always_false(): bool {
    let s = S { f: 0, s: b"" };
    s != s
}
```

If the operands have different types, there is a type checking error

```move
1u8 == 1u128; // ERROR!
//     ^^^^^ expected an argument of type 'u8'
b"" != 0; // ERROR!
//     ^ expected an argument of type 'vector<u8>'
```

### Typing with references

When comparing [references](./primitive-types/references), the type of the reference (immutable or
mutable) does not matter. This means that you can compare an immutable `&` reference with a mutable
one `&mut` of the same underlying type.

```move
let i = &0;
let m = &mut 1;

i == m; // `false`
m == i; // `false`
m == m; // `true`
i == i; // `true`
```

The above is equivalent to applying an explicit freeze to each mutable reference where needed

```move
let i = &0;
let m = &mut 1;

i == freeze(m); // `false`
freeze(m) == i; // `false`
m == m; // `true`
i == i; // `true`
```

But again, the underlying type must be the same type

```move
let i = &0;
let s = &b"";

i == s; // ERROR!
//   ^ expected an argument of type '&u64'
```

### Automatic Borrowing

Starting in Move 2024 edition, the `==` and `!=` operators automatically borrow their operands if
one of the operands is a reference and the other is not. This means that the following code works
without any errors:

```move
let r = &0;

// In all cases, `0` is automatically borrowed as `&0`
r == 0; // `true`
0 == r; // `true`
r != 0; // `false`
0 != r; // `false`
```

This automatic borrow is always an immutable borrow.

## Restrictions

Both `==` and `!=` consume the value when comparing them. As a result, the type system enforces that
the type must have [`drop`](./abilities). Recall that without the [`drop` ability](./abilities),
ownership must be transferred by the end of the function, and such values can only be explicitly
destroyed within their declaring module. If these were used directly with either equality `==` or
non-equality `!=`, the value would be destroyed which would break [`drop` ability](./abilities)
safety guarantees!

```move
module 0::example;

public struct Coin has store { value: u64 }
fun invalid(c1: Coin, c2: Coin) {
    c1 == c2 // ERROR!
//  ^^    ^^ These assets would be destroyed!
}
```

But, a programmer can _always_ borrow the value first instead of directly comparing the value, and
reference types have the [`drop` ability](./abilities). For example

```move
module 0::example;

public struct Coin has store { value: u64 }
fun swap_if_equal(c1: Coin, c2: Coin): (Coin, Coin) {
    let are_equal = &c1 == c2; // valid, note `c2` is automatically borrowed
    if (are_equal) (c2, c1) else (c1, c2)
}
```

## Avoid Extra Copies

While a programmer _can_ compare any value whose type has [`drop`](./abilities), a programmer should
often compare by reference to avoid expensive copies.

```move
let v1: vector<u8> = function_that_returns_vector();
let v2: vector<u8> = function_that_returns_vector();
assert!(copy v1 == copy v2, 42);
//      ^^^^       ^^^^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(copy s1 == copy s2, 42);
//      ^^^^       ^^^^
use_two_foos(s1, s2);
```

This code is perfectly acceptable (assuming `Foo` has [`drop`](./abilities)), just not efficient.
The highlighted copies can be removed and replaced with borrows

```move
let v1: vector<u8> = function_that_returns_vector();
let v2: vector<u8> = function_that_returns_vector();
assert!(&v1 == &v2, 42);
//      ^      ^
use_two_vectors(v1, v2);

let s1: Foo = function_that_returns_large_struct();
let s2: Foo = function_that_returns_large_struct();
assert!(&s1 == &s2, 42);
//      ^      ^
use_two_foos(s1, s2);
```

The efficiency of the `==` itself remains the same, but the `copy`s are removed and thus the program
is more efficient.

>>>> move-book/reference/extensions.md
---
title: 'Module Extensions | Reference'
description: ''
---

# Module Extensions

**Module Extensions** let a package add new declarations to an existing module **as if** they were
defined inside that module. Extensions are opt-in via a mode attribute and never modify or remove
existing items.

### Example

Imagine you have an off-the-shelf module that you want to test in your package, but it
lacks some internal accessors or testing operations that would allow you to write full tests over
it. As a toy example, consider a simple counter module defined as a library:

```move
module counter::counter {
    public struct Counter has drop { value: u64 }

    public fun new(): Counter { Counter { value: 0 } }

    public fun incr(mut c: Counter): Counter {
        c.value = c.value + 1;
        c
    }

    public fun destroy(c: Counter): u64 {
        let Counter { value } = c;
        value
    }
}
```

You might use this module in your own package to implement a step counter:

```move
module app::step_counter {
    use counter::counter::{Counter, new, incr, destroy};
    enum Step { Once, Many(u64) }

    public fun step(c: Counter, s: Step): Counter {
        match s {
            Step::Once => incr(c),
            Step::Many(n) => {
                let mut c = c;
                let mut i = 0;
                while (i < n) {
                    c = incr(c);
                    i = i + 1;
                }
                c
            }
        }
    }
}
```

Suppose you wanted to write additional tests for this counter behavior, including ensuring
invariants and the ability to peek at the current value without consuming the counter. Extensions
allow you to add this behavior as test definitions in your own package without forking and updating
the downstream dependency.

```move
#[test_only]
extend module counter::counter {
    /// Peek at the current value without consuming the counter.
    public fun peek(c: &Counter): u64 { c.value }
}

#[test_only]
extend module app::step_counter {
    use counter::counter::{Counter, new, incr, peek};

    // Local test helper to keep assertions tidy.
    fun expect_value(c: &Counter, want: u64) { assert!(c.peek() == want, 0); }

    /// Equivalence: Once == Many(1).
    #[test]
    fun once_equals_many1() {
        let c1a = step(new(), Step::Once);
        let c1b = step(new(), Step::Many(1));
        expect_value(&c1a, 1);
        expect_value(&c1b, 1);
    }
}
```

In this usage, you extend both the `counter::counter` module (to add helpers and tests) and the
`app::step_counter` module (to add tests for the step logic). All of this code lives in your
package, and it only affects test builds. The publishable code remains unchanged.


> **Note**: Extensions can only add new items; they cannot modify or remove existing items. In >
> addition, only extensions defined in the root package are applied (extensions in dependencies are
> not).

## Extension Syntax

Extension are defined by adding the `extend` keyword before the `module` keyword:

```move
#[mode(name1, name2, ...)]      // or #[test_only]
extend module <address>::<identifier> {
    (<use> | <type> | <function> | <constant>)*
}
```

Extensions are allowed for single-file module forms:

```move
#[mode(test)]
extend module p<address>::<identifier>;

(<use> | <type> | <function> | <constant>)*
```

In both cases:

* The extension must define a mode attribute.
* `<address>::<identifier>` is the package and module name.
* The module elements are as in a standard [module](modules).
* The extension block is compiled into the target module under the enabled modes.
* `<address>::<identifier>` must resolve to an existing module in the current build.

## Applying Extensions

Let `M` be a module in the current build. Let `E1, E2, ... En` be all extensions targeting `M` such
that:

- `Ei` is defined in the root package of the current build (others are ignored).
- `Ei` targets `M`
- `Ei` has an active mode attribute.

During expansion, the effective contents of `M` are transformed into:

```
module M {
    ... original contents of M ...
    ... contents of E1 ...
    ... contents of E2 ...
    ...
    ... contents of En ...
}
```

Name resolution, visibility, edition rules, type checking, etc., are applied to the resultant
module as a whole. This means each declaration in an extension is treated as if it were written
directly in the target module, and subject to the same visibility, edition features, duplicate
definition errors, name conflicts, etc.

This means that extensions may not modify or override existing declarations, and may not shadow
existing `use` definitions, etc. New use definitions may be added, but their compilation is still
subject to decidable dependency ordering, as described in the [`use`](uses) section.

> **Tip**: Extension code is subject of the same edition features as the target module. If the
> target module is in an older edition, the extension code must also be compatible with that
> edition.

>>>> move-book/reference/friends.md
---
title: 'Friends | Reference'
description: ''
---

# DEPRECATED: Friends

NOTE: this feature has been superseded by [`public(package)`](./functions#visibility).

The `friend` syntax was used to declare modules that are trusted by the current module. A trusted
module is allowed to call any function defined in the current module that have the `public(friend)`
visibility. For details on function visibilities, refer to the _Visibility_ section in
[Functions](./functions).

## Friend declaration

A module can declare other modules as friends via friend declaration statements, in the format of

- `friend <address::name>` — friend declaration using fully qualified module name like the example
  below, or

  ```move
  module 0x42::a {
      friend 0x42::b;
  }
  ```

- `friend <module-name-alias>` — friend declaration using a module name alias, where the module
  alias is introduced via the `use` statement.

  ```move
  module 0x42::a {
      use 0x42::b;
      friend b;
  }
  ```

A module may have multiple friend declarations, and the union of all the friend modules forms the
friend list. In the example below, both `0x42::B` and `0x42::C` are considered as friends of
`0x42::A`.

```move
module 0x42::a;

friend 0x42::b;
friend 0x42::c;
```

Unlike `use` statements, `friend` can only be declared in the module scope and not in the expression
block scope. `friend` declarations may be located anywhere a top-level construct (e.g., `use`,
`function`, `struct`, etc.) is allowed. However, for readability, it is advised to place friend
declarations near the beginning of the module definition.

### Friend declaration rules

Friend declarations are subject to the following rules:

- A module cannot declare itself as a friend.

  ```move
  module 0x42::m { friend Self; // ERROR! }
  //                      ^^^^ Cannot declare the module itself as a friend

  module 0x43::m { friend 0x43::M; // ERROR! }
  //                      ^^^^^^^ Cannot declare the module itself as a friend
  ```

- Friend modules must be known by the compiler

  ```move
  module 0x42::m { friend 0x42::nonexistent; // ERROR! }
  //                      ^^^^^^^^^^^^^^^^^ Unbound module '0x42::nonexistent'
  ```

- Friend modules must be within the same account address.

  ```move
  module 0x42::m {}

  module 0x42::n { friend 0x42::m; // ERROR! }
  //                      ^^^^^^^ Cannot declare modules out of the current address as a friend
  ```

- Friends relationships cannot create cyclic module dependencies.

  Cycles are not allowed in the friend relationships, e.g., the relation `0x2::a` friends `0x2::b`
  friends `0x2::c` friends `0x2::a` is not allowed. More generally, declaring a friend module adds a
  dependency upon the current module to the friend module (because the purpose is for the friend to
  call functions in the current module). If that friend module is already used, either directly or
  transitively, a cycle of dependencies would be created.

  ```move
  module 0x2::a {
      use 0x2::c;
      friend 0x2::b;

      public fun a() {
          c::c()
      }
  }

  module 0x2::b {
      friend 0x2::c; // ERROR!
  //         ^^^^^^ This friend relationship creates a dependency cycle: '0x2::b' is a friend of '0x2::a' uses '0x2::c' is a friend of '0x2::b'
  }

  module 0x2::c {
      public fun c() {}
  }
  ```

- The friend list for a module cannot contain duplicates.

  ```move
  module 0x42::a {}

  module 0x42::m {
      use 0x42::a as aliased_a;
      friend 0x42::A;
      friend aliased_a; // ERROR!
  //         ^^^^^^^^^ Duplicate friend declaration '0x42::a'. Friend declarations in a module must be unique
  }
  ```

>>>> move-book/reference/functions.md
---
title: 'Functions | Reference'
description: ''
---

# Functions

Functions are declared inside of modules and define the logic and behavior of the module. Functions
can be reused, either being called from other functions or as entry points for execution.

## Declaration

Functions are declared with the `fun` keyword followed by the function name, type parameters,
parameters, a return type, and finally the function body.

```text
<visibility>? <entry>? <macro>? fun <identifier><[type_parameters: constraint],*>([identifier: type],*): <return_type> <function_body>
```

For example

```move
fun foo<T1, T2>(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }
```

### Visibility

Module functions, by default, can only be called within the same module. These internal (sometimes
called private) functions cannot be called from other modules or as entry points.

```move
module a::m {
    fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module b::other {
    fun calls_m_foo(): u64 {
        a::m::foo() // ERROR!
//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'
    }
}
```

To allow access from other modules, the function must be declared `public` or `public(package)`.
Tangential to visibility, an [`entry`](#entry-modifier) function can be called as an entry point for
execution.

#### `public` visibility

A `public` function can be called by _any_ function defined in _any_ module. As shown in the
following example, a `public` function can be called by:

- other functions defined in the same module,
- functions defined in another module, or
- as an entry point for execution.

```move
module a::m {
    public fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module b::other {
    fun calls_m_foo(): u64 {
        a::m::foo() // valid
    }
}
```

Fore more details on the entry point to execution see [the section below](#entry-modifier).

#### `public(package)` visibility

The `public(package)` visibility modifier is a more restricted form of the `public` modifier to give
more control about where a function can be used. A `public(package)` function can be called by:

- other functions defined in the same module, or
- other functions defined in the same package (the same address)

```move
module a::m {
    public(package) fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid
}

module a::n {
    fun calls_m_foo(): u64 {
        a::m::foo() // valid, also in `a`
    }
}

module b::other {
    fun calls_m_foo(): u64 {
        a::m::foo() // ERROR!
//      ^^^^^^^^^^^ 'foo' can only be called from a module in `a`
    }
}
```

#### DEPRECATED `public(friend)` visibility

Before the addition of `public(package)`, `public(friend)` was used to allow limited public access
to functions in the same package, but where the list of allowed modules had to be explicitly
enumerated by the callee's module. see [Friends](./friends) for more details.

### `entry` modifier

In addition to `public` functions, you might have some functions in your modules that you want to
use as the entry point to execution. The `entry` modifier is designed to allow module functions to
initiate execution, without having to expose the functionality to other modules.

Essentially, the combination of `public` and `entry` functions define the "main" functions of a
module, and they specify where Move programs can start executing.

Keep in mind though, an `entry` function _can_ still be called by other Move functions. So while
they _can_ serve as the start of a Move program, they aren't restricted to that case.

For example:

```move
module a::m {
    entry fun foo(): u64 { 0 }
    fun calls_foo(): u64 { foo() } // valid!
}

module a::n {
    fun calls_m_foo(): u64 {
        a::m::foo() // ERROR!
//      ^^^^^^^^^^^ 'foo' is internal to 'a::m'
    }
}
```

`entry` functions may have restrictions on their parameters and return types. Although, these
restrictions are specific to each individual deployment of Move.

[The documentation for `entry` functions on Sui can be found here.](https://docs.sui.io/concepts/sui-move-concepts/entry-functions)

To enable easier testing, `entry` functions can be called from
[`#[test]` and `#[test_only]`](./unit-testing) contexts.

```move
module a::m {
    entry fun foo(): u64 { 0 }
}
module a::m_test {
    #[test]
    fun my_test(): u64 { a::m::foo() } // valid!
    #[test_only]
    fun my_test_helper(): u64 { a::m::foo() } // valid!
}
```

### `macro` modifier

Unlike normal functions, `macro` functions do not exist at runtime. Instead, these functions are
substituted inline at each call site during compilation. These `macro` functions leverage this
compilation process to provide functionality beyond standard functions, such as accepting
higher-order _lambda_-style functions as arguments. These lambda arguments, also expanded during
compilation, allow you to pass parts of the function body to the macro as arguments. For instance,
consider the following simple loop macro, where the loop body is supplied as a lambda:

```move
macro fun n_times($n: u64, $body: |u64| -> ()) {
    let n = $n;
    let mut i = 0;
    while (i < n) {
        $body(i);
        i = i + 1;
    }
}

fun example() {
    let mut sum = 0;
    n_times!(10, |x| sum = sum + x );
}
```

See the chapter on [macros](./functions/macros) for more information.

### Name

Function names can start with letters `a` to `z`. After the first character, function names can
contain underscores `_`, letters `a` to `z`, letters `A` to `Z`, or digits `0` to `9`.

```move
fun fOO() {}
fun bar_42() {}
fun bAZ_19() {}
```

### Type Parameters

After the name, functions can have type parameters

```move
fun id<T>(x: T): T { x }
fun example<T1: copy, T2>(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }
```

For more details, see [Move generics](./generics).

### Parameters

Functions parameters are declared with a local variable name followed by a type annotation

```move
fun add(x: u64, y: u64): u64 { x + y }
```

We read this as `x` has type `u64`

A function does not have to have any parameters at all.

```move
fun useless() { }
```

This is very common for functions that create new or empty data structures

```move
module a::example;

public struct Counter { count: u64 }

fun new_counter(): Counter {
    Counter { count: 0 }
}
```

### Return type

After the parameters, a function specifies its return type.

```move
fun zero(): u64 { 0 }
```

Here `: u64` indicates that the function's return type is `u64`.

Using [tuples](./primitive-types/tuples), a function can return multiple values:

```move
fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }
```

If no return type is specified, the function has an implicit return type of unit `()`. These
functions are equivalent:

```move
fun just_unit(): () { () }
fun just_unit() { () }
fun just_unit() { }
```

As mentioned in the [tuples section](./primitive-types/tuples), these tuple "values" do not exist as
runtime values. This means that a function that returns unit `()` does not return any value during
execution.

### Function body

A function's body is an expression block. The return value of the function is the last value in the
sequence

```move
fun example(): u64 {
    let mut x = 0;
    x = x + 1;
    x // returns 'x'
}
```

See [the section below for more information on returns](#returning-values)

For more information on expression blocks, see [Move variables](./variables).

### Native Functions

Some functions do not have a body specified, and instead have the body provided by the VM. These
functions are marked `native`.

Without modifying the VM source code, a programmer cannot add new native functions. Furthermore, it
is the intent that `native` functions are used for either standard library code or for functionality
needed for the given Move environment.

Most `native` functions you will likely see are in standard library code, such as `vector`

```move
module std::vector {
    native public fun length<Element>(v: &vector<Element>): u64;
    ...
}
```

## Calling

When calling a function, the name can be specified either through an alias or fully qualified

```move
module a::example {
    public fun zero(): u64 { 0 }
}

module b::other {
    use a::example::{Self, zero};
    fun call_zero() {
        // With the `use` above all of these calls are equivalent
        a::example::zero();
        example::zero();
        zero();
    }
}
```

When calling a function, an argument must be given for every parameter.

```move
module a::example {
    public fun takes_none(): u64 { 0 }
    public fun takes_one(x: u64): u64 { x }
    public fun takes_two(x: u64, y: u64): u64 { x + y }
    public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }
}

module b::other {
    fun call_all() {
        a::example::takes_none();
        a::example::takes_one(0);
        a::example::takes_two(0, 1);
        a::example::takes_three(0, 1, 2);
    }
}
```

Type arguments can be either specified or inferred. Both calls are equivalent.

```move
module a::example {
    public fun id<T>(x: T): T { x }
}

module b::other {
    fun call_all() {
        a::example::id(0);
        a::example::id<u64>(0);
    }
}
```

For more details, see [Move generics](./generics).

## Returning values

The result of a function, its "return value", is the final value of its function body. For example

```move
fun add(x: u64, y: u64): u64 {
    x + y
}
```

The return value here is the result of `x + y`.

[As mentioned above](#function-body), the function's body is an [expression block](./variables). The
expression block can sequence various statements, and the final expression in the block will be
the value of that block

```move
fun double_and_add(x: u64, y: u64): u64 {
    let double_x = x * 2;
    let double_y = y * 2;
    double_x + double_y
}
```

The return value here is the result of `double_x + double_y`

### `return` expression

A function implicitly returns the value that its body evaluates to. However, functions can also use
the explicit `return` expression:

```move
fun f1(): u64 { return 0 }
fun f2(): u64 { 0 }
```

These two functions are equivalent. In this slightly more involved example, the function subtracts
two `u64` values, but returns early with `0` if the second value is too large:

```move
fun safe_sub(x: u64, y: u64): u64 {
    if (y > x) return 0;
    x - y
}
```

Note that the body of this function could also have been written as `if (y > x) 0 else x - y`.

However `return` really shines is in exiting deep within other control flow constructs. In this
example, the function iterates through a vector to find the index of a given value:

```move
fun index_of<T>(v: &vector<T>, target: &T): Option<u64> {
    let mut i = 0;
    let n = v.length();
    while (i < n) {
        if (&v[i] == target) return option::some(i);
        i = i + 1
    };

    option::none()
}
```

Using `return` without an argument is shorthand for `return ()`. That is, the following two
functions are equivalent:

```move
fun foo() { return }
fun foo() { return () }
```

>>>> move-book/reference/functions/macros.md
---
title: 'Macro Functions | Reference'
description: ''
---

# Macro Functions

Macro functions are a way of defining functions that are expanded during compilation at each call
site. The arguments of the macro are not evaluated eagerly like a normal function, and instead are
substituted by expression. In addition, the caller can supply code to the macro via
[lambdas](#lambdas).

These expression substitution mechanics make `macro` functions similar
[to macros found in other programming languages](<https://en.wikipedia.org/wiki/Macro_(computer_science)>);
however, they are more constrained in Move than you might expect from other languages. The
parameters and return values of `macro` functions are still typed--though this can be partially
relaxed with the [`_` type](./../generics#_-type). The upside of this restriction however, is that
`macro` functions can be used anywhere a normal function can be used, which is notably helpful with
[method syntax](./../method-syntax).

A more extensive
[syntactic macro](<https://en.wikipedia.org/wiki/Macro_(computer_science)#Syntactic_macros>) system
may come in the future.

## Syntax

`macro` functions have a similar syntax to normal functions. However, all type parameter names and
all parameter names must start with a `$`. Note that `_` can still be used by itself, but not as a
prefix, and `$_` must be used instead.

```text
<visibility>? macro fun <identifier><[$type_parameters: constraint],*>([$identifier: type],*): <return_type> <function_body>
```

For example, the following `macro` function takes a vector and a lambda, and applies the lambda to
each element of the vector to construct a new vector.

```move
macro fun map<$T, $U>($v: vector<$T>, $f: |$T| -> $U): vector<$U> {
    let mut v = $v;
    v.reverse();
    let mut i = 0;
    let mut result = vector[];
    while (!v.is_empty()) {
        result.push_back($f(v.pop_back()));
        i = i + 1;
    };
    result
}
```

The `$` is there to indicate that the parameters (both type and value parameters) do not behave like
their normal, non-macro counterparts. For type parameters, they can be instantiated with any type
(even a reference type `&` or `&mut`), and they will satisfy any constraint. Similarly for
parameters, they will not be evaluated eagerly, and instead the argument expression will be
substituted at each usage.

## Lambdas

Lambdas are a new type of expression that can only be used with `macro`s. These are used to pass
code from the caller into the body of the `macro`. While the substitution is done at compile time,
they are used similarly to [anonymous functions](https://en.wikipedia.org/wiki/Anonymous_function),
[lambdas](https://en.wikipedia.org/wiki/Lambda_calculus), or
[closures](<https://en.wikipedia.org/wiki/Closure_(computer_programming)>) in other languages.

As seen in the example above (`$f: |$T| -> $U`), lambda types are defined with the syntax

```text
|<type>,*| (-> <type>)?
```

A few examples

```move
|u64, u64| -> u128 // a lambda that takes two u64s and returns a u128
|&mut vector<u8>| -> &mut u8 // a lambda that takes a &mut vector<u8> and returns a &mut u8
```

If the return type is not annotated, it is unit `()` by default.

```move
// the following are equivalent
|&mut vector<u8>, u64|
|&mut vector<u8>, u64| -> ()
```

Lambda expressions are then defined at the call site of the `macro` with the syntax

```text
|(<identifier> (: <type>)?),*| <expression>
|(<identifier> (: <type>)?),*| -> <type> { <expression> }
```

Note that if the return type is annotated, the body of the lambda must be enclosed in `{}`.

Using the `map` macro defined above

```move
let v = vector[1, 2, 3];
let doubled: vector<u64> = map!(v, |x| 2 * x);
let bytes: vector<vector<u8>> = map!(v, |x| std::bcs::to_bytes(&x));
```

And with type annotations

```move
let doubled: vector<u64> = map!(v, |x: u64| 2 * x); // return type annotation optional
let bytes: vector<vector<u8>> = map!(v, |x: u64| -> vector<u8> { std::bcs::to_bytes(&x) });
```

### Capturing

Lambda expressions can also refer to variables in the scope where the lambda is defined. This is
sometimes called "capturing".

```move
let res = foo();
let incremented = map!(vector[1, 2, 3], |x| x + res);
```

Any variable can be captured, including mutable and immutable references.

See the [Examples](#iterating-over-a-vector) section for more complicated usages.

### Limitations

Currently, lambdas can only be used directly in the call of a `macro` function. They cannot be bound
to a variable. For example, the following is code will produce an error:

```move
let f = |x| 2 * x;
//      ^^^^^^^^^ Error! Lambdas must be used directly in 'macro' calls
let doubled: vector<u64> = map!(vector[1, 2, 3], f);
```

## Typing

Like normal functions, `macro` functions are typed--the types of the parameters and return value
must be annotated. However, the body of the function is not type checked until the macro is
expanded. This means that not all usages of a given macro may be valid. For example

```move
macro fun add_one<$T>($x: $T): $T {
    $x + 1
}
```

The above macro will not type check if `$T` is not a primitive integer type.

This can be particularly useful in conjunction with [method syntax](./../method-syntax), where the
function is not resolved until after the macro is expanded.

```move
macro fun call_foo<$T, $U>($x: $T): &$U {
    $x.foo()
}
```

This macro will only expand successfully if `$T` has a method `foo` that returns a reference `&$U`.
As described in the [hygiene](#hygiene) section, `foo` will be resolved based on the scope where
`call_foo` was defined--not where it was expanded.

### Type Parameters

Type parameters can be instantiated with any type, including reference types `&` and `&mut`. They
can also be instantiated with [tuple types](./../primitive-types/tuples), though the utility of this
is limited currently since tuples cannot be bound to a variable.

This relaxation forces the constraints of a type parameter to be satisfied at the call site in a way
that does not normally occur. It is generally recommended however to add all necessary constraints
to a type parameter. For example

```move
public struct NoAbilities()
public struct CopyBox<T: copy> has copy, drop { value: T }
macro fun make_box<$T>($x: $T): CopyBox<$T> {
    CopyBox { value: $x }
}
```

This macro will expand only if `$T` is instantiated with a type with the `copy` ability.

```move
make_box!(1); // Valid!
make_box!(NoAbilities()); // Error! 'NoAbilities' does not have the copy ability
```

The suggested declaration of `make_box` would be to add the `copy` constraint to the type parameter.
This then communicates to the caller that the type must have the `copy` ability.

```move
macro fun make_box<$T: copy>($x: $T): CopyBox<$T> {
    CopyBox { value: $x }
}
```

One might reasonably ask then, why have this relaxation if the recommendation is not to use it? The
constraints on type parameters simply cannot be enforced in all cases because the bodies are not
checked until expansion. In the following example, the `copy` constraint on `$T` is not necessary in
the signature, but is necessary in the body.

```move
macro fun read_ref<$T>($r: &$T): $T {
    *$r
}
```

If however, you want to have an extremely relaxed type signature, it is instead recommended to use
the [`_` type](#_-type).

### `_` Type

Normally, the [`_` placeholder type](./../generics#_-type) is used in expressions to allow for
partial annotations of type arguments. However, with `macro` functions, the `_` type can be used in
place of type parameters to relax the signature for any type. This should increase the ergonomics of
declaring "generic" `macro` functions.

For example, we could take any combination of integers and add them together.

```move
macro fun add($x: _, $y: _, $z: _): u256 {
    ($x as u256) + ($y as u256) + ($z as u256)
}
```

Additionally, the `_` type can be instantiated _multiple_ times with different types. For example

```move
public struct Box<T> has copy, drop, store { value: T }
macro fun create_two($f: |_| -> Box<_>): (Box<u8>, Box<u16>) {
    ($f(0u8), $f(0u16))
}
```

If we declared the function with type parameters instead, the types would have to unify to a common
type, which is not possible in this case.

```move
macro fun create_two<$T>($f: |$T| -> Box<$T>): (Box<u8>, Box<u16>) {
    ($f(0u8), $f(0u16))
    //           ^^^^ Error! expected `u8` but found `u16`
}
...
let (a, b) = create_two!(|value| Box { value });
```

In this case, `$T` must be instantiated with a single type, but inference finds that `$T` must be
bound to both `u8` and `u16`.

There is a tradeoff however, as the `_` type conveys less meaning and intention for the caller.
Consider `map` macro from above re-declared with `_` instead of `$T` and `$U`.

```move
macro fun map($v: vector<_>, $f: |_| -> _): vector<_> {
```

There is no longer any indication of behavior of `$f` at the type level. The caller must gain
understanding from comments or the body of the macro.

## Expansion and Substitution

The body of the `macro` is substituted into the call site at compile time. Each parameter is
replaced by the _expression_, not the value, of its argument. For lambdas, additional local
variables can have values bound within the context of the `macro` body.

Taking a very simple example

```move
macro fun apply($f: |u64| -> u64, $x: u64): u64 {
    $f($x)
}
```

With the call site

```move
let incremented = apply!(|x| x + 1, 5);
```

This will roughly be expanded to

```move
let incremented = {
    let x = { 5 };
    { x + 1 }
};
```

Again, the value of `x` is not substituted, but the expression `5` is. This might mean that an
argument is evaluated multiple times, or not at all, depending on the body of the `macro`.

```move
macro fun dup($f: |u64, u64| -> u64, $x: u64): u64 {
    $f($x, $x)
}
```

```move
let sum = dup!(|x, y| x + y, foo());
```

is expanded to

```move
let sum = {
    let x = { foo() };
    let y = { foo() };
    { x + y }
};
```

Note that `foo()` will be called twice. Which would not happen if `dup` were a normal function.

It is often recommended to create predictable evaluation behavior by binding arguments to local
variables.

```move
macro fun dup($f: |u64, u64| -> u64, $x: u64): u64 {
    let a = $x;
    $f(a, a)
}
```

Now that same call site will expand to

```move
let sum = {
    let a = { foo() };
    {
        let x = { a };
        let y = { a };
        { x + y }
    }
};
```

### Hygiene

In the example above, the `dup` macro had a local variable `a` that was used to bind the argument
`$x`. You might ask, what would happen if the variable was instead named `x`? Would that conflict
with the `x` in the lambda?

The short answer is, no. `macro` functions are
[hygienic](https://en.wikipedia.org/wiki/Hygienic_macro), meaning that the expansion of `macro`s and
lambdas will not accidentally capture variables from another scope.

The compiler does this by associating a unique number with each scope. When the `macro` is expanded,
the macro body gets its own scope. Additionally, the arguments are re-scoped on each usage.

Modifying the `dup` macro to use `x` instead of `a`

```move
macro fun dup($f: |u64, u64| -> u64, $x: u64): u64 {
    let a = $x;
    $f(a, a)
}
```

The expansion of the call site

```move
// let sum = dup!(|x, y| x + y, foo());
let sum = {
    let x#1 = { foo() };
    {
        let x#2 = { x#1 };
        let y#2 = { x#1 };
        { x#2 + y#2 }
    }
};
```

This is an approximation of the compiler's internal representation, some details are omitted for the
simplicity of this example.

And each usage of an argument is re-scoped so that the different usages do not conflict.

```move
macro fun apply_twice($f: |u64| -> u64, $x: u64): u64 {
    $f($x) + $f($x)
}
```

```move
let result = apply_twice!(|x| x + 1, { let x = 5; x });
```

Expands to

```move
let result = {
    {
        let x#1 = { let x#2 = { 5 }; x#2 };
        { x#1 + x#1 }
    }
    +
    {
        let x#3 = { let x#4 = { 5 }; x#4 };
        { x#3 + x#3 }
    }
};
```

Similar to variable hygiene, [method resolution](./../method-syntax) is also scoped to the macro
definition. For example

```move
public struct S { f: u64, g: u64 }

fun f(s: &S): u64 {
    s.f
}
fun g(s: &S): u64 {
    s.g
}

use fun f as foo;
macro fun call_foo($s: &S): u64 {
    let s = $s;
    s.foo()
}
```

The method call `foo` will in this case always resolve to the function `f`, even if `call_foo` is
used in a scope where `foo` is bound to a different function, such as `g`.

```move
fun example(s: &S): u64 {
    use fun g as foo;
    call_foo!(s) // expands to 'f(s)', not 'g(s)'
}
```

Due to this though, unused `use fun` declarations might not get warnings in modules with `macro`
functions.

### Control Flow

Similar to variable hygiene, control flow constructs are also always scoped to where they are
defined, not to where they are expanded.

```move
macro fun maybe_div($x: u64, $y: u64): u64 {
    let x = $x;
    let y = $y;
    if (y == 0) return 0;
    x / y
}
```

At the call site, `return` will always return from the `macro` body, not from the caller.

```move
let result: vector<u64> = vector[maybe_div!(10, 0)];
```

Will expand to

```move
let result: vector<u64> = vector['a: {
    let x = { 10 };
    let y = { 0 };
    if (y == 0) return 'a 0;
    x / y
}];
```

Where `return 'a 0` will return to the block `'a: { ... }` and not to the caller's body. See the
section on [labeled control flow](./../control-flow/labeled-control-flow) for more details.

Similarly, `return` in a lambda will return from the lambda, not from the `macro` body and not from
the outer function.

```move
macro fun apply($f: |u64| -> u64, $x: u64): u64 {
    $f($x)
}
```

and

```move
let result = apply!(|x| { if (x == 0) return 0; x + 1 }, 100);
```

will expand to

```move
let result = {
    let x = { 100 };
    'a: {
        if (x == 0) return 'a 0;
        x + 1
    }
};
```

In addition to returning from the lambda, a label can be used to return to the outer function. In
the `vector::any` macro, a `return` with a label is used to return from the entire `macro` early

```move
public macro fun any<$T>($v: &vector<$T>, $f: |&$T| -> bool): bool {
    let v = $v;
    'any: {
        v.do_ref!(|e| if ($f(e)) return 'any true);
        false
    }
}
```

The `return 'any true` exits from the "loop" early when the condition is met. Otherwise, the macro
"returns" `false`.

### Method Syntax

When applicable, `macro` functions can be called using [method syntax](./../method-syntax). When
using method syntax, the evaluation of the arguments will change in that the first argument (the
"receiver" of the method) will be evaluated outside of the macro expansion. This example is
contrived, but will concisely demonstrate the behavior.

```move
public struct S() has copy, drop;
public fun foo(): S { abort 0 }
public macro fun maybe_s($s: S, $cond: bool): S {
    if ($cond) $s
    else S()
}
```

Even though `foo()` will abort, its return type can be used to start a method call.

`$s` will not be evaluated if `$cond` is `false`, and under a normal non-method call, an argument of
`foo()` would not be evaluated and would not abort. The following example demonstrates `$s` not
being evaluated with an argument of `foo()`.

```move
maybe_s!(foo(), false) // does not abort
```

It becomes more clear as to why it does not abort when looking at the expanded form

```move
if (false) foo()
else S()
```

However, when using method syntax, the first argument is evaluated before the macro is expanded. So
the same argument of `foo()` for `$s` will now be evaluated and will abort.

```move
foo().maybe_s!(false) // aborts
```

We can see this more clearly when looking the expanded form

```move
let tmp = foo(); // aborts
if (false) tmp
else S()
```

Conceptually, the receiver for a method call is bound to a temporary variable before the macro is
expanded, which forces the evaluation and thus the abort.

### Parameter Limitations

The parameters of a `macro` function must always be used as expressions. They cannot be used in
situations where the argument might be re-interpreted. For example, the following is not allowed

```move
macro fun no($x: _): _ {
    $x.f
}
```

The reason is that if the argument `$x` was not a reference, it would be borrowed first, which would
could re-interpret the argument. To get around this limitation, you should bind the argument to a
local variable.

```move
macro fun yes($x: _): _ {
    let x = $x;
    x.f
}
```

## Examples

### Lazy arguments: assert_eq

```move
macro fun assert_eq<$T>($left: $T, $right: $T, $code: u64) {
    let left = $left;
    let right = $right;
    if (left != right) {
        std::debug::print(&b"assertion failed.\n left: ");
        std::debug::print(&left);
        std::debug::print(&b"\n does not equal right: ");
        std::debug::print(&right);
        abort $code;
    }
}
```

In this case the argument to `$code` is not evaluated unless the assertion fails.

```move
assert_eq!(vector[true, false], vector[true, false], 1 / 0); // division by zero is not evaluated
```

### Any integer square root

This macro calculates the integer square root for any integer type, besides `u256`.

`$T` is the type of the input and `$bitsize` is the number of bits in that type, for example `u8`
has 8 bits. `$U` should be set to the next larger integer type, for example `u16` for `u8`.

In this `macro`, the type of the integer literals are `1` and `0` are annotated, e.g. `(1: $U)`
allowing for the type of the literal to differ with each call. Similarly, `as` can be used with the
type parameters `$T` and `$U`. This macro will then only successfully expand if `$T` and `$U` are
instantiated with the integer types.

```move
macro fun num_sqrt<$T, $U>($x: $T, $bitsize: u8): $T {
    let x = $x;
    let mut bit = (1: $U) << $bitsize;
    let mut res = (0: $U);
    let mut x = x as $U;

    while (bit != 0) {
        if (x >= res + bit) {
            x = x - (res + bit);
            res = (res >> 1) + bit;
        } else {
            res = res >> 1;
        };
        bit = bit >> 2;
    };

    res as $T
}
```

### Iterating over a vector

The two `macro`s iterate over a vector, immutably and mutably respectively.

```move
macro fun for_imm<$T>($v: &vector<$T>, $f: |&$T|) {
    let v = $v;
    let n = v.length();
    let mut i = 0;
    while (i < n) {
        $f(&v[i]);
        i = i + 1;
    }
}

macro fun for_mut<$T>($v: &mut vector<$T>, $f: |&mut $T|) {
    let v = $v;
    let n = v.length();
    let mut i = 0;
    while (i < n) {
        $f(&mut v[i]);
        i = i + 1;
    }
}
```

A few examples of usage

```move
fun imm_examples(v: &vector<u64>) {
    // print all elements
    for_imm!(v, |x| std::debug::print(x));

    // sum all elements
    let mut sum = 0;
    for_imm!(v, |x| sum = sum + x);

    // find the max element
    let mut max = 0;
    for_imm!(v, |x| if (x > max) max = x);
}

fun mut_examples(v: &mut vector<u64>) {
    // increment each element
    for_mut!(v, |x| *x = *x + 1);

    // set each element to the previous value, and the first to last value
    let mut prev = v[v.length() - 1];
    for_mut!(v, |x| {
        let tmp = *x;
        *x = prev;
        prev = tmp;
    });

    // set the max element to 0
    let mut max = &mut 0;
    for_mut!(v, |x| if (*x > *max) max = x);
    *max = 0;
}
```

### Non-loop lambda usage

Lambdas do not need to be used in loops, and are often useful for conditionally applying code.

```move
macro fun inspect<$T>($opt: &Option<$T>, $f: |&$T|) {
    let opt = $opt;
    if (opt.is_some()) $f(opt.borrow())
}

macro fun is_some_and<$T>($opt: &Option<$T>, $f: |&$T| -> bool): bool {
    let opt = $opt;
    if (opt.is_some()) $f(opt.borrow())
    else false
}

macro fun map<$T, $U>($opt: Option<$T>, $f: |$T| -> $U): Option<$U> {
    let opt = $opt;
    if (opt.is_some()) {
        option::some($f(opt.destroy_some()))
    } else {
        opt.destroy_none();
        option::none()
    }
}
```

And some examples of usage

```move
fun examples(opt: Option<u64>) {
    // print the value if it exists
    inspect!(&opt, |x| std::debug::print(x));

    // check if the value is 0
    let is_zero = is_some_and!(&opt, |x| *x == 0);

    // upcast the u64 to a u256
    let str_opt = map!(opt, |x| x as u256);
}
```

>>>> move-book/reference/generics.md
---
title: 'Generics | Reference'
description: ''
---

# Generics

Generics can be used to define functions and structs over different input data types. This language
feature is sometimes referred to as parametric polymorphism. In Move, we will often use the term
generics interchangeably with _type parameters_ and _type arguments_.

Generics are commonly used in library code, such as in [vector](./primitive-types/vector), to
declare code that works over any possible type (that satisfies the specified constraints). This sort
of parameterization allows you to reuse the same implementation across multiple types and
situations.

## Declaring Type Parameters

Both functions and structs can take a list of type parameters in their signatures, enclosed by a
pair of angle brackets `<...>`.

### Generic Functions

Type parameters for functions are placed after the function name and before the (value) parameter
list. The following code defines a generic identity function that takes a value of any type and
returns that value unchanged.

```move
fun id<T>(x: T): T {
    // this type annotation is unnecessary but valid
    (x: T)
}
```

Once defined, the type parameter `T` can be used in parameter types, return types, and inside the
function body.

### Generic Structs

Type parameters for structs are placed after the struct name, and can be used to name the types of
the fields.

```move
public struct Foo<T> has copy, drop { x: T }

public struct Bar<T1, T2> has copy, drop {
    x: T1,
    y: vector<T2>,
}
```

Note that [type parameters do not have to be used](#unused-type-parameters)

## Type Arguments

### Calling Generic Functions

When calling a generic function, one can specify the type arguments for the function's type
parameters in a list enclosed by a pair of angle brackets.

```move
fun foo() {
    let x = id<bool>(true);
}
```

If you do not specify the type arguments, Move's [type inference](#type-inference) will supply them
for you.

### Using Generic Structs

Similarly, one can attach a list of type arguments for the struct's type parameters when
constructing or destructing values of generic types.

```move
fun foo() {
    // type arguments on construction
    let foo = Foo<bool> { x: true };
    let bar = Bar<u64, u8> { x: 0, y: vector<u8>[] };

    // type arguments on destruction
    let Foo<bool> { x } = foo;
    let Bar<u64, u8> { x, y } = bar;
}
```

In any case if you do not specify the type arguments, Move's [type inference](#type-inference) will
supply them for you.

### Type Argument Mismatch

If you specify the type arguments and they conflict with the actual values supplied, an error will
be given:

```move
fun foo() {
    let x = id<u64>(true); // ERROR! true is not a u64
}
```

and similarly:

```move
fun foo() {
    let foo = Foo<bool> { x: 0 }; // ERROR! 0 is not a bool
    let Foo<address> { x } = foo; // ERROR! bool is incompatible with address
}
```

## Type Inference

In most cases, the Move compiler will be able to infer the type arguments so you don't have to write
them down explicitly. Here's what the examples above would look like if we omit the type arguments:

```move
fun foo() {
    let x = id(true);
    //        ^ <bool> is inferred

    let foo = Foo { x: true };
    //           ^ <bool> is inferred

    let Foo { x } = foo;
    //     ^ <bool> is inferred
}
```

Note: when the compiler is unable to infer the types, you'll need annotate them manually. A common
scenario is to call a function with type parameters appearing only at return positions.

```move
module a::m;

fun foo() {
    let v = vector[]; // ERROR!
    //            ^ The compiler cannot figure out the element type, since it is never used

    let v = vector<u64>[];
    //            ^~~~~ Must annotate manually in this case.
}
```

Note that these cases are a bit contrived since the `vector[]` is never used, ad as such, Move's
type inference cannot infer the type.

However, the compiler will be able to infer the type if that value is used later in that function:

```move
module a::m;

fun foo() {
    let v = vector[];
    //            ^ <u64> is inferred
    vector::push_back(&mut v, 42);
    //               ^ <u64> is inferred
}
```

### `_` Type

In some cases, you might want to explicitly annotate some of the type arguments, but let the
compiler infer the others. The `_` type serves as such a placeholder for the compiler to infer the
type.

```move
let bar = Bar<u64, _> { x: 0, y: vector[b"hello"] };
//                 ^ vector<u8> is inferred
```

The placeholder `_` may only appear in expressions and macro function definitions, not signatures.
This means you cannot use `_` as part of the definition of a function parameter, function return
type, constant definition type, and datatype field.

## Integers

In Move, the integer types `u8`, `u16`, `u32`, `u64`, `u128`, and `u256` are all distinct types.
However, each one of these types can be created with the same numerical value syntax. In other
words, if a type suffix is not provided, the compiler will infer the integer type based on the usage
of the value.

```move
let x8: u8 = 0;
let x16: u16 = 0;
let x32: u32 = 0;
let x64: u64 = 0;
let x128: u128 = 0;
let x256: u256 = 0;
```

If the value is not used in a context that requires a specific integer type, `u64` is taken as a
default.

```move
let x = 0;
//      ^ u64 is used by default
```

If the value however is too large for the inferred type, an error will be given

```move
let i: u8 = 256; // ERROR!
//          ^^^ too large for u8
let x = 340282366920938463463374607431768211454;
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ too large for u64
```

In cases where the number is too large, you might need to annotate it explicitly

```move
let x = 340282366920938463463374607431768211454u128;
//                                             ^^^^ valid!
```

## Unused Type Parameters

For a struct definition, an unused type parameter is one that does not appear in any field defined
in the struct, but is checked statically at compile time. Move allows unused type parameters so the
following struct definition is valid:

```move
public struct Foo<T> {
    foo: u64
}
```

This can be convenient when modeling certain concepts. Here is an example:

```move
module a::m;

// Currency Specifiers
public struct A {}
public struct B {}

// A generic coin type that can be instantiated using a currency
// specifier type.
//   e.g. Coin<A>, Coin<B> etc.
public struct Coin<Currency> has store {
    value: u64
}

// Write code generically about all currencies
public fun mint_generic<Currency>(value: u64): Coin<Currency> {
    Coin { value }
}

// Write code concretely about one currency
public fun mint_a(value: u64): Coin<A> {
    mint_generic(value)
}
public fun mint_b(value: u64): Coin<B> {
    mint_generic(value)
}
```

In this example, `Coin<Currency>` is generic on the `Currency` type parameter, which specifies the
currency of the coin and allows code to be written either generically on any currency or concretely
on a specific currency. This generality applies even when the `Currency` type parameter does not
appear in any of the fields defined in `Coin`.

### Phantom Type Parameters

In the example above, although `struct Coin` asks for the `store` ability, neither `Coin<A>` nor
`Coin<B>` will have the `store` ability. This is because of the rules for
[Conditional Abilities and Generic Types](./abilities#conditional-abilities-and-generic-types) and
the fact that `A` and `B` don't have the `store` ability, despite the fact that they are not even
used in the body of `struct Coin`. This might cause some unpleasant consequences. For example, we
are unable to put `Coin<A>` into a wallet in storage.

One possible solution would be to add spurious ability annotations to `A` and `B` (i.e.,
`public struct Currency1 has store {}`). But, this might lead to bugs or security vulnerabilities
because it weakens the types with unnecessary ability declarations. For example, we would never
expect a value in the storage to have a field in type `A`, but this would be possible with the
spurious `store` ability. Moreover, the spurious annotations would be infectious, requiring many
functions generic on the unused type parameter to also include the necessary constraints.

Phantom type parameters solve this problem. Unused type parameters can be marked as _phantom_ type
parameters, which do not participate in the ability derivation for structs. In this way, arguments
to phantom type parameters are not considered when deriving the abilities for generic types, thus
avoiding the need for spurious ability annotations. For this relaxed rule to be sound, Move's type
system guarantees that a parameter declared as `phantom` is either not used at all in the struct
definition, or it is only used as an argument to type parameters also declared as `phantom`.

#### Declaration

In a struct definition a type parameter can be declared as phantom by adding the `phantom` keyword
before its declaration.

```move
public struct Coin<phantom Currency> has store {
    value: u64
}
```

If a type parameter is declared as phantom we say it is a phantom type parameter. When defining a
struct, Move's type checker ensures that every phantom type parameter is either not used inside the
struct definition or it is only used as an argument to a phantom type parameter.

```move
public struct S1<phantom T1, T2> { f: u64 }
//               ^^^^^^^ valid, T1 does not appear inside the struct definition

public struct S2<phantom T1, T2> { f: S1<T1, T2> }
//               ^^^^^^^ valid, T1 appears in phantom position
```

The following code shows examples of violations of the rule:

```move
public struct S1<phantom T> { f: T }
//               ^^^^^^^ ERROR!  ^ Not a phantom position

public struct S2<T> { f: T }
public struct S3<phantom T> { f: S2<T> }
//               ^^^^^^^ ERROR!     ^ Not a phantom position
```

More formally, if a type is used as an argument to a phantom type parameter we say the type appears
in _phantom position_. With this definition in place, the rule for the correct use of phantom
parameters can be specified as follows: **A phantom type parameter can only appear in phantom
position**.

Note that specifying `phantom` is not required, but the compiler will warn if a type parameter could
be `phantom` but was not marked as such.

#### Instantiation

When instantiating a struct, the arguments to phantom parameters are excluded when deriving the
struct abilities. For example, consider the following code:

```move
public struct S<T1, phantom T2> has copy { f: T1 }
public struct NoCopy {}
public struct HasCopy has copy {}
```

Consider now the type `S<HasCopy, NoCopy>`. Since `S` is defined with `copy` and all non-phantom
arguments have `copy` then `S<HasCopy, NoCopy>` also has `copy`.

#### Phantom Type Parameters with Ability Constraints

Ability constraints and phantom type parameters are orthogonal features in the sense that phantom
parameters can be declared with ability constraints.

```move
public struct S<phantom T: copy> {}
```

When instantiating a phantom type parameter with an ability constraint, the type argument has to
satisfy that constraint, even though the parameter is phantom. The usual restrictions apply and `T`
can only be instantiated with arguments having `copy`.

## Constraints

In the examples above, we have demonstrated how one can use type parameters to define "unknown"
types that can be plugged in by callers at a later time. This however means the type system has
little information about the type and has to perform checks in a very conservative way. In some
sense, the type system must assume the worst case scenario for an unconstrained generic--a type with
no [abilities](./abilities).

Constraints offer a way to specify what properties these unknown types have so the type system can
allow operations that would otherwise be unsafe.

### Declaring Constraints

Constraints can be imposed on type parameters using the following syntax.

```move
// T is the name of the type parameter
T: <ability> (+ <ability>)*
```

The `<ability>` can be any of the four [abilities](./abilities), and a type parameter can be
constrained with multiple abilities at once. So all of the following would be valid type parameter
declarations:

```move
T: copy
T: copy + drop
T: copy + drop + store + key
```

### Verifying Constraints

Constraints are checked at instantiation sites

```move
public struct Foo<T: copy> { x: T }

public struct Bar { x: Foo<u8> }
//                         ^^ valid, u8 has `copy`

public struct Baz<T> { x: Foo<T> }
//                            ^ ERROR! T does not have 'copy'
```

And similarly for functions

```move
fun unsafe_consume<T>(x: T) {
    // ERROR! x does not have 'drop'
}

fun consume<T: drop>(x: T) {
    // valid, x will be dropped automatically
}

public struct NoAbilities {}

fun foo() {
    let r = NoAbilities {};
    consume<NoAbilities>(NoAbilities);
    //      ^^^^^^^^^^^ ERROR! NoAbilities does not have 'drop'
}
```

And some similar examples, but with `copy`

```move
fun unsafe_double<T>(x: T) {
    (copy x, x)
    // ERROR! T does not have 'copy'
}

fun double<T: copy>(x: T) {
    (copy x, x) // valid, T has 'copy'
}

public struct NoAbilities {}

fun foo(): (NoAbilities, NoAbilities) {
    let r = NoAbilities {};
    double<NoAbilities>(r)
    //     ^ ERROR! NoAbilities does not have 'copy'
}
```

For more information, see the abilities section on
[conditional abilities and generic types](./abilities#conditional-abilities-and-generic-types).

## Limitations on Recursions

### Recursive Structs

Generic structs can not contain fields of the same type, either directly or indirectly, even with
different type arguments. All of the following struct definitions are invalid:

```move
public struct Foo<T> {
    x: Foo<u64> // ERROR! 'Foo' containing 'Foo'
}

public struct Bar<T> {
    x: Bar<T> // ERROR! 'Bar' containing 'Bar'
}

// ERROR! 'A' and 'B' forming a cycle, which is not allowed either.
public struct A<T> {
    x: B<T, u64>
}

public struct B<T1, T2> {
    x: A<T1>
    y: A<T2>
}
```

### Advanced Topic: Type-level Recursions

Move allows generic functions to be called recursively. However, when used in combination with
generic structs, this could create an infinite number of types in certain cases, and allowing this
means adding unnecessary complexity to the compiler, vm and other language components. Therefore,
such recursions are forbidden.

This restriction might be relaxed in the future, but for now, the following examples should give you
an idea of what is allowed and what is not.

```move
module a::m;

public struct A<T> {}

// Finitely many types -- allowed.
// foo<T> -> foo<T> -> foo<T> -> ... is valid
fun foo<T>() {
    foo<T>();
}

// Finitely many types -- allowed.
// foo<T> -> foo<A<u64>> -> foo<A<u64>> -> ... is valid
fun foo<T>() {
    foo<A<u64>>();
}
```

Not allowed:

```move
module a::m;

public struct A<T> {}

// Infinitely many types -- NOT allowed.
// error!
// foo<T> -> foo<A<T>> -> foo<A<A<T>>> -> ...
fun foo<T>() {
    foo<Foo<T>>();
}
```

And similarly, not allowed:

```move
module a::n;

public struct A<T> {}

// Infinitely many types -- NOT allowed.
// error!
// foo<T1, T2> -> bar<T2, T1> -> foo<T2, A<T1>>
//   -> bar<A<T1>, T2> -> foo<A<T1>, A<T2>>
//   -> bar<A<T2>, A<T1>> -> foo<A<T2>, A<A<T1>>>
//   -> ...
fun foo<T1, T2>() {
    bar<T2, T1>();
}

fun bar<T1, T2> {
    foo<T1, A<T2>>();
}
```

Note, the check for type level recursions is based on a conservative analysis on the call sites and
does NOT take control flow or runtime values into account.

```move
module a::m;

public struct A<T> {}

// Infinitely many types -- NOT allowed.
// error!
fun foo<T>(n: u64) {
    if (n > 0) foo<A<T>>(n - 1);
}
```

The function in the example above will technically terminate for any given input and therefore only
creating finitely many types, but it is still considered invalid by Move's type system.

>>>> move-book/reference/index-syntax.md
---
title: 'Index Syntax | Reference'
description: ''
---

# Index Syntax

Move provides syntax attributes to allow you to define operations that look and feel like native
Move code, lowering these operations into your user-provided definitions.

Our first syntax method, `index`, allows you to define a group of operations that can be used as
custom index accessors for your datatypes, such as accessing a matrix element as `m[i,j]`, by
annotating functions that should be used for these index operations. Moreover, these definitions are
bespoke per-type and available implicitly for any programmer using your type.

## Overview and Summary

To start, consider a `Matrix` type that uses a vector of vectors to represent its values. You can
write a small library using `index` syntax annotations on the `borrow` and `borrow_mut` functions as
follows:

```move
module matrix::matrix;

public struct Matrix<T> { v: vector<vector<T>> }

#[syntax(index)]
public fun borrow<T>(s: &Matrix<T>, i: u64, j: u64): &T {
    vector::borrow(vector::borrow(&s.v, i), j)
}

#[syntax(index)]
public fun borrow_mut<T>(s: &mut Matrix<T>, i: u64, j: u64): &mut T {
    vector::borrow_mut(vector::borrow_mut(&mut s.v, i), j)
}

public fun make_matrix<T>(v: vector<vector<T>>):  Matrix<T> {
    Matrix { v }
}
```

Now anyone using this `Matrix` type has access to index syntax for it:

```move
let mut m = matrix::make_matrix(vector[
    vector[1, 0, 0],
    vector[0, 1, 0],
    vector[0, 0, 1],
]);x

let mut i = 0;
while (i < 3) {
    let mut j = 0;
    while (j < 3) {
        if (i == j) {
            assert!(m[i, j] == 1, 1);
        } else {
            assert!(m[i, j] == 0, 0);
        };
        *(&mut m[i,j]) = 2;
        j = j + 1;
    };
    i = i + 1;
}
```

## Usage

As the example indicates, if you define a datatype and an associated index syntax method, anyone can
invoke that method by writing index syntax on a value of that type:

```move
let mat = matrix::make_matrix(...);
let m_0_0 = mat[0, 0];
```

During compilation, the compiler translates these into the appropriate function invocations based on
the position and mutable usage of the expression:

```move
let mut mat = matrix::make_matrix(...);

let m_0_0 = mat[0, 0];
// translates to `copy matrix::borrow(&mat, 0, 0)`

let m_0_0 = &mat[0, 0];
// translates to `matrix::borrow(&mat, 0, 0)`

let m_0_0 = &mut mat[0, 0];
// translates to `matrix::borrow_mut(&mut mat, 0, 0)`
```

You can also intermix index expressions with field accesses:

```move
public struct V { v: vector<u64> }

public struct Vs { vs: vector<V> }

fun borrow_first(input: &Vs): &u64 {
    &input.vs[0].v[0]
    // translates to `vector::borrow(&vector::borrow(&input.vs, 0).v, 0)`
}
````

### Index Functions Take Flexible Arguments

Note that, aside from the definition and type limitations described in the rest of this chapter,
Move places no restrictions on the values your index syntax method takes as parameters. This allows
you to implement intricate programmatic behavior when defining index syntax, such as a data
structure that takes a default value if the index is out of bounds:

```move
#[syntax(index)]
public fun borrow_or_set<Key: copy, Value: drop>(
    input: &mut MTable<Key, Value>,
    key: Key,
    default: Value
): &mut Value {
    if (contains(input, key)) {
        borrow(input, key)
    } else {
        insert(input, key, default);
        borrow(input, key)
    }
}
```

Now, when you index into `MTable`, you must also provide a default value:

```move
let string_key: String = ...;
let mut table: MTable<String, u64> = m_table::make_table();
let entry: &mut u64 = &mut table[string_key, 0];
```

This sort of extensible power allows you to write precise index interfaces for your types,
concretely enforcing bespoke behavior.

## Defining Index Syntax Functions

This powerful syntax form allows all of your user-defined datatypes to behave in this way, assuming
your definitions adhere to the following rules:

1. The `#[syntax(index)]` attribute is added to the designated functions defined in the same module
   as the subject type.
1. The designated functions have `public` visibility.
1. The functions take a reference type as its subject type (its first argument) and returns a
   matching references type (`mut` if the subject was `mut`).
1. Each type has only a single mutable and single immutable definition.
1. Immutable and mutable versions have type agreement:
   - The subject types match, differing only in mutability.
   - The return types match the mutability of their subject types.
   - Type parameters, if present, have identical constraints between both versions.
   - All parameters beyond the subject type are identical.

The following content and additional examples describe these rules in greater detail.

### Declaration

To declare an index syntax method, add the `#[syntax(index)]` attribute above the relevant function
definition in the same module as the subject type's definition. This signals to the compiler that
the function is an index accessor for the specified type.

#### Immutable Accessor

The immutable index syntax method is defined for read-only access. It takes an immutable reference
of the subject type and returns an immutable reference to the element type. The `borrow` function
defined in `std::vector` is an example of this:

```move
#[syntax(index)]
public native fun borrow<Element>(v: &vector<Element>, i: u64): &Element;
```

#### Mutable Accessor

The mutable index syntax method is the dual of the immutable one, allowing for both read and write
operations. It takes a mutable reference of the subject type and returns a mutable reference to the
element type. The `borrow_mut` function defined in `std::vector` is an example of this:

```move
#[syntax(index)]
public native fun borrow_mut<Element>(v: &mut vector<Element>, i: u64): &mut Element;
```

#### Visibility

To ensure that indexing functions are available anywhere the type is used, all index syntax methods
must have public visibility. This ensures ergonomic usage of indexing across modules and packages in
Move.

#### No Duplicates

In addition to the above requirements, we restrict each subject base type to defining a single index
syntax method for immutable references and a single index syntax method for mutable references. For
example, you cannot define a specialized version for a polymorphic type:

```move
#[syntax(index)]
public fun borrow_matrix_u64(s: &Matrix<u64>, i: u64, j: u64): &u64 { ... }

#[syntax(index)]
public fun borrow_matrix<T>(s: &Matrix<T>, i: u64, j: u64): &T { ... }
    // ERROR! Matrix already has a definition
    // for its immutable index syntax method
```

This ensures that you can always tell which method is being invoked, without the need to inspect
type instantiation.

### Type Constraints

By default, an index syntax method has the following type constraints:

**Its subject type (first argument) must be a reference to a single type defined in the same module
as the marked function.** This means that you cannot define index syntax methods for tuples, type
parameters, or values:

```move
#[syntax(index)]
public fun borrow_fst(x: &(u64, u64), ...): &u64 { ... }
    // ERROR because the subject type is a tuple

#[syntax(index)]
public fun borrow_tyarg<T>(x: &T, ...): &T { ... }
    // ERROR because the subject type is a type parameter

#[syntax(index)]
public fun borrow_value(x: Matrix<u64>, ...): &u64 { ... }
    // ERROR because x is not a reference
```

**The subject type must match mutability with the return type.** This restriction allows you to
clarify the expected behavior when borrowing an indexed expression as `&vec[i]` versus
`&mut vec[i]`. The Move compiler uses the mutability marker to determine which borrow form to call
to produce a reference of the appropriate mutability. As a result, we disallow index syntax methods
whose subject and return mutability differ:

```move
#[syntax(index)]
public fun borrow_imm(x: &mut Matrix<u64>, ...): &u64 { ... }
    // ERROR! incompatible mutability
    // expected a mutable reference '&mut' return type
```

### Type Compatibility

When defining an immutable and mutable index syntax method pair, they are subject to a number of
compatibility constraints:

1. They must take the same number of type parameters, those type parameters must have the same
   constraints.
1. Type parameters must be used the same _by position_, not name.
1. Their subject types must match exactly except for the mutability.
1. Their return types must match exactly except for the mutability.
1. All other parameter types must match exactly.

These constraints are to ensure that index syntax behaves identically regardless of being in a
mutable or immutable position.

To illustrate some of these errors, recall the previous `Matrix` definition:

```move
#[syntax(index)]
public fun borrow<T>(s: &Matrix<T>, i: u64, j: u64): &T {
    vector::borrow(vector::borrow(&s.v, i), j)
}
```

All of the following are type-incompatible definitions of the mutable version:

```move
#[syntax(index)]
public fun borrow_mut<T: drop>(s: &mut Matrix<T>, i: u64, j: u64): &mut T { ... }
    // ERROR! `T` has `drop` here, but no in the immutable version

#[syntax(index)]
public fun borrow_mut(s: &mut Matrix<u64>, i: u64, j: u64): &mut u64 { ... }
    // ERROR! This takes a different number of type parameters

#[syntax(index)]
public fun borrow_mut<T, U>(s: &mut Matrix<U>, i: u64, j: u64): &mut U { ... }
    // ERROR! This takes a different number of type parameters

#[syntax(index)]
public fun borrow_mut<U>(s: &mut Matrix<U>, i_j: (u64, u64)): &mut U { ... }
    // ERROR! This takes a different number of arguments

#[syntax(index)]
public fun borrow_mut<U>(s: &mut Matrix<U>, i: u64, j: u32): &mut U { ... }
    // ERROR! `j` is a different type
```

Again, the goal here is to make the usage across the immutable and mutable versions consistent. This
allows index syntax methods to work without changing out the behavior or constraints based on
mutable versus immutable usage, ultimately ensuring a consistent interface to program against.

>>>> move-book/reference/index.md
# The Move Reference

Welcome to Move, a next generation language for secure asset programming. Its primary use case is in
blockchain environments, where Move programs are used to construct state changes. Move allows
developers to write programs that flexibly manage and transfer assets, while providing the security
and protections against attacks on those assets. However, Move has been developed with use cases in
mind outside a blockchain context as well.

Move takes its cue from [Rust](https://www.rust-lang.org/) by using resource types with move (hence
the name) semantics as an explicit representation of digital assets, such as currency.

<!-- TODO do we have a pre-existing summary we can copy in here? -->

>>>> move-book/reference/method-syntax.md
---
title: 'Method Syntax | Reference'
description: ''
---

# Methods

As a syntactic convenience, some functions in Move can be called as "methods" on a value. This is done
by using the `.` operator to call the function, where the value on the left-hand side of the `.` is
the first argument to the function (sometimes called the receiver). The type of that value
statically determines which function is called. This is an important difference from some other
languages, where this syntax might indicate a dynamic call, where the function to be called is
determined at runtime. In Move, all function calls are statically determined.

In short, this syntax exists to make it easier to call functions without having to create an alias
with `use`, and without having to explicitly borrow the first argument to the function.
Additionally, this can make code more readable, as it reduces the amount of boilerplate needed to
call a function and makes it easier to chain function calls.

## Syntax

The syntax for calling a method is as follows:

```text
<expression> . <identifier> <[type_arguments],*> ( <arguments> )
```

For example

```move
coin.value();
*nums.borrow_mut(i) = 5;
```

## Method Resolution

When a method is called, the compiler will statically determine which function is called based on
the type of the receiver (the argument on the left-hand side of the `.`). The compiler maintains a
mapping from type and method name to the module and function name that should be called. This
mapping is created form the `use fun` aliases that are currently in scope, and from the appropriate
functions in the receiver type's defining module. In all cases, the receiver type is the first
argument to the function, whether by-value or by-reference.

In this section, when we say a method "resolves" to a function, we mean that the compiler will
statically replace the method with a normal [function](./functions) call. For example if we have
`x.foo(e)` with `foo` resolving to `a::m::foo`, the compiler will replace `x.foo(e)` with
`a::m::foo(x, e)`, potentially [automatically borrowing](#automatic-borrowing) `x`.

### Functions in the Defining Module

In a type’s defining module, the compiler will automatically create a method alias for any function
declaration for its types when the type is the first argument in the function. For example,

```move
module a::m;

public struct X() has copy, drop, store;
public fun foo(x: &X) { ... }
public fun bar(flag: bool, x: &X) { ... }
```

The function `foo` can be called as a method on a value of type `X`. However, not the first argument
(and one is not created for `bool` since `bool` is not defined in that module). For example,

```move
fun example(x: a::m::X) {
    x.foo(); // valid
    // x.bar(true); ERROR!
}
```

### `use fun` Aliases

Like a traditional [`use`](uses), a `use fun` statement creates an alias local to its current
scope. This could be for the current module or the current expression block. However, the alias is
associated to a type.

The syntax for a `use fun` statement is as follows:

```move
use fun <function> as <type>.<method alias>;
```

This creates an alias for the `<function>`, which the `<type>` can receive as `<method alias>`.

For example

```move
module a::cup;

public struct Cup<T>(T) has copy, drop, store;

public fun cup_borrow<T>(c: &Cup<T>): &T {
    &c.0
}

public fun cup_value<T>(c: Cup<T>): T {
    let Cup(t) = c;
    t
}

public fun cup_swap<T: drop>(c: &mut Cup<T>, t: T) {
    c.0 = t;
}
```

We can now create `use fun` aliases to these functions

```move
module b::example;

use fun a::cup::cup_borrow as Cup.borrow;
use fun a::cup::cup_value as Cup.value;
use fun a::cup::cup_swap as Cup.set;

fun example(c: &mut Cup<u64>) {
    let _ = c.borrow(); // resolves to a::cup::cup_borrow
    let v = c.value(); // resolves to a::cup::cup_value
    c.set(v * 2); // resolves to a::cup::cup_swap
}
```

Note that the `<function>` in the `use fun` does not have to be a fully resolved path, and an alias
can be used instead, so the declarations in the above example could equivalently be written as

```move
use a::cup::{Self, cup_swap};

use fun cup::cup_borrow as Cup.borrow;
use fun cup::cup_value as Cup.value;
use fun cup_swap as Cup.set;
```

While these examples are cute for renaming the functions in the current module, the feature is
perhaps more useful for declaring methods on types from other modules. For example, if we wanted to
add a new utility to `Cup`, we could do so with a `use fun` alias and still use method syntax

```move
module b::example;

fun double(c: &Cup<u64>): Cup<u64> {
    let v = c.value();
    Cup::new(v * 2)
}
```

Normally, we would be stuck having to call it as `double(&c)` because `b::example` did not define
`Cup`, but instead we can use a `use fun` alias

```move
fun double_double(c: Cup<u64>): (Cup<u64>, Cup<u64>) {
    use fun b::example::double as Cup.dub;
    (c.dub(), c.dub()) // resolves to b::example::double in both calls
}
```

While `use fun` can be made in any scope, the target `<function>` of the `use fun` must have a first
argument that is the same as the `<type>`.

```move
public struct X() has copy, drop, store;

fun new(): X { X() }
fun flag(flag: bool): u8 { if (flag) 1 else 0 }

use fun new as X.new; // ERROR!
use fun flag as X.flag; // ERROR!
// Neither `new` nor `flag` has first argument of type `X`
```

But any first argument of the `<type>` can be used, including references and mutable references

```move
public struct X() has copy, drop, store;

public fun by_val(_: X) {}
public fun by_ref(_: &X) {}
public fun by_mut(_: &mut X) {}

// All 3 valid, in any scope
use fun by_val as X.v;
use fun by_ref as X.r;
use fun by_mut as X.m;
```

Note for generics, the methods are associated for _all_ instances of the generic type. You cannot
overload the method to resolve to different functions depending on the instantiation.

```move
public struct Cup<T>(T) has copy, drop, store;

public fun value<T: copy>(c: &Cup<T>): T {
    c.0
}

use fun value as Cup<bool>.flag; // ERROR!
use fun value as Cup<u64>.num; // ERROR!
// In both cases, `use fun` aliases cannot be generic, they must work for all instances of the type
```

### `public use fun` Aliases

Unlike a traditional [`use`](uses), the `use fun` statement can be made `public`, which allows it
to be used outside of its declared scope. A `use fun` can be made `public` if it is declared in the
module that defines the receivers type, much like the method aliases that are
[automatically created](#functions-in-the-defining-module) for functions in the defining module. Or
conversely, one can think that an implicit `public use fun` is created automatically for every
function in the defining module that has a first argument of the receiver type (if it is defined in
that module). Both of these views are equivalent.

```move
module a::cup;

public struct Cup<T>(T) has copy, drop, store;

public use fun cup_borrow as Cup.borrow;
public fun cup_borrow<T>(c: &Cup<T>): &T {
    &c.0
}
```

In this example, a public method alias is created for `a::cup::Cup.borrow` and
`a::cup::Cup.cup_borrow`. Both resolve to `a::cup::cup_borrow`. And both are "public" in the sense
that they can be used outside of `a::cup`, without an additional `use` or `use fun`.

```move
module b::example;

fun example<T: drop>(c: a::cup::Cup<u64>) {
    c.borrow(); // resolves to a::cup::cup_borrow
    c.cup_borrow(); // resolves to a::cup::cup_borrow
}
```

The `public use fun` declarations thus serve as a way of renaming a function if you want to give it
a cleaner name for use with method syntax. This is especially helpful if you have a module with
multiple types, and similarly named functions for each type.

```move
module a::shapes;

public struct Rectangle { base: u64, height: u64 }
public struct Box { base: u64, height: u64, depth: u64 }

// Rectangle and Box can have methods with the same name

public use fun rectangle_base as Rectangle.base;
public fun rectangle_base(rectangle: &Rectangle): u64 {
    rectangle.base
}

public use fun box_base as Box.base;
public fun box_base(box: &Box): u64 {
    box.base
}
```

Another use for `public use fun` is adding methods to types from other modules. This can be helpful
in conjunction with functions spread out across a single package.

```move
module a::cup {
    public struct Cup<T>(T) has copy, drop, store;

    public fun new<T>(t: T): Cup<T> { Cup(t) }
    public fun borrow<T>(c: &Cup<T>): &T {
        &c.0
    }
    // `public use fun` to a function defined in another module
    public use fun a::utils::split as Cup.split;
}

module a::utils {
    use a::m::{Self, Cup};

    public fun split<u64>(c: Cup<u64>): (Cup<u64>, Cup<u64>) {
        let Cup(t) = c;
        let half = t / 2;
        let rem = if (t > 0) t - half else 0;
        (cup::new(half), cup::new(rem))
    }

}
```

And note that this `public use fun` does not create a circular dependency, as the `use fun` is not
present after the module is compiled--all methods are resolved statically.

### Interactions with `use` Aliases

A small detail to note is that method aliases respect normal `use` aliases.

```move
module a::cup {
    public struct Cup<T>(T) has copy, drop, store;

    public fun cup_borrow<T>(c: &Cup<T>): &T {
        &c.0
    }
}

module b::other {
    use a::cup::{Cup, cup_borrow as borrow};

    fun example(c: &Cup<u64>) {
        c.borrow(); // resolves to a::cup::cup_borrow
    }
}
```

A helpful way to think about this is that `use` creates an implicit `use fun` alias for the function
whenever it can. In this case the `use a::cup::cup_borrow as borrow` creates an implicit
`use fun a::cup::cup_borrow as Cup.borrow` because it would be a valid `use fun` alias. Both views
are equivalent. This line of reasoning can inform how specific methods will resolve with shadowing.
See the cases in [Scoping](#scoping) for more details.

### Scoping

If not `public`, a `use fun` alias is local to its scope, much like a normal [`use`](uses). For
example

```move
module a::m {
    public struct X() has copy, drop, store;
    public fun foo(_: &X) {}
    public fun bar(_: &X) {}
}

module b::other {
    use a::m::X;

    use fun a::m::foo as X.f;

    fun example(x: &X) {
        x.f(); // resolves to a::m::foo
        {
            use a::m::bar as f;
            x.f(); // resolves to a::m::bar
        };
        x.f(); // still resolves to a::m::foo
        {
            use fun a::m::bar as X.f;
            x.f(); // resolves to a::m::bar
        }
    }
```

## Automatic Borrowing

When resolving a method, the compiler will automatically borrow the receiver if the function expects
a reference. For example

```move
module a::m;

public struct X() has copy, drop;
public fun by_val(_: X) {}
public fun by_ref(_: &X) {}
public fun by_mut(_: &mut X) {}

fun example(mut x: X) {
    x.by_ref(); // resolves to a::m::by_ref(&x)
    x.by_mut(); // resolves to a::m::by_mut(&mut x)
}
```

In these examples, `x` was automatically borrowed to `&x` and `&mut x` respectively. This will also
work through field access

```move
module a::m;

public struct X() has copy, drop;
public fun by_val(_: X) {}
public fun by_ref(_: &X) {}
public fun by_mut(_: &mut X) {}

public struct Y has drop { x: X }

fun example(mut y: Y) {
    y.x.by_ref(); // resolves to a::m::by_ref(&y.x)
    y.x.by_mut(); // resolves to a::m::by_mut(&mut y.x)
}
```

Note that in both examples, the local variable had to be labeled as [`mut`](./variables) to allow
for the `&mut` borrow. Without this, there would be an error saying that `x` (or `y` in the second
example) is not mutable.

Keep in mind that without a reference, normal rules for variable and field access come into play.
Meaning a value might be moved or copied if it is not borrowed.

```move
module a::m;

public struct X() has copy, drop;
public fun by_val(_: X) {}
public fun by_ref(_: &X) {}
public fun by_mut(_: &mut X) {}

public struct Y has drop { x: X }
public fun drop_y(y: Y) { y }

fun example(y: Y) {
    y.x.by_val(); // copies `y.x` since `by_val` is by-value and `X` has `copy`
    y.drop_y(); // moves `y` since `drop_y` is by-value and `Y` does _not_ have `copy`
}
```

## Chaining

Method calls can be chained, because any expression can be the receiver of the method.

```move
module a::shapes {
    public struct Point has copy, drop, store { x: u64, y: u64 }
    public struct Line has copy, drop, store { start: Point, end: Point }

    public fun x(p: &Point): u64 { p.x }
    public fun y(p: &Point): u64 { p.y }

    public fun start(l: &Line): &Point { &l.start }
    public fun end(l: &Line): &Point { &l.end }

}

module b::example {
    use a::shapes::Line;

    public fun x_values(l: Line): (u64, u64) {
        (l.start().x(), l.end().x())
    }

}
```

In this example for `l.start().x()`, the compiler first resolves `l.start()` to
`a::shapes::start(&l)`. Then `.x()` is resolved to `a::shapes::x(a::shapes::start(&l))`. Similarly
for `l.end().x()`. Keep in mind, this feature is not "special"--the left-hand side of the `.` can be
any expression, and the compiler will resolve the method call as normal. We simply draw attention to
this sort of "chaining" because it is a common practice to increase readability.

>>>> move-book/reference/modes.md
---
title: 'Compilation Modes | Reference'
description: ''
---

# Compilation Modes

A mode is a named, compile-time switch that controls which declarations are included in a build.

- `#[mode(name1, name2, ...)]` filters declarations by enabled mode names.
- `#[test_only] ≡ #[mode(test)]`.
- Unannotated declarations are always included.
- Annotated declarations are included if and only if any listed name is enabled.
- Enabling any mode (including test) mean the build is not publishable.
- Modes affect compile-time inclusion only; other than publishability, they are erased at the
  bytecode level.

## Mode Basics

Modes are expressed with the attributes:

```move
#[mode(name1, name2, ...)]

#[test_only] // (shorthand for #[mode(test)])
```

Code compiled with any mode enabled (including test) is not publishable.

This section defines the syntax, inclusion rules, scope, and tool interactions for modes. (For an
introductory tutorial with examples, see the guide page.)

### Mode Annotations

The `#[mode(...)]` may be placed on modules and module members (functions, structs, constants,
etc.).


```move
#[mode(name1, name2, ...)]
module <addr_opt>::<ident> { ... }

module <addr_opt>::<ident> {
    #[mode(name1, name2, ...)]
    <decl>
}
```
> **Note**: `#[test_only]` is exactly equivalent to `#[mode(test)]`.

## Mode Names

Each name is a nonempty identifier. Mode names are compared case-sensitively.

## Inclusion model

Let `M` be the set of enabled modes for a build. Let `S(m)` be the set of modes listed on
declaration `m`, where `#[test_only]` contributes `{test}`, and unannotated declarations have `S(x)
= ∅`. A declaration x is included in the compilation unit if and only if one of the following is
true:

* `S(x) = ∅` (unannotated)
* `S(x) ∩ M ≠ ∅:` (annotation included)

That is: unannotated declarations are always included; annotated declarations are included if and
only if at least one of their listed names is enabled in the build, and otherwise they are excluded.

### Module scope

If a module is excluded, all of its members are excluded implicitly. If a module is included, an
annotated member may still be excluded if its own `S(m)` does not intersect `M`.

### Multiple modes on one attribute

The list in `#[mode(a, b, c)]` is disjunctive (logical OR): inclusion occurs if any listed name
matches.

## Name resolution & duplicates

Modes are a compile-time filter only. They do not introduce runtime conditionals and have no
representation in bytecode. All verification is performed on the included subset of the source.

Standard name resolution rules apply when duplicates are present. That means two modes may not
enable different modules or members with the same name in the same build. Similarly, a
mode-annotated definition may not override an unannotated declaration with the same name.

To provide mode-specific alternatives, place them in separate modules gated by modes, or use
distinct names and select them in tests or drivers.

## Usage Tooling & flags

For building and testing, `move build --mode <name>` adds `<name>` to `M`. Multiple modes may be
enabled by passing `--mode` repeatedly; `M ` is the union of all names passed, e.g., `move build
--mode test --mode debug`. This will enable all modules and members annotated with either
`#[mode(test)]` or `#[mode(debug)]`. Note that `move test` implicitly supplies `--mode test`.

## Publishability

Any build that enables at least one mode (including test) produces non-publishable outputs. To
create publishable artifacts, no modes may be enabled.

>>>> move-book/reference/modules.md
---
title: 'Modules | Reference'
description: ''
---

# Modules

**Modules** are the core program unit that define types along with functions that operate on these
types. Struct types define the schema of Move's [storage](./abilities#key), and module functions
define the rules interacting with values of those types. While modules themselves are also stored in
storage, they are not accessible from within a Move program. In a blockchain environment, the
modules are stored on chain in a process typically referred to as "publishing". After being
published, [`entry`](./functions#entry-modifier) and [`public`](./functions#visibility)
functions can be invoked according to the rules of that particular Move instance.

## Syntax

A module has the following syntax:

```text
module <address>::<identifier> {
    (<use> | <type> | <function> | <constant>)*
}
```

where `<address>` is a valid [address](./primitive-types/address) specifying the module's
package.

For example:

```move
module 0::test;

use std::debug;

const ONE: u64 = 1;

public struct Example has copy, drop { i: u64 }

public fun print(x: u64) {
    let sum = x + ONE;
    let example = Example { i: sum };
    debug::print(&sum)
}
```

## Names

The `module test_addr::test` part specifies that the module `test` will be published under the
numerical [address](./primitive-types/address) value assigned for the name `test_addr` in the
[package settings](./packages).

Modules should normally be declared using [named addresses](./primitive-types/address) (as
opposed to using the numerical value directly). For example:

```move
module test_addr::test;

use std::debug;
use test_addr::another_test;

public struct Example has copy, drop { a: address }

public fun print() {
    let example = Example { a: @test_addr };
    debug::print(&example)
}
```

These named addresses commonly match the name of the [package](./packages).

Because named addresses only exist at the source language level and during compilation, named
addresses will be fully substituted for their value at the bytecode level. For example if we had the
following code:

```move
fun example() {
    my_addr::m::foo(@my_addr);
}
```

and we compiled it with `my_addr` set to `0xC0FFEE`, then it would be operationally equivalent to
the following:

```move
fun example() {
    0xC0FFEE::m::foo(@0xC0FFEE);
}
```

While at the source level these two different accesses are equivalent, it is a best practice to
always use the named address and not the numerical value assigned to that address.

Module names can start with a lowercase letter from `a` to `z` or an uppercase letter from `A` to
`Z`. After the first character, module names can contain underscores `_`, letters `a` to `z`,
letters `A` to `Z`, or digits `0` to `9`.

```move
module a::my_module {}
module a::foo_bar_42 {}
```

Typically, module names start with a lowercase letter. A module named `my_module` should be stored
in a source file named `my_module.move`.

## Members

All members inside a `module` block can appear in any order. Fundamentally, a module is a collection
of [`types`](./structs) and [`functions`](./functions). The [`use`](./uses) keyword refers
to members from other modules. The [`const`](./constants) keyword defines constants that can be
used in the functions of a module.

The [`friend`](./friends) syntax is a deprecated concept for specifying a list of trusted
modules. The concept has been superseded by [`public(package)`](./functions#visibility)

<!-- TODO member access rules -->

>>>> move-book/reference/packages.md
---
title: 'Packages | Reference'
description: ''
---

# Packages

Packages allow Move programmers to more easily re-use code and share it across projects. The Move
package system allows programmers to easily:

- Define a package containing Move code;
- Parameterize a package by [named addresses](./primitive-types/address);
- Import and use packages in other Move code and instantiate named addresses;
- Build packages and generate associated compilation artifacts from packages; and
- Work with a common interface around compiled Move artifacts.

## Package Layout and Manifest Syntax

A Move package source directory contains a `Move.toml` package manifest file, a generated
`Move.lock` file, and a set of subdirectories:

```plaintext
a_move_package
├── Move.toml      (required)
├── Move.lock      (generated)
├── sources        (required)
├── doc_templates  (optional)
├── examples       (optional, test & dev mode)
└── tests          (optional, test mode)
```

The directories and files labeled "required" must be present for a directory to be considered a Move
package and built. Optional directories may be present, and if so, they will be included in the
compilation process depending on the mode used to build the package. For instance, when built in
"dev" or "test" modes, the `tests` and `examples` directories will also be included.

Going through each of these in turn:

1. The [`Move.toml`](#movetoml) file is the package manifest and is required for a directory to be
   considered a Move package. This file contains metadata about the package, such as name,
   dependencies, and so on.
1. The [`Move.lock`](#movelock) file is generated by the Move CLI and contains the fixed build
   versions of the package and its dependencies. It is used to ensure consistent versions are used
   across different builds and that changes in dependencies are apparent as a change in this file.
1. The `sources` directory is required and contains the Move modules that make up the package.
   Modules in this directory will always be included in the compilation process.
1. The `doc_templates` directory can contain documentation templates that will be used when
   generating documentation for the package.
1. The `examples` directory can hold additional code to be used only for development and/or
   tutorials, this will not be included when compiled outside of `test` or `dev` modes.
1. The `tests` directory can contain Move modules that are only included when compiled in `test`
   mode or when [Move unit tests](./unit-testing) are run.

### Move.toml

The Move package manifest is defined within the `Move.toml` file and has the following syntax.
Optional fields are marked with `*`, `+` denotes one or more elements:

```toml
[package]
name = <string>
edition* = <string>      # e.g., "2024.alpha" to use the Move 2024 edition,
                         # currently in alpha. Will default to the latest stable edition if not specified.
license* = <string>              # e.g., "MIT", "GPL", "Apache 2.0"
authors* = [<string>,+]  # e.g., ["Joe Smith (joesmith@noemail.com)", "John Snow (johnsnow@noemail.com)"]

# Additional fields may be added to this section by external tools. E.g., on Sui the following sections are added:
published-at* = "<hex-address>" # The address that the package is published at. Should be set after the first publication.

[dependencies] # (Optional section) Paths to dependencies
# One or more lines declaring dependencies in the following format

# ##### Local Dependencies #####
# For local dependencies use `local = path`. Path is relative to the package root
# Local = { local = "../path/to" }
# To resolve a version conflict and force a specific version for dependency
# override you can use `override = true`
# Override = { local = "../conflicting/version", override = true }
# To instantiate address values in a dependency, use `addr_subst`
<string> = {
    local = <string>,
    override* = <bool>,
    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }
}

# ##### Git Dependencies #####
# For remote import, use the `{ git = "...", subdir = "...", rev = "..." }`.
# Revision must be supplied, it can be a branch, a tag, or a commit hash.
# If no `subdir` is specified, the root of the repository is used.
# MyRemotePackage = { git = "https://some.remote/host.git", subdir = "remote/path", rev = "main" }
<string> = {
    git = <URL ending in .git>,
    subdir=<path to dir containing Move.toml inside git repo>,
    rev=<git commit hash>,
    override* = <bool>,
    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }
}

[addresses]  # (Optional section) Declares named addresses in this package
# One or more lines declaring named addresses in the following format
# Addresses that match the name of the package must be set to `"0x0"` or they will be unable to be published.
<addr_name> = "_" | "<hex_address>" # e.g., std = "_" or my_addr = "0xC0FFEECAFE"

# Named addresses will be accessible in Move as `@name`. They're also exported:
# for example, `std = "0x1"` is exported by the Standard Library.
# alice = "0xA11CE"

[dev-dependencies] # (Optional section) Same as [dependencies] section, but only included in "dev" and "test" modes
# The dev-dependencies section allows overriding dependencies for `--test` and
# `--dev` modes. You can e.g., introduce test-only dependencies here.
# Local = { local = "../path/to/dev-build" }
<string> = {
    local = <string>,
    override* = <bool>,
    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }
}
<string> = {
    git = <URL ending in .git>,
    subdir=<path to dir containing Move.toml inside git repo>,
    rev=<git commit hash>,
    override* = <bool>,
    addr_subst* = { (<string> = (<string> | "<hex_address>"))+ }
}

[dev-addresses] # (Optional section) Same as [addresses] section, but only included in "dev" and "test" modes
# The dev-addresses section allows overwriting named addresses for the `--test`
# and `--dev` modes.
<addr_name> = "<hex_address>" # e.g., alice = "0xB0B"
```

An example of a minimal package manifest:

```toml
[package]
name = "AName"
```

An example of a more standard package manifest that also includes the Move standard library and
instantiates the named address `std` from the `LocalDep` package with the address value `0x1`:

```toml
[package]
name = "AName"
license = "Apache 2.0"

[addresses]
address_to_be_filled_in = "_"
specified_address = "0xB0B"

[dependencies]
# Local dependency
LocalDep = { local = "projects/move-awesomeness", addr_subst = { "std" = "0x1" } }
# Git dependency
MoveStdlib = { git = "https://github.com/MystenLabs/sui.git", subdir = "crates/sui-framework/packages/move-stdlib", rev = "framework/mainnet" }

[dev-addresses] # For use when developing this module
address_to_be_filled_in = "0x101010101"
```

Most of the sections in the package manifest are self explanatory, but named addresses can be a bit
difficult to understand so we examine them in more detail in
[Named Addresses During Compilation](#named-addresses-during-compilation).

## Named Addresses During Compilation

Recall that Move has [named addresses](./primitive-types/address) and that named addresses cannot be
declared in Move. Instead they are declared at the package level: in the manifest file (`Move.toml`)
for a Move package you declare named addresses in the package, instantiate other named addresses,
and rename named addresses from other packages within the Move package system.

Let's go through each of these actions, and how they are performed in the package's manifest
one-by-one:

### Declaring Named Addresses

Let's say we have a Move module in `example_pkg/sources/A.move` as follows:

```move
module named_addr::a {
    public fun x(): address { @named_addr }
}
```

We could in `example_pkg/Move.toml` declare the named address `named_addr` in two different ways.
The first:

```toml
[package]
name = "example_pkg"
...
[addresses]
named_addr = "_"
```

Declares `named_addr` as a named address in the package `example_pkg` and that _this address can be
any valid address value_. In particular, an importing package can pick the value of the named
address `named_addr` to be any address it wishes. Intuitively you can think of this as
parameterizing the package `example_pkg` by the named address `named_addr`, and the package can then
be instantiated later on by an importing package.

`named_addr` can also be declared as:

```toml
[package]
name = "example_pkg"
...
[addresses]
named_addr = "0xCAFE"
```

which states that the named address `named_addr` is exactly `0xCAFE` and cannot be changed. This is
useful so other importing packages can use this named address without needing to worry about the
exact value assigned to it.

With these two different declaration methods, there are two ways that information about named
addresses can flow in the package graph:

- The former ("unassigned named addresses") allows named address values to flow from the importation
  site to the declaration site.
- The latter ("assigned named addresses") allows named address values to flow from the declaration
  site upwards in the package graph to usage sites.

With these two methods for flowing named address information throughout the package graph the rules
around scoping and renaming become important to understand.

## Scope and Renaming of Named Addresses

A named address `N` in a package `P` is in scope if:

1. `P` declares a named address `N`; or
2. A package in one of `P`'s transitive dependencies declares the named address `N` and there is a
   dependency path in the package graph between `P` and the declaring package of `N` with no
   renaming of `N`.

Additionally, every named address in a package is exported. Because of this and the above scoping
rules each package can be viewed as coming with a set of named addresses that will be brought into
scope when the package is imported, e.g., if you import `example_pkg`, that import will also bring
the `named_addr` named address into scope. Because of this, if `P` imports two packages `P1` and
`P2` both of which declare a named address `N` an issue arises in `P`: which "`N`" is meant when `N`
is referred to in `P`? The one from `P1` or `P2`? To prevent this ambiguity around which package a
named address is coming from, we enforce that the sets of scopes introduced by all dependencies in a
package are disjoint, and provide a way to _rename named addresses_ when the package that brings
them into scope is imported.

Renaming a named address when importing can be done as follows in our `P`, `P1`, and `P2` example
above:

```toml
[package]
name = "P"
...
[dependencies]
P1 = { local = "some_path_to_P1", addr_subst = { "P1N" = "N" } }
P2 = { local = "some_path_to_P2"  }
```

With this renaming `N` refers to the `N` from `P2` and `P1N` will refer to `N` coming from `P1`:

```move
module N::A {
    public fun x(): address { @P1N }
}
```

It is important to note that _renaming is not local_: once a named address `N` has been renamed to
`N2` in a package `P` all packages that import `P` will not see `N` but only `N2` unless `N` is
reintroduced from outside of `P`. This is why rule (2) in the scoping rules at the start of this
section specifies a "dependency path in the package graph between `P` and the declaring
package of `N` with no renaming of `N`."

### Instantiating Named Addresses

Named addresses can be instantiated multiple times across the package graph as long as it is always
with the same value. It is an error if the same named address (regardless of renaming) is
instantiated with differing values across the package graph.

A Move package can only be compiled if all named addresses resolve to a value. This presents issues
if the package wishes to expose an uninstantiated named address. This is what the `[dev-addresses]`
section solves in part. This section can set values for named addresses, but cannot introduce any
named addresses. Additionally, only the `[dev-addresses]` in the root package are included in `dev`
mode. For example a root package with the following manifest would not compile outside of `dev` mode
since `named_addr` would be uninstantiated:

```toml
[package]
name = "example_pkg"
...
[addresses]
named_addr = "_"

[dev-addresses]
named_addr = "0xC0FFEE"
```

## Usage and Artifacts

The Move package system comes with a command line option as part of the CLI:
`sui move <command> <command_flags>`. Unless a particular path is provided, all package commands
will run in the current enclosing Move package. The full list of commands and flags for the Move CLI
can be found by running `sui move --help`.

### Artifacts

A package can be compiled using CLI commands. This will create a `build` directory containing
build-related artifacts (including bytecode binaries, source maps, and documentation). The general
layout of the `build` directory is as follows:

```plaintext
a_move_package
├── BuildInfo.yaml
├── bytecode_modules
│   ├── dependencies
│   │   ├── <dep_pkg_name>
│   │   │   └── *.mv
│   │   ...
│   │   └──  <dep_pkg_name>
│   │       └── *.mv
│   ...
│   └── *.mv
├── docs
│   ├── dependencies
│   │   ├── <dep_pkg_name>
│   │   │   └── *.md
│   │   ...
│   │   └──  <dep_pkg_name>
│   │       └── *.md
│   ...
│   └── *.md
├── source_maps
│   ├── dependencies
│   │   ├── <dep_pkg_name>
│   │   │   └── *.mvsm
│   │   ...
│   │   └──  <dep_pkg_name>
│   │       └── *.mvsm
│   ...
│   └── *.mvsm
└── sources
    ...
    └── *.move
    ├── dependencies
    │   ├── <dep_pkg_name>
    │   │   └── *.move
    │   ...
    │   └──  <dep_pkg_name>
    │       └── *.move
    ...
    └── *.move
```

## Move.lock

The `Move.lock` file is generated at the root of the Move package when the package is built. The
`Move.lock` file contains information about your package and its build configuration, and acts as a
communication layer between the Move compiler and other tools, like chain-specific command line
interfaces and third-party package managers.

Like the `Move.toml` file, the `Move.lock` file is a text-based TOML file. Unlike the package
manifest however, the `Move.lock` file is not intended for you to edit directly. Processes on the
toolchain, like the Move compiler, access and edit the file to read and append relevant information
to it. You also must not move the file from the root, as it needs to be at the same level as the
`Move.toml` manifest in the package.

If you are using source control for your package, it's recommended practice to check in the
`Move.lock` file that corresponds with your desired built or published package. This ensures that
every build of your package is an exact replica of the original, and that changes to the build will
be apparent as changes to the `Move.lock` file.

The `Move.lock` file is a TOML file that currently contains the following fields.

**Note**: other fields may be added to the lock file either in the future, or by third-party
package managers as well.

### The `[move]` Section

This section contains the core information needed in the lockfile:

- The version of the lockfile (needed for backwards compatibility checking, and versioning lockfile
  changes in the future).
- The hash of the `Move.toml` file that was used to generate this lock file.
- The hash of the `Move.lock` file of all dependencies. If no dependencies are present, this will be
  an empty string.
- The list of dependencies.

```toml
[move]
version = <string> # Lock file version, used for backwards compatibility checking.
manifest_digest = <hash> # Sha3-256 hash of the Move.toml file that was used to generate this lock file.
deps_digest = <hash> # Sha3-256 hash of the Move.lock file of all dependencies. If no dependencies are present, this will be an empty string.
dependencies = { (name = <string>)* } # List of dependencies. Not present if there are no dependencies.
```

### The `[move.package]` Sections

After the Move compiler resolves each of the dependencies for the package it writes the location of
the dependency to the `Move.lock` file. If a dependency failed to resolve, the compiler will not
write the `Move.lock` file and the build fails. If all dependencies resolve, the `Move.lock` file
contains the locations (local and remote) of all of the package's transitive dependencies. These
will be stored in the `Move.lock` file in the following format:

```toml
# ...

[[move.package]]
name = "A"
source = { git = "https://github.com/b/c.git", subdir = "e/f", rev = "a1b2c3" }

[[move.package]]
name = "B"
source = { local = "../local-dep" }
```

### The `[move.toolchain-version]` Section

As mentioned above, additional fields may be added to the lock file by external tools. For example,
the Sui package manager adds toolchain version information to the lock file that can then be used
for on-chain source verification:

```toml
# ...

[move.toolchain-version]
compiler-version = <string> # The version of the Move compiler used to build the package, e.g. "1.21.0"
edition = <string> # The edition of the Move language used to build the package, e.g. "2024.alpha"
flavor = <string> # The flavor of the Move compiler used to build the package, e.g. "sui"
```

>>>> move-book/reference/primitive-types.md
---
title: 'Primitive Types | Reference'
description: ''
---

# Primitive Types

The primitive types are the basic building blocks of the language.

These primitive types can be used on their own or can be used to build more complex,
user-defined types, e.g. in a [`struct`](./structs).

- [Integers](./primitive-types/integers)
- [Bool](./primitive-types/bool)
- [Address](./primitive-types/address)
- [Vector](./primitive-types/vector)

These primitive types are used in conjunction with other types

- [References](./primitive-types/references)
- [Tuples and Unit](./primitive-types/tuples)

>>>> move-book/reference/primitive-types/address.md
---
title: 'Address | Reference'
description: ''
---

# Address

`address` is a built-in type in Move that is used to represent locations (sometimes called accounts)
in storage. An `address` value is a 256-bit (32 byte) identifier. Move uses addresses to
differentiate packages of [modules](./../modules), where each package has its own address and
modules. Specific deployments of Move might also use the `address` value for
[storage](./../abilities#key) operations.

> For Sui, `address` is used to represent "accounts", and also objects via strong type wrappers
> (with `sui::object::UID` and `sui::object::ID`).

Although an `address` is a 256 bit integer under the hood, Move addresses are intentionally
opaque---they cannot be created from integers, they do not support arithmetic operations, and they
cannot be modified. Specific deployments of Move might have `native` functions to enable some of
these operations (e.g., creating an `address` from bytes `vector<u8>`), but these are not part of
the Move language itself.

While there are runtime address values (values of type `address`), they _cannot_ be used to access
modules at runtime.

## Addresses and Their Syntax

Addresses come in two flavors, named or numerical. The syntax for a named address follows the same
rules for any named identifier in Move. The syntax of a numerical address is not restricted to
hex-encoded values, and any valid [`u256` numerical value](./integers) can be used as an address
value, e.g., `42`, `0xCAFE`, and `10_000` are all valid numerical address literals.

To distinguish when an address is being used in an expression context or not, the syntax when using
an address differs depending on the context where it's used:

- When an address is used as an expression, the address must be prefixed by the `@` character, i.e.,
  [`@<numerical_value>`](./integers) or `@<named_address_identifier>`.
- Outside of expression contexts, the address may be written without the leading `@` character,
  i.e., [`<numerical_value>`](./integers) or `<named_address_identifier>`.

In general, you can think of `@` as an operator that takes an address from being a namespace item to
being an expression item.

## Named Addresses

Named addresses are a feature that allow identifiers to be used in place of numerical values in any
spot where addresses are used, and not just at the value level. Named addresses are declared and
bound as top level elements (outside of modules and scripts) in Move packages, or passed as
arguments to the Move compiler.

Named addresses only exist at the source language level and will be fully substituted for their
value at the bytecode level. Because of this, modules and module members should be accessed through
the module's named address and not through the numerical value assigned to the named address during
compilation. So while `use my_addr::foo` is equivalent to `use 0x2::foo` (if `my_addr` is assigned
`0x2`), it is a best practice to always use the `my_addr` name.

### Examples

```move
// shorthand for
// 0x0000000000000000000000000000000000000000000000000000000000000001
let a1: address = @0x1;
// shorthand for
// 0x0000000000000000000000000000000000000000000000000000000000000042
let a2: address = @0x42;
// shorthand for
// 0x00000000000000000000000000000000000000000000000000000000DEADBEEF
let a3: address = @0xDEADBEEF;
// shorthand for
// 0x000000000000000000000000000000000000000000000000000000000000000A
let a4: address = @0x0000000000000000000000000000000A;
// Assigns `a5` the value of the named address `std`
let a5: address = @std;
// Any valid numerical value can be used as an address
let a6: address = @66;
let a7: address = @42_000;

module 66::some_module {   // Not in expression context, so no @ needed
    use 0x1::other_module; // Not in expression context so no @ needed
    use std::vector;       // Can use a named address as a namespace item
    ...
}

module std::other_module {  // Can use a named address when declaring a module
    ...
}
```

>>>> move-book/reference/primitive-types/bool.md
---
title: 'Bool | Reference'
description: ''
---

# Bool

`bool` is Move's primitive type for boolean `true` and `false` values.

## Literals

Literals for `bool` are either `true` or `false`.

## Operations

### Logical

`bool` supports three logical operations:

| Syntax                    | Description                  | Equivalent Expression                                               |
| ------------------------- | ---------------------------- | ------------------------------------------------------------------- |
| `&&`                      | short-circuiting logical and | `p && q` is equivalent to `if (p) q else false`                     |
| <code>&vert;&vert;</code> | short-circuiting logical or  | <code>p &vert;&vert; q</code> is equivalent to `if (p) true else q` |
| `!`                       | logical negation             | `!p` is equivalent to `if (p) false else true`                      |

### Control Flow

`bool` values are used in several of Move's control-flow constructs:

- [`if (bool) { ... }`](./../control-flow/conditionals)
- [`while (bool) { .. }`](./../control-flow/loops)
- [`assert!(bool, u64)`](./../abort-and-assert)

## Ownership

As with the other scalar values built-in to the language, boolean values are implicitly copyable,
meaning they can be copied without an explicit instruction such as
[`copy`](.././variables#move-and-copy).

>>>> move-book/reference/primitive-types/integers.md
---
title: 'Integers | Reference'
description: ''
---

# Integers

Move supports six unsigned integer types: `u8`, `u16`, `u32`, `u64`, `u128`, and `u256`. Values of
these types range from 0 to a maximum that depends on the size of the type.

| Type                             | Value Range              |
| -------------------------------- | ------------------------ |
| Unsigned 8-bit integer, `u8`     | 0 to 2<sup>8</sup> - 1   |
| Unsigned 16-bit integer, `u16`   | 0 to 2<sup>16</sup> - 1  |
| Unsigned 32-bit integer, `u32`   | 0 to 2<sup>32</sup> - 1  |
| Unsigned 64-bit integer, `u64`   | 0 to 2<sup>64</sup> - 1  |
| Unsigned 128-bit integer, `u128` | 0 to 2<sup>128</sup> - 1 |
| Unsigned 256-bit integer, `u256` | 0 to 2<sup>256</sup> - 1 |

## Literals

Literal values for these types are specified either as a sequence of digits (e.g.,`112`) or as hex
literals, e.g., `0xFF`. The type of the literal can optionally be added as a suffix, e.g., `112u8`.
If the type is not specified, the compiler will try to infer the type from the context where the
literal is used. If the type cannot be inferred, it is assumed to be `u64`.

Number literals can be separated by underscores for grouping and readability. (e.g.,`1_234_5678`,
`1_000u128`, `0xAB_CD_12_35`).

If a literal is too large for its specified (or inferred) size range, an error is reported.

### Examples

```move
// literals with explicit annotations;
let explicit_u8 = 1u8;
let explicit_u16 = 1u16;
let explicit_u32 = 1u32;
let explicit_u64 = 2u64;
let explicit_u128 = 3u128;
let explicit_u256 = 1u256;
let explicit_u64_underscored = 154_322_973u64;

// literals with simple inference
let simple_u8: u8 = 1;
let simple_u16: u16 = 1;
let simple_u32: u32 = 1;
let simple_u64: u64 = 2;
let simple_u128: u128 = 3;
let simple_u256: u256 = 1;

// literals with more complex inference
let complex_u8 = 1; // inferred: u8
// right hand argument to shift must be u8
let _unused = 10 << complex_u8;

let x: u8 = 38;
let complex_u8 = 2; // inferred: u8
// arguments to `+` must have the same type
let _unused = x + complex_u8;

let complex_u128 = 133_876; // inferred: u128
// inferred from function argument type
function_that_takes_u128(complex_u128);

// literals can be written in hex
let hex_u8: u8 = 0x1;
let hex_u16: u16 = 0x1BAE;
let hex_u32: u32 = 0xDEAD80;
let hex_u64: u64 = 0xCAFE;
let hex_u128: u128 = 0xDEADBEEF;
let hex_u256: u256 = 0x1123_456A_BCDE_F;
```

## Operations

### Arithmetic

Each of these types supports the same set of checked arithmetic operations. For all of these
operations, both arguments (the left and right side operands) _must_ be of the same type. If you
need to operate over values of different types, you will need to first perform a [cast](#casting).
Similarly, if you expect the result of the operation to be too large for the integer type, perform a
[cast](#casting) to a larger size before performing the operation.

All arithmetic operations abort instead of behaving in a way that mathematical integers would not
(e.g., overflow, underflow, divide-by-zero).

| Syntax | Operation           | Aborts If                                |
| ------ | ------------------- | ---------------------------------------- |
| `+`    | addition            | Result is too large for the integer type |
| `-`    | subtraction         | Result is less than zero                 |
| `*`    | multiplication      | Result is too large for the integer type |
| `%`    | modular division    | The divisor is `0`                       |
| `/`    | truncating division | The divisor is `0`                       |

### Bitwise

The integer types support the following bitwise operations that treat each number as a series of
individual bits, either 0 or 1, instead of as numerical integer values.

Bitwise operations do not abort.

| Syntax              | Operation   | Description                                           |
| ------------------- | ----------- | ----------------------------------------------------- |
| `&`                 | bitwise and | Performs a boolean and for each bit pairwise          |
| <code>&#124;</code> | bitwise or  | Performs a boolean or for each bit pairwise           |
| `^`                 | bitwise xor | Performs a boolean exclusive or for each bit pairwise |

### Bit Shifts

Similar to the bitwise operations, each integer type supports bit shifts. But unlike the other
operations, the right hand side operand (how many bits to shift by) must _always_ be a `u8` and need
not match the left side operand (the number you are shifting).

Bit shifts can abort if the number of bits to shift by is greater than or equal to `8`, `16`, `32`,
`64`, `128` or `256` for `u8`, `u16`, `u32`, `u64`, `u128` and `u256` respectively.

| Syntax | Operation   | Aborts if                                                               |
| ------ | ----------- | ----------------------------------------------------------------------- |
| `<<`   | shift left  | Number of bits to shift by is greater than the size of the integer type |
| `>>`   | shift right | Number of bits to shift by is greater than the size of the integer type |

### Comparisons

Integer types are the _only_ types in Move that can use the comparison operators. Both arguments
need to be of the same type. If you need to compare integers of different types, you must
[cast](#casting) one of them first.

Comparison operations do not abort.

| Syntax | Operation                |
| ------ | ------------------------ |
| `<`    | less than                |
| `>`    | greater than             |
| `<=`   | less than or equal to    |
| `>=`   | greater than or equal to |

### Equality

Like all types with [`drop`](./../abilities), all integer types support the ["equal"](./../equality)
and ["not equal"](./../equality) operations. Both arguments need to be of the same type. If you need
to compare integers of different types, you must [cast](#casting) one of them first.

Equality operations do not abort.

| Syntax | Operation |
| ------ | --------- |
| `==`   | equal     |
| `!=`   | not equal |

For more details see the section on [equality](./../equality)

## Casting

Integer types of one size can be cast to integer types of another size. Integers are the only types
in Move that support casting.

Casts _do not_ truncate. Casting aborts if the result is too large for the specified type.

| Syntax     | Operation                                            | Aborts if                              |
| ---------- | ---------------------------------------------------- | -------------------------------------- |
| `(e as T)` | Cast integer expression `e` into an integer type `T` | `e` is too large to represent as a `T` |

Here, the type of `e` must be `8`, `16`, `32`, `64`, `128` or `256` and `T` must be `u8`, `u16`,
`u32`, `u64`, `u128`, or `u256`.

For example:

- `(x as u8)`
- `(y as u16)`
- `(873u16 as u32)`
- `(2u8 as u64)`
- `(1 + 3 as u128)`
- `(4/2 + 12345 as u256)`

## Ownership

As with the other scalar values built-in to the language, integer values are implicitly copyable,
meaning they can be copied without an explicit instruction such as
[`copy`](./../variables#move-and-copy).

>>>> move-book/reference/primitive-types/references.md
---
title: 'References | Reference'
description: ''
---

# References

Move has two types of references: immutable `&` and mutable `&mut`. Immutable references are read
only, and cannot modify the underlying value (or any of its fields). Mutable references allow for
modifications via a write through that reference. Move's type system enforces an ownership
discipline that prevents reference errors.

## Reference Operators

Move provides operators for creating and extending references as well as converting a mutable
reference to an immutable one. Here and elsewhere, we use the notation `e: T` for "expression `e`
has type `T`".

| Syntax      | Type                                                  | Description                                                    |
| ----------- | ----------------------------------------------------- | -------------------------------------------------------------- |
| `&e`        | `&T` where `e: T` and `T` is a non-reference type     | Create an immutable reference to `e`                           |
| `&mut e`    | `&mut T` where `e: T` and `T` is a non-reference type | Create a mutable reference to `e`.                             |
| `&e.f`      | `&T` where `e.f: T`                                   | Create an immutable reference to field `f` of struct `e`.      |
| `&mut e.f`  | `&mut T` where `e.f: T`                               | Create a mutable reference to field `f` of struct`e`.          |
| `freeze(e)` | `&T` where `e: &mut T`                                | Convert the mutable reference `e` into an immutable reference. |

The `&e.f` and `&mut e.f` operators can be used both to create a new reference into a struct or to
extend an existing reference:

```move
let s = S { f: 10 };
let f_ref1: &u64 = &s.f; // works
let s_ref: &S = &s;
let f_ref2: &u64 = &s_ref.f // also works
```

A reference expression with multiple fields works as long as both structs are in the same module:

```move
public struct A { b: B }
public struct B { c : u64 }
fun f(a: &A): &u64 {
    &a.b.c
}
```

Finally, note that references to references are not allowed:

```move
let x = 7;
let y: &u64 = &x;
// highlight-error
let z: &&u64 = &y; // ERROR! will not compile
```

## Reading and Writing Through References

Both mutable and immutable references can be read to produce a copy of the referenced value.

Only mutable references can be written. A write `*x = v` discards the value previously stored in `x`
and updates it with `v`.

Both operations use the C-like `*` syntax. However, note that a read is an expression, whereas a
write is a mutation that must occur on the left hand side of an equals.

| Syntax     | Type                                | Description                         |
| ---------- | ----------------------------------- | ----------------------------------- |
| `*e`       | `T` where `e` is `&T` or `&mut T`   | Read the value pointed to by `e`    |
| `*e1 = e2` | `()` where `e1: &mut T` and `e2: T` | Update the value in `e1` with `e2`. |

In order for a reference to be read, the underlying type must have the
[`copy` ability](../abilities) as reading the reference creates a new copy of the value. This rule
prevents the copying of assets:

```move
fun copy_coin_via_ref_bad(c: Coin) {
    let c_ref = &c;
    // highlight-error
    let counterfeit: Coin = *c_ref; // not allowed!
    pay(c);
    pay(counterfeit);
}
```

Dually: in order for a reference to be written to, the underlying type must have the
[`drop` ability](../abilities) as writing to the reference will discard (or "drop") the old value.
This rule prevents the destruction of resource values:

```move
fun destroy_coin_via_ref_bad(mut ten_coins: Coin, c: Coin) {
    let ref = &mut ten_coins;
    // highlight-error
    *ref = c; // ERROR! not allowed--would destroy 10 coins!
}
```

## `freeze` inference

A mutable reference can be used in a context where an immutable reference is expected:

```move
let mut x = 7;
let y: &u64 = &mut x;
```

This works because the under the hood, the compiler inserts `freeze` instructions where they are
needed. Here are a few more examples of `freeze` inference in action:

```move
fun takes_immut_returns_immut(x: &u64): &u64 { x }

// freeze inference on return value
fun takes_mut_returns_immut(x: &mut u64): &u64 { x }

fun expression_examples() {
    let mut x = 0;
    let mut y = 0;
    takes_immut_returns_immut(&x); // no inference
    takes_immut_returns_immut(&mut x); // inferred freeze(&mut x)
    takes_mut_returns_immut(&mut x); // no inference

    assert!(&x == &mut y, 42); // inferred freeze(&mut y)
}

fun assignment_examples() {
    let x = 0;
    let y = 0;
    let imm_ref: &u64 = &x;

    imm_ref = &x; // no inference
    imm_ref = &mut y; // inferred freeze(&mut y)
}
```

### Subtyping

With this `freeze` inference, the Move type checker can view `&mut T` as a subtype of `&T`. As shown
above, this means that anywhere for any expression where a `&T` value is used, a `&mut T` value can
also be used. This terminology is used in error messages to concisely indicate that a `&mut T` was
needed where a `&T` was supplied. For example

```move
module a::example {
    fun read_and_assign(store: &mut u64, new_value: &u64) {
        *store = *new_value
    }

    fun subtype_examples() {
        let mut x: &u64 = &0;
        let mut y: &mut u64 = &mut 1;

        x = &mut 1; // valid
        // highlight-error
        y = &2; // ERROR! invalid!

        read_and_assign(y, x); // valid
        // highlight-error
        read_and_assign(x, y); // ERROR! invalid!
    }
}
```

will yield the following error messages

```text
error:

    ┌── example.move:11:9 ───
    │
 12 │         y = &2; // invalid!
    │         ^ Invalid assignment to local 'y'
    ·
 12 │         y = &2; // invalid!
    │             -- The type: '&{integer}'
    ·
  9 │         let mut y: &mut u64 = &mut 1;
    │                    -------- Is not a subtype of: '&mut u64'
    │

error:

    ┌── example.move:14:9 ───
    │
 15 │         read_and_assign(x, y); // invalid!
    │         ^^^^^^^^^^^^^^^^^^^^^ Invalid call of 'a::example::read_and_assign'. Invalid argument for parameter 'store'
    ·
  8 │         let mut x: &u64 = &0;
    │                    ---- The type: '&u64'
    ·
  3 │     fun read_and_assign(store: &mut u64, new_value: &u64) {
    │                                -------- Is not a subtype of: '&mut u64'
    │
```

The only other types that currently have subtyping are [tuples](./tuples)

## Ownership

Both mutable and immutable references can always be copied and extended _even if there are existing
copies or extensions of the same reference_:

```move
fun reference_copies(s: &mut S) {
  let s_copy1 = s; // ok
  let s_extension = &mut s.f; // also ok
  let s_copy2 = s; // still ok
  ...
}
```

This might be surprising for programmers familiar with Rust's ownership system, which would reject
the code above. Move's type system is more permissive in its treatment of
[copies](./../variables#move-and-copy), but equally strict in ensuring unique ownership of mutable
references before writes.

### References Cannot Be Stored

References and tuples are the _only_ types that cannot be stored as a field value of structs, which
also means that they cannot exist in storage or [objects](./../abilities/object). All references
created during program execution will be destroyed when a Move program terminates; they are entirely
ephemeral. This also applies to all types without the `store` ability: any value of a non-`store`
type must be destroyed before the program terminates.

This is another difference between Move and Rust, which allows references to be stored inside of
structs.

One could imagine a fancier, more expressive, type system that would allow references to be stored
in structs. We could allow references inside of structs that do not have the `store`
[ability](./../abilities), but the core difficulty is that Move has a fairly complex system for
tracking static reference safety. This aspect of the type system would also have to be extended to
support storing references inside of structs. In short, Move's reference safety system would have to
expand to support stored references, and it is something we are keeping an eye on as the language
evolves.

<!-- TODO actually document a sketch of the borrow rules -->

>>>> move-book/reference/primitive-types/tuples.md
---
title: 'Tuples and Unit | Reference'
description: ''
---

# Tuples and Unit

Move does not fully support tuples as one might expect coming from another language with them as a
[first-class value](https://en.wikipedia.org/wiki/First-class_citizen). However, in order to support
multiple return values, Move has tuple-like expressions. These expressions do not result in a
concrete value at runtime (there are no tuples in the bytecode), and as a result they are very
limited:

- They can only appear in expressions (usually in the return position for a function).
- They cannot be bound to local variables.
- They cannot be stored in structs.
- Tuple types cannot be used to instantiate generics.

Similarly, [unit `()`](https://en.wikipedia.org/wiki/Unit_type) is a type created by the Move source
language in order to be expression based. The unit value `()` does not result in any runtime value.
We can consider unit`()` to be an empty tuple, and any restrictions that apply to tuples also apply
to unit.

It might feel weird to have tuples in the language at all given these restrictions. But one of the
most common use cases for tuples in other languages is for functions to allow functions to return
multiple values. Some languages work around this by forcing the users to write structs that contain
the multiple return values. However in Move, you cannot put references inside of
[structs](./../structs). This required Move to support multiple return values. These multiple return
values are all pushed on the stack at the bytecode level. At the source level, these multiple return
values are represented using tuples.

## Literals

Tuples are created by a comma separated list of expressions inside of parentheses.

| Syntax          | Type                                                                         | Description                                                  |
| --------------- | ---------------------------------------------------------------------------- | ------------------------------------------------------------ |
| `()`            | `(): ()`                                                                     | Unit, the empty tuple, or the tuple of arity 0               |
| `(e1, ..., en)` | `(e1, ..., en): (T1, ..., Tn)` where `e_i: Ti` s.t. `0 < i <= n` and `n > 0` | A `n`-tuple, a tuple of arity `n`, a tuple with `n` elements |

Note that `(e)` does not have type `(e): (t)`, in other words there is no tuple with one element. If
there is only a single element inside of the parentheses, the parentheses are only used for
disambiguation and do not carry any other special meaning.

Sometimes, tuples with two elements are called "pairs" and tuples with three elements are called
"triples."

### Examples

```move
module 0::example;

// all 3 of these functions are equivalent

// when no return type is provided, it is assumed to be `()`
fun returns_unit_1() { }

// there is an implicit () value in empty expression blocks
fun returns_unit_2(): () { }

// explicit version of `returns_unit_1` and `returns_unit_2`
fun returns_unit_3(): () { () }


fun returns_3_values(): (u64, bool, address) {
    (0, false, @0x42)
}
fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) {
    (x, 0, 1, b"foobar")
}
```

## Operations

The only operation that can be done on tuples currently is destructuring.

### Destructuring

For tuples of any size, they can be destructured in either a `let` binding or in an assignment.

For example:

```move
module 0x42::example;

// all 3 of these functions are equivalent
fun returns_unit() {}
fun returns_2_values(): (bool, bool) { (true, false) }
fun returns_4_values(x: &u64): (&u64, u8, u128, vector<u8>) { (x, 0, 1, b"foobar") }

fun examples(cond: bool) {
    let () = ();
    let (mut x, mut y): (u8, u64) = (0, 1);
    let (mut a, mut b, mut c, mut d) = (@0x0, 0, false, b"");

    () = ();
    (x, y) = if (cond) (1, 2) else (3, 4);
    (a, b, c, d) = (@0x1, 1, true, b"1");
}

fun examples_with_function_calls() {
    let () = returns_unit();
    let (mut x, mut y): (bool, bool) = returns_2_values();
    let (mut a, mut b, mut c, mut d) = returns_4_values(&0);

    () = returns_unit();
    (x, y) = returns_2_values();
    (a, b, c, d) = returns_4_values(&1);
}
```

For more details, see [Move Variables](./../variables).

## Subtyping

Along with references, tuples are the only types that have
[subtyping](https://en.wikipedia.org/wiki/Subtyping) in Move. Tuples have subtyping only in the
sense that subtype with references (in a covariant way).

For example:

```move
let x: &u64 = &0;
let y: &mut u64 = &mut 1;

// (&u64, &mut u64) is a subtype of (&u64, &u64)
// since &mut u64 is a subtype of &u64
let (a, b): (&u64, &u64) = (x, y);

// (&mut u64, &mut u64) is a subtype of (&u64, &u64)
// since &mut u64 is a subtype of &u64
let (c, d): (&u64, &u64) = (y, y);

// highlight-error-start
// ERROR! (&u64, &mut u64) is NOT a subtype of (&mut u64, &mut u64)
// since &u64 is NOT a subtype of &mut u64
let (e, f): (&mut u64, &mut u64) = (x, y);
// highlight-error-end
```

## Ownership

As mentioned above, tuple values don't really exist at runtime. And currently they cannot be stored
into local variables because of this (but it is likely that this feature will come at some point in
the future). As such, tuples can only be moved currently, as copying them would require putting them
into a local variable first.

>>>> move-book/reference/primitive-types/vector.md
---
title: 'Vector | Reference'
description: ''
---

# Vector

`vector<T>` is the only primitive collection type provided by Move. A `vector<T>` is a homogeneous
collection of `T`'s that can grow or shrink by pushing/popping values off the "end".

A `vector<T>` can be instantiated with any type `T`. For example, `vector<u64>`, `vector<address>`,
`vector<0x42::my_module::MyData>`, and `vector<vector<u8>>` are all valid vector types.

## Literals

### General `vector` Literals

Vectors of any type can be created with `vector` literals.

| Syntax                | Type                                                                          | Description                                |
| --------------------- | ----------------------------------------------------------------------------- | ------------------------------------------ |
| `vector[]`            | `vector[]: vector<T>` where `T` is any single, non-reference type             | An empty vector                            |
| `vector[e1, ..., en]` | `vector[e1, ..., en]: vector<T>` where `e_i: T` s.t. `0 < i <= n` and `n > 0` | A vector with `n` elements (of length `n`) |

In these cases, the type of the `vector` is inferred, either from the element type or from the
vector's usage. If the type cannot be inferred, or simply for added clarity, the type can be
specified explicitly:

```move
vector<T>[]: vector<T>
vector<T>[e1, ..., en]: vector<T>
```

#### Example Vector Literals

```move
(vector[]: vector<bool>);
(vector[0u8, 1u8, 2u8]: vector<u8>);
(vector<u128>[]: vector<u128>);
(vector<address>[@0x42, @0x100]: vector<address>);
```

### `vector<u8>` literals

A common use-case for vectors in Move is to represent "byte arrays", which are represented with
`vector<u8>`. These values are often used for cryptographic purposes, such as a public key or a hash
result. These values are so common that specific syntax is provided to make the values more
readable, as opposed to having to use `vector[]` where each individual `u8` value is specified in
numeric form.

There are currently two supported types of `vector<u8>` literals, _byte strings_ and _hex strings_.

#### Byte Strings

Byte strings are quoted string literals prefixed by a `b`, e.g. `b"Hello!\n"`.

These are ASCII encoded strings that allow for escape sequences. Currently, the supported escape
sequences are:

| Escape Sequence | Description                                    |
| --------------- | ---------------------------------------------- |
| `\n`            | New line (or Line feed)                        |
| `\r`            | Carriage return                                |
| `\t`            | Tab                                            |
| `\\`            | Backslash                                      |
| `\0`            | Null                                           |
| `\"`            | Quote                                          |
| `\xHH`          | Hex escape, inserts the hex byte sequence `HH` |

#### Hex Strings

Hex strings are quoted string literals prefixed by a `x`, e.g. `x"48656C6C6F210A"`.

Each byte pair, ranging from `00` to `FF`, is interpreted as hex encoded `u8` value. So each byte
pair corresponds to a single entry in the resulting `vector<u8>`.

#### Example String Literals

```move
fun byte_and_hex_strings() {
    assert!(b"" == x"", 0);
    assert!(b"Hello!\n" == x"48656C6C6F210A", 1);
    assert!(b"\x48\x65\x6C\x6C\x6F\x21\x0A" == x"48656C6C6F210A", 2);
    assert!(
        b"\"Hello\tworld!\"\n \r \\Null=\0" ==
            x"2248656C6C6F09776F726C6421220A200D205C4E756C6C3D00",
        3
    );
}
```

## Operations

`vector` supports the following operations via the `std::vector` module in the Move standard
library:

| Function                                                   | Description                                                                                                                                                     | Aborts?                        |
| ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ |
| `vector::empty<T>(): vector<T>`                            | Create an empty vector that can store values of type `T`                                                                                                        | Never                          |
| `vector::singleton<T>(t: T): vector<T>`                    | Create a vector of size 1 containing `t`                                                                                                                        | Never                          |
| `vector::push_back<T>(v: &mut vector<T>, t: T)`            | Add `t` to the end of `v`                                                                                                                                       | Never                          |
| `vector::pop_back<T>(v: &mut vector<T>): T`                | Remove and return the last element in `v`                                                                                                                       | If `v` is empty                |
| `vector::borrow<T>(v: &vector<T>, i: u64): &T`             | Return an immutable reference to the `T` at index `i`                                                                                                           | If `i` is not in bounds        |
| `vector::borrow_mut<T>(v: &mut vector<T>, i: u64): &mut T` | Return a mutable reference to the `T` at index `i`                                                                                                              | If `i` is not in bounds        |
| `vector::destroy_empty<T>(v: vector<T>)`                   | Delete `v`                                                                                                                                                      | If `v` is not empty            |
| `vector::append<T>(v1: &mut vector<T>, v2: vector<T>)`     | Add the elements in `v2` to the end of `v1`                                                                                                                     | Never                          |
| `vector::contains<T>(v: &vector<T>, e: &T): bool`          | Return true if `e` is in the vector `v`. Otherwise, returns false                                                                                               | Never                          |
| `vector::swap<T>(v: &mut vector<T>, i: u64, j: u64)`       | Swaps the elements at the `i`th and `j`th indices in the vector `v`                                                                                             | If `i` or `j` is out of bounds |
| `vector::reverse<T>(v: &mut vector<T>)`                    | Reverses the order of the elements in the vector `v` in place                                                                                                   | Never                          |
| `vector::index_of<T>(v: &vector<T>, e: &T): (bool, u64)`   | Return `(true, i)` if `e` is in the vector `v` at index `i`. Otherwise, returns `(false, 0)`                                                                    | Never                          |
| `vector::remove<T>(v: &mut vector<T>, i: u64): T`          | Remove the `i`th element of the vector `v`, shifting all subsequent elements. This is O(n) and preserves ordering of elements in the vector                     | If `i` is out of bounds        |
| `vector::swap_remove<T>(v: &mut vector<T>, i: u64): T`     | Swap the `i`th element of the vector `v` with the last element and then pop the element, This is O(1), but does not preserve ordering of elements in the vector | If `i` is out of bounds        |

<!-- TODO we should just link out to generated stdlib docs? Maybe?  -->

More operations may be added over time.

## Example

```move
use std::vector;

let mut v = vector::empty<u64>();
vector::push_back(&mut v, 5);
vector::push_back(&mut v, 6);

assert!(*vector::borrow(&v, 0) == 5, 42);
assert!(*vector::borrow(&v, 1) == 6, 42);
assert!(vector::pop_back(&mut v) == 6, 42);
assert!(vector::pop_back(&mut v) == 5, 42);
```

## Destroying and copying `vector`s

Some behaviors of `vector<T>` depend on the abilities of the element type, `T`. For example, vectors
containing elements that do not have `drop` cannot be implicitly discarded like `v` in the example
above--they must be explicitly destroyed with `vector::destroy_empty`.

Note that `vector::destroy_empty` will abort at runtime unless `vec` contains zero elements:

```move
fun destroy_any_vector<T>(vec: vector<T>) {
    vector::destroy_empty(vec) // deleting this line will cause a compiler error
}
```

But no error would occur for dropping a vector that contains elements with `drop`:

```move
fun destroy_droppable_vector<T: drop>(vec: vector<T>) {
    // valid!
    // nothing needs to be done explicitly to destroy the vector
}
```

Similarly, vectors cannot be copied unless the element type has `copy`. In other words, a
`vector<T>` has `copy` if and only if `T` has `copy`. Note that it will be implicitly copied if
needed:

```move
let x = vector[10];
let y = x; // implicit copy
let z = x;
(y, z)
```

Keep in mind, copies of large vectors can be expensive. If this is a concern, annotating the
`intended` usage can prevent accidental copies. For example,

```move
let x = vector[10];
let y = move x;
let z = x; // ERROR! x has been moved
(y, z)
```

For more details see the sections on [type abilities](./../abilities) and [generics](./../generics).

## Ownership

As mentioned [above](#destroying-and-copying-vectors), `vector` values can be copied only if the
elements can be copied. In that case, the copy can be done via a
[`copy`](./../variables#move-and-copy) or a
[dereference `*`](./references#reading-and-writing-through-references).

>>>> move-book/reference/structs.md
---
title: 'Structs | Reference'
description: ''
---

# Structs and Resources

A _struct_ is a user-defined data structure containing typed fields. Structs can store any
non-reference, non-tuple type, including other structs.

Structs can be used to define all "asset" values or unrestricted values, where the operations
performed on those values can be controlled by the struct's [abilities](./abilities). By default,
structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be dropped,
and cannot be stored in storage. This means that all values have to have ownership transferred
(linear) and the values must be dealt with by the end of the program's execution (ephemeral). We can
relax this behavior by giving the struct [abilities](./abilities) which allow values to be copied
or dropped and also to be stored in storage or to define storage schemas.

## Defining Structs

Structs must be defined inside a module, and the struct's fields can either be named or positional:

```move
module a::m;

public struct Foo { x: u64, y: bool }
public struct Bar {}
public struct Baz { foo: Foo, }
//                          ^ note: it is fine to have a trailing comma

public struct PosFoo(u64, bool)
public struct PosBar()
public struct PosBaz(Foo)
```

Structs cannot be recursive, so the following definitions are invalid:

```move
public struct Foo { x: Foo }
//                     ^ ERROR! recursive definition

public struct A { b: B }
public struct B { a: A }
//                   ^ ERROR! recursive definition

public struct D(D)
//              ^ ERROR! recursive definition
```

### Visibility

As you may have noticed, all structs are declared as `public`. This means that the type of the
struct can be referred to from any other module. However, the fields of the struct, and the ability
to create or destroy the struct, are still internal to the module that defines the struct.

In the future, we plan on adding to declare structs as `public(package)` or as internal, much like
[functions](./functions#visibility).

### Abilities

As mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value
to be used in these ways (e.g., copied, dropped, stored in an [object](./abilities/object), or
used to define a storable [object](./abilities/object)), structs can be granted
[abilities](./abilities) by annotating them with `has <ability>`:

```move
module a::m {
    public struct Foo has copy, drop { x: u64, y: bool }
}
```

The ability declaration can occur either before or after the struct's fields. However, only one or
the other can be used, and not both. If declared after the struct's fields, the ability declaration
must be terminated with a semicolon:

```move
module a::m;

public struct PreNamedAbilities has copy, drop { x: u64, y: bool }
public struct PostNamedAbilities { x: u64, y: bool } has copy, drop;
public struct PostNamedAbilitiesInvalid { x: u64, y: bool } has copy, drop
//                                                                        ^ ERROR! missing semicolon

public struct NamedInvalidAbilities has copy { x: u64, y: bool } has drop;
//                                                               ^ ERROR! duplicate ability declaration

public struct PrePositionalAbilities has copy, drop (u64, bool)
public struct PostPositionalAbilities (u64, bool) has copy, drop;
public struct PostPositionalAbilitiesInvalid (u64, bool) has copy, drop
//                                                                     ^ ERROR! missing semicolon
public struct InvalidAbilities has copy (u64, bool) has drop;
//                                                  ^ ERROR! duplicate ability declaration
```

For more details, see the section on
[annotating a struct's abilities](./abilities#annotating-structs-and-enums).

### Naming

Structs must start with a capital letter `A` to `Z`. After the first letter, struct names can
contain underscores `_`, letters `a` to `z`, letters `A` to `Z`, or digits `0` to `9`.

```move
public struct Foo {}
public struct BAR {}
public struct B_a_z_4_2 {}
public struct P_o_s_Foo()
```

This naming restriction of starting with `A` to `Z` is in place to give room for future language
features. It may or may not be removed later.

## Using Structs

### Creating Structs

Values of a struct type can be created (or "packed") by indicating the struct name, followed by
value for each field.

For a struct with named fields, the order of the fields does not matter, but the field name needs to
be provided. For a struct with positional fields, the order of the fields must match the order of
the fields in the struct definition, and it must be created using `()` instead of `{}` to enclose
the parameters.

```move
module a::m;

public struct Foo has drop { x: u64, y: bool }
public struct Baz has drop { foo: Foo }
public struct Positional(u64, bool) has drop;

fun example() {
    let foo = Foo { x: 0, y: false };
    let baz = Baz { foo: foo };
    // Note: positional struct values are created using parentheses and
    // based on position instead of name.
    let pos = Positional(0, false);
    let pos_invalid = Positional(false, 0);
    //                           ^ ERROR! Fields are out of order and the types don't match.
}
```

For structs with named fields, you can use the following shorthand if you have a local variable with
the same name as the field:

```move
let baz = Baz { foo: foo };
// is equivalent to
let baz = Baz { foo };
```

This is sometimes called "field name punning".

### Destroying Structs via Pattern Matching

Struct values can be destroyed by binding or assigning them in patterns using similar syntax to
constructing them.

```move
module a::m;

public struct Foo { x: u64, y: bool }
public struct Bar(Foo)
public struct Baz {}
public struct Qux()

fun example_destroy_foo() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y: foo_y } = foo;
    //        ^ shorthand for `x: x`

    // two new bindings
    //   x: u64 = 3
    //   foo_y: bool = false
}

fun example_destroy_foo_wildcard() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y: _ } = foo;

    // only one new binding since y was bound to a wildcard
    //   x: u64 = 3
}

fun example_destroy_foo_assignment() {
    let x: u64;
    let y: bool;
    Foo { x, y } = Foo { x: 3, y: false };

    // mutating existing variables x and y
    //   x = 3, y = false
}

fun example_foo_ref() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y } = &foo;

    // two new bindings
    //   x: &u64
    //   y: &bool
}

fun example_foo_ref_mut() {
    let foo = Foo { x: 3, y: false };
    let Foo { x, y } = &mut foo;

    // two new bindings
    //   x: &mut u64
    //   y: &mut bool
}

fun example_destroy_bar() {
    let bar = Bar(Foo { x: 3, y: false });
    let Bar(Foo { x, y }) = bar;
    //            ^ nested pattern

    // two new bindings
    //   x: u64 = 3
    //   y: bool = false
}

fun example_destroy_baz() {
    let baz = Baz {};
    let Baz {} = baz;
}

fun example_destroy_qux() {
    let qux = Qux();
    let Qux() = qux;
}
```

### Accessing Struct Fields

Fields of a struct can be accessed using the dot operator `.`.

For structs with named fields, the fields can be accessed by their name:

```move
public struct Foo { x: u64, y: bool }
let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
```

For positional structs, fields can be accessed by their position in the struct definition:

```move
public struct PosFoo(u64, bool)
let pos_foo = PosFoo(3, true);
let x = pos_foo.0;  // x == 3
let y = pos_foo.1;  // y == true
```

Accessing struct fields without borrowing or copying them is subject to the field's ability
constraints. For more details see the sections on
[borrowing structs and fields](#borrowing-structs-and-fields) and
[reading and writing fields](#reading-and-writing-fields) for more information.

### Borrowing Structs and Fields

The `&` and `&mut` operator can be used to create references to structs or fields. These examples
include some optional type annotations (e.g., `: &Foo`) to demonstrate the type of operations.

```move
let foo = Foo { x: 3, y: true };
let foo_ref: &Foo = &foo;
let y: bool = foo_ref.y;         // reading a field via a reference to the struct
let x_ref: &u64 = &foo.x;        // borrowing a field by extending a reference to the struct

let x_ref_mut: &mut u64 = &mut foo.x;
*x_ref_mut = 42;            // modifying a field via a mutable reference
```

It is possible to borrow inner fields of nested structs:

```move
let foo = Foo { x: 3, y: true };
let bar = Bar(foo);

let x_ref = &bar.0.x;
```

You can also borrow a field via a reference to a struct:

```move
let foo = Foo { x: 3, y: true };
let foo_ref = &foo;
let x_ref = &foo_ref.x;
// this has the same effect as let x_ref = &foo.x
```

### Reading and Writing Fields

If you need to read and copy a field's value, you can then dereference the borrowed field:

```move
let foo = Foo { x: 3, y: true };
let bar = Bar(copy foo);
let x: u64 = *&foo.x;
let y: bool = *&foo.y;
let foo2: Foo = *&bar.0;
```

More canonically, the dot operator can be used to read fields of a struct without any borrowing. As
is true with
[dereferencing](./primitive-types/references#reading-and-writing-through-references), the field
type must have the `copy` [ability](./abilities).

```move
let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
```

Dot operators can be chained to access nested fields:

```move
let bar = Bar(Foo { x: 3, y: true });
let x = baz.0.x; // x = 3;
```

However, this is not permitted for fields that contain non-primitive types, such a vector or another
struct:

```move
let foo = Foo { x: 3, y: true };
let bar = Bar(foo);
let foo2: Foo = *&bar.0;
let foo3: Foo = bar.0; // error! must add an explicit copy with *&
```

We can mutably borrow a field to a struct to assign it a new value:

```move
let mut foo = Foo { x: 3, y: true };
*&mut foo.x = 42;     // foo = Foo { x: 42, y: true }
*&mut foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let mut bar = Bar(foo);               // bar = Bar(Foo { x: 42, y: false })
*&mut bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })
*&mut bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })
```

Similar to dereferencing, we can instead directly use the dot operator to modify a field. And in
both cases, the field type must have the `drop` [ability](./abilities).

```move
let mut foo = Foo { x: 3, y: true };
foo.x = 42;     // foo = Foo { x: 42, y: true }
foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let mut bar = Bar(foo);         // bar = Bar(Foo { x: 42, y: false })
bar.0.x = 52;                   // bar = Bar(Foo { x: 52, y: false })
bar.0 = Foo { x: 62, y: true }; // bar = Bar(Foo { x: 62, y: true })
```

The dot syntax for assignment also works via a reference to a struct:

```move
let mut foo = Foo { x: 3, y: true };
let foo_ref = &mut foo;
foo_ref.x = foo_ref.x + 1;
```

## Privileged Struct Operations

Most struct operations on a struct type `T` can only be performed inside the module that declares
`T`:

- Struct types can only be created ("packed"), destroyed ("unpacked") inside the module that defines
  the struct.
- The fields of a struct are only accessible inside the module that defines the struct.

Following these rules, if you want to modify your struct outside the module, you will need to
provide public APIs for them. The end of the chapter contains some examples of this.

However as stated [in the visibility section above](#visibility), struct _types_ are always visible
to another module

```move
module a::m {
    public struct Foo has drop { x: u64 }

    public fun new_foo(): Foo {
        Foo { x: 42 }
    }
}

module a::n {
    use a::m::Foo;

    public struct Wrapper has drop {
        foo: Foo
        //   ^ valid the type is public

    }

    fun f1(foo: Foo) {
        let x = foo.x;
        //      ^ ERROR! cannot access fields of `Foo` outside of `a::m`
    }

    fun f2() {
        let foo_wrapper = Wrapper { foo: a::m::new_foo() };
        //                               ^ valid the function is public
    }
}

```

## Ownership

As mentioned above in [Defining Structs](#defining-structs), structs are by default linear and
ephemeral. This means they cannot be copied or dropped. This property can be very useful when
modeling real world assets like money, as you do not want money to be duplicated or get lost in
circulation.

```move
module a::m;

public struct Foo { x: u64 }

public fun copying() {
    let foo = Foo { x: 100 };
    let foo_copy = copy foo; // ERROR! 'copy'-ing requires the 'copy' ability
    let foo_ref = &foo;
    let another_copy = *foo_ref // ERROR! dereference requires the 'copy' ability
}

public fun destroying_1() {
    let foo = Foo { x: 100 };

    // error! when the function returns, foo still contains a value.
    // This destruction requires the 'drop' ability
}

public fun destroying_2(f: &mut Foo) {
    *f = Foo { x: 100 } // error!
                        // destroying the old value via a write requires the 'drop' ability
}
```

To fix the example `fun destroying_1`, you would need to manually "unpack" the value:

```move
module a::m;

public struct Foo { x: u64 }

public fun destroying_1_fixed() {
    let foo = Foo { x: 100 };
    let Foo { x: _ } = foo;
}
```

Recall that you are only able to deconstruct a struct within the module in which it is defined. This
can be leveraged to enforce certain invariants in a system, for example, conservation of money.

If on the other hand, your struct does not represent something valuable, you can add the abilities
`copy` and `drop` to get a struct value that might feel more familiar from other programming
languages:

```move
module a::m;

public struct Foo has copy, drop { x: u64 }

public fun run() {
    let foo = Foo { x: 100 };
    let foo_copy = foo;
    //             ^ this code copies foo,
    //             whereas `let x = move foo` would move foo

    let x = foo.x;            // x = 100
    let x_copy = foo_copy.x;  // x = 100

    // both foo and foo_copy are implicitly discarded when the function returns
}
```

## Storage

Structs can be used to define storage schemas, but the details are different per deployment of Move.
See the documentation for the [`key` ability](./abilities#key) and
[Sui objects](./abilities/object) for more details.

>>>> move-book/reference/unit-testing.md
---
title: 'Unit Tests | Reference'
description: ''
---

# Unit Tests

Unit testing for Move uses three annotations in the Move source language:

- `#[test]` marks a function as a test;
- `#[expected_failure]` marks that a test is expected to fail;
- `#[test_only]` marks a module or module member ([`use`](./uses), [function](./functions),
  [struct](./structs), or [constant](./constants)) as code to be included for testing only.

These annotations can be placed on any appropriate form with any visibility. Whenever a module or
module member is annotated as `#[test_only]` or `#[test]`, it will not be included in the compiled
bytecode unless it is compiled for testing.

## Test Annotations

The `#[test]` annotation can only be placed on a function with no parameters. This annotation marks
the function as a test to be run by the unit testing harness.

```move
#[test] // OK
fun this_is_a_test() { ... }

#[test] // Will fail to compile since the test takes an argument
fun this_is_not_correct(arg: u64) { ... }
```

A test can also be annotated as an `#[expected_failure]`. This annotation marks that the test is
expected to raise an error. There are a number of options that can be used with the
`#[expected_failure]` annotation to ensure only a failure with the specified condition is marked as
passing, these options are detailed in [Expected Failures](#expected-failures). Only functions that
have the `#[test]` annotation can also be annotated as an #`[expected_failure]`.

Some simple examples of using the `#[expected_failure]` annotation are shown below:

```move
#[test, expected_failure]
public fun this_test_will_abort_and_pass() { abort 1 }

#[test, expected_failure]
public fun test_will_error_and_pass() { 1/0; }

// Will pass since test fails with the expected abort code constant.
// ENotFound is a constant defined in the module.
#[test, expected_failure(abort_code = ENotFound)]
public fun test_will_error_and_pass_abort_code() { abort ENotFound }

// Will fail since test fails with a different error than expected.
#[test, expected_failure(abort_code = my_module::ENotFound)]
public fun test_will_error_and_fail() { 1/0; }

#[test, expected_failure] // Can have multiple in one attribute. This test will pass.
public fun this_other_test_will_abort_and_pass() { abort 1 }
```

> **Note**: `#[test]` and `#[test_only]` functions can also call
> [`entry`](./functions#entry-modifier) functions, regardless of their visibility.

## Expected Failures

There are a number of different ways that you can use the `#[expected_failure]` annotation to
specify different types of error conditions. These are:

### 1. `#[expected_failure(abort_code = <constant>)]`

This will pass if the test aborts with the specified constant value in the module that defines the
constant and fail otherwise. This is the recommended way of testing for expected test failures.

> **Note**: You can reference constants outside of the current module or package in
> `expected_failure` annotations.

```move
module pkg_addr::other_module {
    const ENotFound: u64 = 1;
    public fun will_abort() {
        abort ENotFound
    }
}

module pkg_addr::my_module {
    use pkg_addr::other_module;
    const ENotFound: u64 = 1;

    #[test, expected_failure(abort_code = ENotFound)]
    fun test_will_abort_and_pass() { abort ENotFound }

    #[test, expected_failure(abort_code = other_module::ENotFound)]
    fun test_will_abort_and_pass() { other_module::will_abort() }

    // FAIL: Will not pass since we are expecting the constant from the wrong module.
    #[test, expected_failure(abort_code = ENotFound)]
    fun test_will_abort_and_pass() { other_module::will_abort() }
}
```

### 2. `#[expected_failure(arithmetic_error, location = <location>)]`

This specifies that the test is expected to fail with an arithmetic error (e.g., integer overflow,
division by zero, etc.) at the specified location. The `<location>` must be a valid path to a module
location, e.g., `Self`, or `my_package::my_module`.

```move
module pkg_addr::other_module {
    public fun will_arith_error() { 1/0; }
}

module pkg_addr::my_module {
    use pkg_addr::other_module;
    
    #[test, expected_failure(arithmetic_error, location = Self)]
    fun test_will_arith_error_and_pass1() { 1/0; }

    #[test, expected_failure(arithmetic_error, location = pkg_addr::other_module)]
    fun test_will_arith_error_and_pass2() { other_module::will_arith_error() }

    // FAIL: Will fail since the location we expect it the fail at is different from where
    // the test actually failed.
    #[test, expected_failure(arithmetic_error, location = Self)]
    fun test_will_arith_error_and_fail() { other_module::will_arith_error() }
}
```

### 3. `#[expected_failure(out_of_gas, location = <location>)]`

This specifies that the test is expected to fail with an out of gas error at the specified location.
The `<location>` must be a valid path to a module location, e.g., `Self`, or
`my_package::my_module`.

```move
module pkg_addr::other_module {
    public fun will_oog() { loop {} }
}

module pkg_addr::my_module {
    use pkg_addr::other_module;
    
    #[test, expected_failure(out_of_gas, location = Self)]
    fun test_will_oog_and_pass1() { loop {} }

    #[test, expected_failure(arithmetic_error, location = pkg_addr::other_module)]
    fun test_will_oog_and_pass2() { other_module::will_oog() }

    // FAIL: Will fail since the location we expect it the fail at is different from where
    // the test actually failed.
    #[test, expected_failure(out_of_gas, location = Self)]
    fun test_will_oog_and_fail() { other_module::will_oog() }
}
```

### 4. `#[expected_failure(vector_error, minor_status = <u64_opt>, location = <location>)]`

This specifies that the test is expected to fail with a vector error at the specified location with
the given `minor_status` (if provided). The `<location>` must be a valid path to a module
location, e.g., `Self`, or `my_package::my_module`. The `<u64_opt>` is an optional parameter that
specifies the minor status of the vector error. If it is not specified, the test will pass if the
test fails with any minor status. If it is specified, the test will only pass if the test fails with
a vector error with the specified minor status.

```move
module pkg_addr::other_module {
    public fun vector_borrow_empty() {
        &vector<u64>[][1];
    }
}

module pkg_addr::my_module {
    #[test, expected_failure(vector_error, location = Self)]
    fun vector_abort_same_module() {
        vector::borrow(&vector<u64>[], 1);
    }

    #[test, expected_failure(vector_error, location = pkg_addr::other_module)]
    fun vector_abort_same_module() {
        other_module::vector_borrow_empty();
    }

    // Can specify minor statues (i.e., vector-specific error codes) to expect.
    #[test, expected_failure(vector_error, minor_status = 1, location = Self)]
    fun native_abort_good_right_code() {
        vector::borrow(&vector<u64>[], 1);
    }

    // FAIL: correct error, but wrong location.
    #[test, expected_failure(vector_error, location = pkg_addr::other_module)]
    fun vector_abort_same_module() {
        other_module::vector_borrow_empty();
    }

    // FAIL: correct error and location but the minor status differs so this test will fail.
    #[test, expected_failure(vector_error, minor_status = 0, location = Self)]
    fun vector_abort_wrong_minor_code() {
        vector::borrow(&vector<u64>[], 1);
    }
}
```

### 5. `#[expected_failure]`

This will pass if the test aborts with _any_ error code. You should be **_incredibly careful_**
using this to annotate expected tests failures, and always prefer one of the ways described above
instead. Examples of these types of annotations are:

```move
#[test, expected_failure]
fun test_will_abort_and_pass1() { abort 1 }

#[test, expected_failure]
fun test_will_arith_error_and_pass2() { 1/0; }
```

## Test Only Annotations

A module and any of its members can be declared as test only. If an item is annotated as
`#[test_only]` the item will only be included in the compiled Move bytecode when compiled in test
mode. Additionally, when compiled outside of test mode, any non-test `use`s of a `#[test_only]`
module will raise an error during compilation.

> **Note**: functions that are annotated with `#[test_only]` will only be available to be called
> from test code, but they themselves are not tests and will not be run as tests by the unit testing
> framework.

```move
#[test_only] // test only attributes can be attached to modules
module abc { ... }

#[test_only] // test only attributes can be attached to constants
const MY_ADDR: address = @0x1;

#[test_only] // .. to uses
use pkg_addr::some_other_module;

#[test_only] // .. to structs
public struct SomeStruct { ... }

#[test_only] // .. and functions. Can only be called from test code, but this is _not_ a test!
fun test_only_function(...) { ... }
```

## Running Unit Tests

Use the `sui move test` command to run unit tests for a [Move package](./packages).

When running tests, every test will either `PASS`, `FAIL`, or `TIMEOUT`. If a test case fails, the
location of the failure along with the function name that caused the failure will be reported if
possible. You can see an example of this below.

A test will be marked as timing out if it exceeds the maximum number of instructions that can be
executed for any single test. This bound can be changed using the options below. Additionally, while
the result of a test is always deterministic, tests are run in parallel by default, so the ordering
of test results in a test run is non-deterministic unless running with only one thread, which can be
configured via an option.

These aforementioned options are two among many that can fine-tune testing and help debug failing
tests. To see all available options, and a description of what each one does, pass the `--help` flag
to the `sui move test` command:

```
$ sui move test --help
```

## Example

A simple module using some of the unit testing features is shown in the following example:

First create an empty package and change directory into it:

```bash
$ sui move new test_example; cd test_example
```

Next add the following module under the `sources` directory:

```move
// filename: sources/my_module.move
module test_example::my_module;

public struct Wrapper(u64)

const ECoinIsZero: u64 = 0;

public fun make_sure_non_zero_coin(coin: Wrapper): Wrapper {
    assert!(coin.0 > 0, ECoinIsZero);
    coin
}

#[test]
fun make_sure_non_zero_coin_passes() {
    let coin = Wrapper(1);
    let Wrapper(_) = make_sure_non_zero_coin(coin);
}

#[test, expected_failure(abort_code = ECoinIsZero)]
// Or #[test, expected_failure] if we don't care about the abort code
fun make_sure_zero_coin_fails() {
    let coin = Wrapper(0);
    let Wrapper(_) = make_sure_non_zero_coin(coin);
}

#[test_only] // test only helper function
fun make_coin_zero(coin: &mut Wrapper) {
    coin.0 = 0;
}

#[test, expected_failure(abort_code = ECoinIsZero)]
fun make_sure_zero_coin_fails2() {
    let mut coin = Wrapper(10);
    coin.make_coin_zero();
    let Wrapper(_) = make_sure_non_zero_coin(coin);
}
```

### Running Tests

You can then run these tests with the `move test` command:

```bash
$ sui move test
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ PASS    ] 0x0::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails2
Test result: OK. Total tests: 3; passed: 3; failed: 0
```

### Using Test Flags

#### Passing specific tests to run

You can run a specific test, or a set of tests with `sui move test <str>`. This will only run tests
whose fully qualified name contains `<str>`. For example if we wanted to only run tests with
`"non_zero"` in their name:

```bash
$ sui move test non_zero
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ PASS    ] 0x0::my_module::make_sure_non_zero_coin_passes
Test result: OK. Total tests: 1; passed: 1; failed: 0
```

#### `-i <bound>` or `--gas_used <bound>`

This bounds the amount of gas that can be consumed for any one test to `<bound>`:

```bash
$ sui move test -i 0
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ TIMEOUT ] 0x0::my_module::make_sure_non_zero_coin_passes
[ FAIL    ] 0x0::my_module::make_sure_zero_coin_fails
[ FAIL    ] 0x0::my_module::make_sure_zero_coin_fails2

Test failures:

Failures in 0x0::my_module:

┌── make_sure_non_zero_coin_passes ──────
│ Test timed out
└──────────────────


┌── make_sure_zero_coin_fails ──────
│ error[E11001]: test failure
│    ┌─ ./sources/my_module.move:22:27
│    │
│ 21 │     fun make_sure_zero_coin_fails() {
│    │         ------------------------- In this function in 0x0::my_module
│ 22 │         let coin = MyCoin(0);
│    │                           ^ Test did not error as expected. Expected test to abort with code 0 <SNIP>
│
│
└──────────────────


┌── make_sure_zero_coin_fails2 ──────
│ error[E11001]: test failure
│    ┌─ ./sources/my_module.move:34:31
│    │
│ 33 │     fun make_sure_zero_coin_fails2() {
│    │         -------------------------- In this function in 0x0::my_module
│ 34 │         let mut coin = MyCoin(10);
│    │                               ^^ Test did not error as expected. Expected test to abort with code 0 <SNIP>
│
│
└──────────────────

Test result: FAILED. Total tests: 3; passed: 0; failed: 3
```

#### `-s` or `--statistics`

With these flags you can gather statistics about the tests run and report the runtime and gas used
for each test. You can additionally add `csv` (`sui move test -s csv`) to get the gas usage in a csv
output format. For example, if we wanted to see the statistics for the tests in the example above:

```bash
$ sui move test -s
INCLUDING DEPENDENCY Bridge
INCLUDING DEPENDENCY DeepBook
INCLUDING DEPENDENCY SuiSystem
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING test_example
Running Move unit tests
[ PASS    ] 0x0::my_module::make_sure_non_zero_coin_passes
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails
[ PASS    ] 0x0::my_module::make_sure_zero_coin_fails2

Test Statistics:

┌────────────────────────────────────────────────┬────────────┬───────────────────────────┐
│                   Test Name                    │    Time    │         Gas Used          │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x0::my_module::make_sure_non_zero_coin_passes │   0.001    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x0::my_module::make_sure_zero_coin_fails      │   0.001    │             1             │
├────────────────────────────────────────────────┼────────────┼───────────────────────────┤
│ 0x0::my_module::make_sure_zero_coin_fails2     │   0.001    │             1             │
└────────────────────────────────────────────────┴────────────┴───────────────────────────┘

Test result: OK. Total tests: 3; passed: 3; failed: 0
```

>>>> move-book/reference/uses.md
---
title: 'Uses and Aliases | Reference'
description: ''
---

# Uses and Aliases

The `use` syntax can be used to create aliases to members in other modules. `use` can be used to
create aliases that last either for the entire module, or for a given expression block scope.

## Syntax

There are several different syntax cases for `use`. Starting with the most simple, we have the
following for creating aliases to other modules

```move
use <address>::<module name>;
use <address>::<module name> as <module alias name>;
```

For example

```move
use std::vector;
use std::option as o;
```

`use std::vector;` introduces an alias `vector` for `std::vector`. This means that anywhere you
would want to use the module name `std::vector` (assuming this `use` is in scope), you could use
`vector` instead. `use std::vector;` is equivalent to `use std::vector as vector;`

Similarly `use std::option as o;` would let you use `o` instead of `std::option`

```move
use std::vector;
use std::option as o;

fun new_vec(): vector<o::Option<u8>> {
    let mut v = vector[];
    vector::push_back(&mut v, o::some(0));
    vector::push_back(&mut v, o::none());
    v
}
```

If you want to import a specific module member (such as a function or struct). You can use the
following syntax.

```move
use <address>::<module name>::<module member>;
use <address>::<module name>::<module member> as <member alias>;
```

For example

```move
use std::vector::push_back;
use std::option::some as s;
```

This would let you use the function `std::vector::push_back` without full qualification. Similarly
for `std::option::some` with `s`. Instead you could use `push_back` and `s` respectively. Again,
`use std::vector::push_back;` is equivalent to `use std::vector::push_back as push_back;`

```move
use std::vector::push_back;
use std::option::some as s;

fun new_vec(): vector<std::option::Option<u8>> {
    let mut v = vector[];
    vector::push_back(&mut v, s(0));
    vector::push_back(&mut v, std::option::none());
    v
}
```

### Multiple Aliases

If you want to add aliases for multiple module members at once, you can do so with the following
syntax

```move
use <address>::<module name>::{<module member>, <module member> as <member alias> ... };
```

For example

```move
use std::vector::push_back;
use std::option::{some as s, none as n};

fun new_vec(): vector<std::option::Option<u8>> {
    let mut v = vector[];
    push_back(&mut v, s(0));
    push_back(&mut v, n());
    v
}
```

### Self aliases

If you need to add an alias to the Module itself in addition to module members, you can do that in a
single `use` using `Self`. `Self` is a member of sorts that refers to the module.

```move
use std::option::{Self, some, none};
```

For clarity, all of the following are equivalent:

```move
use std::option;
use std::option as option;
use std::option::Self;
use std::option::Self as option;
use std::option::{Self};
use std::option::{Self as option};
```

### Multiple Aliases for the Same Definition

If needed, you can have as many aliases for any item as you like

```move
use std::vector::push_back;
use std::option::{Option, some, none};

fun new_vec(): vector<Option<u8>> {
    let mut v = vector[];
    push_back(&mut v, some(0));
    push_back(&mut v, none());
    v
}
```

### Nested imports

In Move, you can also import multiple names with the same `use` declaration. This brings all
provided names into scope:

```move
use std::{
    vector::{Self as vec, push_back},
    string::{String, Self as str}
};

fun example(s: &mut String) {
    let mut v = vec::empty();
    push_back(&mut v, 0);
    push_back(&mut v, 10);
    str::append_utf8(s, v);
}
```

## Inside a `module`

Inside of a `module` all `use` declarations are usable regardless of the order of declaration.

```move
module a::example;

use std::vector;

fun new_vec(): vector<Option<u8>> {
    let mut v = vector[];
    vector::push_back(&mut v, 0);
    vector::push_back(&mut v, 10);
    v
}

use std::option::{Option, some, none};
```

The aliases declared by `use` in the module usable within that module.

Additionally, the aliases introduced cannot conflict with other module members. See
[Uniqueness](#uniqueness) for more details

## Inside an expression

You can add `use` declarations to the beginning of any expression block

```move
module a::example;

fun new_vec(): vector<Option<u8>> {
    use std::vector::push_back;
    use std::option::{Option, some, none};

    let mut v = vector[];
    push_back(&mut v, some(0));
    push_back(&mut v, none());
    v
}
```

As with `let`, the aliases introduced by `use` in an expression block are removed at the end of that
block.

```move
module a::example;

fun new_vec(): vector<Option<u8>> {
    let result = {
        use std::vector::push_back;
        use std::option::{Option, some, none};

        let mut v = vector[];
        push_back(&mut v, some(0));
        push_back(&mut v, none());
        v
    };
    result
}
```

Attempting to use the alias after the block ends will result in an error

```move
fun new_vec(): vector<Option<u8>> {
    let mut result = {
        use std::vector::push_back;
        use std::option::{Option, some, none};

        let mut v = vector[];
        push_back(&mut v, some(0));
        v
    };
    push_back(&mut result, std::option::none());
    // ^^^^^^ ERROR! unbound function 'push_back'
    result
}
```

Any `use` must be the first item in the block. If the `use` comes after any expression or `let`, it
will result in a parsing error

```move
{
    let mut v = vector[];
    use std::vector; // ERROR!
}
```

This allows you to shorten your import blocks in many situations. Note that these imports, as the
previous ones, are all subject to the naming and uniqueness rules described in the following
sections.

## Naming rules

Aliases must follow the same rules as other module members. This means that aliases to structs (and
constants) must start with `A` to `Z`

```move
module a::data {
    public struct S {}
    const FLAG: bool = false;
    public fun foo() {}
}
module a::example {
    use a::data::{
        S as s, // ERROR!
        FLAG as fLAG, // ERROR!
        foo as FOO,  // valid
        foo as bar, // valid
    };
}
```

## Uniqueness

Inside a given scope, all aliases introduced by `use` declarations must be unique.

For a module, this means aliases introduced by `use` cannot overlap

```move
module a::example;

use std::option::{none as foo, some as foo}; // ERROR!
//                                     ^^^ duplicate 'foo'

use std::option::none as bar;

use std::option::some as bar; // ERROR!
//                       ^^^ duplicate 'bar'
```

And, they cannot overlap with any of the module's other members

```move
module a::data {
    public struct S {}
}

module example {
    use a::data::S;

    public struct S { value: u64 } // ERROR!
    //            ^ conflicts with alias 'S' above
}
```

Inside of an expression block, they cannot overlap with each other, but they can
[shadow](#shadowing) other aliases or names from an outer scope

## Shadowing

`use` aliases inside of an expression block can shadow names (module members or aliases) from the
outer scope. As with shadowing of locals, the shadowing ends at the end of the expression block;

```move
module a::example;

public struct WrappedVector { vec: vector<u64> }

public fun empty(): WrappedVector {
    WrappedVector { vec: std::vector::empty() }
}

public fun push_back(v: &mut WrappedVector, value: u64) {
    std::vector::push_back(&mut v.vec, value);
}

fun example1(): WrappedVector {
    use std::vector::push_back;
    // 'push_back' now refers to std::vector::push_back
    let mut vec = vector[];
    push_back(&mut vec, 0);
    push_back(&mut vec, 1);
    push_back(&mut vec, 10);
    WrappedVector { vec }
}

fun example2(): WrappedVector {
    let vec = {
        use std::vector::push_back;
        // 'push_back' now refers to std::vector::push_back

        let mut v = vector[];
        push_back(&mut v, 0);
        push_back(&mut v, 1);
        v
    };
    // 'push_back' now refers to Self::push_back
    let mut res = WrappedVector { vec };
    push_back(&mut res, 10);
    res
}
```

## Unused Use or Alias

An unused `use` will result in a warning

```move
module a::example;

use std::option::{some, none}; // Warning!
//                      ^^^^ unused alias 'none'

public fun example(): std::option::Option<u8> {
    some(0)
}
```

>>>> move-book/reference/variables.md
---
title: 'Local Variables and Scope | Reference'
description: ''
---

# Local Variables and Scope

Local variables in Move are lexically (statically) scoped. New variables are introduced with the
keyword `let`, which will shadow any previous local with the same name. Locals marked as `mut` are
mutable and can be updated both directly and via a mutable reference.

## Declaring Local Variables

### `let` bindings

Move programs use `let` to bind variable names to values:

```move
let x = 1;
let y = x + x;
```

`let` can also be used without binding a value to the local.

```move
let x;
```

The local can then be assigned a value later.

```move
let x;
if (cond) {
  x = 1
} else {
  x = 0
}
```

This can be very helpful when trying to extract a value from a loop when a default value cannot be
provided.

```move
let x;
let mut i = 0;
loop {
    let (res, cond) = foo(i);
    if (!cond) {
        x = res;
        break
    };
    i = i + 1;
}
```

To modify a local variable _after_ it is assigned, or to borrow it mutably (`&mut`), it must be
declared as `mut`.

```move
let mut x = 0;
if (cond) x = x + 1;
foo(&mut x);
```

For more details see the section on [assignments](#assignments) below.

### Variables must be assigned before use

Move's type system prevents a local variable from being used before it has been assigned.

```move
let x;
// highlight-error
x + x // ERROR! x is used before being assigned
```

```move
let x;
if (cond) x = 0;
// highlight-error
x + x // ERROR! x does not have a value in all cases
```

```move
let x;
while (cond) x = 0;
// highlight-error
x + x // ERROR! x does not have a value in all cases
```

### Valid variable names

Variable names can contain underscores `_`, letters `a` to `z`, letters `A` to `Z`, and digits `0`
to `9`. Variable names must start with either an underscore `_` or a letter `a` through `z`. They
_cannot_ start with uppercase letters.

```move
// all valid
let x = e;
let _x = e;
let _A = e;
let x0 = e;
let xA = e;
let foobar_123 = e;

// all invalid
// highlight-error-start
let X = e; // ERROR!
let Foo = e; // ERROR!
// highlight-error-end
```

### Type annotations

The type of a local variable can almost always be inferred by Move's type system. However, Move
allows explicit type annotations that can be useful for readability, clarity, or debuggability. The
syntax for adding a type annotation is:

```move
let x: T = e; // "Variable x of type T is initialized to expression e"
```

Some examples of explicit type annotations:

```move
module 0::example;

public struct S { f: u64, g: u64 }

fun annotated() {
    let u: u8 = 0;
    let b: vector<u8> = b"hello";
    let a: address = @0x0;
    let (x, y): (&u64, &mut u64) = (&0, &mut 1);
    let S { f, g: f2 }: S = S { f: 0, g: 1 };
}
```

Note that the type annotations must always be to the right of the pattern:

```move
// highlight-error-start
// ERROR! should be let (x, y): (&u64, &mut u64) = ...
let (x: &u64, y: &mut u64) = (&0, &mut 1);
// highlight-error-end
```

### When annotations are necessary

In some cases, a local type annotation is required if the type system cannot infer the type. This
commonly occurs when the type argument for a generic type cannot be inferred. For example:

```move
// highlight-error-start
let _v1 = vector[]; // ERROR!
//        ^^^^^^^^ Could not infer this type. Try adding an annotation
// highlight-error-end
let v2: vector<u64> = vector[]; // no error
```

In a rarer case, the type system might not be able to infer a type for divergent code (where all the
following code is unreachable). Both [`return`](./functions#return-expression) and
[`abort`](./abort-and-assert) are expressions and can have any type. A
[`loop`](./control-flow/loops) has type `()` if it has a `break` (or `T` if has a `break e` where
`e: T`), but if there is no break out of the `loop`, it could have any type. If these types cannot
be inferred, a type annotation is required. For example, this code:

```move
let a: u8 = return ();
let b: bool = abort 0;
let c: signer = loop ();

// highlight-error-start
let x = return (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let y = abort 0; // ERROR!
//  ^ Could not infer this type. Try adding an annotation
let z = loop (); // ERROR!
//  ^ Could not infer this type. Try adding an annotation
// highlight-error-end
```

Adding type annotations to this code will expose other errors about dead code or unused local
variables, but the example is still helpful for understanding this problem.

### Multiple declarations with tuples

`let` can introduce more than one local at a time using tuples. The locals declared inside the
parenthesis are initialized to the corresponding values from the tuple.

```move
let () = ();
let (x0, x1) = (0, 1);
let (y0, y1, y2) = (0, 1, 2);
let (z0, z1, z2, z3) = (0, 1, 2, 3);
```

The type of the expression must match the arity of the tuple pattern exactly.

```move
// highlight-error
let (x, y) = (0, 1, 2); // ERROR!
// highlight-error
let (x, y, z, q) = (0, 1, 2); // ERROR!
```

You cannot declare more than one local with the same name in a single `let`.

```move
// highlight-error
let (x, x) = 0; // ERROR!
```

The mutability of the local variables declared can be mixed.

```move
let (mut x, y) = (0, 1);
x = 1;
```

### Multiple declarations with structs

`let` can also introduce more than one local variables at a time when destructuring (or matching
against) a struct. In this form, the `let` creates a set of local variables that are initialized to
the values of the fields from a struct. The syntax looks like this:

```move
public struct T { f1: u64, f2: u64 }
```

```move
let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
```

Similarly for positional structs

```move
public struct P(u64, u64)
```

and

```move
let P (local1, local2) = P ( 1, 2 );
// local1: u64
// local2: u64
```

Here is a more complicated example:

```move
module 0::example;

public struct X(u64)
public struct Y { x1: X, x2: X }

fun new_x(): X {
    X(1)
}

fun example() {
    let Y { x1: X(f), x2 } = Y { x1: new_x(), x2: new_x() };
    assert!(f + x2.0 == 2, 42);

    let Y { x1: X(f1), x2: X(f2) } = Y { x1: new_x(), x2: new_x() };
    assert!(f1 + f2 == 2, 42);

    // `struct X` without `drop` ability and needs to be destroyed manually
    let X(_) = x2;
}
```

Fields of structs can serve double duty, identifying the field to bind _and_ the name of the
variable. This is sometimes referred to as punning.

```move
let Y { x1, x2 } = e;
```

is equivalent to:

```move
let Y { x1: x1, x2: x2 } = e;
```

As shown with tuples, you cannot declare more than one local with the same name in a single `let`.

```move
// highlight-error
let Y { x1: x, x2: x } = e; // ERROR!
```

And as with tuples, the mutability of the local variables declared can be mixed.

```move
let Y { x1: mut x1, x2 } = e;
```

Furthermore, the mutability of annotation can be applied to the punned fields. Giving the equivalent
example

```move
let Y { mut x1, x2 } = e;
```

### Destructuring against references

In the examples above for structs, the bound value in the let was moved, destroying the struct value
and binding its fields.

```move
public struct T { f1: u64, f2: u64 }
```

```move
let T { f1: local1, f2: local2 } = T { f1: 1, f2: 2 };
// local1: u64
// local2: u64
```

In this scenario the struct value `T { f1: 1, f2: 2 }` no longer exists after the `let`.

If you wish instead to not move and destroy the struct value, you can borrow each of its fields. For
example:

```move
let t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &t;
// local1: &u64
// local2: &u64
```

And similarly with mutable references:

```move
let mut t = T { f1: 1, f2: 2 };
let T { f1: local1, f2: local2 } = &mut t;
// local1: &mut u64
// local2: &mut u64
```

This behavior can also work with nested structs.

```move
module 0::example;

public struct X(u64)
public struct Y { x1: X, x2: X }

fun new_x(): X {
    X(1)
}

fun example() {
    let mut y = Y { x1: new_x(), x2: new_x() };

    let Y { x1: X(f), x2 } = &y;
    assert!(*f + x2.0 == 2, 42);

    let Y { x1: X(f1), x2: X(f2) } = &mut y;
    *f1 = *f1 + 1;
    *f2 = *f2 + 1;
    assert!(*f1 + *f2 == 4, 42);

    // `struct X and struct Y` without `drop` ability and needs to be destroyed manually
    let Y { x1: X(_), x2: X(_) } = y;
}
```

### Ignoring Values

In `let` bindings, it is often helpful to ignore some values. Local variables that start with `_`
will be ignored and not introduce a new variable

```move
fun three(): (u64, u64, u64) {
    (0, 1, 2)
}
```

```move
let (x1, _, z1) = three();
let (x2, _y, z2) = three();
assert!(x1 + z1 == x2 + z2, 42);
```

This can be necessary at times as the compiler will warn on unused local variables

```move
let (x1, y, z1) = three(); // WARNING!
//       ^ unused local 'y'
```

### General `let` grammar

All of the different structures in `let` can be combined! With that we arrive at this general
grammar for `let` statements:

> _let-binding_ → **let** _pattern-or-list_ _type-annotation_<sub>_opt_</sub> >
> _initializer_<sub>_opt_</sub> > _pattern-or-list_ → _pattern_ | **(** _pattern-list_ **)** >
> _pattern-list_ → _pattern_ **,**<sub>_opt_</sub> | _pattern_ **,** _pattern-list_ >
> _type-annotation_ → **:** _type_ _initializer_ → **=** _expression_

The general term for the item that introduces the bindings is a _pattern_. The pattern serves to
both destructure data (possibly recursively) and introduce the bindings. The pattern grammar is as
follows:

> _pattern_ -> _local-variable_ | _struct-type_ **\{** _field-binding-list_ **\}** >
> _field-binding-list_ → _field-binding_ **,**<sub>_opt_</sub> | _field-binding_ **,** >
> _field-binding-list_ > _field-binding_ → _field_ | _field_ **:** _pattern_

A few concrete examples with this grammar applied:

```move
    let (x, y): (u64, u64) = (0, 1);
//       ^                           local-variable
//       ^                           pattern
//          ^                        local-variable
//          ^                        pattern
//          ^                        pattern-list
//       ^^^^                        pattern-list
//      ^^^^^^                       pattern-or-list
//            ^^^^^^^^^^^^           type-annotation
//                         ^^^^^^^^  initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding

    let Foo { f, g: x } = Foo { f: 0, g: 1 };
//      ^^^                                    struct-type
//            ^                                field
//            ^                                field-binding
//               ^                             field
//                  ^                          local-variable
//                  ^                          pattern
//               ^^^^                          field-binding
//            ^^^^^^^                          field-binding-list
//      ^^^^^^^^^^^^^^^                        pattern
//      ^^^^^^^^^^^^^^^                        pattern-or-list
//                      ^^^^^^^^^^^^^^^^^^^^   initializer
//  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ let-binding
```

## Mutations

### Assignments

After the local is introduced (either by `let` or as a function parameter), a `mut` local can be
modified via an assignment:

```move
x = e
```

Unlike `let` bindings, assignments are expressions. In some languages, assignments return the value
that was assigned, but in Move, the type of any assignment is always `()`.

```move
(x = e: ())
```

Practically, assignments being expressions means that they can be used without adding a new
expression block with braces (`{`...`}`).

```move
let x;
if (cond) x = 1 else x = 2;
```

The assignment uses the similar pattern syntax scheme as `let` bindings, but with absence of `mut`:

```move
module 0::example;

public struct X { f: u64 }

fun new_x(): X {
    X { f: 1 }
}

// Note: this example will complain about unused variables and assignments.
fun example() {
    let (mut x, mut y, mut f, mut g) = (0, 0, 0, 0);

    (X { f }, X { f: x }) = (new_x(), new_x());
    assert!(f + x == 2, 42);

    (x, y, f, _, g) = (0, 0, 0, 0, 0);
}
```

Note that a local variable can only have one type, so the type of the local cannot change between
assignments.

```move
let mut x;
x = 0;
// highlight-error
x = false; // ERROR!
```

### Mutating through a reference

In addition to directly modifying a local with assignment, a `mut` local can be modified via a
mutable reference `&mut`.

```move
let mut x = 0;
let r = &mut x;
*r = 1;
assert!(x == 1, 42);
```

This is particularly useful if either:

(1) You want to modify different variables depending on some condition.

```move
let mut x = 0;
let mut y = 1;
let r = if (cond) &mut x else &mut y;
*r = *r + 1;
```

(2) You want another function to modify your local value.

```move
let mut x = 0;
modify_ref(&mut x);
```

This sort of modification is how you modify structs and vectors!

```move
let mut v = vector[];
vector::push_back(&mut v, 100);
assert!(*vector::borrow(&v, 0) == 100, 42);
```

For more details, see [Move references](./primitive-types/references).

## Scopes

Any local declared with `let` is available for any subsequent expression, _within that scope_.
Scopes are declared with expression blocks, `{`...`}`.

Locals cannot be used outside of the declared scope.

```move
let x = 0;
{
    let y = 1;
};
// highlight-error-start
x + y // ERROR!
//  ^ unbound local 'y'
// highlight-error-end
```

But, locals from an outer scope _can_ be used in a nested scope.

```move
{
    let x = 0;
    {
        let y = x + 1; // valid
    }
}
```

Locals can be mutated in any scope where they are accessible. That mutation survives with the local,
regardless of the scope that performed the mutation.

```move
let mut x = 0;
x = x + 1;
assert!(x == 1, 42);
{
    x = x + 1;
    assert!(x == 2, 42);
};
assert!(x == 2, 42);
```

### Expression Blocks

An expression block is a series of statements separated by semicolons (`;`). The resulting value of
an expression block is the value of the last expression in the block.

```move
{ let x = 1; let y = 1; x + y }
```

In this example, the result of the block is `x + y`.

A statement can be either a `let` declaration or an expression. Remember that assignments (`x = e`)
are expressions of type `()`.

```move
{ let x; let y = 1; x = 1; x + y }
```

Function calls are another common expression of type `()`. Function calls that modify data are
commonly used as statements.

```move
{ let v = vector[]; vector::push_back(&mut v, 1); v }
```

This is not just limited to `()` types---any expression can be used as a statement in a sequence!

```move
{
    let x = 0;
    x + 1; // value is discarded
    x + 2; // value is discarded
    b"hello"; // value is discarded
}
```

But! If the expression contains a resource (a value without the `drop` [ability](./abilities)), you
will get an error. This is because Move's type system guarantees that any value that is dropped has
the `drop` [ability](./abilities). (Ownership must be transferred or the value must be explicitly
destroyed within its declaring module.)

```move
{
    let x = 0;
// highlight-error-start
    Coin { value: x }; // ERROR!
//  ^^^^^^^^^^^^^^^^^ unused value without the `drop` ability
// highlight-error-end
    x
}
```

If a final expression is not present in a block---that is, if there is a trailing semicolon `;`,
there is an implicit [unit `()` value](https://en.wikipedia.org/wiki/Unit_type). Similarly, if the
expression block is empty, there is an implicit unit `()` value.

Both are equivalent

```move
{ x = x + 1; 1 / x; }
```

```move
{ x = x + 1; 1 / x; () }
```

Similarly both are equivalent

```move
{ }
```

```move
{ () }
```

An expression block is itself an expression and can be used anyplace an expression is used. (Note:
The body of a function is also an expression block, but the function body cannot be replaced by
another expression.)

```move
let my_vector: vector<vector<u8>> = {
    let mut v = vector[];
    vector::push_back(&mut v, b"hello");
    vector::push_back(&mut v, b"goodbye");
    v
};
```

(The type annotation is not needed in this example and only added for clarity.)

### Shadowing

If a `let` introduces a local variable with a name already in scope, that previous variable can no
longer be accessed for the rest of this scope. This is called _shadowing_.

```move
let x = 0;
assert!(x == 0, 42);

let x = 1; // x is shadowed
assert!(x == 1, 42);
```

When a local is shadowed, it does not need to retain the same type as before.

```move
let x = 0;
assert!(x == 0, 42);

let x = b"hello"; // x is shadowed
assert!(x == b"hello", 42);
```

After a local is shadowed, the value stored in the local still exists, but will no longer be
accessible. This is important to keep in mind with values of types without the
[`drop` ability](./abilities), as ownership of the value must be transferred by the end of the
function.

```move
module 0::example;

public struct Coin has store { value: u64 }

fun unused_coin(): Coin {
// highlight-error-start
    let x = Coin { value: 0 }; // ERROR!
//      ^ This local still contains a value without the `drop` ability
    x.value = 1;
    let x = Coin { value: 10 };
    x
//  ^ Invalid return
// highlight-error-end
}
```

When a local is shadowed inside a scope, the shadowing only remains for that scope. The shadowing is
gone once that scope ends.

```move
let x = 0;
{
    let x = 1;
    assert!(x == 1, 42);
};
assert!(x == 0, 42);
```

Remember, locals can change type when they are shadowed.

```move
let x = 0;
{
    let x = b"hello";
    assert!(x == b"hello", 42);
};
assert!(x == 0, 42);
```

## Move and Copy

All local variables in Move can be used in two ways, either by `move` or `copy`. If one or the other
is not specified, the Move compiler is able to infer whether a `copy` or a `move` should be used.
This means that in all of the examples above, a `move` or a `copy` would be inserted by the
compiler. A local variable cannot be used without the use of `move` or `copy`.

`copy` will likely feel the most familiar coming from other programming languages, as it creates a
new copy of the value inside of the variable to use in that expression. With `copy`, the local
variable can be used more than once.

```move
let x = 0;
let y = copy x + 1;
let z = copy x + 2;
```

Any value with the `copy` [ability](./abilities) can be copied in this way, and will be copied
implicitly unless a `move` is specified.

`move` takes the value out of the local variable _without_ copying the data. After a `move` occurs,
the local variable is unavailable, even if the value's type has the `copy` [ability](./abilities).

```move
let x = 1;
// highlight-error-start
let y = move x + 1;
//      ------ Local was moved here
let z = move x + 2; // Error!
//      ^^^^^^ Invalid usage of local 'x'
// highlight-error-end
y + z
```

### Safety

Move's type system will prevent a value from being used after it is moved. This is the same safety
check described in [`let` declaration](#let-bindings) that prevents local variables from being used
before it is assigned a value.

<!-- For more information, see TODO future section on ownership and move semantics. -->

### Inference

As mentioned above, the Move compiler will infer a `copy` or `move` if one is not indicated. The
algorithm for doing so is quite simple:

- Any value with the `copy` [ability](./abilities) is given a `copy`.
- Any reference (both mutable `&mut` and immutable `&`) is given a `copy`.
  - Except under special circumstances where it is made a `move` for predictable borrow checker
    errors. This will happen once the reference is no longer used.
- Any other value is given a `move`.

Given the structs

```move
public struct Foo has copy, drop, store { f: u64 }
public struct Coin has store { value: u64 }
```

we have the following example

```move
let s = b"hello";
let foo = Foo { f: 0 };
let coin = Coin { value: 0 };
let coins = vector[Coin { value: 0 }, Coin { value: 0 }];

let s2 = s; // copy
let foo2 = foo; // copy
let coin2 = coin; // move
let coins2 = coins; // move

let x = 0;
let b = false;
let addr = @0x42;
let x_ref = &x;
let coin_ref = &mut coin2;

let x2 = x; // copy
let b2 = b; // copy
let addr2 = @0x42; // copy
let x_ref2 = x_ref; // copy
let coin_ref2 = coin_ref; // copy
```

>>>> move-book/site/README.md
# Website

This website is built using [Docusaurus](https://docusaurus.io/), a modern static website generator.

## Installation

```bash
yarn
```

## Local Development

```bash
yarn start
```

This command starts a local development server and opens up a browser window. Most changes are reflected live without having to restart the server.

## Build

```bash
yarn build
```

This command generates static content into the `build` directory and can be served using any static contents hosting service.

## Deployment

Using SSH:

```bash
USE_SSH=true yarn deploy
```

Not using SSH:

```bash
GIT_USER=<Your GitHub username> yarn deploy
```

If you are using GitHub pages for hosting, this command is a convenient way to build the website and push to the `gh-pages` branch.

>>>> move-book/site/packages/samples/sources/README.md
# Managing Samples

For every page in the book (under the `src/` directory), there is a `samples/` directory which contains the code samples for that page. The `samples/` directory is organized in the same way as the `src/` directory, with the same directory structure and file names.

## Rules

1. There's one Move file per page in the book.
2. The file name is the same as the page name (or similar for keywords).
3. The file can hold multiple modules.
4. The modules are named after the sub-sections of the page.
5. Anchors should be used to point to the specific code snippets in the Move file.

## Example

For example, the `src/basic-syntax/address.md` page has a corresponding `samples/guides/address.move` file. The file contains the code samples for the page, organized in modules named after the sub-sections of the page.

```bash
samples/
    basic-syntax/
        address.move
```

>>>> move-book/site/packages/samples/sources/hello-sui/README.md
# Hello Sui

This tutorial is packed as a separate package which you can find in the root of this repository.
